var Yo = Object.defineProperty;
var Xo = (C,A,c)=>A in C ? Yo(C, A, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: c
}) : C[A] = c;
var pt = (C,A,c)=>(Xo(C, typeof A != "symbol" ? A + "" : A, c),
c);
import {R as We, I as zo} from "./round-4f8fa324.js";
const Vo = -1;
var Wo = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Yr(C) {
    return C && C.__esModule && Object.prototype.hasOwnProperty.call(C, "default") ? C.default : C
}
var Nn = {}
  , Ho = {
    get exports() {
        return Nn
    },
    set exports(C) {
        Nn = C
    }
};
(function(C, A) {
    (function(S, t) {
        C.exports = t()
    }
    )(Wo, function() {
        return function(c) {
            var S = {};
            function t(e) {
                if (S[e])
                    return S[e].exports;
                var f = S[e] = {
                    i: e,
                    l: !1,
                    exports: {}
                };
                return c[e].call(f.exports, f, f.exports, t),
                f.l = !0,
                f.exports
            }
            return t.m = c,
            t.c = S,
            t.d = function(e, f, r) {
                t.o(e, f) || Object.defineProperty(e, f, {
                    enumerable: !0,
                    get: r
                })
            }
            ,
            t.r = function(e) {
                typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                    value: "Module"
                }),
                Object.defineProperty(e, "__esModule", {
                    value: !0
                })
            }
            ,
            t.t = function(e, f) {
                if (f & 1 && (e = t(e)),
                f & 8 || f & 4 && typeof e == "object" && e && e.__esModule)
                    return e;
                var r = Object.create(null);
                if (t.r(r),
                Object.defineProperty(r, "default", {
                    enumerable: !0,
                    value: e
                }),
                f & 2 && typeof e != "string")
                    for (var o in e)
                        t.d(r, o, function(a) {
                            return e[a]
                        }
                        .bind(null, o));
                return r
            }
            ,
            t.n = function(e) {
                var f = e && e.__esModule ? function() {
                    return e.default
                }
                : function() {
                    return e
                }
                ;
                return t.d(f, "a", f),
                f
            }
            ,
            t.o = function(e, f) {
                return Object.prototype.hasOwnProperty.call(e, f)
            }
            ,
            t.p = "",
            t(t.s = 1528)
        }([function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            function t(n) {
                return !!n.get && typeof n.get == "function" || !!n.set && typeof n.set == "function"
            }
            function e(n, s, l) {
                var i = l ? n[s] : Object.getOwnPropertyDescriptor(n, s);
                return !l && i.value && typeof i.value == "object" && (i = i.value),
                i && t(i) ? (typeof i.enumerable > "u" && (i.enumerable = !0),
                typeof i.configurable > "u" && (i.configurable = !0),
                i) : !1
            }
            function f(n, s) {
                var l = Object.getOwnPropertyDescriptor(n, s);
                return l ? (l.value && typeof l.value == "object" && (l = l.value),
                l.configurable === !1) : !1
            }
            function r(n, s, l, i) {
                for (var h in s)
                    if (s.hasOwnProperty(h)) {
                        var u = e(s, h, l);
                        if (u !== !1) {
                            var d = i || n;
                            if (f(d.prototype, h)) {
                                if (a.ignoreFinals)
                                    continue;
                                throw new Error("cannot override final property '" + h + "', set Class.ignoreFinals = true to skip")
                            }
                            Object.defineProperty(n.prototype, h, u)
                        } else
                            n.prototype[h] = s[h]
                    }
            }
            function o(n, s) {
                if (s) {
                    Array.isArray(s) || (s = [s]);
                    for (var l = 0; l < s.length; l++)
                        r(n, s[l].prototype || s[l])
                }
            }
            function a(n) {
                n || (n = {});
                var s, l;
                if (n.initialize) {
                    if (typeof n.initialize != "function")
                        throw new Error("initialize must be a function");
                    s = n.initialize,
                    delete n.initialize
                } else if (n.Extends) {
                    var i = n.Extends;
                    s = function() {
                        i.apply(this, arguments)
                    }
                } else
                    s = function() {}
                    ;
                n.Extends ? (s.prototype = Object.create(n.Extends.prototype),
                s.prototype.constructor = s,
                l = n.Extends,
                delete n.Extends) : s.prototype.constructor = s;
                var h = null;
                return n.Mixins && (h = n.Mixins,
                delete n.Mixins),
                o(s, h),
                r(s, n, !0, l),
                s
            }
            a.extend = r,
            a.mixin = o,
            a.ignoreFinals = !1,
            c.exports = a
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function() {};
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                var o = typeof e;
                return !e || o === "number" || o === "string" ? r : e.hasOwnProperty(f) && e[f] !== void 0 ? e[f] : r
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(124)
              , r = new e({
                initialize: function(a, n) {
                    this.x = 0,
                    this.y = 0,
                    typeof a == "object" ? (this.x = a.x || 0,
                    this.y = a.y || 0) : (n === void 0 && (n = a),
                    this.x = a || 0,
                    this.y = n || 0)
                },
                clone: function() {
                    return new r(this.x,this.y)
                },
                copy: function(o) {
                    return this.x = o.x || 0,
                    this.y = o.y || 0,
                    this
                },
                setFromObject: function(o) {
                    return this.x = o.x || 0,
                    this.y = o.y || 0,
                    this
                },
                set: function(o, a) {
                    return a === void 0 && (a = o),
                    this.x = o,
                    this.y = a,
                    this
                },
                setTo: function(o, a) {
                    return this.set(o, a)
                },
                setToPolar: function(o, a) {
                    return a == null && (a = 1),
                    this.x = Math.cos(o) * a,
                    this.y = Math.sin(o) * a,
                    this
                },
                equals: function(o) {
                    return this.x === o.x && this.y === o.y
                },
                fuzzyEquals: function(o, a) {
                    return f(this.x, o.x, a) && f(this.y, o.y, a)
                },
                angle: function() {
                    var o = Math.atan2(this.y, this.x);
                    return o < 0 && (o += 2 * Math.PI),
                    o
                },
                setAngle: function(o) {
                    return this.setToPolar(o, this.length())
                },
                add: function(o) {
                    return this.x += o.x,
                    this.y += o.y,
                    this
                },
                subtract: function(o) {
                    return this.x -= o.x,
                    this.y -= o.y,
                    this
                },
                multiply: function(o) {
                    return this.x *= o.x,
                    this.y *= o.y,
                    this
                },
                scale: function(o) {
                    return isFinite(o) ? (this.x *= o,
                    this.y *= o) : (this.x = 0,
                    this.y = 0),
                    this
                },
                divide: function(o) {
                    return this.x /= o.x,
                    this.y /= o.y,
                    this
                },
                negate: function() {
                    return this.x = -this.x,
                    this.y = -this.y,
                    this
                },
                distance: function(o) {
                    var a = o.x - this.x
                      , n = o.y - this.y;
                    return Math.sqrt(a * a + n * n)
                },
                distanceSq: function(o) {
                    var a = o.x - this.x
                      , n = o.y - this.y;
                    return a * a + n * n
                },
                length: function() {
                    var o = this.x
                      , a = this.y;
                    return Math.sqrt(o * o + a * a)
                },
                setLength: function(o) {
                    return this.normalize().scale(o)
                },
                lengthSq: function() {
                    var o = this.x
                      , a = this.y;
                    return o * o + a * a
                },
                normalize: function() {
                    var o = this.x
                      , a = this.y
                      , n = o * o + a * a;
                    return n > 0 && (n = 1 / Math.sqrt(n),
                    this.x = o * n,
                    this.y = a * n),
                    this
                },
                normalizeRightHand: function() {
                    var o = this.x;
                    return this.x = this.y * -1,
                    this.y = o,
                    this
                },
                normalizeLeftHand: function() {
                    var o = this.x;
                    return this.x = this.y,
                    this.y = o * -1,
                    this
                },
                dot: function(o) {
                    return this.x * o.x + this.y * o.y
                },
                cross: function(o) {
                    return this.x * o.y - this.y * o.x
                },
                lerp: function(o, a) {
                    a === void 0 && (a = 0);
                    var n = this.x
                      , s = this.y;
                    return this.x = n + a * (o.x - n),
                    this.y = s + a * (o.y - s),
                    this
                },
                transformMat3: function(o) {
                    var a = this.x
                      , n = this.y
                      , s = o.val;
                    return this.x = s[0] * a + s[3] * n + s[6],
                    this.y = s[1] * a + s[4] * n + s[7],
                    this
                },
                transformMat4: function(o) {
                    var a = this.x
                      , n = this.y
                      , s = o.val;
                    return this.x = s[0] * a + s[4] * n + s[12],
                    this.y = s[1] * a + s[5] * n + s[13],
                    this
                },
                reset: function() {
                    return this.x = 0,
                    this.y = 0,
                    this
                },
                limit: function(o) {
                    var a = this.length();
                    return a && a > o && this.scale(o / a),
                    this
                },
                reflect: function(o) {
                    return o = o.clone().normalize(),
                    this.subtract(o.scale(2 * this.dot(o)))
                },
                mirror: function(o) {
                    return this.reflect(o).negate()
                },
                rotate: function(o) {
                    var a = Math.cos(o)
                      , n = Math.sin(o);
                    return this.set(a * this.x - n * this.y, n * this.x + a * this.y)
                }
            });
            r.ZERO = new r,
            r.RIGHT = new r(1,0),
            r.LEFT = new r(-1,0),
            r.UP = new r(0,-1),
            r.DOWN = new r(0,1),
            r.ONE = new r(1,1),
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(56)
              , r = new e({
                initialize: function(a, n) {
                    a === void 0 && (a = 0),
                    n === void 0 && (n = a),
                    this.type = f.POINT,
                    this.x = a,
                    this.y = n
                },
                setTo: function(o, a) {
                    return o === void 0 && (o = 0),
                    a === void 0 && (a = o),
                    this.x = o,
                    this.y = a,
                    this
                }
            });
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(24)
              , r = t(20)
              , o = new e({
                initialize: function(n) {
                    this.scene = n,
                    this.systems = n.sys,
                    this.events = n.sys.events,
                    this.displayList,
                    this.updateList,
                    this.events.once(r.BOOT, this.boot, this),
                    this.events.on(r.START, this.start, this)
                },
                boot: function() {
                    this.displayList = this.systems.displayList,
                    this.updateList = this.systems.updateList,
                    this.events.once(r.DESTROY, this.destroy, this)
                },
                start: function() {
                    this.events.once(r.SHUTDOWN, this.shutdown, this)
                },
                existing: function(a) {
                    return (a.renderCanvas || a.renderWebGL) && this.displayList.add(a),
                    a.preUpdate && this.updateList.add(a),
                    a
                },
                shutdown: function() {
                    this.events.off(r.SHUTDOWN, this.shutdown, this)
                },
                destroy: function() {
                    this.shutdown(),
                    this.events.off(r.START, this.start, this),
                    this.scene = null,
                    this.systems = null,
                    this.events = null,
                    this.displayList = null,
                    this.updateList = null
                }
            });
            o.register = function(a, n) {
                o.prototype.hasOwnProperty(a) || (o.prototype[a] = n)
            }
            ,
            o.remove = function(a) {
                o.prototype.hasOwnProperty(a) && delete o.prototype[a]
            }
            ,
            f.register("GameObjectFactory", o, "add"),
            c.exports = o
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                if (!e || typeof e == "number")
                    return r;
                if (e.hasOwnProperty(f))
                    return e[f];
                if (f.indexOf(".") !== -1) {
                    for (var o = f.split("."), a = e, n = r, s = 0; s < o.length; s++)
                        if (a.hasOwnProperty(o[s]))
                            n = a[o[s]],
                            a = a[o[s]];
                        else {
                            n = r;
                            break
                        }
                    return n
                } else
                    return r
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                if (typeof e != "object" || e.nodeType || e === e.window)
                    return !1;
                try {
                    if (e.constructor && !{}.hasOwnProperty.call(e.constructor.prototype, "isPrototypeOf"))
                        return !1
                } catch {
                    return !1
                }
                return !0
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {}
              , e = {
                install: function(f) {
                    for (var r in t)
                        f[r] = t[r]
                },
                register: function(f, r) {
                    t[f] = r
                },
                destroy: function() {
                    t = {}
                }
            };
            c.exports = e
        }
        , function(c, S, t) {
            var e = Object.prototype.hasOwnProperty
              , f = "~";
            function r() {}
            Object.create && (r.prototype = Object.create(null),
            new r().__proto__ || (f = !1));
            function o(l, i, h) {
                this.fn = l,
                this.context = i,
                this.once = h || !1
            }
            function a(l, i, h, u, d) {
                if (typeof h != "function")
                    throw new TypeError("The listener must be a function");
                var v = new o(h,u || l,d)
                  , p = f ? f + i : i;
                return l._events[p] ? l._events[p].fn ? l._events[p] = [l._events[p], v] : l._events[p].push(v) : (l._events[p] = v,
                l._eventsCount++),
                l
            }
            function n(l, i) {
                --l._eventsCount === 0 ? l._events = new r : delete l._events[i]
            }
            function s() {
                this._events = new r,
                this._eventsCount = 0
            }
            s.prototype.eventNames = function() {
                var i = [], h, u;
                if (this._eventsCount === 0)
                    return i;
                for (u in h = this._events)
                    e.call(h, u) && i.push(f ? u.slice(1) : u);
                return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(h)) : i
            }
            ,
            s.prototype.listeners = function(i) {
                var h = f ? f + i : i
                  , u = this._events[h];
                if (!u)
                    return [];
                if (u.fn)
                    return [u.fn];
                for (var d = 0, v = u.length, p = new Array(v); d < v; d++)
                    p[d] = u[d].fn;
                return p
            }
            ,
            s.prototype.listenerCount = function(i) {
                var h = f ? f + i : i
                  , u = this._events[h];
                return u ? u.fn ? 1 : u.length : 0
            }
            ,
            s.prototype.emit = function(i, h, u, d, v, p) {
                var g = f ? f + i : i;
                if (!this._events[g])
                    return !1;
                var m = this._events[g], x = arguments.length, T, E;
                if (m.fn) {
                    switch (m.once && this.removeListener(i, m.fn, void 0, !0),
                    x) {
                    case 1:
                        return m.fn.call(m.context),
                        !0;
                    case 2:
                        return m.fn.call(m.context, h),
                        !0;
                    case 3:
                        return m.fn.call(m.context, h, u),
                        !0;
                    case 4:
                        return m.fn.call(m.context, h, u, d),
                        !0;
                    case 5:
                        return m.fn.call(m.context, h, u, d, v),
                        !0;
                    case 6:
                        return m.fn.call(m.context, h, u, d, v, p),
                        !0
                    }
                    for (E = 1,
                    T = new Array(x - 1); E < x; E++)
                        T[E - 1] = arguments[E];
                    m.fn.apply(m.context, T)
                } else {
                    var P = m.length, M;
                    for (E = 0; E < P; E++)
                        switch (m[E].once && this.removeListener(i, m[E].fn, void 0, !0),
                        x) {
                        case 1:
                            m[E].fn.call(m[E].context);
                            break;
                        case 2:
                            m[E].fn.call(m[E].context, h);
                            break;
                        case 3:
                            m[E].fn.call(m[E].context, h, u);
                            break;
                        case 4:
                            m[E].fn.call(m[E].context, h, u, d);
                            break;
                        default:
                            if (!T)
                                for (M = 1,
                                T = new Array(x - 1); M < x; M++)
                                    T[M - 1] = arguments[M];
                            m[E].fn.apply(m[E].context, T)
                        }
                }
                return !0
            }
            ,
            s.prototype.on = function(i, h, u) {
                return a(this, i, h, u, !1)
            }
            ,
            s.prototype.once = function(i, h, u) {
                return a(this, i, h, u, !0)
            }
            ,
            s.prototype.removeListener = function(i, h, u, d) {
                var v = f ? f + i : i;
                if (!this._events[v])
                    return this;
                if (!h)
                    return n(this, v),
                    this;
                var p = this._events[v];
                if (p.fn)
                    p.fn === h && (!d || p.once) && (!u || p.context === u) && n(this, v);
                else {
                    for (var g = 0, m = [], x = p.length; g < x; g++)
                        (p[g].fn !== h || d && !p[g].once || u && p[g].context !== u) && m.push(p[g]);
                    m.length ? this._events[v] = m.length === 1 ? m[0] : m : n(this, v)
                }
                return this
            }
            ,
            s.prototype.removeAllListeners = function(i) {
                var h;
                return i ? (h = f ? f + i : i,
                this._events[h] && n(this, h)) : (this._events = new r,
                this._eventsCount = 0),
                this
            }
            ,
            s.prototype.off = s.prototype.removeListener,
            s.prototype.addListener = s.prototype.on,
            s.prefixed = f,
            s.EventEmitter = s,
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(57)
              , r = t(171)
              , o = t(306)
              , a = t(56)
              , n = t(47)
              , s = t(174)
              , l = new e({
                initialize: function(h, u, d, v) {
                    h === void 0 && (h = 0),
                    u === void 0 && (u = 0),
                    d === void 0 && (d = 0),
                    v === void 0 && (v = 0),
                    this.type = a.RECTANGLE,
                    this.x = h,
                    this.y = u,
                    this.width = d,
                    this.height = v
                },
                contains: function(i, h) {
                    return f(this, i, h)
                },
                getPoint: function(i, h) {
                    return r(this, i, h)
                },
                getPoints: function(i, h, u) {
                    return o(this, i, h, u)
                },
                getRandomPoint: function(i) {
                    return s(this, i)
                },
                setTo: function(i, h, u, d) {
                    return this.x = i,
                    this.y = h,
                    this.width = u,
                    this.height = d,
                    this
                },
                setEmpty: function() {
                    return this.setTo(0, 0, 0, 0)
                },
                setPosition: function(i, h) {
                    return h === void 0 && (h = i),
                    this.x = i,
                    this.y = h,
                    this
                },
                setSize: function(i, h) {
                    return h === void 0 && (h = i),
                    this.width = i,
                    this.height = h,
                    this
                },
                isEmpty: function() {
                    return this.width <= 0 || this.height <= 0
                },
                getLineA: function(i) {
                    return i === void 0 && (i = new n),
                    i.setTo(this.x, this.y, this.right, this.y),
                    i
                },
                getLineB: function(i) {
                    return i === void 0 && (i = new n),
                    i.setTo(this.right, this.y, this.right, this.bottom),
                    i
                },
                getLineC: function(i) {
                    return i === void 0 && (i = new n),
                    i.setTo(this.right, this.bottom, this.x, this.bottom),
                    i
                },
                getLineD: function(i) {
                    return i === void 0 && (i = new n),
                    i.setTo(this.x, this.bottom, this.x, this.y),
                    i
                },
                left: {
                    get: function() {
                        return this.x
                    },
                    set: function(i) {
                        i >= this.right ? this.width = 0 : this.width = this.right - i,
                        this.x = i
                    }
                },
                right: {
                    get: function() {
                        return this.x + this.width
                    },
                    set: function(i) {
                        i <= this.x ? this.width = 0 : this.width = i - this.x
                    }
                },
                top: {
                    get: function() {
                        return this.y
                    },
                    set: function(i) {
                        i >= this.bottom ? this.height = 0 : this.height = this.bottom - i,
                        this.y = i
                    }
                },
                bottom: {
                    get: function() {
                        return this.y + this.height
                    },
                    set: function(i) {
                        i <= this.y ? this.height = 0 : this.height = i - this.y
                    }
                },
                centerX: {
                    get: function() {
                        return this.x + this.width / 2
                    },
                    set: function(i) {
                        this.x = i - this.width / 2
                    }
                },
                centerY: {
                    get: function() {
                        return this.y + this.height / 2
                    },
                    set: function(i) {
                        this.y = i - this.height / 2
                    }
                }
            });
            c.exports = l
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Alpha: t(607),
                AlphaSingle: t(303),
                BlendMode: t(304),
                ComputedSize: t(608),
                Crop: t(609),
                Depth: t(305),
                Flip: t(610),
                GetBounds: t(611),
                Mask: t(309),
                Origin: t(632),
                PathFollower: t(633),
                Pipeline: t(167),
                ScrollFactor: t(312),
                Size: t(634),
                Texture: t(635),
                TextureCrop: t(636),
                Tint: t(637),
                ToJSON: t(176),
                Transform: t(313),
                TransformMatrix: t(25),
                Visible: t(314)
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @author       Matthew Groves <@doormat>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            function t(e) {
                for (var f = "", r = 0; r < e; ++r)
                    r > 0 && (f += `
else `),
                    r < e - 1 && (f += "if(test == " + r + ".0){}");
                return f
            }
            c.exports = {
                getTintFromFloats: function(e, f, r, o) {
                    var a = (e * 255 | 0) & 255
                      , n = (f * 255 | 0) & 255
                      , s = (r * 255 | 0) & 255
                      , l = (o * 255 | 0) & 255;
                    return (l << 24 | a << 16 | n << 8 | s) >>> 0
                },
                getTintAppendFloatAlpha: function(e, f) {
                    var r = (f * 255 | 0) & 255;
                    return (r << 24 | e) >>> 0
                },
                getTintAppendFloatAlphaAndSwap: function(e, f) {
                    var r = (e >> 16 | 0) & 255
                      , o = (e >> 8 | 0) & 255
                      , a = (e | 0) & 255
                      , n = (f * 255 | 0) & 255;
                    return (n << 24 | a << 16 | o << 8 | r) >>> 0
                },
                getFloatsFromUintRGB: function(e) {
                    var f = (e >> 16 | 0) & 255
                      , r = (e >> 8 | 0) & 255
                      , o = (e | 0) & 255;
                    return [f / 255, r / 255, o / 255]
                },
                checkShaderMax: function(e, f) {
                    (!f || f === -1) && (f = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS));
                    for (var r = e.createShader(e.FRAGMENT_SHADER), o = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join(`
`); ; ) {
                        var a = o.replace(/%forloop%/gi, t(f));
                        if (e.shaderSource(r, a),
                        e.compileShader(r),
                        !e.getShaderParameter(r, e.COMPILE_STATUS))
                            f = f / 2 | 0;
                        else
                            break
                    }
                    return f
                },
                parseFragmentShaderMaxTextures: function(e, f) {
                    if (!e)
                        return "";
                    for (var r = "", o = 0; o < f; o++)
                        o > 0 && (r += `
	else `),
                        o < f - 1 && (r += "if (outTexId < " + o + ".5)"),
                        r += `
	{`,
                        r += `
		texture = texture2D(uMainSampler[` + o + "], outTexCoord);",
                        r += `
	}`;
                    return e = e.replace(/%count%/gi, f.toString()),
                    e.replace(/%forloop%/gi, r)
                }
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(193)
              , f = t(6)
              , r = function(o, a, n) {
                var s = f(o, a, null);
                if (s === null)
                    return n;
                if (Array.isArray(s))
                    return e.RND.pick(s);
                if (typeof s == "object") {
                    if (s.hasOwnProperty("randInt"))
                        return e.RND.integerInRange(s.randInt[0], s.randInt[1]);
                    if (s.hasOwnProperty("randFloat"))
                        return e.RND.realInRange(s.randFloat[0], s.randFloat[1])
                } else if (typeof s == "function")
                    return s(a);
                return s
            };
            c.exports = r
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                PI2: Math.PI * 2,
                TAU: Math.PI * .5,
                EPSILON: 1e-6,
                DEG_TO_RAD: Math.PI / 180,
                RAD_TO_DEG: 180 / Math.PI,
                RND: null,
                MIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER || -9007199254740991,
                MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(176)
              , r = t(101)
              , o = t(9)
              , a = t(75)
              , n = t(20)
              , s = new e({
                Extends: o,
                initialize: function(i, h) {
                    o.call(this),
                    this.scene = i,
                    this.displayList = null,
                    this.type = h,
                    this.state = 0,
                    this.parentContainer = null,
                    this.name = "",
                    this.active = !0,
                    this.tabIndex = -1,
                    this.data = null,
                    this.renderFlags = 15,
                    this.cameraFilter = 0,
                    this.input = null,
                    this.body = null,
                    this.ignoreDestroy = !1,
                    this.on(a.ADDED_TO_SCENE, this.addedToScene, this),
                    this.on(a.REMOVED_FROM_SCENE, this.removedFromScene, this),
                    i.sys.queueDepthSort()
                },
                setActive: function(l) {
                    return this.active = l,
                    this
                },
                setName: function(l) {
                    return this.name = l,
                    this
                },
                setState: function(l) {
                    return this.state = l,
                    this
                },
                setDataEnabled: function() {
                    return this.data || (this.data = new r(this)),
                    this
                },
                setData: function(l, i) {
                    return this.data || (this.data = new r(this)),
                    this.data.set(l, i),
                    this
                },
                incData: function(l, i) {
                    return this.data || (this.data = new r(this)),
                    this.data.inc(l, i),
                    this
                },
                toggleData: function(l) {
                    return this.data || (this.data = new r(this)),
                    this.data.toggle(l),
                    this
                },
                getData: function(l) {
                    return this.data || (this.data = new r(this)),
                    this.data.get(l)
                },
                setInteractive: function(l, i, h) {
                    return this.scene.sys.input.enable(this, l, i, h),
                    this
                },
                disableInteractive: function() {
                    return this.input && (this.input.enabled = !1),
                    this
                },
                removeInteractive: function() {
                    return this.scene.sys.input.clear(this),
                    this.input = void 0,
                    this
                },
                addedToScene: function() {},
                removedFromScene: function() {},
                update: function() {},
                toJSON: function() {
                    return f(this)
                },
                willRender: function(l) {
                    return !(s.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & l.id)
                },
                getIndexList: function() {
                    for (var l = this, i = this.parentContainer, h = []; i && (h.unshift(i.getIndex(l)),
                    l = i,
                    i.parentContainer); )
                        i = i.parentContainer;
                    return this.displayList ? h.unshift(this.displayList.getIndex(l)) : h.unshift(this.scene.sys.displayList.getIndex(l)),
                    h
                },
                addToDisplayList: function(l) {
                    return l === void 0 && (l = this.scene.sys.displayList),
                    this.displayList && this.displayList !== l && this.removeFromDisplayList(),
                    l.exists(this) || (this.displayList = l,
                    l.add(this, !0),
                    l.queueDepthSort(),
                    this.emit(a.ADDED_TO_SCENE, this, this.scene),
                    l.events.emit(n.ADDED_TO_SCENE, this, this.scene)),
                    this
                },
                addToUpdateList: function() {
                    return this.scene && this.preUpdate && this.scene.sys.updateList.add(this),
                    this
                },
                removeFromDisplayList: function() {
                    var l = this.displayList || this.scene.sys.displayList;
                    return l.exists(this) && (l.remove(this, !0),
                    l.queueDepthSort(),
                    this.displayList = null,
                    this.emit(a.REMOVED_FROM_SCENE, this, this.scene),
                    l.events.emit(n.REMOVED_FROM_SCENE, this, this.scene)),
                    this
                },
                removeFromUpdateList: function() {
                    return this.scene && this.preUpdate && this.scene.sys.updateList.remove(this),
                    this
                },
                destroy: function(l) {
                    !this.scene || this.ignoreDestroy || (l === void 0 && (l = !1),
                    this.preDestroy && this.preDestroy.call(this),
                    this.emit(a.DESTROY, this, l),
                    this.removeAllListeners(),
                    this.postPipelines && this.resetPostPipeline(!0),
                    this.removeFromDisplayList(),
                    this.removeFromUpdateList(),
                    this.input && (this.scene.sys.input.clear(this),
                    this.input = void 0),
                    this.data && (this.data.destroy(),
                    this.data = void 0),
                    this.body && (this.body.destroy(),
                    this.body = void 0),
                    this.active = !1,
                    this.visible = !1,
                    this.scene = void 0,
                    this.parentContainer = void 0)
                }
            });
            s.RENDER_MASK = 15,
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(24)
              , r = t(20)
              , o = new e({
                initialize: function(n) {
                    this.scene = n,
                    this.systems = n.sys,
                    this.events = n.sys.events,
                    this.displayList,
                    this.updateList,
                    this.events.once(r.BOOT, this.boot, this),
                    this.events.on(r.START, this.start, this)
                },
                boot: function() {
                    this.displayList = this.systems.displayList,
                    this.updateList = this.systems.updateList,
                    this.events.once(r.DESTROY, this.destroy, this)
                },
                start: function() {
                    this.events.once(r.SHUTDOWN, this.shutdown, this)
                },
                shutdown: function() {
                    this.events.off(r.SHUTDOWN, this.shutdown, this)
                },
                destroy: function() {
                    this.shutdown(),
                    this.events.off(r.START, this.start, this),
                    this.scene = null,
                    this.systems = null,
                    this.events = null,
                    this.displayList = null,
                    this.updateList = null
                }
            });
            o.register = function(a, n) {
                o.prototype.hasOwnProperty(a) || (o.prototype[a] = n)
            }
            ,
            o.remove = function(a) {
                o.prototype.hasOwnProperty(a) && delete o.prototype[a]
            }
            ,
            f.register("GameObjectCreator", o, "make"),
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(7)
              , f = function() {
                var r, o, a, n, s, l, i = arguments[0] || {}, h = 1, u = arguments.length, d = !1;
                for (typeof i == "boolean" && (d = i,
                i = arguments[1] || {},
                h = 2),
                u === h && (i = this,
                --h); h < u; h++)
                    if ((r = arguments[h]) != null)
                        for (o in r)
                            a = i[o],
                            n = r[o],
                            i !== n && (d && n && (e(n) || (s = Array.isArray(n))) ? (s ? (s = !1,
                            l = a && Array.isArray(a) ? a : []) : l = a && e(a) ? a : {},
                            i[o] = f(d, l, n)) : n !== void 0 && (i[o] = n));
                return i
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                return Math.max(f, Math.min(r, e))
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(25)
              , f = new e
              , r = new e
              , o = new e
              , a = {
                camera: f,
                sprite: r,
                calc: o
            }
              , n = function(s, l, i) {
                var h = f
                  , u = r
                  , d = o;
                return u.applyITRS(s.x, s.y, s.rotation, s.scaleX, s.scaleY),
                h.copyFrom(l.matrix),
                i ? (h.multiplyWithOffset(i, -l.scrollX * s.scrollFactorX, -l.scrollY * s.scrollFactorY),
                u.e = s.x,
                u.f = s.y) : (u.e -= l.scrollX * s.scrollFactorX,
                u.f -= l.scrollY * s.scrollFactorY),
                h.multiply(u, d),
                a
            };
            c.exports = n
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                ADDED_TO_SCENE: t(656),
                BOOT: t(657),
                CREATE: t(658),
                DESTROY: t(659),
                PAUSE: t(660),
                POST_UPDATE: t(661),
                PRE_RENDER: t(662),
                PRE_UPDATE: t(663),
                READY: t(664),
                REMOVED_FROM_SCENE: t(665),
                RENDER: t(666),
                RESUME: t(667),
                SHUTDOWN: t(668),
                SLEEP: t(669),
                START: t(670),
                TRANSITION_COMPLETE: t(671),
                TRANSITION_INIT: t(672),
                TRANSITION_OUT: t(673),
                TRANSITION_START: t(674),
                TRANSITION_WAKE: t(675),
                UPDATE: t(676),
                WAKE: t(677)
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                LOADER_IDLE: 0,
                LOADER_LOADING: 1,
                LOADER_PROCESSING: 2,
                LOADER_COMPLETE: 3,
                LOADER_SHUTDOWN: 4,
                LOADER_DESTROYED: 5,
                FILE_PENDING: 10,
                FILE_LOADING: 11,
                FILE_LOADED: 12,
                FILE_FAILED: 13,
                FILE_PROCESSING: 14,
                FILE_ERRORED: 16,
                FILE_COMPLETE: 17,
                FILE_DESTROYED: 18,
                FILE_POPULATED: 19
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                BLUR: t(612),
                BOOT: t(613),
                CONTEXT_LOST: t(614),
                CONTEXT_RESTORED: t(615),
                DESTROY: t(616),
                FOCUS: t(617),
                HIDDEN: t(618),
                PAUSE: t(619),
                POST_RENDER: t(620),
                POST_STEP: t(621),
                PRE_RENDER: t(622),
                PRE_STEP: t(623),
                READY: t(624),
                RESUME: t(625),
                STEP: t(626),
                VISIBLE: t(627)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(21)
              , r = t(95)
              , o = t(2)
              , a = t(155)
              , n = t(240)
              , s = t(517)
              , l = t(156)
              , i = new e({
                initialize: function(u, d) {
                    this.loader = u,
                    this.cache = o(d, "cache", !1),
                    this.type = o(d, "type", !1),
                    this.key = o(d, "key", !1);
                    var v = this.key;
                    if (u.prefix && u.prefix !== "" && (this.key = u.prefix + v),
                    !this.type || !this.key)
                        throw new Error("Invalid Loader." + this.type + " key");
                    var p = o(d, "url");
                    p === void 0 ? p = u.path + v + "." + o(d, "extension", "") : typeof p == "string" && !p.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) && (p = u.path + p),
                    this.url = p,
                    this.src = "",
                    this.xhrSettings = l(o(d, "responseType", void 0)),
                    o(d, "xhrSettings", !1) && (this.xhrSettings = n(this.xhrSettings, o(d, "xhrSettings", {}))),
                    this.xhrLoader = null,
                    this.state = typeof this.url == "function" ? f.FILE_POPULATED : f.FILE_PENDING,
                    this.bytesTotal = 0,
                    this.bytesLoaded = -1,
                    this.percentComplete = -1,
                    this.crossOrigin = void 0,
                    this.data = void 0,
                    this.config = o(d, "config", {}),
                    this.multiFile,
                    this.linkFile
                },
                setLink: function(h) {
                    this.linkFile = h,
                    h.linkFile = this
                },
                resetXHR: function() {
                    this.xhrLoader && (this.xhrLoader.onload = void 0,
                    this.xhrLoader.onerror = void 0,
                    this.xhrLoader.onprogress = void 0)
                },
                load: function() {
                    this.state === f.FILE_POPULATED ? this.loader.nextFile(this, !0) : (this.state = f.FILE_LOADING,
                    this.src = a(this, this.loader.baseURL),
                    this.src.indexOf("data:") === 0 ? console.warn("Local data URIs are not supported: " + this.key) : this.xhrLoader = s(this, this.loader.xhr))
                },
                onLoad: function(h, u) {
                    var d = h.responseURL && (h.responseURL.indexOf("file://") === 0 || h.responseURL.indexOf("capacitor://") === 0)
                      , v = d && u.target.status === 0
                      , p = !(u.target && u.target.status !== 200) || v;
                    h.readyState === 4 && h.status >= 400 && h.status <= 599 && (p = !1),
                    this.state = f.FILE_LOADED,
                    this.resetXHR(),
                    this.loader.nextFile(this, p)
                },
                onError: function() {
                    this.resetXHR(),
                    this.loader.nextFile(this, !1)
                },
                onProgress: function(h) {
                    h.lengthComputable && (this.bytesLoaded = h.loaded,
                    this.bytesTotal = h.total,
                    this.percentComplete = Math.min(this.bytesLoaded / this.bytesTotal, 1),
                    this.loader.emit(r.FILE_PROGRESS, this, this.percentComplete))
                },
                onProcess: function() {
                    this.state = f.FILE_PROCESSING,
                    this.onProcessComplete()
                },
                onProcessComplete: function() {
                    this.state = f.FILE_COMPLETE,
                    this.multiFile && this.multiFile.onFileComplete(this),
                    this.loader.fileProcessComplete(this)
                },
                onProcessError: function() {
                    this.state = f.FILE_ERRORED,
                    this.multiFile && this.multiFile.onFileFailed(this),
                    this.loader.fileProcessComplete(this)
                },
                hasCacheConflict: function() {
                    return this.cache && this.cache.exists(this.key)
                },
                addToCache: function() {
                    this.cache && this.cache.add(this.key, this.data),
                    this.pendingDestroy()
                },
                pendingDestroy: function(h) {
                    h === void 0 && (h = this.data);
                    var u = this.key
                      , d = this.type;
                    this.loader.emit(r.FILE_COMPLETE, u, d, h),
                    this.loader.emit(r.FILE_KEY_COMPLETE + d + "-" + u, u, d, h),
                    this.loader.flagForRemoval(this)
                },
                destroy: function() {
                    this.loader = null,
                    this.cache = null,
                    this.xhrSettings = null,
                    this.multiFile = null,
                    this.linkFile = null,
                    this.data = null
                }
            });
            i.createObjectURL = function(h, u, d) {
                if (typeof URL == "function")
                    h.src = URL.createObjectURL(u);
                else {
                    var v = new FileReader;
                    v.onload = function() {
                        h.removeAttribute("crossOrigin"),
                        h.src = "data:" + (u.type || d) + ";base64," + v.result.split(",")[1]
                    }
                    ,
                    v.onerror = h.onerror,
                    v.readAsDataURL(u)
                }
            }
            ,
            i.revokeObjectURL = function(h) {
                typeof URL == "function" && URL.revokeObjectURL(h.src)
            }
            ,
            c.exports = i
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {}
              , e = {}
              , f = {};
            f.register = function(r, o, a, n) {
                n === void 0 && (n = !1),
                t[r] = {
                    plugin: o,
                    mapping: a,
                    custom: n
                }
            }
            ,
            f.registerCustom = function(r, o, a, n) {
                e[r] = {
                    plugin: o,
                    mapping: a,
                    data: n
                }
            }
            ,
            f.hasCore = function(r) {
                return t.hasOwnProperty(r)
            }
            ,
            f.hasCustom = function(r) {
                return e.hasOwnProperty(r)
            }
            ,
            f.getCore = function(r) {
                return t[r]
            }
            ,
            f.getCustom = function(r) {
                return e[r]
            }
            ,
            f.getCustomClass = function(r) {
                return e.hasOwnProperty(r) ? e[r].plugin : null
            }
            ,
            f.remove = function(r) {
                t.hasOwnProperty(r) && delete t[r]
            }
            ,
            f.removeCustom = function(r) {
                e.hasOwnProperty(r) && delete e[r]
            }
            ,
            f.destroyCorePlugins = function() {
                for (var r in t)
                    t.hasOwnProperty(r) && delete t[r]
            }
            ,
            f.destroyCustomPlugins = function() {
                for (var r in e)
                    e.hasOwnProperty(r) && delete e[r]
            }
            ,
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(14)
              , r = t(3)
              , o = new e({
                initialize: function(n, s, l, i, h, u) {
                    n === void 0 && (n = 1),
                    s === void 0 && (s = 0),
                    l === void 0 && (l = 0),
                    i === void 0 && (i = 1),
                    h === void 0 && (h = 0),
                    u === void 0 && (u = 0),
                    this.matrix = new Float32Array([n, s, l, i, h, u, 0, 0, 1]),
                    this.decomposedMatrix = {
                        translateX: 0,
                        translateY: 0,
                        scaleX: 1,
                        scaleY: 1,
                        rotation: 0
                    }
                },
                a: {
                    get: function() {
                        return this.matrix[0]
                    },
                    set: function(a) {
                        this.matrix[0] = a
                    }
                },
                b: {
                    get: function() {
                        return this.matrix[1]
                    },
                    set: function(a) {
                        this.matrix[1] = a
                    }
                },
                c: {
                    get: function() {
                        return this.matrix[2]
                    },
                    set: function(a) {
                        this.matrix[2] = a
                    }
                },
                d: {
                    get: function() {
                        return this.matrix[3]
                    },
                    set: function(a) {
                        this.matrix[3] = a
                    }
                },
                e: {
                    get: function() {
                        return this.matrix[4]
                    },
                    set: function(a) {
                        this.matrix[4] = a
                    }
                },
                f: {
                    get: function() {
                        return this.matrix[5]
                    },
                    set: function(a) {
                        this.matrix[5] = a
                    }
                },
                tx: {
                    get: function() {
                        return this.matrix[4]
                    },
                    set: function(a) {
                        this.matrix[4] = a
                    }
                },
                ty: {
                    get: function() {
                        return this.matrix[5]
                    },
                    set: function(a) {
                        this.matrix[5] = a
                    }
                },
                rotation: {
                    get: function() {
                        return Math.acos(this.a / this.scaleX) * (Math.atan(-this.c / this.a) < 0 ? -1 : 1)
                    }
                },
                rotationNormalized: {
                    get: function() {
                        var a = this.matrix
                          , n = a[0]
                          , s = a[1]
                          , l = a[2]
                          , i = a[3];
                        return n || s ? s > 0 ? Math.acos(n / this.scaleX) : -Math.acos(n / this.scaleX) : l || i ? f.TAU - (i > 0 ? Math.acos(-l / this.scaleY) : -Math.acos(l / this.scaleY)) : 0
                    }
                },
                scaleX: {
                    get: function() {
                        return Math.sqrt(this.a * this.a + this.b * this.b)
                    }
                },
                scaleY: {
                    get: function() {
                        return Math.sqrt(this.c * this.c + this.d * this.d)
                    }
                },
                loadIdentity: function() {
                    var a = this.matrix;
                    return a[0] = 1,
                    a[1] = 0,
                    a[2] = 0,
                    a[3] = 1,
                    a[4] = 0,
                    a[5] = 0,
                    this
                },
                translate: function(a, n) {
                    var s = this.matrix;
                    return s[4] = s[0] * a + s[2] * n + s[4],
                    s[5] = s[1] * a + s[3] * n + s[5],
                    this
                },
                scale: function(a, n) {
                    var s = this.matrix;
                    return s[0] *= a,
                    s[1] *= a,
                    s[2] *= n,
                    s[3] *= n,
                    this
                },
                rotate: function(a) {
                    var n = Math.sin(a)
                      , s = Math.cos(a)
                      , l = this.matrix
                      , i = l[0]
                      , h = l[1]
                      , u = l[2]
                      , d = l[3];
                    return l[0] = i * s + u * n,
                    l[1] = h * s + d * n,
                    l[2] = i * -n + u * s,
                    l[3] = h * -n + d * s,
                    this
                },
                multiply: function(a, n) {
                    var s = this.matrix
                      , l = a.matrix
                      , i = s[0]
                      , h = s[1]
                      , u = s[2]
                      , d = s[3]
                      , v = s[4]
                      , p = s[5]
                      , g = l[0]
                      , m = l[1]
                      , x = l[2]
                      , T = l[3]
                      , E = l[4]
                      , P = l[5]
                      , M = n === void 0 ? this : n;
                    return M.a = g * i + m * u,
                    M.b = g * h + m * d,
                    M.c = x * i + T * u,
                    M.d = x * h + T * d,
                    M.e = E * i + P * u + v,
                    M.f = E * h + P * d + p,
                    M
                },
                multiplyWithOffset: function(a, n, s) {
                    var l = this.matrix
                      , i = a.matrix
                      , h = l[0]
                      , u = l[1]
                      , d = l[2]
                      , v = l[3]
                      , p = l[4]
                      , g = l[5]
                      , m = n * h + s * d + p
                      , x = n * u + s * v + g
                      , T = i[0]
                      , E = i[1]
                      , P = i[2]
                      , M = i[3]
                      , L = i[4]
                      , R = i[5];
                    return l[0] = T * h + E * d,
                    l[1] = T * u + E * v,
                    l[2] = P * h + M * d,
                    l[3] = P * u + M * v,
                    l[4] = L * h + R * d + m,
                    l[5] = L * u + R * v + x,
                    this
                },
                transform: function(a, n, s, l, i, h) {
                    var u = this.matrix
                      , d = u[0]
                      , v = u[1]
                      , p = u[2]
                      , g = u[3]
                      , m = u[4]
                      , x = u[5];
                    return u[0] = a * d + n * p,
                    u[1] = a * v + n * g,
                    u[2] = s * d + l * p,
                    u[3] = s * v + l * g,
                    u[4] = i * d + h * p + m,
                    u[5] = i * v + h * g + x,
                    this
                },
                transformPoint: function(a, n, s) {
                    s === void 0 && (s = {
                        x: 0,
                        y: 0
                    });
                    var l = this.matrix
                      , i = l[0]
                      , h = l[1]
                      , u = l[2]
                      , d = l[3]
                      , v = l[4]
                      , p = l[5];
                    return s.x = a * i + n * u + v,
                    s.y = a * h + n * d + p,
                    s
                },
                invert: function() {
                    var a = this.matrix
                      , n = a[0]
                      , s = a[1]
                      , l = a[2]
                      , i = a[3]
                      , h = a[4]
                      , u = a[5]
                      , d = n * i - s * l;
                    return a[0] = i / d,
                    a[1] = -s / d,
                    a[2] = -l / d,
                    a[3] = n / d,
                    a[4] = (l * u - i * h) / d,
                    a[5] = -(n * u - s * h) / d,
                    this
                },
                copyFrom: function(a) {
                    var n = this.matrix;
                    return n[0] = a.a,
                    n[1] = a.b,
                    n[2] = a.c,
                    n[3] = a.d,
                    n[4] = a.e,
                    n[5] = a.f,
                    this
                },
                copyFromArray: function(a) {
                    var n = this.matrix;
                    return n[0] = a[0],
                    n[1] = a[1],
                    n[2] = a[2],
                    n[3] = a[3],
                    n[4] = a[4],
                    n[5] = a[5],
                    this
                },
                copyToContext: function(a) {
                    var n = this.matrix;
                    return a.transform(n[0], n[1], n[2], n[3], n[4], n[5]),
                    a
                },
                setToContext: function(a) {
                    var n = this.matrix;
                    return a.setTransform(n[0], n[1], n[2], n[3], n[4], n[5]),
                    a
                },
                copyToArray: function(a) {
                    var n = this.matrix;
                    return a === void 0 ? a = [n[0], n[1], n[2], n[3], n[4], n[5]] : (a[0] = n[0],
                    a[1] = n[1],
                    a[2] = n[2],
                    a[3] = n[3],
                    a[4] = n[4],
                    a[5] = n[5]),
                    a
                },
                setTransform: function(a, n, s, l, i, h) {
                    var u = this.matrix;
                    return u[0] = a,
                    u[1] = n,
                    u[2] = s,
                    u[3] = l,
                    u[4] = i,
                    u[5] = h,
                    this
                },
                decomposeMatrix: function() {
                    var a = this.decomposedMatrix
                      , n = this.matrix
                      , s = n[0]
                      , l = n[1]
                      , i = n[2]
                      , h = n[3]
                      , u = s * h - l * i;
                    if (a.translateX = n[4],
                    a.translateY = n[5],
                    s || l) {
                        var d = Math.sqrt(s * s + l * l);
                        a.rotation = l > 0 ? Math.acos(s / d) : -Math.acos(s / d),
                        a.scaleX = d,
                        a.scaleY = u / d
                    } else if (i || h) {
                        var v = Math.sqrt(i * i + h * h);
                        a.rotation = Math.PI * .5 - (h > 0 ? Math.acos(-i / v) : -Math.acos(i / v)),
                        a.scaleX = u / v,
                        a.scaleY = v
                    } else
                        a.rotation = 0,
                        a.scaleX = 0,
                        a.scaleY = 0;
                    return a
                },
                applyITRS: function(a, n, s, l, i) {
                    var h = this.matrix
                      , u = Math.sin(s)
                      , d = Math.cos(s);
                    return h[4] = a,
                    h[5] = n,
                    h[0] = d * l,
                    h[1] = u * l,
                    h[2] = -u * i,
                    h[3] = d * i,
                    this
                },
                applyInverse: function(a, n, s) {
                    s === void 0 && (s = new r);
                    var l = this.matrix
                      , i = l[0]
                      , h = l[1]
                      , u = l[2]
                      , d = l[3]
                      , v = l[4]
                      , p = l[5]
                      , g = 1 / (i * d + u * -h);
                    return s.x = d * g * a + -u * g * n + (p * u - v * d) * g,
                    s.y = i * g * n + -h * g * a + (-p * i + v * h) * g,
                    s
                },
                getX: function(a, n) {
                    return a * this.a + n * this.c + this.e
                },
                getY: function(a, n) {
                    return a * this.b + n * this.d + this.f
                },
                getXRound: function(a, n, s) {
                    var l = this.getX(a, n);
                    return s && (l = Math.round(l)),
                    l
                },
                getYRound: function(a, n, s) {
                    var l = this.getY(a, n);
                    return s && (l = Math.round(l)),
                    l
                },
                getCSSMatrix: function() {
                    var a = this.matrix;
                    return "matrix(" + a[0] + "," + a[1] + "," + a[2] + "," + a[3] + "," + a[4] + "," + a[5] + ")"
                },
                destroy: function() {
                    this.matrix = null,
                    this.decomposedMatrix = null
                }
            });
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(2)
              , f = function(r, o, a, n, s, l) {
                r === void 0 && (r = 0),
                o === void 0 && (o = 0),
                a === void 0 && (a = l.width),
                n === void 0 && (n = l.height),
                s || (s = {});
                var i = e(s, "isNotEmpty", !1)
                  , h = e(s, "isColliding", !1)
                  , u = e(s, "hasInterestingFace", !1);
                r < 0 && (a += r,
                r = 0),
                o < 0 && (n += o,
                o = 0),
                r + a > l.width && (a = Math.max(l.width - r, 0)),
                o + n > l.height && (n = Math.max(l.height - o, 0));
                for (var d = [], v = o; v < o + n; v++)
                    for (var p = r; p < r + a; p++) {
                        var g = l.data[v][p];
                        if (g !== null) {
                            if (i && g.index === -1 || h && !g.collides || u && !g.hasInterestingFace)
                                continue;
                            d.push(g)
                        }
                    }
                return d
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o, a, n) {
                o === void 0 && (o = 0),
                a === void 0 && (a = 0),
                n === void 0 && (n = 1);
                var s, l = 0, i = e.length;
                if (n === 1)
                    for (s = a; s < i; s++)
                        e[s][f] = r + l * o,
                        l++;
                else
                    for (s = a; s >= 0; s--)
                        e[s][f] = r + l * o,
                        l++;
                return e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(35)
              , f = t(13)
              , r = function(o, a, n) {
                a.x = f(n, "x", 0),
                a.y = f(n, "y", 0),
                a.depth = f(n, "depth", 0),
                a.flipX = f(n, "flipX", !1),
                a.flipY = f(n, "flipY", !1);
                var s = f(n, "scale", null);
                typeof s == "number" ? a.setScale(s) : s !== null && (a.scaleX = f(s, "x", 1),
                a.scaleY = f(s, "y", 1));
                var l = f(n, "scrollFactor", null);
                typeof l == "number" ? a.setScrollFactor(l) : l !== null && (a.scrollFactorX = f(l, "x", 1),
                a.scrollFactorY = f(l, "y", 1)),
                a.rotation = f(n, "rotation", 0);
                var i = f(n, "angle", null);
                i !== null && (a.angle = i),
                a.alpha = f(n, "alpha", 1);
                var h = f(n, "origin", null);
                if (typeof h == "number")
                    a.setOrigin(h);
                else if (h !== null) {
                    var u = f(h, "x", .5)
                      , d = f(h, "y", .5);
                    a.setOrigin(u, d)
                }
                a.blendMode = f(n, "blendMode", e.NORMAL),
                a.visible = f(n, "visible", !0);
                var v = f(n, "add", !0);
                return v && o.sys.displayList.add(a),
                a.preUpdate && o.sys.updateList.add(a),
                a
            };
            c.exports = r
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                ORTHOGONAL: 0,
                ISOMETRIC: 1,
                STAGGERED: 2,
                HEXAGONAL: 3
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(19)
              , f = function(r, o, a, n, s) {
                var l = n.alpha * a.alpha;
                if (l <= 0)
                    return !1;
                var i = e(a, n, s).calc;
                return o.globalCompositeOperation = r.blendModes[a.blendMode],
                o.globalAlpha = l,
                o.save(),
                i.setToContext(o),
                o.imageSmoothingEnabled = !(!r.antialias || a.frame && a.frame.source.scaleMode),
                !0
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(33)
              , f = t(192)
              , r = []
              , o = !1
              , a = function() {
                var n = function(g, m, x, T, E) {
                    m === void 0 && (m = 1),
                    x === void 0 && (x = 1),
                    T === void 0 && (T = e.CANVAS),
                    E === void 0 && (E = !1);
                    var P, M = i(T);
                    return M === null ? (M = {
                        parent: g,
                        canvas: document.createElement("canvas"),
                        type: T
                    },
                    T === e.CANVAS && r.push(M),
                    P = M.canvas) : (M.parent = g,
                    P = M.canvas),
                    E && (M.parent = P),
                    P.width = m,
                    P.height = x,
                    o && T === e.CANVAS && f.disable(P.getContext("2d")),
                    P
                }
                  , s = function(g, m, x) {
                    return n(g, m, x, e.CANVAS)
                }
                  , l = function(g, m, x) {
                    return n(g, m, x, e.WEBGL)
                }
                  , i = function(g) {
                    if (g === void 0 && (g = e.CANVAS),
                    g === e.WEBGL)
                        return null;
                    for (var m = 0; m < r.length; m++) {
                        var x = r[m];
                        if (!x.parent && x.type === g)
                            return x
                    }
                    return null
                }
                  , h = function(g) {
                    var m = g instanceof HTMLCanvasElement;
                    r.forEach(function(x) {
                        (m && x.canvas === g || !m && x.parent === g) && (x.parent = null,
                        x.canvas.width = 1,
                        x.canvas.height = 1)
                    })
                }
                  , u = function() {
                    var g = 0;
                    return r.forEach(function(m) {
                        m.parent && g++
                    }),
                    g
                }
                  , d = function() {
                    return r.length - u()
                }
                  , v = function() {
                    o = !0
                }
                  , p = function() {
                    o = !1
                };
                return {
                    create2D: s,
                    create: n,
                    createWebGL: l,
                    disableSmoothing: v,
                    enableSmoothing: p,
                    first: i,
                    free: d,
                    pool: r,
                    remove: h,
                    total: u
                }
            };
            c.exports = a()
        }
        , function(c, S) {
            var t = {};
            c.exports = t,
            function() {
                t._nextId = 0,
                t._seed = 0,
                t._nowStartTime = +new Date,
                t.extend = function(f, r) {
                    var o, a;
                    typeof r == "boolean" ? (o = 2,
                    a = r) : (o = 1,
                    a = !0);
                    for (var n = o; n < arguments.length; n++) {
                        var s = arguments[n];
                        if (s)
                            for (var l in s)
                                a && s[l] && s[l].constructor === Object && (!f[l] || f[l].constructor === Object) ? (f[l] = f[l] || {},
                                t.extend(f[l], a, s[l])) : f[l] = s[l]
                    }
                    return f
                }
                ,
                t.clone = function(f, r) {
                    return t.extend({}, r, f)
                }
                ,
                t.keys = function(f) {
                    if (Object.keys)
                        return Object.keys(f);
                    var r = [];
                    for (var o in f)
                        r.push(o);
                    return r
                }
                ,
                t.values = function(f) {
                    var r = [];
                    if (Object.keys) {
                        for (var o = Object.keys(f), a = 0; a < o.length; a++)
                            r.push(f[o[a]]);
                        return r
                    }
                    for (var n in f)
                        r.push(f[n]);
                    return r
                }
                ,
                t.get = function(f, r, o, a) {
                    r = r.split(".").slice(o, a);
                    for (var n = 0; n < r.length; n += 1)
                        f = f[r[n]];
                    return f
                }
                ,
                t.set = function(f, r, o, a, n) {
                    var s = r.split(".").slice(a, n);
                    return t.get(f, r, 0, -1)[s[s.length - 1]] = o,
                    o
                }
                ,
                t.shuffle = function(f) {
                    for (var r = f.length - 1; r > 0; r--) {
                        var o = Math.floor(t.random() * (r + 1))
                          , a = f[r];
                        f[r] = f[o],
                        f[o] = a
                    }
                    return f
                }
                ,
                t.choose = function(f) {
                    return f[Math.floor(t.random() * f.length)]
                }
                ,
                t.isElement = function(f) {
                    return typeof HTMLElement < "u" ? f instanceof HTMLElement : !!(f && f.nodeType && f.nodeName)
                }
                ,
                t.isArray = function(f) {
                    return Object.prototype.toString.call(f) === "[object Array]"
                }
                ,
                t.isFunction = function(f) {
                    return typeof f == "function"
                }
                ,
                t.isPlainObject = function(f) {
                    return typeof f == "object" && f.constructor === Object
                }
                ,
                t.isString = function(f) {
                    return Object.prototype.toString.call(f) === "[object String]"
                }
                ,
                t.clamp = function(f, r, o) {
                    return f < r ? r : f > o ? o : f
                }
                ,
                t.sign = function(f) {
                    return f < 0 ? -1 : 1
                }
                ,
                t.now = function() {
                    if (typeof window < "u" && window.performance) {
                        if (window.performance.now)
                            return window.performance.now();
                        if (window.performance.webkitNow)
                            return window.performance.webkitNow()
                    }
                    return new Date - t._nowStartTime
                }
                ,
                t.random = function(f, r) {
                    return f = typeof f < "u" ? f : 0,
                    r = typeof r < "u" ? r : 1,
                    f + e() * (r - f)
                }
                ;
                var e = function() {
                    return t._seed = (t._seed * 9301 + 49297) % 233280,
                    t._seed / 233280
                };
                t.colorToNumber = function(f) {
                    return f = f.replace("#", ""),
                    f.length == 3 && (f = f.charAt(0) + f.charAt(0) + f.charAt(1) + f.charAt(1) + f.charAt(2) + f.charAt(2)),
                    parseInt(f, 16)
                }
                ,
                t.logLevel = 1,
                t.log = function() {
                    console && t.logLevel > 0 && t.logLevel <= 3 && console.log.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)))
                }
                ,
                t.info = function() {
                    console && t.logLevel > 0 && t.logLevel <= 2 && console.info.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)))
                }
                ,
                t.warn = function() {
                    console && t.logLevel > 0 && t.logLevel <= 3 && console.warn.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)))
                }
                ,
                t.nextId = function() {
                    return t._nextId++
                }
                ,
                t.indexOf = function(f, r) {
                    if (f.indexOf)
                        return f.indexOf(r);
                    for (var o = 0; o < f.length; o++)
                        if (f[o] === r)
                            return o;
                    return -1
                }
                ,
                t.map = function(f, r) {
                    if (f.map)
                        return f.map(r);
                    for (var o = [], a = 0; a < f.length; a += 1)
                        o.push(r(f[a]));
                    return o
                }
                ,
                t.topologicalSort = function(f) {
                    var r = []
                      , o = []
                      , a = [];
                    for (var n in f)
                        !o[n] && !a[n] && t._topologicalSort(n, o, a, f, r);
                    return r
                }
                ,
                t._topologicalSort = function(f, r, o, a, n) {
                    var s = a[f] || [];
                    o[f] = !0;
                    for (var l = 0; l < s.length; l += 1) {
                        var i = s[l];
                        o[i] || r[i] || t._topologicalSort(i, r, o, a, n)
                    }
                    o[f] = !1,
                    r[f] = !0,
                    n.push(f)
                }
                ,
                t.chain = function() {
                    for (var f = [], r = 0; r < arguments.length; r += 1) {
                        var o = arguments[r];
                        o._chained ? f.push.apply(f, o._chained) : f.push(o)
                    }
                    var a = function() {
                        for (var n, s = new Array(arguments.length), l = 0, i = arguments.length; l < i; l++)
                            s[l] = arguments[l];
                        for (l = 0; l < f.length; l += 1) {
                            var h = f[l].apply(n, s);
                            typeof h < "u" && (n = h)
                        }
                        return n
                    };
                    return a._chained = f,
                    a
                }
                ,
                t.chainPathBefore = function(f, r, o) {
                    return t.set(f, r, t.chain(o, t.get(f, r)))
                }
                ,
                t.chainPathAfter = function(f, r, o) {
                    return t.set(f, r, t.chain(t.get(f, r), o))
                }
            }()
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = {
                VERSION: "3.55.2",
                BlendModes: t(35),
                ScaleModes: t(168),
                AUTO: 0,
                CANVAS: 1,
                WEBGL: 2,
                HEADLESS: 3,
                FOREVER: -1,
                NONE: 4,
                UP: 5,
                DOWN: 6,
                LEFT: 7,
                RIGHT: 8
            };
            c.exports = e
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(11)
              , r = t(15)
              , o = t(47)
              , a = new e({
                Extends: r,
                Mixins: [f.AlphaSingle, f.BlendMode, f.Depth, f.GetBounds, f.Mask, f.Origin, f.Pipeline, f.ScrollFactor, f.Transform, f.Visible],
                initialize: function(s, l, i) {
                    l === void 0 && (l = "Shape"),
                    r.call(this, s, l),
                    this.geom = i,
                    this.pathData = [],
                    this.pathIndexes = [],
                    this.fillColor = 16777215,
                    this.fillAlpha = 1,
                    this.strokeColor = 16777215,
                    this.strokeAlpha = 1,
                    this.lineWidth = 1,
                    this.isFilled = !1,
                    this.isStroked = !1,
                    this.closePath = !0,
                    this._tempLine = new o,
                    this.width = 0,
                    this.height = 0,
                    this.initPipeline()
                },
                setFillStyle: function(n, s) {
                    return s === void 0 && (s = 1),
                    n === void 0 ? this.isFilled = !1 : (this.fillColor = n,
                    this.fillAlpha = s,
                    this.isFilled = !0),
                    this
                },
                setStrokeStyle: function(n, s, l) {
                    return l === void 0 && (l = 1),
                    n === void 0 ? this.isStroked = !1 : (this.lineWidth = n,
                    this.strokeColor = s,
                    this.strokeAlpha = l,
                    this.isStroked = !0),
                    this
                },
                setClosePath: function(n) {
                    return this.closePath = n,
                    this
                },
                setSize: function(n, s) {
                    return this.width = n,
                    this.height = s,
                    this
                },
                setDisplaySize: function(n, s) {
                    return this.displayWidth = n,
                    this.displayHeight = s,
                    this
                },
                preDestroy: function() {
                    this.geom = null,
                    this._tempLine = null,
                    this.pathData = [],
                    this.pathIndexes = []
                },
                displayWidth: {
                    get: function() {
                        return this.scaleX * this.width
                    },
                    set: function(n) {
                        this.scaleX = n / this.width
                    }
                },
                displayHeight: {
                    get: function() {
                        return this.scaleY * this.height
                    },
                    set: function(n) {
                        this.scaleY = n / this.height
                    }
                }
            });
            c.exports = a
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                SKIP_CHECK: -1,
                NORMAL: 0,
                ADD: 1,
                MULTIPLY: 2,
                SCREEN: 3,
                OVERLAY: 4,
                DARKEN: 5,
                LIGHTEN: 6,
                COLOR_DODGE: 7,
                COLOR_BURN: 8,
                HARD_LIGHT: 9,
                SOFT_LIGHT: 10,
                DIFFERENCE: 11,
                EXCLUSION: 12,
                HUE: 13,
                SATURATION: 14,
                COLOR: 15,
                LUMINOSITY: 16,
                ERASE: 17,
                SOURCE_IN: 18,
                SOURCE_OUT: 19,
                SOURCE_ATOP: 20,
                DESTINATION_OVER: 21,
                DESTINATION_IN: 22,
                DESTINATION_OUT: 23,
                DESTINATION_ATOP: 24,
                LIGHTER: 25,
                COPY: 26,
                XOR: 27
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(14)
              , f = function(r) {
                return r * e.DEG_TO_RAD
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                DESTROY: t(743),
                FADE_IN_COMPLETE: t(744),
                FADE_IN_START: t(745),
                FADE_OUT_COMPLETE: t(746),
                FADE_OUT_START: t(747),
                FLASH_COMPLETE: t(748),
                FLASH_START: t(749),
                FOLLOW_UPDATE: t(750),
                PAN_COMPLETE: t(751),
                PAN_START: t(752),
                POST_RENDER: t(753),
                PRE_RENDER: t(754),
                ROTATE_COMPLETE: t(755),
                ROTATE_START: t(756),
                SHAKE_COMPLETE: t(757),
                SHAKE_START: t(758),
                ZOOM_COMPLETE: t(759),
                ZOOM_START: t(760)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(103)
              , r = t(328)
              , o = t(188)
              , a = t(329)
              , n = new e({
                initialize: function(l, i, h, u) {
                    l === void 0 && (l = 0),
                    i === void 0 && (i = 0),
                    h === void 0 && (h = 0),
                    u === void 0 && (u = 255),
                    this.r = 0,
                    this.g = 0,
                    this.b = 0,
                    this.a = 255,
                    this._h = 0,
                    this._s = 0,
                    this._v = 0,
                    this._locked = !1,
                    this.gl = [0, 0, 0, 1],
                    this._color = 0,
                    this._color32 = 0,
                    this._rgba = "",
                    this.setTo(l, i, h, u)
                },
                transparent: function() {
                    return this._locked = !0,
                    this.red = 0,
                    this.green = 0,
                    this.blue = 0,
                    this.alpha = 0,
                    this._locked = !1,
                    this.update(!0)
                },
                setTo: function(s, l, i, h, u) {
                    return h === void 0 && (h = 255),
                    u === void 0 && (u = !0),
                    this._locked = !0,
                    this.red = s,
                    this.green = l,
                    this.blue = i,
                    this.alpha = h,
                    this._locked = !1,
                    this.update(u)
                },
                setGLTo: function(s, l, i, h) {
                    return h === void 0 && (h = 1),
                    this._locked = !0,
                    this.redGL = s,
                    this.greenGL = l,
                    this.blueGL = i,
                    this.alphaGL = h,
                    this._locked = !1,
                    this.update(!0)
                },
                setFromRGB: function(s) {
                    return this._locked = !0,
                    this.red = s.r,
                    this.green = s.g,
                    this.blue = s.b,
                    s.hasOwnProperty("a") && (this.alpha = s.a),
                    this._locked = !1,
                    this.update(!0)
                },
                setFromHSV: function(s, l, i) {
                    return o(s, l, i, this)
                },
                update: function(s) {
                    if (s === void 0 && (s = !1),
                    this._locked)
                        return this;
                    var l = this.r
                      , i = this.g
                      , h = this.b
                      , u = this.a;
                    return this._color = f(l, i, h),
                    this._color32 = r(l, i, h, u),
                    this._rgba = "rgba(" + l + "," + i + "," + h + "," + u / 255 + ")",
                    s && a(l, i, h, this),
                    this
                },
                updateHSV: function() {
                    var s = this.r
                      , l = this.g
                      , i = this.b;
                    return a(s, l, i, this),
                    this
                },
                clone: function() {
                    return new n(this.r,this.g,this.b,this.a)
                },
                gray: function(s) {
                    return this.setTo(s, s, s)
                },
                random: function(s, l) {
                    s === void 0 && (s = 0),
                    l === void 0 && (l = 255);
                    var i = Math.floor(s + Math.random() * (l - s))
                      , h = Math.floor(s + Math.random() * (l - s))
                      , u = Math.floor(s + Math.random() * (l - s));
                    return this.setTo(i, h, u)
                },
                randomGray: function(s, l) {
                    s === void 0 && (s = 0),
                    l === void 0 && (l = 255);
                    var i = Math.floor(s + Math.random() * (l - s));
                    return this.setTo(i, i, i)
                },
                saturate: function(s) {
                    return this.s += s / 100,
                    this
                },
                desaturate: function(s) {
                    return this.s -= s / 100,
                    this
                },
                lighten: function(s) {
                    return this.v += s / 100,
                    this
                },
                darken: function(s) {
                    return this.v -= s / 100,
                    this
                },
                brighten: function(s) {
                    var l = this.r
                      , i = this.g
                      , h = this.b;
                    return l = Math.max(0, Math.min(255, l - Math.round(255 * -(s / 100)))),
                    i = Math.max(0, Math.min(255, i - Math.round(255 * -(s / 100)))),
                    h = Math.max(0, Math.min(255, h - Math.round(255 * -(s / 100)))),
                    this.setTo(l, i, h)
                },
                color: {
                    get: function() {
                        return this._color
                    }
                },
                color32: {
                    get: function() {
                        return this._color32
                    }
                },
                rgba: {
                    get: function() {
                        return this._rgba
                    }
                },
                redGL: {
                    get: function() {
                        return this.gl[0]
                    },
                    set: function(s) {
                        this.gl[0] = Math.min(Math.abs(s), 1),
                        this.r = Math.floor(this.gl[0] * 255),
                        this.update(!0)
                    }
                },
                greenGL: {
                    get: function() {
                        return this.gl[1]
                    },
                    set: function(s) {
                        this.gl[1] = Math.min(Math.abs(s), 1),
                        this.g = Math.floor(this.gl[1] * 255),
                        this.update(!0)
                    }
                },
                blueGL: {
                    get: function() {
                        return this.gl[2]
                    },
                    set: function(s) {
                        this.gl[2] = Math.min(Math.abs(s), 1),
                        this.b = Math.floor(this.gl[2] * 255),
                        this.update(!0)
                    }
                },
                alphaGL: {
                    get: function() {
                        return this.gl[3]
                    },
                    set: function(s) {
                        this.gl[3] = Math.min(Math.abs(s), 1),
                        this.a = Math.floor(this.gl[3] * 255),
                        this.update()
                    }
                },
                red: {
                    get: function() {
                        return this.r
                    },
                    set: function(s) {
                        s = Math.floor(Math.abs(s)),
                        this.r = Math.min(s, 255),
                        this.gl[0] = s / 255,
                        this.update(!0)
                    }
                },
                green: {
                    get: function() {
                        return this.g
                    },
                    set: function(s) {
                        s = Math.floor(Math.abs(s)),
                        this.g = Math.min(s, 255),
                        this.gl[1] = s / 255,
                        this.update(!0)
                    }
                },
                blue: {
                    get: function() {
                        return this.b
                    },
                    set: function(s) {
                        s = Math.floor(Math.abs(s)),
                        this.b = Math.min(s, 255),
                        this.gl[2] = s / 255,
                        this.update(!0)
                    }
                },
                alpha: {
                    get: function() {
                        return this.a
                    },
                    set: function(s) {
                        s = Math.floor(Math.abs(s)),
                        this.a = Math.min(s, 255),
                        this.gl[3] = s / 255,
                        this.update()
                    }
                },
                h: {
                    get: function() {
                        return this._h
                    },
                    set: function(s) {
                        this._h = s,
                        o(s, this._s, this._v, this)
                    }
                },
                s: {
                    get: function() {
                        return this._s
                    },
                    set: function(s) {
                        this._s = s,
                        o(this._h, s, this._v, this)
                    }
                },
                v: {
                    get: function() {
                        return this._v
                    },
                    set: function(s) {
                        this._v = s,
                        o(this._h, this._s, s, this)
                    }
                }
            });
            c.exports = n
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = new e({
                initialize: function(o, a, n) {
                    this.x = 0,
                    this.y = 0,
                    this.z = 0,
                    typeof o == "object" ? (this.x = o.x || 0,
                    this.y = o.y || 0,
                    this.z = o.z || 0) : (this.x = o || 0,
                    this.y = a || 0,
                    this.z = n || 0)
                },
                up: function() {
                    return this.x = 0,
                    this.y = 1,
                    this.z = 0,
                    this
                },
                min: function(r) {
                    return this.x = Math.min(this.x, r.x),
                    this.y = Math.min(this.y, r.y),
                    this.z = Math.min(this.z, r.z),
                    this
                },
                max: function(r) {
                    return this.x = Math.max(this.x, r.x),
                    this.y = Math.max(this.y, r.y),
                    this.z = Math.max(this.z, r.z),
                    this
                },
                clone: function() {
                    return new f(this.x,this.y,this.z)
                },
                addVectors: function(r, o) {
                    return this.x = r.x + o.x,
                    this.y = r.y + o.y,
                    this.z = r.z + o.z,
                    this
                },
                crossVectors: function(r, o) {
                    var a = r.x
                      , n = r.y
                      , s = r.z
                      , l = o.x
                      , i = o.y
                      , h = o.z;
                    return this.x = n * h - s * i,
                    this.y = s * l - a * h,
                    this.z = a * i - n * l,
                    this
                },
                equals: function(r) {
                    return this.x === r.x && this.y === r.y && this.z === r.z
                },
                copy: function(r) {
                    return this.x = r.x,
                    this.y = r.y,
                    this.z = r.z || 0,
                    this
                },
                set: function(r, o, a) {
                    return typeof r == "object" ? (this.x = r.x || 0,
                    this.y = r.y || 0,
                    this.z = r.z || 0) : (this.x = r || 0,
                    this.y = o || 0,
                    this.z = a || 0),
                    this
                },
                setFromMatrixPosition: function(r) {
                    return this.fromArray(r.val, 12)
                },
                setFromMatrixColumn: function(r, o) {
                    return this.fromArray(r.val, o * 4)
                },
                fromArray: function(r, o) {
                    return o === void 0 && (o = 0),
                    this.x = r[o],
                    this.y = r[o + 1],
                    this.z = r[o + 2],
                    this
                },
                add: function(r) {
                    return this.x += r.x,
                    this.y += r.y,
                    this.z += r.z || 0,
                    this
                },
                addScalar: function(r) {
                    return this.x += r,
                    this.y += r,
                    this.z += r,
                    this
                },
                addScale: function(r, o) {
                    return this.x += r.x * o,
                    this.y += r.y * o,
                    this.z += r.z * o || 0,
                    this
                },
                subtract: function(r) {
                    return this.x -= r.x,
                    this.y -= r.y,
                    this.z -= r.z || 0,
                    this
                },
                multiply: function(r) {
                    return this.x *= r.x,
                    this.y *= r.y,
                    this.z *= r.z || 1,
                    this
                },
                scale: function(r) {
                    return isFinite(r) ? (this.x *= r,
                    this.y *= r,
                    this.z *= r) : (this.x = 0,
                    this.y = 0,
                    this.z = 0),
                    this
                },
                divide: function(r) {
                    return this.x /= r.x,
                    this.y /= r.y,
                    this.z /= r.z || 1,
                    this
                },
                negate: function() {
                    return this.x = -this.x,
                    this.y = -this.y,
                    this.z = -this.z,
                    this
                },
                distance: function(r) {
                    var o = r.x - this.x
                      , a = r.y - this.y
                      , n = r.z - this.z || 0;
                    return Math.sqrt(o * o + a * a + n * n)
                },
                distanceSq: function(r) {
                    var o = r.x - this.x
                      , a = r.y - this.y
                      , n = r.z - this.z || 0;
                    return o * o + a * a + n * n
                },
                length: function() {
                    var r = this.x
                      , o = this.y
                      , a = this.z;
                    return Math.sqrt(r * r + o * o + a * a)
                },
                lengthSq: function() {
                    var r = this.x
                      , o = this.y
                      , a = this.z;
                    return r * r + o * o + a * a
                },
                normalize: function() {
                    var r = this.x
                      , o = this.y
                      , a = this.z
                      , n = r * r + o * o + a * a;
                    return n > 0 && (n = 1 / Math.sqrt(n),
                    this.x = r * n,
                    this.y = o * n,
                    this.z = a * n),
                    this
                },
                dot: function(r) {
                    return this.x * r.x + this.y * r.y + this.z * r.z
                },
                cross: function(r) {
                    var o = this.x
                      , a = this.y
                      , n = this.z
                      , s = r.x
                      , l = r.y
                      , i = r.z;
                    return this.x = a * i - n * l,
                    this.y = n * s - o * i,
                    this.z = o * l - a * s,
                    this
                },
                lerp: function(r, o) {
                    o === void 0 && (o = 0);
                    var a = this.x
                      , n = this.y
                      , s = this.z;
                    return this.x = a + o * (r.x - a),
                    this.y = n + o * (r.y - n),
                    this.z = s + o * (r.z - s),
                    this
                },
                applyMatrix3: function(r) {
                    var o = this.x
                      , a = this.y
                      , n = this.z
                      , s = r.val;
                    return this.x = s[0] * o + s[3] * a + s[6] * n,
                    this.y = s[1] * o + s[4] * a + s[7] * n,
                    this.z = s[2] * o + s[5] * a + s[8] * n,
                    this
                },
                applyMatrix4: function(r) {
                    var o = this.x
                      , a = this.y
                      , n = this.z
                      , s = r.val
                      , l = 1 / (s[3] * o + s[7] * a + s[11] * n + s[15]);
                    return this.x = (s[0] * o + s[4] * a + s[8] * n + s[12]) * l,
                    this.y = (s[1] * o + s[5] * a + s[9] * n + s[13]) * l,
                    this.z = (s[2] * o + s[6] * a + s[10] * n + s[14]) * l,
                    this
                },
                transformMat3: function(r) {
                    var o = this.x
                      , a = this.y
                      , n = this.z
                      , s = r.val;
                    return this.x = o * s[0] + a * s[3] + n * s[6],
                    this.y = o * s[1] + a * s[4] + n * s[7],
                    this.z = o * s[2] + a * s[5] + n * s[8],
                    this
                },
                transformMat4: function(r) {
                    var o = this.x
                      , a = this.y
                      , n = this.z
                      , s = r.val;
                    return this.x = s[0] * o + s[4] * a + s[8] * n + s[12],
                    this.y = s[1] * o + s[5] * a + s[9] * n + s[13],
                    this.z = s[2] * o + s[6] * a + s[10] * n + s[14],
                    this
                },
                transformCoordinates: function(r) {
                    var o = this.x
                      , a = this.y
                      , n = this.z
                      , s = r.val
                      , l = o * s[0] + a * s[4] + n * s[8] + s[12]
                      , i = o * s[1] + a * s[5] + n * s[9] + s[13]
                      , h = o * s[2] + a * s[6] + n * s[10] + s[14]
                      , u = o * s[3] + a * s[7] + n * s[11] + s[15];
                    return this.x = l / u,
                    this.y = i / u,
                    this.z = h / u,
                    this
                },
                transformQuat: function(r) {
                    var o = this.x
                      , a = this.y
                      , n = this.z
                      , s = r.x
                      , l = r.y
                      , i = r.z
                      , h = r.w
                      , u = h * o + l * n - i * a
                      , d = h * a + i * o - s * n
                      , v = h * n + s * a - l * o
                      , p = -s * o - l * a - i * n;
                    return this.x = u * h + p * -s + d * -i - v * -l,
                    this.y = d * h + p * -l + v * -s - u * -i,
                    this.z = v * h + p * -i + u * -l - d * -s,
                    this
                },
                project: function(r) {
                    var o = this.x
                      , a = this.y
                      , n = this.z
                      , s = r.val
                      , l = s[0]
                      , i = s[1]
                      , h = s[2]
                      , u = s[3]
                      , d = s[4]
                      , v = s[5]
                      , p = s[6]
                      , g = s[7]
                      , m = s[8]
                      , x = s[9]
                      , T = s[10]
                      , E = s[11]
                      , P = s[12]
                      , M = s[13]
                      , L = s[14]
                      , R = s[15]
                      , O = 1 / (o * u + a * g + n * E + R);
                    return this.x = (o * l + a * d + n * m + P) * O,
                    this.y = (o * i + a * v + n * x + M) * O,
                    this.z = (o * h + a * p + n * T + L) * O,
                    this
                },
                projectViewMatrix: function(r, o) {
                    return this.applyMatrix4(r).applyMatrix4(o)
                },
                unprojectViewMatrix: function(r, o) {
                    return this.applyMatrix4(r).applyMatrix4(o)
                },
                unproject: function(r, o) {
                    var a = r.x
                      , n = r.y
                      , s = r.z
                      , l = r.w
                      , i = this.x - a
                      , h = l - this.y - 1 - n
                      , u = this.z;
                    return this.x = 2 * i / s - 1,
                    this.y = 2 * h / l - 1,
                    this.z = 2 * u - 1,
                    this.project(o)
                },
                reset: function() {
                    return this.x = 0,
                    this.y = 0,
                    this.z = 0,
                    this
                }
            });
            f.ZERO = new f,
            f.RIGHT = new f(1,0,0),
            f.LEFT = new f(-1,0,0),
            f.UP = new f(0,-1,0),
            f.DOWN = new f(0,1,0),
            f.FORWARD = new f(0,0,1),
            f.BACK = new f(0,0,-1),
            f.ONE = new f(1,1,1),
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                CSV: 0,
                TILED_JSON: 1,
                ARRAY_2D: 2,
                WELTMEISTER: 3
            }
        }
        , function(c, S, t) {
            var e = {};
            c.exports = e;
            var f = t(64)
              , r = t(83)
              , o = t(165)
              , a = t(32)
              , n = t(84)
              , s = t(271);
            (function() {
                e._inertiaScale = 4,
                e._nextCollidingGroupId = 1,
                e._nextNonCollidingGroupId = -1,
                e._nextCategory = 1,
                e.create = function(i) {
                    var h = {
                        id: a.nextId(),
                        type: "body",
                        label: "Body",
                        parts: [],
                        plugin: {},
                        angle: 0,
                        vertices: null,
                        position: {
                            x: 0,
                            y: 0
                        },
                        force: {
                            x: 0,
                            y: 0
                        },
                        torque: 0,
                        positionImpulse: {
                            x: 0,
                            y: 0
                        },
                        previousPositionImpulse: {
                            x: 0,
                            y: 0
                        },
                        constraintImpulse: {
                            x: 0,
                            y: 0,
                            angle: 0
                        },
                        totalContacts: 0,
                        speed: 0,
                        angularSpeed: 0,
                        velocity: {
                            x: 0,
                            y: 0
                        },
                        angularVelocity: 0,
                        isSensor: !1,
                        isStatic: !1,
                        isSleeping: !1,
                        motion: 0,
                        sleepThreshold: 60,
                        density: .001,
                        restitution: 0,
                        friction: .1,
                        frictionStatic: .5,
                        frictionAir: .01,
                        collisionFilter: {
                            category: 1,
                            mask: 4294967295,
                            group: 0
                        },
                        slop: .05,
                        timeScale: 1,
                        events: null,
                        bounds: null,
                        chamfer: null,
                        circleRadius: 0,
                        positionPrev: null,
                        anglePrev: 0,
                        parent: null,
                        axes: null,
                        area: 0,
                        mass: 0,
                        inverseMass: 0,
                        inertia: 0,
                        inverseInertia: 0,
                        _original: null,
                        render: {
                            visible: !0,
                            opacity: 1,
                            sprite: {
                                xOffset: 0,
                                yOffset: 0
                            },
                            fillColor: null,
                            fillOpacity: null,
                            lineColor: null,
                            lineOpacity: null,
                            lineThickness: null
                        },
                        gameObject: null,
                        scale: {
                            x: 1,
                            y: 1
                        },
                        centerOfMass: {
                            x: 0,
                            y: 0
                        },
                        centerOffset: {
                            x: 0,
                            y: 0
                        },
                        gravityScale: {
                            x: 1,
                            y: 1
                        },
                        ignoreGravity: !1,
                        ignorePointer: !1,
                        onCollideCallback: null,
                        onCollideEndCallback: null,
                        onCollideActiveCallback: null,
                        onCollideWith: {}
                    };
                    !i.hasOwnProperty("position") && i.hasOwnProperty("vertices") ? i.position = f.centre(i.vertices) : i.hasOwnProperty("vertices") || (h.vertices = f.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"));
                    var u = a.extend(h, i);
                    return l(u, i),
                    u.setOnCollideWith = function(d, v) {
                        return v ? this.onCollideWith[d.id] = v : delete this.onCollideWith[d.id],
                        this
                    }
                    ,
                    u
                }
                ,
                e.nextGroup = function(i) {
                    return i ? e._nextNonCollidingGroupId-- : e._nextCollidingGroupId++
                }
                ,
                e.nextCategory = function() {
                    return e._nextCategory = e._nextCategory << 1,
                    e._nextCategory
                }
                ;
                var l = function(i, h) {
                    h = h || {},
                    e.set(i, {
                        bounds: i.bounds || n.create(i.vertices),
                        positionPrev: i.positionPrev || r.clone(i.position),
                        anglePrev: i.anglePrev || i.angle,
                        vertices: i.vertices,
                        parts: i.parts || [i],
                        isStatic: i.isStatic,
                        isSleeping: i.isSleeping,
                        parent: i.parent || i
                    });
                    var u = i.bounds;
                    if (f.rotate(i.vertices, i.angle, i.position),
                    s.rotate(i.axes, i.angle),
                    n.update(u, i.vertices, i.velocity),
                    e.set(i, {
                        axes: h.axes || i.axes,
                        area: h.area || i.area,
                        mass: h.mass || i.mass,
                        inertia: h.inertia || i.inertia
                    }),
                    i.parts.length === 1) {
                        var d = i.centerOfMass
                          , v = i.centerOffset
                          , p = u.max.x - u.min.x
                          , g = u.max.y - u.min.y;
                        d.x = -(u.min.x - i.position.x) / p,
                        d.y = -(u.min.y - i.position.y) / g,
                        v.x = p * d.x,
                        v.y = g * d.y
                    }
                };
                e.set = function(i, h, u) {
                    var d;
                    typeof h == "string" && (d = h,
                    h = {},
                    h[d] = u);
                    for (d in h)
                        if (Object.prototype.hasOwnProperty.call(h, d))
                            switch (u = h[d],
                            d) {
                            case "isStatic":
                                e.setStatic(i, u);
                                break;
                            case "isSleeping":
                                o.set(i, u);
                                break;
                            case "mass":
                                e.setMass(i, u);
                                break;
                            case "density":
                                e.setDensity(i, u);
                                break;
                            case "inertia":
                                e.setInertia(i, u);
                                break;
                            case "vertices":
                                e.setVertices(i, u);
                                break;
                            case "position":
                                e.setPosition(i, u);
                                break;
                            case "angle":
                                e.setAngle(i, u);
                                break;
                            case "velocity":
                                e.setVelocity(i, u);
                                break;
                            case "angularVelocity":
                                e.setAngularVelocity(i, u);
                                break;
                            case "parts":
                                e.setParts(i, u);
                                break;
                            case "centre":
                                e.setCentre(i, u);
                                break;
                            default:
                                i[d] = u
                            }
                }
                ,
                e.setStatic = function(i, h) {
                    for (var u = 0; u < i.parts.length; u++) {
                        var d = i.parts[u];
                        d.isStatic = h,
                        h ? (d._original = {
                            restitution: d.restitution,
                            friction: d.friction,
                            mass: d.mass,
                            inertia: d.inertia,
                            density: d.density,
                            inverseMass: d.inverseMass,
                            inverseInertia: d.inverseInertia
                        },
                        d.restitution = 0,
                        d.friction = 1,
                        d.mass = d.inertia = d.density = 1 / 0,
                        d.inverseMass = d.inverseInertia = 0,
                        d.positionPrev.x = d.position.x,
                        d.positionPrev.y = d.position.y,
                        d.anglePrev = d.angle,
                        d.angularVelocity = 0,
                        d.speed = 0,
                        d.angularSpeed = 0,
                        d.motion = 0) : d._original && (d.restitution = d._original.restitution,
                        d.friction = d._original.friction,
                        d.mass = d._original.mass,
                        d.inertia = d._original.inertia,
                        d.density = d._original.density,
                        d.inverseMass = d._original.inverseMass,
                        d.inverseInertia = d._original.inverseInertia,
                        d._original = null)
                    }
                }
                ,
                e.setMass = function(i, h) {
                    var u = i.inertia / (i.mass / 6);
                    i.inertia = u * (h / 6),
                    i.inverseInertia = 1 / i.inertia,
                    i.mass = h,
                    i.inverseMass = 1 / i.mass,
                    i.density = i.mass / i.area
                }
                ,
                e.setDensity = function(i, h) {
                    e.setMass(i, h * i.area),
                    i.density = h
                }
                ,
                e.setInertia = function(i, h) {
                    i.inertia = h,
                    i.inverseInertia = 1 / i.inertia
                }
                ,
                e.setVertices = function(i, h) {
                    h[0].body === i ? i.vertices = h : i.vertices = f.create(h, i),
                    i.axes = s.fromVertices(i.vertices),
                    i.area = f.area(i.vertices),
                    e.setMass(i, i.density * i.area);
                    var u = f.centre(i.vertices);
                    f.translate(i.vertices, u, -1),
                    e.setInertia(i, e._inertiaScale * f.inertia(i.vertices, i.mass)),
                    f.translate(i.vertices, i.position),
                    n.update(i.bounds, i.vertices, i.velocity)
                }
                ,
                e.setParts = function(i, h, u) {
                    var d;
                    for (h = h.slice(0),
                    i.parts.length = 0,
                    i.parts.push(i),
                    i.parent = i,
                    d = 0; d < h.length; d++) {
                        var v = h[d];
                        v !== i && (v.parent = i,
                        i.parts.push(v))
                    }
                    if (i.parts.length !== 1) {
                        if (u = typeof u < "u" ? u : !0,
                        u) {
                            var p = [];
                            for (d = 0; d < h.length; d++)
                                p = p.concat(h[d].vertices);
                            f.clockwiseSort(p);
                            var g = f.hull(p)
                              , m = f.centre(g);
                            e.setVertices(i, g),
                            f.translate(i.vertices, m)
                        }
                        var x = e._totalProperties(i)
                          , T = x.centre.x
                          , E = x.centre.y
                          , P = i.bounds
                          , M = i.centerOfMass
                          , L = i.centerOffset;
                        n.update(P, i.vertices, i.velocity),
                        M.x = -(P.min.x - T) / (P.max.x - P.min.x),
                        M.y = -(P.min.y - E) / (P.max.y - P.min.y),
                        L.x = T,
                        L.y = E,
                        i.area = x.area,
                        i.parent = i,
                        i.position.x = T,
                        i.position.y = E,
                        i.positionPrev.x = T,
                        i.positionPrev.y = E,
                        e.setMass(i, x.mass),
                        e.setInertia(i, x.inertia),
                        e.setPosition(i, x.centre)
                    }
                }
                ,
                e.setCentre = function(i, h, u) {
                    u ? (i.positionPrev.x += h.x,
                    i.positionPrev.y += h.y,
                    i.position.x += h.x,
                    i.position.y += h.y) : (i.positionPrev.x = h.x - (i.position.x - i.positionPrev.x),
                    i.positionPrev.y = h.y - (i.position.y - i.positionPrev.y),
                    i.position.x = h.x,
                    i.position.y = h.y)
                }
                ,
                e.setPosition = function(i, h) {
                    var u = r.sub(h, i.position);
                    i.positionPrev.x += u.x,
                    i.positionPrev.y += u.y;
                    for (var d = 0; d < i.parts.length; d++) {
                        var v = i.parts[d];
                        v.position.x += u.x,
                        v.position.y += u.y,
                        f.translate(v.vertices, u),
                        n.update(v.bounds, v.vertices, i.velocity)
                    }
                }
                ,
                e.setAngle = function(i, h) {
                    var u = h - i.angle;
                    i.anglePrev += u;
                    for (var d = 0; d < i.parts.length; d++) {
                        var v = i.parts[d];
                        v.angle += u,
                        f.rotate(v.vertices, u, i.position),
                        s.rotate(v.axes, u),
                        n.update(v.bounds, v.vertices, i.velocity),
                        d > 0 && r.rotateAbout(v.position, u, i.position, v.position)
                    }
                }
                ,
                e.setVelocity = function(i, h) {
                    i.positionPrev.x = i.position.x - h.x,
                    i.positionPrev.y = i.position.y - h.y,
                    i.velocity.x = h.x,
                    i.velocity.y = h.y,
                    i.speed = r.magnitude(i.velocity)
                }
                ,
                e.setAngularVelocity = function(i, h) {
                    i.anglePrev = i.angle - h,
                    i.angularVelocity = h,
                    i.angularSpeed = Math.abs(i.angularVelocity)
                }
                ,
                e.translate = function(i, h) {
                    e.setPosition(i, r.add(i.position, h))
                }
                ,
                e.rotate = function(i, h, u) {
                    if (!u)
                        e.setAngle(i, i.angle + h);
                    else {
                        var d = Math.cos(h)
                          , v = Math.sin(h)
                          , p = i.position.x - u.x
                          , g = i.position.y - u.y;
                        e.setPosition(i, {
                            x: u.x + (p * d - g * v),
                            y: u.y + (p * v + g * d)
                        }),
                        e.setAngle(i, i.angle + h)
                    }
                }
                ,
                e.scale = function(i, h, u, d) {
                    var v = 0
                      , p = 0;
                    d = d || i.position;
                    for (var g = 0; g < i.parts.length; g++) {
                        var m = i.parts[g];
                        m.scale.x = h,
                        m.scale.y = u,
                        f.scale(m.vertices, h, u, d),
                        m.axes = s.fromVertices(m.vertices),
                        m.area = f.area(m.vertices),
                        e.setMass(m, i.density * m.area),
                        f.translate(m.vertices, {
                            x: -m.position.x,
                            y: -m.position.y
                        }),
                        e.setInertia(m, e._inertiaScale * f.inertia(m.vertices, m.mass)),
                        f.translate(m.vertices, {
                            x: m.position.x,
                            y: m.position.y
                        }),
                        g > 0 && (v += m.area,
                        p += m.inertia),
                        m.position.x = d.x + (m.position.x - d.x) * h,
                        m.position.y = d.y + (m.position.y - d.y) * u,
                        n.update(m.bounds, m.vertices, i.velocity)
                    }
                    i.parts.length > 1 && (i.area = v,
                    i.isStatic || (e.setMass(i, i.density * v),
                    e.setInertia(i, p))),
                    i.circleRadius && (h === u ? i.circleRadius *= h : i.circleRadius = null)
                }
                ,
                e.update = function(i, h, u, d) {
                    var v = Math.pow(h * u * i.timeScale, 2)
                      , p = 1 - i.frictionAir * u * i.timeScale
                      , g = i.position.x - i.positionPrev.x
                      , m = i.position.y - i.positionPrev.y;
                    i.velocity.x = g * p * d + i.force.x / i.mass * v,
                    i.velocity.y = m * p * d + i.force.y / i.mass * v,
                    i.positionPrev.x = i.position.x,
                    i.positionPrev.y = i.position.y,
                    i.position.x += i.velocity.x,
                    i.position.y += i.velocity.y,
                    i.angularVelocity = (i.angle - i.anglePrev) * p * d + i.torque / i.inertia * v,
                    i.anglePrev = i.angle,
                    i.angle += i.angularVelocity,
                    i.speed = r.magnitude(i.velocity),
                    i.angularSpeed = Math.abs(i.angularVelocity);
                    for (var x = 0; x < i.parts.length; x++) {
                        var T = i.parts[x];
                        f.translate(T.vertices, i.velocity),
                        x > 0 && (T.position.x += i.velocity.x,
                        T.position.y += i.velocity.y),
                        i.angularVelocity !== 0 && (f.rotate(T.vertices, i.angularVelocity, i.position),
                        s.rotate(T.axes, i.angularVelocity),
                        x > 0 && r.rotateAbout(T.position, i.angularVelocity, i.position, T.position)),
                        n.update(T.bounds, T.vertices, i.velocity)
                    }
                }
                ,
                e.applyForce = function(i, h, u) {
                    i.force.x += u.x,
                    i.force.y += u.y;
                    var d = {
                        x: h.x - i.position.x,
                        y: h.y - i.position.y
                    };
                    i.torque += d.x * u.y - d.y * u.x
                }
                ,
                e._totalProperties = function(i) {
                    for (var h = {
                        mass: 0,
                        area: 0,
                        inertia: 0,
                        centre: {
                            x: 0,
                            y: 0
                        }
                    }, u = i.parts.length === 1 ? 0 : 1; u < i.parts.length; u++) {
                        var d = i.parts[u]
                          , v = d.mass !== 1 / 0 ? d.mass : 1;
                        h.mass += v,
                        h.area += d.area,
                        h.inertia += d.inertia,
                        h.centre = r.add(h.centre, r.mult(d.position, v))
                    }
                    return h.centre = r.div(h.centre, h.mass),
                    h
                }
            }
            )()
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e.y + e.height - e.height * e.originY
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e.x - e.width * e.originX
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e.x + e.width - e.width * e.originX
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e.y - e.height * e.originY
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o, a, n) {
                o === void 0 && (o = 0),
                a === void 0 && (a = 0),
                n === void 0 && (n = 1);
                var s, l = 0, i = e.length;
                if (n === 1)
                    for (s = a; s < i; s++)
                        e[s][f] += r + l * o,
                        l++;
                else
                    for (s = a; s >= 0; s--)
                        e[s][f] += r + l * o,
                        l++;
                return e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(307)
              , r = t(172)
              , o = t(56)
              , a = t(173)
              , n = t(3)
              , s = new e({
                initialize: function(i, h, u, d) {
                    i === void 0 && (i = 0),
                    h === void 0 && (h = 0),
                    u === void 0 && (u = 0),
                    d === void 0 && (d = 0),
                    this.type = o.LINE,
                    this.x1 = i,
                    this.y1 = h,
                    this.x2 = u,
                    this.y2 = d
                },
                getPoint: function(l, i) {
                    return f(this, l, i)
                },
                getPoints: function(l, i, h) {
                    return r(this, l, i, h)
                },
                getRandomPoint: function(l) {
                    return a(this, l)
                },
                setTo: function(l, i, h, u) {
                    return l === void 0 && (l = 0),
                    i === void 0 && (i = 0),
                    h === void 0 && (h = 0),
                    u === void 0 && (u = 0),
                    this.x1 = l,
                    this.y1 = i,
                    this.x2 = h,
                    this.y2 = u,
                    this
                },
                getPointA: function(l) {
                    return l === void 0 && (l = new n),
                    l.set(this.x1, this.y1),
                    l
                },
                getPointB: function(l) {
                    return l === void 0 && (l = new n),
                    l.set(this.x2, this.y2),
                    l
                },
                left: {
                    get: function() {
                        return Math.min(this.x1, this.x2)
                    },
                    set: function(l) {
                        this.x1 <= this.x2 ? this.x1 = l : this.x2 = l
                    }
                },
                right: {
                    get: function() {
                        return Math.max(this.x1, this.x2)
                    },
                    set: function(l) {
                        this.x1 > this.x2 ? this.x1 = l : this.x2 = l
                    }
                },
                top: {
                    get: function() {
                        return Math.min(this.y1, this.y2)
                    },
                    set: function(l) {
                        this.y1 <= this.y2 ? this.y1 = l : this.y2 = l
                    }
                },
                bottom: {
                    get: function() {
                        return Math.max(this.y1, this.y2)
                    },
                    set: function(l) {
                        this.y1 > this.y2 ? this.y1 = l : this.y2 = l
                    }
                }
            });
            c.exports = s
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                var a = r || f.fillColor
                  , n = o || f.fillAlpha
                  , s = (a & 16711680) >>> 16
                  , l = (a & 65280) >>> 8
                  , i = a & 255;
                e.fillStyle = "rgba(" + s + "," + l + "," + i + "," + n + ")"
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = new e({
                initialize: function(o, a, n, s) {
                    var l = [];
                    s.forEach(function(h) {
                        h && l.push(h)
                    }),
                    this.loader = o,
                    this.type = a,
                    this.key = n,
                    this.multiKeyIndex = o.multiKeyIndex++,
                    this.files = l,
                    this.complete = !1,
                    this.pending = l.length,
                    this.failed = 0,
                    this.config = {},
                    this.baseURL = o.baseURL,
                    this.path = o.path,
                    this.prefix = o.prefix;
                    for (var i = 0; i < l.length; i++)
                        l[i].multiFile = this
                },
                isReadyToProcess: function() {
                    return this.pending === 0 && this.failed === 0 && !this.complete
                },
                addToMultiFile: function(r) {
                    return this.files.push(r),
                    r.multiFile = this,
                    this.pending++,
                    this.complete = !1,
                    this
                },
                onFileComplete: function(r) {
                    var o = this.files.indexOf(r);
                    o !== -1 && this.pending--
                },
                onFileFailed: function(r) {
                    var o = this.files.indexOf(r);
                    o !== -1 && this.failed++
                }
            });
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                var a = e - r
                  , n = f - o;
                return Math.sqrt(a * a + n * n)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                BOOT: t(922),
                DESTROY: t(923),
                DRAG_END: t(924),
                DRAG_ENTER: t(925),
                DRAG: t(926),
                DRAG_LEAVE: t(927),
                DRAG_OVER: t(928),
                DRAG_START: t(929),
                DROP: t(930),
                GAME_OUT: t(931),
                GAME_OVER: t(932),
                GAMEOBJECT_DOWN: t(933),
                GAMEOBJECT_DRAG_END: t(934),
                GAMEOBJECT_DRAG_ENTER: t(935),
                GAMEOBJECT_DRAG: t(936),
                GAMEOBJECT_DRAG_LEAVE: t(937),
                GAMEOBJECT_DRAG_OVER: t(938),
                GAMEOBJECT_DRAG_START: t(939),
                GAMEOBJECT_DROP: t(940),
                GAMEOBJECT_MOVE: t(941),
                GAMEOBJECT_OUT: t(942),
                GAMEOBJECT_OVER: t(943),
                GAMEOBJECT_POINTER_DOWN: t(944),
                GAMEOBJECT_POINTER_MOVE: t(945),
                GAMEOBJECT_POINTER_OUT: t(946),
                GAMEOBJECT_POINTER_OVER: t(947),
                GAMEOBJECT_POINTER_UP: t(948),
                GAMEOBJECT_POINTER_WHEEL: t(949),
                GAMEOBJECT_UP: t(950),
                GAMEOBJECT_WHEEL: t(951),
                MANAGER_BOOT: t(952),
                MANAGER_PROCESS: t(953),
                MANAGER_UPDATE: t(954),
                POINTER_DOWN: t(955),
                POINTER_DOWN_OUTSIDE: t(956),
                POINTER_MOVE: t(957),
                POINTER_OUT: t(958),
                POINTER_OVER: t(959),
                POINTER_UP: t(960),
                POINTER_UP_OUTSIDE: t(961),
                POINTER_WHEEL: t(962),
                POINTERLOCK_CHANGE: t(963),
                PRE_UPDATE: t(964),
                SHUTDOWN: t(965),
                START: t(966),
                UPDATE: t(967)
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return e.y = f + e.height * e.originY,
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return e.x = f + e.width * e.originX,
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return e.x = f - e.width + e.width * e.originX,
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return e.y = f - e.height + e.height * e.originY,
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                CIRCLE: 0,
                ELLIPSE: 1,
                LINE: 2,
                POINT: 3,
                POLYGON: 4,
                RECTANGLE: 5,
                TRIANGLE: 6
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                return e.width <= 0 || e.height <= 0 ? !1 : e.x <= f && e.x + e.width >= f && e.y <= r && e.y + e.height >= r
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(175)
              , r = t(9)
              , o = t(374)
              , a = t(2)
              , n = t(69)
              , s = t(91)
              , l = t(141)
              , i = t(12)
              , h = t(375)
              , u = new e({
                Extends: r,
                initialize: function(v) {
                    r.call(this);
                    var p = v.game
                      , g = p.renderer
                      , m = g.gl;
                    this.name = a(v, "name", "WebGLPipeline"),
                    this.game = p,
                    this.renderer = g,
                    this.manager,
                    this.gl = m,
                    this.view = p.canvas,
                    this.width = 0,
                    this.height = 0,
                    this.vertexCount = 0,
                    this.vertexCapacity = 0,
                    this.vertexData,
                    this.vertexBuffer,
                    this.topology = a(v, "topology", m.TRIANGLES),
                    this.bytes,
                    this.vertexViewF32,
                    this.vertexViewU32,
                    this.active = !0,
                    this.currentUnit = 0,
                    this.forceZero = a(v, "forceZero", !1),
                    this.hasBooted = !1,
                    this.isPostFX = !1,
                    this.renderTargets = [],
                    this.currentRenderTarget,
                    this.shaders = [],
                    this.currentShader,
                    this.projectionMatrix,
                    this.projectionWidth = 0,
                    this.projectionHeight = 0,
                    this.config = v,
                    this.glReset = !1
                },
                boot: function() {
                    var d, v = this.gl, p = this.config, g = this.renderer;
                    this.isPostFX || (this.projectionMatrix = new n().identity());
                    var m = this.renderTargets
                      , x = a(p, "renderTarget", !1);
                    typeof x == "boolean" && x && (x = 1);
                    var T = g.width
                      , E = g.height;
                    if (typeof x == "number")
                        for (d = 0; d < x; d++)
                            m.push(new l(g,T,E,1,0,!0));
                    else if (Array.isArray(x))
                        for (d = 0; d < x.length; d++) {
                            var P = a(x[d], "scale", 1)
                              , M = a(x[d], "minFilter", 0)
                              , L = a(x[d], "autoClear", 1);
                            m.push(new l(g,T,E,P,M,L))
                        }
                    m.length && (this.currentRenderTarget = m[0]),
                    this.setShadersFromConfig(p);
                    var R = this.shaders
                      , O = 0;
                    for (d = 0; d < R.length; d++)
                        R[d].vertexSize > O && (O = R[d].vertexSize);
                    var F = a(p, "batchSize", g.config.batchSize);
                    this.vertexCapacity = F * 6;
                    var B = new ArrayBuffer(this.vertexCapacity * O);
                    this.vertexData = B,
                    this.bytes = new Uint8Array(B),
                    this.vertexViewF32 = new Float32Array(B),
                    this.vertexViewU32 = new Uint32Array(B);
                    var N = a(p, "vertices", null);
                    for (N ? (this.vertexViewF32.set(N),
                    this.vertexBuffer = g.createVertexBuffer(B, v.STATIC_DRAW)) : this.vertexBuffer = g.createVertexBuffer(B.byteLength, v.DYNAMIC_DRAW),
                    this.setVertexBuffer(),
                    d = R.length - 1; d >= 0; d--)
                        R[d].rebind();
                    this.hasBooted = !0,
                    g.on(s.RESIZE, this.resize, this),
                    g.on(s.PRE_RENDER, this.onPreRender, this),
                    g.on(s.RENDER, this.onRender, this),
                    g.on(s.POST_RENDER, this.onPostRender, this),
                    this.emit(o.BOOT, this),
                    this.onBoot()
                },
                onBoot: function() {},
                onResize: function() {},
                setShader: function(d, v) {
                    var p = this.renderer;
                    if (d !== this.currentShader || p.currentProgram !== this.currentShader.program) {
                        this.flush(),
                        p.resetTextures();
                        var g = this.setVertexBuffer();
                        g && !v && (v = !0),
                        d.bind(v, !1),
                        this.currentShader = d
                    }
                    return this
                },
                getShaderByName: function(d) {
                    for (var v = this.shaders, p = 0; p < v.length; p++)
                        if (v[p].name === d)
                            return v[p]
                },
                setShadersFromConfig: function(d) {
                    var v, p = this.shaders, g = this.renderer;
                    for (v = 0; v < p.length; v++)
                        p[v].destroy();
                    var m = "vertShader"
                      , x = "fragShader"
                      , T = "attributes"
                      , E = a(d, m, null)
                      , P = i.parseFragmentShaderMaxTextures(a(d, x, null), g.maxTextures)
                      , M = a(d, T, null)
                      , L = a(d, "shaders", [])
                      , R = L.length;
                    if (R === 0)
                        E && P && (this.shaders = [new h(this,"default",E,P,f(M))]);
                    else {
                        var O = [];
                        for (v = 0; v < R; v++) {
                            var F = L[v]
                              , B = a(F, "name", "default")
                              , N = a(F, m, E)
                              , Y = i.parseFragmentShaderMaxTextures(a(F, x, P), g.maxTextures)
                              , z = a(F, T, M);
                            N && Y && O.push(new h(this,B,N,Y,f(z)))
                        }
                        this.shaders = O
                    }
                    return this.shaders.length === 0 ? console.warn("Pipeline: " + this.name + " - Invalid shader config") : this.currentShader = this.shaders[0],
                    this
                },
                setGameObject: function(d, v) {
                    return v === void 0 && (v = d.frame),
                    this.currentUnit = this.renderer.setTextureSource(v.source),
                    this.currentUnit
                },
                shouldFlush: function(d) {
                    return d === void 0 && (d = 0),
                    this.vertexCount + d > this.vertexCapacity
                },
                resize: function(d, v) {
                    (d !== this.width || v !== this.height) && this.flush(),
                    this.width = d,
                    this.height = v;
                    for (var p = this.renderTargets, g = 0; g < p.length; g++)
                        p[g].resize(d, v);
                    return this.setProjectionMatrix(d, v),
                    this.emit(o.RESIZE, d, v, this),
                    this.onResize(d, v),
                    this
                },
                setProjectionMatrix: function(d, v) {
                    var p = this.projectionMatrix;
                    if (!p)
                        return this;
                    this.projectionWidth = d,
                    this.projectionHeight = v,
                    p.ortho(0, d, v, 0, -1e3, 1e3);
                    for (var g = this.shaders, m = "uProjectionMatrix", x = 0; x < g.length; x++) {
                        var T = g[x];
                        T.hasUniform(m) && (T.resetUniform(m),
                        T.setMatrix4fv(m, !1, p.val, T))
                    }
                    return this
                },
                updateProjectionMatrix: function() {
                    if (this.projectionMatrix) {
                        var d = this.renderer.projectionWidth
                          , v = this.renderer.projectionHeight;
                        (this.projectionWidth !== d || this.projectionHeight !== v) && this.setProjectionMatrix(d, v)
                    }
                },
                bind: function(d) {
                    if (d === void 0 && (d = this.currentShader),
                    this.glReset)
                        return this.rebind(d);
                    var v = this.setVertexBuffer();
                    return d.bind(v),
                    this.currentShader = d,
                    this.emit(o.BIND, this, d),
                    this.onActive(d),
                    this
                },
                rebind: function(d) {
                    this.setVertexBuffer();
                    for (var v = this.shaders, p = v.length - 1; p >= 0; p--) {
                        var g = v[p].rebind();
                        (!d || g === d) && (this.currentShader = g)
                    }
                    return this.emit(o.REBIND, this.currentShader),
                    this.onActive(this.currentShader),
                    this.onRebind(),
                    this.glReset = !1,
                    this
                },
                setVertexBuffer: function() {
                    var d = this.gl
                      , v = this.vertexBuffer;
                    return d.getParameter(d.ARRAY_BUFFER_BINDING) !== v ? (d.bindBuffer(d.ARRAY_BUFFER, v),
                    !0) : !1
                },
                preBatch: function(d) {
                    return this.currentRenderTarget && this.currentRenderTarget.bind(),
                    this.onPreBatch(d),
                    this
                },
                postBatch: function(d) {
                    return this.onDraw(this.currentRenderTarget),
                    this.onPostBatch(d),
                    this
                },
                onDraw: function() {},
                unbind: function() {
                    this.currentRenderTarget && this.currentRenderTarget.unbind()
                },
                flush: function(d) {
                    if (d === void 0 && (d = !1),
                    this.vertexCount > 0) {
                        this.emit(o.BEFORE_FLUSH, this, d),
                        this.onBeforeFlush(d);
                        var v = this.gl
                          , p = this.vertexCount
                          , g = this.currentShader.vertexSize;
                        this.active && (this.setVertexBuffer(),
                        p === this.vertexCapacity ? v.bufferData(v.ARRAY_BUFFER, this.vertexData, v.DYNAMIC_DRAW) : v.bufferSubData(v.ARRAY_BUFFER, 0, this.bytes.subarray(0, p * g)),
                        v.drawArrays(this.topology, 0, p)),
                        this.vertexCount = 0,
                        this.emit(o.AFTER_FLUSH, this, d),
                        this.onAfterFlush(d)
                    }
                    return this
                },
                onActive: function() {},
                onBind: function() {},
                onRebind: function() {},
                onBatch: function() {},
                onPreBatch: function() {},
                onPostBatch: function() {},
                onPreRender: function() {},
                onRender: function() {},
                onPostRender: function() {},
                onBeforeFlush: function() {},
                onAfterFlush: function() {},
                batchVert: function(d, v, p, g, m, x, T) {
                    var E = this.vertexViewF32
                      , P = this.vertexViewU32
                      , M = this.vertexCount * this.currentShader.vertexComponentCount - 1;
                    E[++M] = d,
                    E[++M] = v,
                    E[++M] = p,
                    E[++M] = g,
                    E[++M] = m,
                    E[++M] = x,
                    P[++M] = T,
                    this.vertexCount++
                },
                batchQuad: function(d, v, p, g, m, x, T, E, P, M, L, R, O, F, B, N, Y, z, W, b) {
                    b === void 0 && (b = this.currentUnit);
                    var D = !1;
                    return this.shouldFlush(6) && (this.flush(),
                    D = !0,
                    b = this.setTexture2D(W)),
                    this.batchVert(v, p, M, L, b, z, F),
                    this.batchVert(g, m, M, O, b, z, N),
                    this.batchVert(x, T, R, O, b, z, Y),
                    this.batchVert(v, p, M, L, b, z, F),
                    this.batchVert(x, T, R, O, b, z, Y),
                    this.batchVert(E, P, R, L, b, z, B),
                    this.onBatch(d),
                    D
                },
                batchTri: function(d, v, p, g, m, x, T, E, P, M, L, R, O, F, B, N, Y) {
                    Y === void 0 && (Y = this.currentUnit);
                    var z = !1;
                    return this.shouldFlush(3) && (this.flush(),
                    z = !0,
                    Y = this.setTexture2D(N)),
                    this.batchVert(v, p, E, P, Y, B, R),
                    this.batchVert(g, m, E, L, Y, B, O),
                    this.batchVert(x, T, M, L, Y, B, F),
                    this.onBatch(d),
                    z
                },
                drawFillRect: function(d, v, p, g, m, x, T, E) {
                    T === void 0 && (T = this.renderer.whiteTexture.glTexture),
                    E === void 0 && (E = !0),
                    d = Math.floor(d),
                    v = Math.floor(v);
                    var P = Math.floor(d + p)
                      , M = Math.floor(v + g)
                      , L = this.setTexture2D(T)
                      , R = i.getTintAppendFloatAlphaAndSwap(m, x)
                      , O = 0
                      , F = 0
                      , B = 1
                      , N = 1;
                    E && (F = 1,
                    N = 0),
                    this.batchQuad(null, d, v, d, M, P, M, P, v, O, F, B, N, R, R, R, R, 0, T, L)
                },
                setTexture2D: function(d) {
                    return d === void 0 && (d = this.renderer.whiteTexture.glTexture),
                    this.currentUnit = this.renderer.setTexture2D(d),
                    this.currentUnit
                },
                bindTexture: function(d, v) {
                    v === void 0 && (v = 0);
                    var p = this.gl;
                    return p.activeTexture(p.TEXTURE0 + v),
                    p.bindTexture(p.TEXTURE_2D, d),
                    this
                },
                bindRenderTarget: function(d, v) {
                    return this.bindTexture(d.texture, v)
                },
                setTime: function(d) {
                    return this.set1f(d, this.game.loop.getDuration()),
                    this
                },
                set1f: function(d, v, p) {
                    return p === void 0 && (p = this.currentShader),
                    p.set1f(d, v),
                    this
                },
                set2f: function(d, v, p, g) {
                    return g === void 0 && (g = this.currentShader),
                    g.set2f(d, v, p),
                    this
                },
                set3f: function(d, v, p, g, m) {
                    return m === void 0 && (m = this.currentShader),
                    m.set3f(d, v, p, g),
                    this
                },
                set4f: function(d, v, p, g, m, x) {
                    return x === void 0 && (x = this.currentShader),
                    x.set4f(d, v, p, g, m),
                    this
                },
                set1fv: function(d, v, p) {
                    return p === void 0 && (p = this.currentShader),
                    p.set1fv(d, v),
                    this
                },
                set2fv: function(d, v, p) {
                    return p === void 0 && (p = this.currentShader),
                    p.set2fv(d, v),
                    this
                },
                set3fv: function(d, v, p) {
                    return p === void 0 && (p = this.currentShader),
                    p.set3fv(d, v),
                    this
                },
                set4fv: function(d, v, p) {
                    return p === void 0 && (p = this.currentShader),
                    p.set4fv(d, v),
                    this
                },
                set1iv: function(d, v, p) {
                    return p === void 0 && (p = this.currentShader),
                    p.set1iv(d, v),
                    this
                },
                set2iv: function(d, v, p) {
                    return p === void 0 && (p = this.currentShader),
                    p.set2iv(d, v),
                    this
                },
                set3iv: function(d, v, p) {
                    return p === void 0 && (p = this.currentShader),
                    p.set3iv(d, v),
                    this
                },
                set4iv: function(d, v, p) {
                    return p === void 0 && (p = this.currentShader),
                    p.set4iv(d, v),
                    this
                },
                set1i: function(d, v, p) {
                    return p === void 0 && (p = this.currentShader),
                    p.set1i(d, v),
                    this
                },
                set2i: function(d, v, p, g) {
                    return g === void 0 && (g = this.currentShader),
                    g.set2i(d, v, p),
                    this
                },
                set3i: function(d, v, p, g, m) {
                    return m === void 0 && (m = this.currentShader),
                    m.set3i(d, v, p, g),
                    this
                },
                set4i: function(d, v, p, g, m, x) {
                    return x === void 0 && (x = this.currentShader),
                    x.set4i(d, v, p, g, m),
                    this
                },
                setMatrix2fv: function(d, v, p, g) {
                    return g === void 0 && (g = this.currentShader),
                    g.setMatrix2fv(d, v, p),
                    this
                },
                setMatrix3fv: function(d, v, p, g) {
                    return g === void 0 && (g = this.currentShader),
                    g.setMatrix3fv(d, v, p),
                    this
                },
                setMatrix4fv: function(d, v, p, g) {
                    return g === void 0 && (g = this.currentShader),
                    g.setMatrix4fv(d, v, p),
                    this
                },
                destroy: function() {
                    this.emit(o.DESTROY, this);
                    var d, v = this.shaders;
                    for (d = 0; d < v.length; d++)
                        v[d].destroy();
                    var p = this.renderTargets;
                    for (d = 0; d < p.length; d++)
                        p[d].destroy();
                    this.gl.deleteBuffer(this.vertexBuffer);
                    var g = this.renderer;
                    return g.off(s.RESIZE, this.resize, this),
                    g.off(s.PRE_RENDER, this.onPreRender, this),
                    g.off(s.RENDER, this.onRender, this),
                    g.off(s.POST_RENDER, this.onPostRender, this),
                    this.removeAllListeners(),
                    this.game = null,
                    this.renderer = null,
                    this.manager = null,
                    this.gl = null,
                    this.view = null,
                    this.shaders = null,
                    this.renderTargets = null,
                    this.bytes = null,
                    this.vertexViewF32 = null,
                    this.vertexViewU32 = null,
                    this.vertexData = null,
                    this.vertexBuffer = null,
                    this.currentShader = null,
                    this.currentRenderTarget = null,
                    this
                }
            });
            c.exports = u
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            function e(I, G, w) {
                w = w || 2;
                var U = G && G.length
                  , X = U ? G[0] * w : I.length
                  , V = f(I, 0, X, w, !0)
                  , H = [];
                if (!V || V.next === V.prev)
                    return H;
                var J, $, _, nt, K, Z, j;
                if (U && (V = i(I, G, V, w)),
                I.length > 80 * w) {
                    J = _ = I[0],
                    $ = nt = I[1];
                    for (var Q = w; Q < X; Q += w)
                        K = I[Q],
                        Z = I[Q + 1],
                        K < J && (J = K),
                        Z < $ && ($ = Z),
                        K > _ && (_ = K),
                        Z > nt && (nt = Z);
                    j = Math.max(_ - J, nt - $),
                    j = j !== 0 ? 1 / j : 0
                }
                return o(V, H, w, J, $, j),
                H
            }
            function f(I, G, w, U, X) {
                var V, H;
                if (X === D(I, G, w, U) > 0)
                    for (V = G; V < w; V += U)
                        H = z(V, I[V], I[V + 1], H);
                else
                    for (V = w - U; V >= G; V -= U)
                        H = z(V, I[V], I[V + 1], H);
                return H && M(H, H.next) && (W(H),
                H = H.next),
                H
            }
            function r(I, G) {
                if (!I)
                    return I;
                G || (G = I);
                var w = I, U;
                do
                    if (U = !1,
                    !w.steiner && (M(w, w.next) || P(w.prev, w, w.next) === 0)) {
                        if (W(w),
                        w = G = w.prev,
                        w === w.next)
                            break;
                        U = !0
                    } else
                        w = w.next;
                while (U || w !== G);
                return G
            }
            function o(I, G, w, U, X, V, H) {
                if (I) {
                    !H && V && p(I, U, X, V);
                    for (var J = I, $, _; I.prev !== I.next; ) {
                        if ($ = I.prev,
                        _ = I.next,
                        V ? n(I, U, X, V) : a(I)) {
                            G.push($.i / w),
                            G.push(I.i / w),
                            G.push(_.i / w),
                            W(I),
                            I = _.next,
                            J = _.next;
                            continue
                        }
                        if (I = _,
                        I === J) {
                            H ? H === 1 ? (I = s(r(I), G, w),
                            o(I, G, w, U, X, V, 2)) : H === 2 && l(I, G, w, U, X, V) : o(r(I), G, w, U, X, V, 1);
                            break
                        }
                    }
                }
            }
            function a(I) {
                var G = I.prev
                  , w = I
                  , U = I.next;
                if (P(G, w, U) >= 0)
                    return !1;
                for (var X = I.next.next; X !== I.prev; ) {
                    if (T(G.x, G.y, w.x, w.y, U.x, U.y, X.x, X.y) && P(X.prev, X, X.next) >= 0)
                        return !1;
                    X = X.next
                }
                return !0
            }
            function n(I, G, w, U) {
                var X = I.prev
                  , V = I
                  , H = I.next;
                if (P(X, V, H) >= 0)
                    return !1;
                for (var J = X.x < V.x ? X.x < H.x ? X.x : H.x : V.x < H.x ? V.x : H.x, $ = X.y < V.y ? X.y < H.y ? X.y : H.y : V.y < H.y ? V.y : H.y, _ = X.x > V.x ? X.x > H.x ? X.x : H.x : V.x > H.x ? V.x : H.x, nt = X.y > V.y ? X.y > H.y ? X.y : H.y : V.y > H.y ? V.y : H.y, K = m(J, $, G, w, U), Z = m(_, nt, G, w, U), j = I.prevZ, Q = I.nextZ; j && j.z >= K && Q && Q.z <= Z; ) {
                    if (j !== I.prev && j !== I.next && T(X.x, X.y, V.x, V.y, H.x, H.y, j.x, j.y) && P(j.prev, j, j.next) >= 0 || (j = j.prevZ,
                    Q !== I.prev && Q !== I.next && T(X.x, X.y, V.x, V.y, H.x, H.y, Q.x, Q.y) && P(Q.prev, Q, Q.next) >= 0))
                        return !1;
                    Q = Q.nextZ
                }
                for (; j && j.z >= K; ) {
                    if (j !== I.prev && j !== I.next && T(X.x, X.y, V.x, V.y, H.x, H.y, j.x, j.y) && P(j.prev, j, j.next) >= 0)
                        return !1;
                    j = j.prevZ
                }
                for (; Q && Q.z <= Z; ) {
                    if (Q !== I.prev && Q !== I.next && T(X.x, X.y, V.x, V.y, H.x, H.y, Q.x, Q.y) && P(Q.prev, Q, Q.next) >= 0)
                        return !1;
                    Q = Q.nextZ
                }
                return !0
            }
            function s(I, G, w) {
                var U = I;
                do {
                    var X = U.prev
                      , V = U.next.next;
                    !M(X, V) && L(X, U, U.next, V) && B(X, V) && B(V, X) && (G.push(X.i / w),
                    G.push(U.i / w),
                    G.push(V.i / w),
                    W(U),
                    W(U.next),
                    U = I = V),
                    U = U.next
                } while (U !== I);
                return r(U)
            }
            function l(I, G, w, U, X, V) {
                var H = I;
                do {
                    for (var J = H.next.next; J !== H.prev; ) {
                        if (H.i !== J.i && E(H, J)) {
                            var $ = Y(H, J);
                            H = r(H, H.next),
                            $ = r($, $.next),
                            o(H, G, w, U, X, V),
                            o($, G, w, U, X, V);
                            return
                        }
                        J = J.next
                    }
                    H = H.next
                } while (H !== I)
            }
            function i(I, G, w, U) {
                var X = [], V, H, J, $, _;
                for (V = 0,
                H = G.length; V < H; V++)
                    J = G[V] * U,
                    $ = V < H - 1 ? G[V + 1] * U : I.length,
                    _ = f(I, J, $, U, !1),
                    _ === _.next && (_.steiner = !0),
                    X.push(x(_));
                for (X.sort(h),
                V = 0; V < X.length; V++)
                    u(X[V], w),
                    w = r(w, w.next);
                return w
            }
            function h(I, G) {
                return I.x - G.x
            }
            function u(I, G) {
                if (G = d(I, G),
                G) {
                    var w = Y(G, I);
                    r(G, G.next),
                    r(w, w.next)
                }
            }
            function d(I, G) {
                var w = G, U = I.x, X = I.y, V = -1 / 0, H;
                do {
                    if (X <= w.y && X >= w.next.y && w.next.y !== w.y) {
                        var J = w.x + (X - w.y) * (w.next.x - w.x) / (w.next.y - w.y);
                        if (J <= U && J > V) {
                            if (V = J,
                            J === U) {
                                if (X === w.y)
                                    return w;
                                if (X === w.next.y)
                                    return w.next
                            }
                            H = w.x < w.next.x ? w : w.next
                        }
                    }
                    w = w.next
                } while (w !== G);
                if (!H)
                    return null;
                if (U === V)
                    return H;
                var $ = H, _ = H.x, nt = H.y, K = 1 / 0, Z;
                w = H;
                do
                    U >= w.x && w.x >= _ && U !== w.x && T(X < nt ? U : V, X, _, nt, X < nt ? V : U, X, w.x, w.y) && (Z = Math.abs(X - w.y) / (U - w.x),
                    B(w, I) && (Z < K || Z === K && (w.x > H.x || w.x === H.x && v(H, w))) && (H = w,
                    K = Z)),
                    w = w.next;
                while (w !== $);
                return H
            }
            function v(I, G) {
                return P(I.prev, I, G.prev) < 0 && P(G.next, I, I.next) < 0
            }
            function p(I, G, w, U) {
                var X = I;
                do
                    X.z === null && (X.z = m(X.x, X.y, G, w, U)),
                    X.prevZ = X.prev,
                    X.nextZ = X.next,
                    X = X.next;
                while (X !== I);
                X.prevZ.nextZ = null,
                X.prevZ = null,
                g(X)
            }
            function g(I) {
                var G, w, U, X, V, H, J, $, _ = 1;
                do {
                    for (w = I,
                    I = null,
                    V = null,
                    H = 0; w; ) {
                        for (H++,
                        U = w,
                        J = 0,
                        G = 0; G < _ && (J++,
                        U = U.nextZ,
                        !!U); G++)
                            ;
                        for ($ = _; J > 0 || $ > 0 && U; )
                            J !== 0 && ($ === 0 || !U || w.z <= U.z) ? (X = w,
                            w = w.nextZ,
                            J--) : (X = U,
                            U = U.nextZ,
                            $--),
                            V ? V.nextZ = X : I = X,
                            X.prevZ = V,
                            V = X;
                        w = U
                    }
                    V.nextZ = null,
                    _ *= 2
                } while (H > 1);
                return I
            }
            function m(I, G, w, U, X) {
                return I = 32767 * (I - w) * X,
                G = 32767 * (G - U) * X,
                I = (I | I << 8) & 16711935,
                I = (I | I << 4) & 252645135,
                I = (I | I << 2) & 858993459,
                I = (I | I << 1) & 1431655765,
                G = (G | G << 8) & 16711935,
                G = (G | G << 4) & 252645135,
                G = (G | G << 2) & 858993459,
                G = (G | G << 1) & 1431655765,
                I | G << 1
            }
            function x(I) {
                var G = I
                  , w = I;
                do
                    (G.x < w.x || G.x === w.x && G.y < w.y) && (w = G),
                    G = G.next;
                while (G !== I);
                return w
            }
            function T(I, G, w, U, X, V, H, J) {
                return (X - H) * (G - J) - (I - H) * (V - J) >= 0 && (I - H) * (U - J) - (w - H) * (G - J) >= 0 && (w - H) * (V - J) - (X - H) * (U - J) >= 0
            }
            function E(I, G) {
                return I.next.i !== G.i && I.prev.i !== G.i && !F(I, G) && (B(I, G) && B(G, I) && N(I, G) && (P(I.prev, I, G.prev) || P(I, G.prev, G)) || M(I, G) && P(I.prev, I, I.next) > 0 && P(G.prev, G, G.next) > 0)
            }
            function P(I, G, w) {
                return (G.y - I.y) * (w.x - G.x) - (G.x - I.x) * (w.y - G.y)
            }
            function M(I, G) {
                return I.x === G.x && I.y === G.y
            }
            function L(I, G, w, U) {
                var X = O(P(I, G, w))
                  , V = O(P(I, G, U))
                  , H = O(P(w, U, I))
                  , J = O(P(w, U, G));
                return !!(X !== V && H !== J || X === 0 && R(I, w, G) || V === 0 && R(I, U, G) || H === 0 && R(w, I, U) || J === 0 && R(w, G, U))
            }
            function R(I, G, w) {
                return G.x <= Math.max(I.x, w.x) && G.x >= Math.min(I.x, w.x) && G.y <= Math.max(I.y, w.y) && G.y >= Math.min(I.y, w.y)
            }
            function O(I) {
                return I > 0 ? 1 : I < 0 ? -1 : 0
            }
            function F(I, G) {
                var w = I;
                do {
                    if (w.i !== I.i && w.next.i !== I.i && w.i !== G.i && w.next.i !== G.i && L(w, w.next, I, G))
                        return !0;
                    w = w.next
                } while (w !== I);
                return !1
            }
            function B(I, G) {
                return P(I.prev, I, I.next) < 0 ? P(I, G, I.next) >= 0 && P(I, I.prev, G) >= 0 : P(I, G, I.prev) < 0 || P(I, I.next, G) < 0
            }
            function N(I, G) {
                var w = I
                  , U = !1
                  , X = (I.x + G.x) / 2
                  , V = (I.y + G.y) / 2;
                do
                    w.y > V != w.next.y > V && w.next.y !== w.y && X < (w.next.x - w.x) * (V - w.y) / (w.next.y - w.y) + w.x && (U = !U),
                    w = w.next;
                while (w !== I);
                return U
            }
            function Y(I, G) {
                var w = new b(I.i,I.x,I.y)
                  , U = new b(G.i,G.x,G.y)
                  , X = I.next
                  , V = G.prev;
                return I.next = G,
                G.prev = I,
                w.next = X,
                X.prev = w,
                U.next = w,
                w.prev = U,
                V.next = U,
                U.prev = V,
                U
            }
            function z(I, G, w, U) {
                var X = new b(I,G,w);
                return U ? (X.next = U.next,
                X.prev = U,
                U.next.prev = X,
                U.next = X) : (X.prev = X,
                X.next = X),
                X
            }
            function W(I) {
                I.next.prev = I.prev,
                I.prev.next = I.next,
                I.prevZ && (I.prevZ.nextZ = I.nextZ),
                I.nextZ && (I.nextZ.prevZ = I.prevZ)
            }
            function b(I, G, w) {
                this.i = I,
                this.x = G,
                this.y = w,
                this.prev = null,
                this.next = null,
                this.z = null,
                this.prevZ = null,
                this.nextZ = null,
                this.steiner = !1
            }
            e.deviation = function(I, G, w, U) {
                var X = G && G.length
                  , V = X ? G[0] * w : I.length
                  , H = Math.abs(D(I, 0, V, w));
                if (X)
                    for (var J = 0, $ = G.length; J < $; J++) {
                        var _ = G[J] * w
                          , nt = J < $ - 1 ? G[J + 1] * w : I.length;
                        H -= Math.abs(D(I, _, nt, w))
                    }
                var K = 0;
                for (J = 0; J < U.length; J += 3) {
                    var Z = U[J] * w
                      , j = U[J + 1] * w
                      , Q = U[J + 2] * w;
                    K += Math.abs((I[Z] - I[Q]) * (I[j + 1] - I[Z + 1]) - (I[Z] - I[j]) * (I[Q + 1] - I[Z + 1]))
                }
                return H === 0 && K === 0 ? 0 : Math.abs((K - H) / H)
            }
            ;
            function D(I, G, w, U) {
                for (var X = 0, V = G, H = w - U; V < w; V += U)
                    X += (I[H] - I[V]) * (I[V + 1] + I[H + 1]),
                    H = V;
                return X
            }
            e.flatten = function(I) {
                for (var G = I[0][0].length, w = {
                    vertices: [],
                    holes: [],
                    dimensions: G
                }, U = 0, X = 0; X < I.length; X++) {
                    for (var V = 0; V < I[X].length; V++)
                        for (var H = 0; H < G; H++)
                            w.vertices.push(I[X][V][H]);
                    X > 0 && (U += I[X - 1].length,
                    w.holes.push(U))
                }
                return w
            }
            ,
            c.exports = e
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                var a = r || f.strokeColor
                  , n = o || f.strokeAlpha
                  , s = (a & 16711680) >>> 16
                  , l = (a & 65280) >>> 8
                  , i = a & 255;
                e.strokeStyle = "rgba(" + s + "," + l + "," + i + "," + n + ")",
                e.lineWidth = f.lineWidth
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(21)
              , r = t(23)
              , o = t(8)
              , a = t(2)
              , n = t(6)
              , s = t(7)
              , l = new e({
                Extends: r,
                initialize: function(h, u, d, v, p) {
                    var g = "json";
                    if (s(u)) {
                        var m = u;
                        u = a(m, "key"),
                        d = a(m, "url"),
                        v = a(m, "xhrSettings"),
                        g = a(m, "extension", g),
                        p = a(m, "dataKey", p)
                    }
                    var x = {
                        type: "json",
                        cache: h.cacheManager.json,
                        extension: g,
                        responseType: "text",
                        key: u,
                        url: d,
                        xhrSettings: v,
                        config: p
                    };
                    r.call(this, h, x),
                    s(d) && (p ? this.data = n(d, p) : this.data = d,
                    this.state = f.FILE_POPULATED)
                },
                onProcess: function() {
                    if (this.state !== f.FILE_POPULATED) {
                        this.state = f.FILE_PROCESSING;
                        try {
                            var i = JSON.parse(this.xhrLoader.responseText)
                        } catch (u) {
                            throw console.warn("Invalid JSON: " + this.key),
                            this.onProcessError(),
                            u
                        }
                        var h = this.config;
                        typeof h == "string" ? this.data = n(i, h, i) : this.data = i
                    }
                    this.onProcessComplete()
                }
            });
            o.register("json", function(i, h, u, d) {
                if (Array.isArray(i))
                    for (var v = 0; v < i.length; v++)
                        this.addFile(new l(this,i[v]));
                else
                    this.addFile(new l(this,i,h,d,u));
                return this
            }),
            c.exports = l
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                DYNAMIC_BODY: 0,
                STATIC_BODY: 1,
                GROUP: 2,
                TILEMAPLAYER: 3,
                FACING_NONE: 10,
                FACING_UP: 11,
                FACING_DOWN: 12,
                FACING_LEFT: 13,
                FACING_RIGHT: 14
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(158)
              , f = t(26)
              , r = function(o, a, n, s, l) {
                for (var i = null, h = null, u = null, d = null, v = f(o, a, n, s, null, l), p = 0; p < v.length; p++) {
                    var g = v[p];
                    g && (g.collides ? (i = e(g.x, g.y - 1, !0, l),
                    h = e(g.x, g.y + 1, !0, l),
                    u = e(g.x - 1, g.y, !0, l),
                    d = e(g.x + 1, g.y, !0, l),
                    g.faceTop = !(i && i.collides),
                    g.faceBottom = !(h && h.collides),
                    g.faceLeft = !(u && u.collides),
                    g.faceRight = !(d && d.collides)) : g.resetFaces())
                }
            };
            c.exports = r
        }
        , function(c, S, t) {
            var e = {};
            c.exports = e;
            var f = t(83)
              , r = t(32);
            (function() {
                e.create = function(o, a) {
                    for (var n = [], s = 0; s < o.length; s++) {
                        var l = o[s]
                          , i = {
                            x: l.x,
                            y: l.y,
                            index: s,
                            body: a,
                            isInternal: !1,
                            contact: null,
                            offset: null
                        };
                        i.contact = {
                            vertex: i,
                            normalImpulse: 0,
                            tangentImpulse: 0
                        },
                        n.push(i)
                    }
                    return n
                }
                ,
                e.fromPath = function(o, a) {
                    var n = /L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/ig
                      , s = [];
                    return o.replace(n, function(l, i, h) {
                        s.push({
                            x: parseFloat(i),
                            y: parseFloat(h)
                        })
                    }),
                    e.create(s, a)
                }
                ,
                e.centre = function(o) {
                    for (var a = e.area(o, !0), n = {
                        x: 0,
                        y: 0
                    }, s, l, i, h = 0; h < o.length; h++)
                        i = (h + 1) % o.length,
                        s = f.cross(o[h], o[i]),
                        l = f.mult(f.add(o[h], o[i]), s),
                        n = f.add(n, l);
                    return f.div(n, 6 * a)
                }
                ,
                e.mean = function(o) {
                    for (var a = {
                        x: 0,
                        y: 0
                    }, n = 0; n < o.length; n++)
                        a.x += o[n].x,
                        a.y += o[n].y;
                    return f.div(a, o.length)
                }
                ,
                e.area = function(o, a) {
                    for (var n = 0, s = o.length - 1, l = 0; l < o.length; l++)
                        n += (o[s].x - o[l].x) * (o[s].y + o[l].y),
                        s = l;
                    return a ? n / 2 : Math.abs(n) / 2
                }
                ,
                e.inertia = function(o, a) {
                    for (var n = 0, s = 0, l = o, i, h, u = 0; u < l.length; u++)
                        h = (u + 1) % l.length,
                        i = Math.abs(f.cross(l[h], l[u])),
                        n += i * (f.dot(l[h], l[h]) + f.dot(l[h], l[u]) + f.dot(l[u], l[u])),
                        s += i;
                    return a / 6 * (n / s)
                }
                ,
                e.translate = function(o, a, n) {
                    var s;
                    if (n)
                        for (s = 0; s < o.length; s++)
                            o[s].x += a.x * n,
                            o[s].y += a.y * n;
                    else
                        for (s = 0; s < o.length; s++)
                            o[s].x += a.x,
                            o[s].y += a.y;
                    return o
                }
                ,
                e.rotate = function(o, a, n) {
                    if (a !== 0) {
                        for (var s = Math.cos(a), l = Math.sin(a), i = 0; i < o.length; i++) {
                            var h = o[i]
                              , u = h.x - n.x
                              , d = h.y - n.y;
                            h.x = n.x + (u * s - d * l),
                            h.y = n.y + (u * l + d * s)
                        }
                        return o
                    }
                }
                ,
                e.contains = function(o, a) {
                    for (var n = 0; n < o.length; n++) {
                        var s = o[n]
                          , l = o[(n + 1) % o.length];
                        if ((a.x - s.x) * (l.y - s.y) + (a.y - s.y) * (s.x - l.x) > 0)
                            return !1
                    }
                    return !0
                }
                ,
                e.scale = function(o, a, n, s) {
                    if (a === 1 && n === 1)
                        return o;
                    s = s || e.centre(o);
                    for (var l, i, h = 0; h < o.length; h++)
                        l = o[h],
                        i = f.sub(l, s),
                        o[h].x = s.x + i.x * a,
                        o[h].y = s.y + i.y * n;
                    return o
                }
                ,
                e.chamfer = function(o, a, n, s, l) {
                    typeof a == "number" ? a = [a] : a = a || [8],
                    n = typeof n < "u" ? n : -1,
                    s = s || 2,
                    l = l || 14;
                    for (var i = [], h = 0; h < o.length; h++) {
                        var u = o[h - 1 >= 0 ? h - 1 : o.length - 1]
                          , d = o[h]
                          , v = o[(h + 1) % o.length]
                          , p = a[h < a.length ? h : a.length - 1];
                        if (p === 0) {
                            i.push(d);
                            continue
                        }
                        var g = f.normalise({
                            x: d.y - u.y,
                            y: u.x - d.x
                        })
                          , m = f.normalise({
                            x: v.y - d.y,
                            y: d.x - v.x
                        })
                          , x = Math.sqrt(2 * Math.pow(p, 2))
                          , T = f.mult(r.clone(g), p)
                          , E = f.normalise(f.mult(f.add(g, m), .5))
                          , P = f.sub(d, f.mult(E, x))
                          , M = n;
                        n === -1 && (M = Math.pow(p, .32) * 1.75),
                        M = r.clamp(M, s, l),
                        M % 2 === 1 && (M += 1);
                        for (var L = Math.acos(f.dot(g, m)), R = L / M, O = 0; O < M; O++)
                            i.push(f.add(f.rotate(T, R * O), P))
                    }
                    return i
                }
                ,
                e.clockwiseSort = function(o) {
                    var a = e.mean(o);
                    return o.sort(function(n, s) {
                        return f.angle(a, n) - f.angle(a, s)
                    }),
                    o
                }
                ,
                e.isConvex = function(o) {
                    var a = 0, n = o.length, s, l, i, h;
                    if (n < 3)
                        return null;
                    for (s = 0; s < n; s++)
                        if (l = (s + 1) % n,
                        i = (s + 2) % n,
                        h = (o[l].x - o[s].x) * (o[i].y - o[l].y),
                        h -= (o[l].y - o[s].y) * (o[i].x - o[l].x),
                        h < 0 ? a |= 1 : h > 0 && (a |= 2),
                        a === 3)
                            return !1;
                    return a !== 0 ? !0 : null
                }
                ,
                e.hull = function(o) {
                    var a = [], n = [], s, l;
                    for (o = o.slice(0),
                    o.sort(function(i, h) {
                        var u = i.x - h.x;
                        return u !== 0 ? u : i.y - h.y
                    }),
                    l = 0; l < o.length; l += 1) {
                        for (s = o[l]; n.length >= 2 && f.cross3(n[n.length - 2], n[n.length - 1], s) <= 0; )
                            n.pop();
                        n.push(s)
                    }
                    for (l = o.length - 1; l >= 0; l -= 1) {
                        for (s = o[l]; a.length >= 2 && f.cross3(a[a.length - 2], a[a.length - 1], s) <= 0; )
                            a.pop();
                        a.push(s)
                    }
                    return a.pop(),
                    n.pop(),
                    a.concat(n)
                }
            }
            )()
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(66)
              , r = t(300)
              , o = t(301)
              , a = t(56)
              , n = t(170)
              , s = new e({
                initialize: function(i, h, u) {
                    i === void 0 && (i = 0),
                    h === void 0 && (h = 0),
                    u === void 0 && (u = 0),
                    this.type = a.CIRCLE,
                    this.x = i,
                    this.y = h,
                    this._radius = u,
                    this._diameter = u * 2
                },
                contains: function(l, i) {
                    return f(this, l, i)
                },
                getPoint: function(l, i) {
                    return r(this, l, i)
                },
                getPoints: function(l, i, h) {
                    return o(this, l, i, h)
                },
                getRandomPoint: function(l) {
                    return n(this, l)
                },
                setTo: function(l, i, h) {
                    return this.x = l,
                    this.y = i,
                    this._radius = h,
                    this._diameter = h * 2,
                    this
                },
                setEmpty: function() {
                    return this._radius = 0,
                    this._diameter = 0,
                    this
                },
                setPosition: function(l, i) {
                    return i === void 0 && (i = l),
                    this.x = l,
                    this.y = i,
                    this
                },
                isEmpty: function() {
                    return this._radius <= 0
                },
                radius: {
                    get: function() {
                        return this._radius
                    },
                    set: function(l) {
                        this._radius = l,
                        this._diameter = l * 2
                    }
                },
                diameter: {
                    get: function() {
                        return this._diameter
                    },
                    set: function(l) {
                        this._diameter = l,
                        this._radius = l * .5
                    }
                },
                left: {
                    get: function() {
                        return this.x - this._radius
                    },
                    set: function(l) {
                        this.x = l + this._radius
                    }
                },
                right: {
                    get: function() {
                        return this.x + this._radius
                    },
                    set: function(l) {
                        this.x = l - this._radius
                    }
                },
                top: {
                    get: function() {
                        return this.y - this._radius
                    },
                    set: function(l) {
                        this.y = l + this._radius
                    }
                },
                bottom: {
                    get: function() {
                        return this.y + this._radius
                    },
                    set: function(l) {
                        this.y = l - this._radius
                    }
                }
            });
            c.exports = s
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                if (e.radius > 0 && f >= e.left && f <= e.right && r >= e.top && r <= e.bottom) {
                    var o = (e.x - f) * (e.x - f)
                      , a = (e.y - r) * (e.y - r);
                    return o + a <= e.radius * e.radius
                } else
                    return !1
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return Math.sqrt((e.x2 - e.x1) * (e.x2 - e.x1) + (e.y2 - e.y1) * (e.y2 - e.y1))
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                var o = r - f;
                return f + ((e - f) % o + o) % o
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(39)
              , r = 1e-6
              , o = new e({
                initialize: function(u) {
                    this.val = new Float32Array(16),
                    u ? this.copy(u) : this.identity()
                },
                clone: function() {
                    return new o(this)
                },
                set: function(h) {
                    return this.copy(h)
                },
                setValues: function(h, u, d, v, p, g, m, x, T, E, P, M, L, R, O, F) {
                    var B = this.val;
                    return B[0] = h,
                    B[1] = u,
                    B[2] = d,
                    B[3] = v,
                    B[4] = p,
                    B[5] = g,
                    B[6] = m,
                    B[7] = x,
                    B[8] = T,
                    B[9] = E,
                    B[10] = P,
                    B[11] = M,
                    B[12] = L,
                    B[13] = R,
                    B[14] = O,
                    B[15] = F,
                    this
                },
                copy: function(h) {
                    var u = h.val;
                    return this.setValues(u[0], u[1], u[2], u[3], u[4], u[5], u[6], u[7], u[8], u[9], u[10], u[11], u[12], u[13], u[14], u[15])
                },
                fromArray: function(h) {
                    return this.setValues(h[0], h[1], h[2], h[3], h[4], h[5], h[6], h[7], h[8], h[9], h[10], h[11], h[12], h[13], h[14], h[15])
                },
                zero: function() {
                    return this.setValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
                },
                transform: function(h, u, d) {
                    var v = a.fromQuat(d)
                      , p = v.val
                      , g = u.x
                      , m = u.y
                      , x = u.z;
                    return this.setValues(p[0] * g, p[1] * g, p[2] * g, 0, p[4] * m, p[5] * m, p[6] * m, 0, p[8] * x, p[9] * x, p[10] * x, 0, h.x, h.y, h.z, 1)
                },
                xyz: function(h, u, d) {
                    this.identity();
                    var v = this.val;
                    return v[12] = h,
                    v[13] = u,
                    v[14] = d,
                    this
                },
                scaling: function(h, u, d) {
                    this.zero();
                    var v = this.val;
                    return v[0] = h,
                    v[5] = u,
                    v[10] = d,
                    v[15] = 1,
                    this
                },
                identity: function() {
                    return this.setValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
                },
                transpose: function() {
                    var h = this.val
                      , u = h[1]
                      , d = h[2]
                      , v = h[3]
                      , p = h[6]
                      , g = h[7]
                      , m = h[11];
                    return h[1] = h[4],
                    h[2] = h[8],
                    h[3] = h[12],
                    h[4] = u,
                    h[6] = h[9],
                    h[7] = h[13],
                    h[8] = d,
                    h[9] = p,
                    h[11] = h[14],
                    h[12] = v,
                    h[13] = g,
                    h[14] = m,
                    this
                },
                getInverse: function(h) {
                    return this.copy(h),
                    this.invert()
                },
                invert: function() {
                    var h = this.val
                      , u = h[0]
                      , d = h[1]
                      , v = h[2]
                      , p = h[3]
                      , g = h[4]
                      , m = h[5]
                      , x = h[6]
                      , T = h[7]
                      , E = h[8]
                      , P = h[9]
                      , M = h[10]
                      , L = h[11]
                      , R = h[12]
                      , O = h[13]
                      , F = h[14]
                      , B = h[15]
                      , N = u * m - d * g
                      , Y = u * x - v * g
                      , z = u * T - p * g
                      , W = d * x - v * m
                      , b = d * T - p * m
                      , D = v * T - p * x
                      , I = E * O - P * R
                      , G = E * F - M * R
                      , w = E * B - L * R
                      , U = P * F - M * O
                      , X = P * B - L * O
                      , V = M * B - L * F
                      , H = N * V - Y * X + z * U + W * w - b * G + D * I;
                    return H ? (H = 1 / H,
                    this.setValues((m * V - x * X + T * U) * H, (v * X - d * V - p * U) * H, (O * D - F * b + B * W) * H, (M * b - P * D - L * W) * H, (x * w - g * V - T * G) * H, (u * V - v * w + p * G) * H, (F * z - R * D - B * Y) * H, (E * D - M * z + L * Y) * H, (g * X - m * w + T * I) * H, (d * w - u * X - p * I) * H, (R * b - O * z + B * N) * H, (P * z - E * b - L * N) * H, (m * G - g * U - x * I) * H, (u * U - d * G + v * I) * H, (O * Y - R * W - F * N) * H, (E * W - P * Y + M * N) * H)) : this
                },
                adjoint: function() {
                    var h = this.val
                      , u = h[0]
                      , d = h[1]
                      , v = h[2]
                      , p = h[3]
                      , g = h[4]
                      , m = h[5]
                      , x = h[6]
                      , T = h[7]
                      , E = h[8]
                      , P = h[9]
                      , M = h[10]
                      , L = h[11]
                      , R = h[12]
                      , O = h[13]
                      , F = h[14]
                      , B = h[15];
                    return this.setValues(m * (M * B - L * F) - P * (x * B - T * F) + O * (x * L - T * M), -(d * (M * B - L * F) - P * (v * B - p * F) + O * (v * L - p * M)), d * (x * B - T * F) - m * (v * B - p * F) + O * (v * T - p * x), -(d * (x * L - T * M) - m * (v * L - p * M) + P * (v * T - p * x)), -(g * (M * B - L * F) - E * (x * B - T * F) + R * (x * L - T * M)), u * (M * B - L * F) - E * (v * B - p * F) + R * (v * L - p * M), -(u * (x * B - T * F) - g * (v * B - p * F) + R * (v * T - p * x)), u * (x * L - T * M) - g * (v * L - p * M) + E * (v * T - p * x), g * (P * B - L * O) - E * (m * B - T * O) + R * (m * L - T * P), -(u * (P * B - L * O) - E * (d * B - p * O) + R * (d * L - p * P)), u * (m * B - T * O) - g * (d * B - p * O) + R * (d * T - p * m), -(u * (m * L - T * P) - g * (d * L - p * P) + E * (d * T - p * m)), -(g * (P * F - M * O) - E * (m * F - x * O) + R * (m * M - x * P)), u * (P * F - M * O) - E * (d * F - v * O) + R * (d * M - v * P), -(u * (m * F - x * O) - g * (d * F - v * O) + R * (d * x - v * m)), u * (m * M - x * P) - g * (d * M - v * P) + E * (d * x - v * m))
                },
                determinant: function() {
                    var h = this.val
                      , u = h[0]
                      , d = h[1]
                      , v = h[2]
                      , p = h[3]
                      , g = h[4]
                      , m = h[5]
                      , x = h[6]
                      , T = h[7]
                      , E = h[8]
                      , P = h[9]
                      , M = h[10]
                      , L = h[11]
                      , R = h[12]
                      , O = h[13]
                      , F = h[14]
                      , B = h[15]
                      , N = u * m - d * g
                      , Y = u * x - v * g
                      , z = u * T - p * g
                      , W = d * x - v * m
                      , b = d * T - p * m
                      , D = v * T - p * x
                      , I = E * O - P * R
                      , G = E * F - M * R
                      , w = E * B - L * R
                      , U = P * F - M * O
                      , X = P * B - L * O
                      , V = M * B - L * F;
                    return N * V - Y * X + z * U + W * w - b * G + D * I
                },
                multiply: function(h) {
                    var u = this.val
                      , d = u[0]
                      , v = u[1]
                      , p = u[2]
                      , g = u[3]
                      , m = u[4]
                      , x = u[5]
                      , T = u[6]
                      , E = u[7]
                      , P = u[8]
                      , M = u[9]
                      , L = u[10]
                      , R = u[11]
                      , O = u[12]
                      , F = u[13]
                      , B = u[14]
                      , N = u[15]
                      , Y = h.val
                      , z = Y[0]
                      , W = Y[1]
                      , b = Y[2]
                      , D = Y[3];
                    return u[0] = z * d + W * m + b * P + D * O,
                    u[1] = z * v + W * x + b * M + D * F,
                    u[2] = z * p + W * T + b * L + D * B,
                    u[3] = z * g + W * E + b * R + D * N,
                    z = Y[4],
                    W = Y[5],
                    b = Y[6],
                    D = Y[7],
                    u[4] = z * d + W * m + b * P + D * O,
                    u[5] = z * v + W * x + b * M + D * F,
                    u[6] = z * p + W * T + b * L + D * B,
                    u[7] = z * g + W * E + b * R + D * N,
                    z = Y[8],
                    W = Y[9],
                    b = Y[10],
                    D = Y[11],
                    u[8] = z * d + W * m + b * P + D * O,
                    u[9] = z * v + W * x + b * M + D * F,
                    u[10] = z * p + W * T + b * L + D * B,
                    u[11] = z * g + W * E + b * R + D * N,
                    z = Y[12],
                    W = Y[13],
                    b = Y[14],
                    D = Y[15],
                    u[12] = z * d + W * m + b * P + D * O,
                    u[13] = z * v + W * x + b * M + D * F,
                    u[14] = z * p + W * T + b * L + D * B,
                    u[15] = z * g + W * E + b * R + D * N,
                    this
                },
                multiplyLocal: function(h) {
                    var u = this.val
                      , d = h.val;
                    return this.setValues(u[0] * d[0] + u[1] * d[4] + u[2] * d[8] + u[3] * d[12], u[0] * d[1] + u[1] * d[5] + u[2] * d[9] + u[3] * d[13], u[0] * d[2] + u[1] * d[6] + u[2] * d[10] + u[3] * d[14], u[0] * d[3] + u[1] * d[7] + u[2] * d[11] + u[3] * d[15], u[4] * d[0] + u[5] * d[4] + u[6] * d[8] + u[7] * d[12], u[4] * d[1] + u[5] * d[5] + u[6] * d[9] + u[7] * d[13], u[4] * d[2] + u[5] * d[6] + u[6] * d[10] + u[7] * d[14], u[4] * d[3] + u[5] * d[7] + u[6] * d[11] + u[7] * d[15], u[8] * d[0] + u[9] * d[4] + u[10] * d[8] + u[11] * d[12], u[8] * d[1] + u[9] * d[5] + u[10] * d[9] + u[11] * d[13], u[8] * d[2] + u[9] * d[6] + u[10] * d[10] + u[11] * d[14], u[8] * d[3] + u[9] * d[7] + u[10] * d[11] + u[11] * d[15], u[12] * d[0] + u[13] * d[4] + u[14] * d[8] + u[15] * d[12], u[12] * d[1] + u[13] * d[5] + u[14] * d[9] + u[15] * d[13], u[12] * d[2] + u[13] * d[6] + u[14] * d[10] + u[15] * d[14], u[12] * d[3] + u[13] * d[7] + u[14] * d[11] + u[15] * d[15])
                },
                premultiply: function(h) {
                    return this.multiplyMatrices(h, this)
                },
                multiplyMatrices: function(h, u) {
                    var d = h.val
                      , v = u.val
                      , p = d[0]
                      , g = d[4]
                      , m = d[8]
                      , x = d[12]
                      , T = d[1]
                      , E = d[5]
                      , P = d[9]
                      , M = d[13]
                      , L = d[2]
                      , R = d[6]
                      , O = d[10]
                      , F = d[14]
                      , B = d[3]
                      , N = d[7]
                      , Y = d[11]
                      , z = d[15]
                      , W = v[0]
                      , b = v[4]
                      , D = v[8]
                      , I = v[12]
                      , G = v[1]
                      , w = v[5]
                      , U = v[9]
                      , X = v[13]
                      , V = v[2]
                      , H = v[6]
                      , J = v[10]
                      , $ = v[14]
                      , _ = v[3]
                      , nt = v[7]
                      , K = v[11]
                      , Z = v[15];
                    return this.setValues(p * W + g * G + m * V + x * _, T * W + E * G + P * V + M * _, L * W + R * G + O * V + F * _, B * W + N * G + Y * V + z * _, p * b + g * w + m * H + x * nt, T * b + E * w + P * H + M * nt, L * b + R * w + O * H + F * nt, B * b + N * w + Y * H + z * nt, p * D + g * U + m * J + x * K, T * D + E * U + P * J + M * K, L * D + R * U + O * J + F * K, B * D + N * U + Y * J + z * K, p * I + g * X + m * $ + x * Z, T * I + E * X + P * $ + M * Z, L * I + R * X + O * $ + F * Z, B * I + N * X + Y * $ + z * Z)
                },
                translate: function(h) {
                    return this.translateXYZ(h.x, h.y, h.z)
                },
                translateXYZ: function(h, u, d) {
                    var v = this.val;
                    return v[12] = v[0] * h + v[4] * u + v[8] * d + v[12],
                    v[13] = v[1] * h + v[5] * u + v[9] * d + v[13],
                    v[14] = v[2] * h + v[6] * u + v[10] * d + v[14],
                    v[15] = v[3] * h + v[7] * u + v[11] * d + v[15],
                    this
                },
                scale: function(h) {
                    return this.scaleXYZ(h.x, h.y, h.z)
                },
                scaleXYZ: function(h, u, d) {
                    var v = this.val;
                    return v[0] = v[0] * h,
                    v[1] = v[1] * h,
                    v[2] = v[2] * h,
                    v[3] = v[3] * h,
                    v[4] = v[4] * u,
                    v[5] = v[5] * u,
                    v[6] = v[6] * u,
                    v[7] = v[7] * u,
                    v[8] = v[8] * d,
                    v[9] = v[9] * d,
                    v[10] = v[10] * d,
                    v[11] = v[11] * d,
                    this
                },
                makeRotationAxis: function(h, u) {
                    var d = Math.cos(u)
                      , v = Math.sin(u)
                      , p = 1 - d
                      , g = h.x
                      , m = h.y
                      , x = h.z
                      , T = p * g
                      , E = p * m;
                    return this.setValues(T * g + d, T * m - v * x, T * x + v * m, 0, T * m + v * x, E * m + d, E * x - v * g, 0, T * x - v * m, E * x + v * g, p * x * x + d, 0, 0, 0, 0, 1)
                },
                rotate: function(h, u) {
                    var d = this.val
                      , v = u.x
                      , p = u.y
                      , g = u.z
                      , m = Math.sqrt(v * v + p * p + g * g);
                    if (Math.abs(m) < r)
                        return this;
                    m = 1 / m,
                    v *= m,
                    p *= m,
                    g *= m;
                    var x = Math.sin(h)
                      , T = Math.cos(h)
                      , E = 1 - T
                      , P = d[0]
                      , M = d[1]
                      , L = d[2]
                      , R = d[3]
                      , O = d[4]
                      , F = d[5]
                      , B = d[6]
                      , N = d[7]
                      , Y = d[8]
                      , z = d[9]
                      , W = d[10]
                      , b = d[11]
                      , D = d[12]
                      , I = d[13]
                      , G = d[14]
                      , w = d[15]
                      , U = v * v * E + T
                      , X = p * v * E + g * x
                      , V = g * v * E - p * x
                      , H = v * p * E - g * x
                      , J = p * p * E + T
                      , $ = g * p * E + v * x
                      , _ = v * g * E + p * x
                      , nt = p * g * E - v * x
                      , K = g * g * E + T;
                    return this.setValues(P * U + O * X + Y * V, M * U + F * X + z * V, L * U + B * X + W * V, R * U + N * X + b * V, P * H + O * J + Y * $, M * H + F * J + z * $, L * H + B * J + W * $, R * H + N * J + b * $, P * _ + O * nt + Y * K, M * _ + F * nt + z * K, L * _ + B * nt + W * K, R * _ + N * nt + b * K, D, I, G, w)
                },
                rotateX: function(h) {
                    var u = this.val
                      , d = Math.sin(h)
                      , v = Math.cos(h)
                      , p = u[4]
                      , g = u[5]
                      , m = u[6]
                      , x = u[7]
                      , T = u[8]
                      , E = u[9]
                      , P = u[10]
                      , M = u[11];
                    return u[4] = p * v + T * d,
                    u[5] = g * v + E * d,
                    u[6] = m * v + P * d,
                    u[7] = x * v + M * d,
                    u[8] = T * v - p * d,
                    u[9] = E * v - g * d,
                    u[10] = P * v - m * d,
                    u[11] = M * v - x * d,
                    this
                },
                rotateY: function(h) {
                    var u = this.val
                      , d = Math.sin(h)
                      , v = Math.cos(h)
                      , p = u[0]
                      , g = u[1]
                      , m = u[2]
                      , x = u[3]
                      , T = u[8]
                      , E = u[9]
                      , P = u[10]
                      , M = u[11];
                    return u[0] = p * v - T * d,
                    u[1] = g * v - E * d,
                    u[2] = m * v - P * d,
                    u[3] = x * v - M * d,
                    u[8] = p * d + T * v,
                    u[9] = g * d + E * v,
                    u[10] = m * d + P * v,
                    u[11] = x * d + M * v,
                    this
                },
                rotateZ: function(h) {
                    var u = this.val
                      , d = Math.sin(h)
                      , v = Math.cos(h)
                      , p = u[0]
                      , g = u[1]
                      , m = u[2]
                      , x = u[3]
                      , T = u[4]
                      , E = u[5]
                      , P = u[6]
                      , M = u[7];
                    return u[0] = p * v + T * d,
                    u[1] = g * v + E * d,
                    u[2] = m * v + P * d,
                    u[3] = x * v + M * d,
                    u[4] = T * v - p * d,
                    u[5] = E * v - g * d,
                    u[6] = P * v - m * d,
                    u[7] = M * v - x * d,
                    this
                },
                fromRotationTranslation: function(h, u) {
                    var d = h.x
                      , v = h.y
                      , p = h.z
                      , g = h.w
                      , m = d + d
                      , x = v + v
                      , T = p + p
                      , E = d * m
                      , P = d * x
                      , M = d * T
                      , L = v * x
                      , R = v * T
                      , O = p * T
                      , F = g * m
                      , B = g * x
                      , N = g * T;
                    return this.setValues(1 - (L + O), P + N, M - B, 0, P - N, 1 - (E + O), R + F, 0, M + B, R - F, 1 - (E + L), 0, u.x, u.y, u.z, 1)
                },
                fromQuat: function(h) {
                    var u = h.x
                      , d = h.y
                      , v = h.z
                      , p = h.w
                      , g = u + u
                      , m = d + d
                      , x = v + v
                      , T = u * g
                      , E = u * m
                      , P = u * x
                      , M = d * m
                      , L = d * x
                      , R = v * x
                      , O = p * g
                      , F = p * m
                      , B = p * x;
                    return this.setValues(1 - (M + R), E + B, P - F, 0, E - B, 1 - (T + R), L + O, 0, P + F, L - O, 1 - (T + M), 0, 0, 0, 0, 1)
                },
                frustum: function(h, u, d, v, p, g) {
                    var m = 1 / (u - h)
                      , x = 1 / (v - d)
                      , T = 1 / (p - g);
                    return this.setValues(p * 2 * m, 0, 0, 0, 0, p * 2 * x, 0, 0, (u + h) * m, (v + d) * x, (g + p) * T, -1, 0, 0, g * p * 2 * T, 0)
                },
                perspective: function(h, u, d, v) {
                    var p = 1 / Math.tan(h / 2)
                      , g = 1 / (d - v);
                    return this.setValues(p / u, 0, 0, 0, 0, p, 0, 0, 0, 0, (v + d) * g, -1, 0, 0, 2 * v * d * g, 0)
                },
                perspectiveLH: function(h, u, d, v) {
                    return this.setValues(2 * d / h, 0, 0, 0, 0, 2 * d / u, 0, 0, 0, 0, -v / (d - v), 1, 0, 0, d * v / (d - v), 0)
                },
                ortho: function(h, u, d, v, p, g) {
                    var m = h - u
                      , x = d - v
                      , T = p - g;
                    return m = m === 0 ? m : 1 / m,
                    x = x === 0 ? x : 1 / x,
                    T = T === 0 ? T : 1 / T,
                    this.setValues(-2 * m, 0, 0, 0, 0, -2 * x, 0, 0, 0, 0, 2 * T, 0, (h + u) * m, (v + d) * x, (g + p) * T, 1)
                },
                lookAtRH: function(h, u, d) {
                    var v = this.val;
                    return i.subVectors(h, u),
                    i.getLengthSquared() === 0 && (i.z = 1),
                    i.normalize(),
                    s.crossVectors(d, i),
                    s.getLengthSquared() === 0 && (Math.abs(d.z) === 1 ? i.x += 1e-4 : i.z += 1e-4,
                    i.normalize(),
                    s.crossVectors(d, i)),
                    s.normalize(),
                    l.crossVectors(i, s),
                    v[0] = s.x,
                    v[1] = s.y,
                    v[2] = s.z,
                    v[4] = l.x,
                    v[5] = l.y,
                    v[6] = l.z,
                    v[8] = i.x,
                    v[9] = i.y,
                    v[10] = i.z,
                    this
                },
                lookAt: function(h, u, d) {
                    var v = h.x
                      , p = h.y
                      , g = h.z
                      , m = d.x
                      , x = d.y
                      , T = d.z
                      , E = u.x
                      , P = u.y
                      , M = u.z;
                    if (Math.abs(v - E) < r && Math.abs(p - P) < r && Math.abs(g - M) < r)
                        return this.identity();
                    var L = v - E
                      , R = p - P
                      , O = g - M
                      , F = 1 / Math.sqrt(L * L + R * R + O * O);
                    L *= F,
                    R *= F,
                    O *= F;
                    var B = x * O - T * R
                      , N = T * L - m * O
                      , Y = m * R - x * L;
                    F = Math.sqrt(B * B + N * N + Y * Y),
                    F ? (F = 1 / F,
                    B *= F,
                    N *= F,
                    Y *= F) : (B = 0,
                    N = 0,
                    Y = 0);
                    var z = R * Y - O * N
                      , W = O * B - L * Y
                      , b = L * N - R * B;
                    return F = Math.sqrt(z * z + W * W + b * b),
                    F ? (F = 1 / F,
                    z *= F,
                    W *= F,
                    b *= F) : (z = 0,
                    W = 0,
                    b = 0),
                    this.setValues(B, z, L, 0, N, W, R, 0, Y, b, O, 0, -(B * v + N * p + Y * g), -(z * v + W * p + b * g), -(L * v + R * p + O * g), 1)
                },
                yawPitchRoll: function(h, u, d) {
                    this.zero(),
                    a.zero(),
                    n.zero();
                    var v = this.val
                      , p = a.val
                      , g = n.val
                      , m = Math.sin(d)
                      , x = Math.cos(d);
                    return v[10] = 1,
                    v[15] = 1,
                    v[0] = x,
                    v[1] = m,
                    v[4] = -m,
                    v[5] = x,
                    m = Math.sin(u),
                    x = Math.cos(u),
                    p[0] = 1,
                    p[15] = 1,
                    p[5] = x,
                    p[10] = x,
                    p[9] = -m,
                    p[6] = m,
                    m = Math.sin(h),
                    x = Math.cos(h),
                    g[5] = 1,
                    g[15] = 1,
                    g[0] = x,
                    g[2] = -m,
                    g[8] = m,
                    g[10] = x,
                    this.multiplyLocal(a),
                    this.multiplyLocal(n),
                    this
                },
                setWorldMatrix: function(h, u, d, v, p) {
                    return this.yawPitchRoll(h.y, h.x, h.z),
                    a.scaling(d.x, d.y, d.z),
                    n.xyz(u.x, u.y, u.z),
                    this.multiplyLocal(a),
                    this.multiplyLocal(n),
                    v && this.multiplyLocal(v),
                    p && this.multiplyLocal(p),
                    this
                },
                multiplyToMat4: function(h, u) {
                    var d = this.val
                      , v = h.val
                      , p = d[0]
                      , g = d[1]
                      , m = d[2]
                      , x = d[3]
                      , T = d[4]
                      , E = d[5]
                      , P = d[6]
                      , M = d[7]
                      , L = d[8]
                      , R = d[9]
                      , O = d[10]
                      , F = d[11]
                      , B = d[12]
                      , N = d[13]
                      , Y = d[14]
                      , z = d[15]
                      , W = v[0]
                      , b = v[1]
                      , D = v[2]
                      , I = v[3]
                      , G = v[4]
                      , w = v[5]
                      , U = v[6]
                      , X = v[7]
                      , V = v[8]
                      , H = v[9]
                      , J = v[10]
                      , $ = v[11]
                      , _ = v[12]
                      , nt = v[13]
                      , K = v[14]
                      , Z = v[15];
                    return u.setValues(W * p + b * T + D * L + I * B, b * g + b * E + D * R + I * N, D * m + b * P + D * O + I * Y, I * x + b * M + D * F + I * z, G * p + w * T + U * L + X * B, G * g + w * E + U * R + X * N, G * m + w * P + U * O + X * Y, G * x + w * M + U * F + X * z, V * p + H * T + J * L + $ * B, V * g + H * E + J * R + $ * N, V * m + H * P + J * O + $ * Y, V * x + H * M + J * F + $ * z, _ * p + nt * T + K * L + Z * B, _ * g + nt * E + K * R + Z * N, _ * m + nt * P + K * O + Z * Y, _ * x + nt * M + K * F + Z * z)
                },
                fromRotationXYTranslation: function(h, u, d) {
                    var v = u.x
                      , p = u.y
                      , g = u.z
                      , m = Math.sin(h.x)
                      , x = Math.cos(h.x)
                      , T = Math.sin(h.y)
                      , E = Math.cos(h.y)
                      , P = v
                      , M = p
                      , L = g
                      , R = -m
                      , O = 0 - R * T
                      , F = 0 - x * T
                      , B = R * E
                      , N = x * E;
                    return d || (P = E * v + T * g,
                    M = O * v + x * p + B * g,
                    L = F * v + m * p + N * g),
                    this.setValues(E, O, F, 0, 0, x, m, 0, T, B, N, 0, P, M, L, 1)
                },
                getMaxScaleOnAxis: function() {
                    var h = this.val
                      , u = h[0] * h[0] + h[1] * h[1] + h[2] * h[2]
                      , d = h[4] * h[4] + h[5] * h[5] + h[6] * h[6]
                      , v = h[8] * h[8] + h[9] * h[9] + h[10] * h[10];
                    return Math.sqrt(Math.max(u, d, v))
                }
            })
              , a = new o
              , n = new o
              , s = new f
              , l = new f
              , i = new f;
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                COMPLETE: t(987),
                DECODED: t(988),
                DECODED_ALL: t(989),
                DESTROY: t(990),
                DETUNE: t(991),
                GLOBAL_DETUNE: t(992),
                GLOBAL_MUTE: t(993),
                GLOBAL_RATE: t(994),
                GLOBAL_VOLUME: t(995),
                LOOP: t(996),
                LOOPED: t(997),
                MUTE: t(998),
                PAN: t(999),
                PAUSE_ALL: t(1e3),
                PAUSE: t(1001),
                PLAY: t(1002),
                RATE: t(1003),
                RESUME_ALL: t(1004),
                RESUME: t(1005),
                SEEK: t(1006),
                STOP_ALL: t(1007),
                STOP: t(1008),
                UNLOCKED: t(1009),
                VOLUME: t(1010)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(21)
              , r = t(23)
              , o = t(8)
              , a = t(2)
              , n = t(7)
              , s = new e({
                Extends: r,
                initialize: function l(i, h, u, d, v) {
                    var p = "png", g;
                    if (n(h)) {
                        var m = h;
                        h = a(m, "key"),
                        u = a(m, "url"),
                        g = a(m, "normalMap"),
                        d = a(m, "xhrSettings"),
                        p = a(m, "extension", p),
                        v = a(m, "frameConfig")
                    }
                    Array.isArray(u) && (g = u[1],
                    u = u[0]);
                    var x = {
                        type: "image",
                        cache: i.textureManager,
                        extension: p,
                        responseType: "blob",
                        key: h,
                        url: u,
                        xhrSettings: d,
                        config: v
                    };
                    if (r.call(this, i, x),
                    g) {
                        var T = new l(i,this.key,g,d,v);
                        T.type = "normalMap",
                        this.setLink(T),
                        i.addFile(T)
                    }
                },
                onProcess: function() {
                    this.state = f.FILE_PROCESSING,
                    this.data = new Image,
                    this.data.crossOrigin = this.crossOrigin;
                    var l = this;
                    this.data.onload = function() {
                        r.revokeObjectURL(l.data),
                        l.onProcessComplete()
                    }
                    ,
                    this.data.onerror = function() {
                        r.revokeObjectURL(l.data),
                        l.onProcessError()
                    }
                    ,
                    r.createObjectURL(this.data, this.xhrLoader.response, "image/png")
                },
                addToCache: function() {
                    var l, i = this.linkFile;
                    i && i.state === f.FILE_COMPLETE ? (this.type === "image" ? l = this.cache.addImage(this.key, this.data, i.data) : l = this.cache.addImage(i.key, i.data, this.data),
                    this.pendingDestroy(l),
                    i.pendingDestroy(l)) : i || (l = this.cache.addImage(this.key, this.data),
                    this.pendingDestroy(l))
                }
            });
            o.register("image", function(l, i, h) {
                if (Array.isArray(l))
                    for (var u = 0; u < l.length; u++)
                        this.addFile(new s(this,l[u]));
                else
                    this.addFile(new s(this,l,i,h));
                return this
            }),
            c.exports = s
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                f ? e.setCollision(!0, !0, !0, !0, !1) : e.resetCollision(!1)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(164)
              , f = t(0)
              , r = t(11)
              , o = t(15)
              , a = t(1065)
              , n = new f({
                Extends: o,
                Mixins: [r.Alpha, r.BlendMode, r.Depth, r.Flip, r.GetBounds, r.Mask, r.Origin, r.Pipeline, r.ScrollFactor, r.Size, r.TextureCrop, r.Tint, r.Transform, r.Visible, a],
                initialize: function(l, i, h, u, d) {
                    o.call(this, l, "Sprite"),
                    this._crop = this.resetCropObject(),
                    this.anims = new e(this),
                    this.setTexture(u, d),
                    this.setPosition(i, h),
                    this.setSizeToFrame(),
                    this.setOriginFromFrame(),
                    this.initPipeline()
                },
                addedToScene: function() {
                    this.scene.sys.updateList.add(this)
                },
                removedFromScene: function() {
                    this.scene.sys.updateList.remove(this)
                },
                preUpdate: function(s, l) {
                    this.anims.update(s, l)
                },
                play: function(s, l) {
                    return this.anims.play(s, l)
                },
                playReverse: function(s, l) {
                    return this.anims.playReverse(s, l)
                },
                playAfterDelay: function(s, l) {
                    return this.anims.playAfterDelay(s, l)
                },
                playAfterRepeat: function(s, l) {
                    return this.anims.playAfterRepeat(s, l)
                },
                chain: function(s) {
                    return this.anims.chain(s)
                },
                stop: function() {
                    return this.anims.stop()
                },
                stopAfterDelay: function(s) {
                    return this.anims.stopAfterDelay(s)
                },
                stopAfterRepeat: function(s) {
                    return this.anims.stopAfterRepeat(s)
                },
                stopOnFrame: function(s) {
                    return this.anims.stopOnFrame(s)
                },
                toJSON: function() {
                    return r.ToJSON(this)
                },
                preDestroy: function() {
                    this.anims.destroy(),
                    this.anims = void 0
                }
            });
            c.exports = n
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                if (!(f >= e.length)) {
                    for (var r = e.length - 1, o = e[f], a = f; a < r; a++)
                        e[a] = e[a + 1];
                    return e.length = r,
                    o
                }
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                ADDED_TO_SCENE: t(643),
                DESTROY: t(644),
                REMOVED_FROM_SCENE: t(645),
                VIDEO_COMPLETE: t(646),
                VIDEO_CREATED: t(647),
                VIDEO_ERROR: t(648),
                VIDEO_LOOP: t(649),
                VIDEO_PLAY: t(650),
                VIDEO_SEEKED: t(651),
                VIDEO_SEEKING: t(652),
                VIDEO_STOP: t(653),
                VIDEO_TIMEOUT: t(654),
                VIDEO_UNLOCKED: t(655)
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                return r === void 0 && (r = 0),
                f === 0 ? e : (e -= r,
                e = f * Math.floor(e / f),
                o ? (r + e) / f : r + e)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                var f = {};
                for (var r in e)
                    Array.isArray(e[r]) ? f[r] = e[r].slice(0) : f[r] = e[r];
                return f
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                var a = e.length;
                if (f < 0 || f > a || f >= r || r > a || f + r > a) {
                    if (o)
                        throw new Error("Range Error: Values outside acceptable range");
                    return !1
                } else
                    return !0
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Angry Bytes (and contributors)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            function t(o, a) {
                return String(o).localeCompare(a)
            }
            function e(o, a) {
                var n = o.length;
                if (n <= 1)
                    return o;
                for (var s = new Array(n), l = 1; l < n; l *= 2) {
                    f(o, a, l, s);
                    var i = o;
                    o = s,
                    s = i
                }
                return o
            }
            function f(o, a, n, s) {
                var l = o.length, i = 0, h = n * 2, u, d, v, p, g;
                for (u = 0; u < l; u += h)
                    for (d = u + n,
                    v = d + n,
                    d > l && (d = l),
                    v > l && (v = l),
                    p = u,
                    g = d; ; )
                        if (p < d && g < v)
                            a(o[p], o[g]) <= 0 ? s[i++] = o[p++] : s[i++] = o[g++];
                        else if (p < d)
                            s[i++] = o[p++];
                        else if (g < v)
                            s[i++] = o[g++];
                        else
                            break
            }
            var r = function(o, a) {
                a === void 0 && (a = t);
                var n = e(o, a);
                return n !== o && f(n, null, o.length, o),
                o
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(134)
              , f = t(205)
              , r = function(o, a) {
                var n = e.Power0;
                if (typeof o == "string")
                    if (e.hasOwnProperty(o))
                        n = e[o];
                    else {
                        var s = "";
                        o.indexOf(".") && (s = o.substr(o.indexOf(".") + 1),
                        s.toLowerCase() === "in" ? s = "easeIn" : s.toLowerCase() === "out" ? s = "easeOut" : s.toLowerCase() === "inout" && (s = "easeInOut")),
                        o = f(o.substr(0, o.indexOf(".") + 1) + s),
                        e.hasOwnProperty(o) && (n = e[o])
                    }
                else
                    typeof o == "function" ? n = o : Array.isArray(o) && o.length;
                if (!a)
                    return n;
                var l = a.slice(0);
                return l.unshift(0),
                function(i) {
                    return l[0] = i,
                    n.apply(this, l)
                }
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(12)
              , f = function(r, o, a, n, s) {
                var l = r.strokeTint
                  , i = e.getTintAppendFloatAlpha(o.strokeColor, o.strokeAlpha * a);
                l.TL = i,
                l.TR = i,
                l.BL = i,
                l.BR = i;
                var h = o.pathData
                  , u = h.length - 1
                  , d = o.lineWidth
                  , v = d / 2
                  , p = h[0] - n
                  , g = h[1] - s;
                o.closePath || (u -= 2);
                for (var m = 2; m < u; m += 2) {
                    var x = h[m] - n
                      , T = h[m + 1] - s;
                    r.batchLine(p, g, x, T, v, v, d, m - 2, o.closePath ? m === u - 1 : !1),
                    p = x,
                    g = T
                }
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(115)
              , r = t(476)
              , o = t(477)
              , a = t(56)
              , n = t(47)
              , s = t(181)
              , l = new e({
                initialize: function(h, u, d, v, p, g) {
                    h === void 0 && (h = 0),
                    u === void 0 && (u = 0),
                    d === void 0 && (d = 0),
                    v === void 0 && (v = 0),
                    p === void 0 && (p = 0),
                    g === void 0 && (g = 0),
                    this.type = a.TRIANGLE,
                    this.x1 = h,
                    this.y1 = u,
                    this.x2 = d,
                    this.y2 = v,
                    this.x3 = p,
                    this.y3 = g
                },
                contains: function(i, h) {
                    return f(this, i, h)
                },
                getPoint: function(i, h) {
                    return r(this, i, h)
                },
                getPoints: function(i, h, u) {
                    return o(this, i, h, u)
                },
                getRandomPoint: function(i) {
                    return s(this, i)
                },
                setTo: function(i, h, u, d, v, p) {
                    return i === void 0 && (i = 0),
                    h === void 0 && (h = 0),
                    u === void 0 && (u = 0),
                    d === void 0 && (d = 0),
                    v === void 0 && (v = 0),
                    p === void 0 && (p = 0),
                    this.x1 = i,
                    this.y1 = h,
                    this.x2 = u,
                    this.y2 = d,
                    this.x3 = v,
                    this.y3 = p,
                    this
                },
                getLineA: function(i) {
                    return i === void 0 && (i = new n),
                    i.setTo(this.x1, this.y1, this.x2, this.y2),
                    i
                },
                getLineB: function(i) {
                    return i === void 0 && (i = new n),
                    i.setTo(this.x2, this.y2, this.x3, this.y3),
                    i
                },
                getLineC: function(i) {
                    return i === void 0 && (i = new n),
                    i.setTo(this.x3, this.y3, this.x1, this.y1),
                    i
                },
                left: {
                    get: function() {
                        return Math.min(this.x1, this.x2, this.x3)
                    },
                    set: function(i) {
                        var h = 0;
                        this.x1 <= this.x2 && this.x1 <= this.x3 ? h = this.x1 - i : this.x2 <= this.x1 && this.x2 <= this.x3 ? h = this.x2 - i : h = this.x3 - i,
                        this.x1 -= h,
                        this.x2 -= h,
                        this.x3 -= h
                    }
                },
                right: {
                    get: function() {
                        return Math.max(this.x1, this.x2, this.x3)
                    },
                    set: function(i) {
                        var h = 0;
                        this.x1 >= this.x2 && this.x1 >= this.x3 ? h = this.x1 - i : this.x2 >= this.x1 && this.x2 >= this.x3 ? h = this.x2 - i : h = this.x3 - i,
                        this.x1 -= h,
                        this.x2 -= h,
                        this.x3 -= h
                    }
                },
                top: {
                    get: function() {
                        return Math.min(this.y1, this.y2, this.y3)
                    },
                    set: function(i) {
                        var h = 0;
                        this.y1 <= this.y2 && this.y1 <= this.y3 ? h = this.y1 - i : this.y2 <= this.y1 && this.y2 <= this.y3 ? h = this.y2 - i : h = this.y3 - i,
                        this.y1 -= h,
                        this.y2 -= h,
                        this.y3 -= h
                    }
                },
                bottom: {
                    get: function() {
                        return Math.max(this.y1, this.y2, this.y3)
                    },
                    set: function(i) {
                        var h = 0;
                        this.y1 >= this.y2 && this.y1 >= this.y3 ? h = this.y1 - i : this.y2 >= this.y1 && this.y2 >= this.y3 ? h = this.y2 - i : h = this.y3 - i,
                        this.y1 -= h,
                        this.y2 -= h,
                        this.y3 -= h
                    }
                }
            });
            c.exports = l
        }
        , function(c, S) {
            var t = {};
            c.exports = t,
            function() {
                t.create = function(e, f) {
                    return {
                        x: e || 0,
                        y: f || 0
                    }
                }
                ,
                t.clone = function(e) {
                    return {
                        x: e.x,
                        y: e.y
                    }
                }
                ,
                t.magnitude = function(e) {
                    return Math.sqrt(e.x * e.x + e.y * e.y)
                }
                ,
                t.magnitudeSquared = function(e) {
                    return e.x * e.x + e.y * e.y
                }
                ,
                t.rotate = function(e, f, r) {
                    var o = Math.cos(f)
                      , a = Math.sin(f);
                    r || (r = {});
                    var n = e.x * o - e.y * a;
                    return r.y = e.x * a + e.y * o,
                    r.x = n,
                    r
                }
                ,
                t.rotateAbout = function(e, f, r, o) {
                    var a = Math.cos(f)
                      , n = Math.sin(f);
                    o || (o = {});
                    var s = r.x + ((e.x - r.x) * a - (e.y - r.y) * n);
                    return o.y = r.y + ((e.x - r.x) * n + (e.y - r.y) * a),
                    o.x = s,
                    o
                }
                ,
                t.normalise = function(e) {
                    var f = t.magnitude(e);
                    return f === 0 ? {
                        x: 0,
                        y: 0
                    } : {
                        x: e.x / f,
                        y: e.y / f
                    }
                }
                ,
                t.dot = function(e, f) {
                    return e.x * f.x + e.y * f.y
                }
                ,
                t.cross = function(e, f) {
                    return e.x * f.y - e.y * f.x
                }
                ,
                t.cross3 = function(e, f, r) {
                    return (f.x - e.x) * (r.y - e.y) - (f.y - e.y) * (r.x - e.x)
                }
                ,
                t.add = function(e, f, r) {
                    return r || (r = {}),
                    r.x = e.x + f.x,
                    r.y = e.y + f.y,
                    r
                }
                ,
                t.sub = function(e, f, r) {
                    return r || (r = {}),
                    r.x = e.x - f.x,
                    r.y = e.y - f.y,
                    r
                }
                ,
                t.mult = function(e, f) {
                    return {
                        x: e.x * f,
                        y: e.y * f
                    }
                }
                ,
                t.div = function(e, f) {
                    return {
                        x: e.x / f,
                        y: e.y / f
                    }
                }
                ,
                t.perp = function(e, f) {
                    return f = f === !0 ? -1 : 1,
                    {
                        x: f * -e.y,
                        y: f * e.x
                    }
                }
                ,
                t.neg = function(e) {
                    return {
                        x: -e.x,
                        y: -e.y
                    }
                }
                ,
                t.angle = function(e, f) {
                    return Math.atan2(f.y - e.y, f.x - e.x)
                }
                ,
                t._temp = [t.create(), t.create(), t.create(), t.create(), t.create(), t.create()]
            }()
        }
        , function(c, S) {
            var t = {};
            c.exports = t,
            function() {
                t.create = function(e) {
                    var f = {
                        min: {
                            x: 0,
                            y: 0
                        },
                        max: {
                            x: 0,
                            y: 0
                        }
                    };
                    return e && t.update(f, e),
                    f
                }
                ,
                t.update = function(e, f, r) {
                    e.min.x = 1 / 0,
                    e.max.x = -1 / 0,
                    e.min.y = 1 / 0,
                    e.max.y = -1 / 0;
                    for (var o = 0; o < f.length; o++) {
                        var a = f[o];
                        a.x > e.max.x && (e.max.x = a.x),
                        a.x < e.min.x && (e.min.x = a.x),
                        a.y > e.max.y && (e.max.y = a.y),
                        a.y < e.min.y && (e.min.y = a.y)
                    }
                    r && (r.x > 0 ? e.max.x += r.x : e.min.x += r.x,
                    r.y > 0 ? e.max.y += r.y : e.min.y += r.y)
                }
                ,
                t.contains = function(e, f) {
                    return f.x >= e.min.x && f.x <= e.max.x && f.y >= e.min.y && f.y <= e.max.y
                }
                ,
                t.overlaps = function(e, f) {
                    return e.min.x <= f.max.x && e.max.x >= f.min.x && e.max.y >= f.min.y && e.min.y <= f.max.y
                }
                ,
                t.translate = function(e, f) {
                    e.min.x += f.x,
                    e.max.x += f.x,
                    e.min.y += f.y,
                    e.max.y += f.y
                }
                ,
                t.shift = function(e, f) {
                    var r = e.max.x - e.min.x
                      , o = e.max.y - e.min.y;
                    e.min.x = f.x,
                    e.max.x = f.x + r,
                    e.min.y = f.y,
                    e.max.y = f.y + o
                }
            }()
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(29)
              , f = t(0)
              , r = t(11)
              , o = t(502)
              , a = new f({
                Mixins: [r.Alpha, r.Flip, r.Visible],
                initialize: function(s, l, i, h, u, d, v, p) {
                    this.layer = s,
                    this.index = l,
                    this.x = i,
                    this.y = h,
                    this.width = u,
                    this.height = d,
                    this.right,
                    this.bottom,
                    this.baseWidth = v !== void 0 ? v : u,
                    this.baseHeight = p !== void 0 ? p : d,
                    this.pixelX = 0,
                    this.pixelY = 0,
                    this.updatePixelXY(),
                    this.properties = {},
                    this.rotation = 0,
                    this.collideLeft = !1,
                    this.collideRight = !1,
                    this.collideUp = !1,
                    this.collideDown = !1,
                    this.faceLeft = !1,
                    this.faceRight = !1,
                    this.faceTop = !1,
                    this.faceBottom = !1,
                    this.collisionCallback = void 0,
                    this.collisionCallbackContext = this,
                    this.tint = 16777215,
                    this.physics = {}
                },
                containsPoint: function(n, s) {
                    return !(n < this.pixelX || s < this.pixelY || n > this.right || s > this.bottom)
                },
                copy: function(n) {
                    return this.index = n.index,
                    this.alpha = n.alpha,
                    this.properties = n.properties,
                    this.visible = n.visible,
                    this.setFlip(n.flipX, n.flipY),
                    this.tint = n.tint,
                    this.rotation = n.rotation,
                    this.collideUp = n.collideUp,
                    this.collideDown = n.collideDown,
                    this.collideLeft = n.collideLeft,
                    this.collideRight = n.collideRight,
                    this.collisionCallback = n.collisionCallback,
                    this.collisionCallbackContext = n.collisionCallbackContext,
                    this
                },
                getCollisionGroup: function() {
                    return this.tileset ? this.tileset.getTileCollisionGroup(this.index) : null
                },
                getTileData: function() {
                    return this.tileset ? this.tileset.getTileData(this.index) : null
                },
                getLeft: function(n) {
                    var s = this.tilemapLayer;
                    return s ? s.tileToWorldX(this.x, n) : this.x * this.baseWidth
                },
                getRight: function(n) {
                    var s = this.tilemapLayer;
                    return s ? this.getLeft(n) + this.width * s.scaleX : this.getLeft(n) + this.width
                },
                getTop: function(n) {
                    var s = this.tilemapLayer;
                    return s ? s.tileToWorldY(this.y, n) - (this.height - this.baseHeight) * s.scaleY : this.y * this.baseHeight - (this.height - this.baseHeight)
                },
                getBottom: function(n) {
                    var s = this.tilemapLayer;
                    return s ? this.getTop(n) + this.height * s.scaleY : this.getTop(n) + this.height
                },
                getBounds: function(n, s) {
                    return s === void 0 && (s = new o),
                    s.x = this.getLeft(),
                    s.y = this.getTop(),
                    s.width = this.getRight() - s.x,
                    s.height = this.getBottom() - s.y,
                    s
                },
                getCenterX: function(n) {
                    return (this.getLeft(n) + this.getRight(n)) / 2
                },
                getCenterY: function(n) {
                    return (this.getTop(n) + this.getBottom(n)) / 2
                },
                intersects: function(n, s, l, i) {
                    return !(l <= this.pixelX || i <= this.pixelY || n >= this.right || s >= this.bottom)
                },
                isInteresting: function(n, s) {
                    return n && s ? this.canCollide || this.hasInterestingFace : n ? this.collides : s ? this.hasInterestingFace : !1
                },
                resetCollision: function(n) {
                    if (n === void 0 && (n = !0),
                    this.collideLeft = !1,
                    this.collideRight = !1,
                    this.collideUp = !1,
                    this.collideDown = !1,
                    this.faceTop = !1,
                    this.faceBottom = !1,
                    this.faceLeft = !1,
                    this.faceRight = !1,
                    n) {
                        var s = this.tilemapLayer;
                        s && this.tilemapLayer.calculateFacesAt(this.x, this.y)
                    }
                    return this
                },
                resetFaces: function() {
                    return this.faceTop = !1,
                    this.faceBottom = !1,
                    this.faceLeft = !1,
                    this.faceRight = !1,
                    this
                },
                setCollision: function(n, s, l, i, h) {
                    if (s === void 0 && (s = n),
                    l === void 0 && (l = n),
                    i === void 0 && (i = n),
                    h === void 0 && (h = !0),
                    this.collideLeft = n,
                    this.collideRight = s,
                    this.collideUp = l,
                    this.collideDown = i,
                    this.faceLeft = n,
                    this.faceRight = s,
                    this.faceTop = l,
                    this.faceBottom = i,
                    h) {
                        var u = this.tilemapLayer;
                        u && this.tilemapLayer.calculateFacesAt(this.x, this.y)
                    }
                    return this
                },
                setCollisionCallback: function(n, s) {
                    return n === null ? (this.collisionCallback = void 0,
                    this.collisionCallbackContext = void 0) : (this.collisionCallback = n,
                    this.collisionCallbackContext = s),
                    this
                },
                setSize: function(n, s, l, i) {
                    return n !== void 0 && (this.width = n),
                    s !== void 0 && (this.height = s),
                    l !== void 0 && (this.baseWidth = l),
                    i !== void 0 && (this.baseHeight = i),
                    this.updatePixelXY(),
                    this
                },
                updatePixelXY: function() {
                    var n = this.layer.orientation;
                    if (n === e.ORTHOGONAL)
                        this.pixelX = this.x * this.baseWidth,
                        this.pixelY = this.y * this.baseHeight;
                    else if (n === e.ISOMETRIC)
                        this.pixelX = (this.x - this.y) * this.baseWidth * .5,
                        this.pixelY = (this.x + this.y) * this.baseHeight * .5;
                    else if (n === e.STAGGERED)
                        this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2),
                        this.pixelY = this.y * (this.baseHeight / 2);
                    else if (n === e.HEXAGONAL) {
                        var s = this.layer.hexSideLength
                          , l = (this.baseHeight - s) / 2 + s;
                        this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2),
                        this.pixelY = this.y * l
                    }
                    return this.right = this.pixelX + this.baseWidth,
                    this.bottom = this.pixelY + this.baseHeight,
                    this
                },
                destroy: function() {
                    this.collisionCallback = void 0,
                    this.collisionCallbackContext = void 0,
                    this.properties = void 0
                },
                canCollide: {
                    get: function() {
                        return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback !== void 0
                    }
                },
                collides: {
                    get: function() {
                        return this.collideLeft || this.collideRight || this.collideUp || this.collideDown
                    }
                },
                hasInterestingFace: {
                    get: function() {
                        return this.faceTop || this.faceBottom || this.faceLeft || this.faceRight
                    }
                },
                tileset: {
                    get: function() {
                        var n = this.layer.tilemapLayer;
                        if (n) {
                            var s = n.gidMap[this.index];
                            if (s)
                                return s
                        }
                        return null
                    }
                },
                tilemapLayer: {
                    get: function() {
                        return this.layer.tilemapLayer
                    }
                },
                tilemap: {
                    get: function() {
                        var n = this.tilemapLayer;
                        return n ? n.tilemap : null
                    }
                }
            });
            c.exports = a
        }
        , function(c, S, t) {
            var e = {};
            c.exports = e;
            var f = t(64)
              , r = t(32)
              , o = t(41)
              , a = t(84)
              , n = t(83)
              , s = t(1393);
            (function() {
                e.rectangle = function(l, i, h, u, d) {
                    d = d || {};
                    var v = {
                        label: "Rectangle Body",
                        position: {
                            x: l,
                            y: i
                        },
                        vertices: f.fromPath("L 0 0 L " + h + " 0 L " + h + " " + u + " L 0 " + u)
                    };
                    if (d.chamfer) {
                        var p = d.chamfer;
                        v.vertices = f.chamfer(v.vertices, p.radius, p.quality, p.qualityMin, p.qualityMax),
                        delete d.chamfer
                    }
                    return o.create(r.extend({}, v, d))
                }
                ,
                e.trapezoid = function(l, i, h, u, d, v) {
                    v = v || {},
                    d *= .5;
                    var p = (1 - d * 2) * h, g = h * d, m = g + p, x = m + g, T;
                    d < .5 ? T = "L 0 0 L " + g + " " + -u + " L " + m + " " + -u + " L " + x + " 0" : T = "L 0 0 L " + m + " " + -u + " L " + x + " 0";
                    var E = {
                        label: "Trapezoid Body",
                        position: {
                            x: l,
                            y: i
                        },
                        vertices: f.fromPath(T)
                    };
                    if (v.chamfer) {
                        var P = v.chamfer;
                        E.vertices = f.chamfer(E.vertices, P.radius, P.quality, P.qualityMin, P.qualityMax),
                        delete v.chamfer
                    }
                    return o.create(r.extend({}, E, v))
                }
                ,
                e.circle = function(l, i, h, u, d) {
                    u = u || {};
                    var v = {
                        label: "Circle Body",
                        circleRadius: h
                    };
                    d = d || 25;
                    var p = Math.ceil(Math.max(10, Math.min(d, h)));
                    return p % 2 === 1 && (p += 1),
                    e.polygon(l, i, p, h, r.extend({}, v, u))
                }
                ,
                e.polygon = function(l, i, h, u, d) {
                    if (d = d || {},
                    h < 3)
                        return e.circle(l, i, u, d);
                    for (var v = 2 * Math.PI / h, p = "", g = v * .5, m = 0; m < h; m += 1) {
                        var x = g + m * v
                          , T = Math.cos(x) * u
                          , E = Math.sin(x) * u;
                        p += "L " + T.toFixed(3) + " " + E.toFixed(3) + " "
                    }
                    var P = {
                        label: "Polygon Body",
                        position: {
                            x: l,
                            y: i
                        },
                        vertices: f.fromPath(p)
                    };
                    if (d.chamfer) {
                        var M = d.chamfer;
                        P.vertices = f.chamfer(P.vertices, M.radius, M.quality, M.qualityMin, M.qualityMax),
                        delete d.chamfer
                    }
                    return o.create(r.extend({}, P, d))
                }
                ,
                e.fromVertices = function(l, i, h, u, d, v, p) {
                    var g, m, x, T, E, P;
                    for (u = u || {},
                    m = [],
                    d = typeof d < "u" ? d : !1,
                    v = typeof v < "u" ? v : .01,
                    p = typeof p < "u" ? p : 10,
                    s || r.warn("Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull."),
                    r.isArray(h[0]) || (h = [h]),
                    P = 0; P < h.length; P += 1)
                        if (T = h[P],
                        x = f.isConvex(T),
                        x || !s)
                            x ? T = f.clockwiseSort(T) : T = f.hull(T),
                            m.push({
                                position: {
                                    x: l,
                                    y: i
                                },
                                vertices: T
                            });
                        else {
                            var M = T.map(function(F) {
                                return [F.x, F.y]
                            });
                            s.makeCCW(M),
                            v !== !1 && s.removeCollinearPoints(M, v);
                            var L = s.quickDecomp(M);
                            for (E = 0; E < L.length; E++) {
                                var R = L[E]
                                  , O = R.map(function(F) {
                                    return {
                                        x: F[0],
                                        y: F[1]
                                    }
                                });
                                p > 0 && f.area(O) < p || m.push({
                                    position: f.centre(O),
                                    vertices: O
                                })
                            }
                        }
                    for (E = 0; E < m.length; E++)
                        m[E] = o.create(r.extend(m[E], u));
                    return d && e.flagCoincidentParts(m, 5),
                    m.length > 1 ? (g = o.create(r.extend({
                        parts: m.slice(0)
                    }, u)),
                    o.setPosition(g, {
                        x: l,
                        y: i
                    }),
                    g) : m[0]
                }
                ,
                e.flagCoincidentParts = function(l, i) {
                    i === void 0 && (i = 5);
                    for (var h = 0; h < l.length; h++)
                        for (var u = l[h], d = h + 1; d < l.length; d++) {
                            var v = l[d];
                            if (a.overlaps(u.bounds, v.bounds))
                                for (var p = u.vertices, g = v.vertices, m = 0; m < u.vertices.length; m++)
                                    for (var x = 0; x < v.vertices.length; x++) {
                                        var T = n.magnitudeSquared(n.sub(p[(m + 1) % p.length], g[x]))
                                          , E = n.magnitudeSquared(n.sub(p[m], g[(x + 1) % g.length]));
                                        T < i && E < i && (p[m].isInternal = !0,
                                        g[x].isInternal = !0)
                                    }
                        }
                    return l
                }
            }
            )()
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e.x - e.width * e.originX + e.width * .5
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                var r = e.width * e.originX;
                return e.x = f + r - e.width * .5,
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e.y - e.height * e.originY + e.height * .5
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                var r = e.height * e.originY;
                return e.y = f + r - e.height * .5,
                e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                POST_RENDER: t(628),
                PRE_RENDER: t(629),
                RENDER: t(630),
                RESIZE: t(631)
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                BITMAPMASK_PIPELINE: "BitmapMaskPipeline",
                LIGHT_PIPELINE: "Light2D",
                POINTLIGHT_PIPELINE: "PointLightPipeline",
                SINGLE_PIPELINE: "SinglePipeline",
                MULTI_PIPELINE: "MultiPipeline",
                ROPE_PIPELINE: "RopePipeline",
                GRAPHICS_PIPELINE: "GraphicsPipeline",
                POSTFX_PIPELINE: "PostFXPipeline",
                UTILITY_PIPELINE: "UtilityPipeline"
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(74)
              , f = function(r, o, a, n) {
                n === void 0 && (n = r);
                var s;
                if (!Array.isArray(o))
                    return s = r.indexOf(o),
                    s !== -1 ? (e(r, s),
                    a && a.call(n, o),
                    o) : null;
                for (var l = o.length - 1, i = []; l >= 0; ) {
                    var h = o[l];
                    s = r.indexOf(h),
                    s !== -1 && (e(r, s),
                    i.push(h),
                    a && a.call(n, h)),
                    l--
                }
                return i
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(199)
              , r = t(10)
              , o = t(3)
              , a = new e({
                initialize: function(s) {
                    this.type = s,
                    this.defaultDivisions = 5,
                    this.arcLengthDivisions = 100,
                    this.cacheArcLengths = [],
                    this.needsUpdate = !0,
                    this.active = !0,
                    this._tmpVec2A = new o,
                    this._tmpVec2B = new o
                },
                draw: function(n, s) {
                    return s === void 0 && (s = 32),
                    n.strokePoints(this.getPoints(s))
                },
                getBounds: function(n, s) {
                    n || (n = new r),
                    s === void 0 && (s = 16);
                    var l = this.getLength();
                    s > l && (s = l / 2);
                    var i = Math.max(1, Math.round(l / s));
                    return f(this.getSpacedPoints(i), n)
                },
                getDistancePoints: function(n) {
                    var s = this.getLength()
                      , l = Math.max(1, s / n);
                    return this.getSpacedPoints(l)
                },
                getEndPoint: function(n) {
                    return n === void 0 && (n = new o),
                    this.getPointAt(1, n)
                },
                getLength: function() {
                    var n = this.getLengths();
                    return n[n.length - 1]
                },
                getLengths: function(n) {
                    if (n === void 0 && (n = this.arcLengthDivisions),
                    this.cacheArcLengths.length === n + 1 && !this.needsUpdate)
                        return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    var s = [], l, i = this.getPoint(0, this._tmpVec2A), h = 0;
                    s.push(0);
                    for (var u = 1; u <= n; u++)
                        l = this.getPoint(u / n, this._tmpVec2B),
                        h += l.distance(i),
                        s.push(h),
                        i.copy(l);
                    return this.cacheArcLengths = s,
                    s
                },
                getPointAt: function(n, s) {
                    var l = this.getUtoTmapping(n);
                    return this.getPoint(l, s)
                },
                getPoints: function(n, s, l) {
                    l === void 0 && (l = []),
                    n || (s ? n = this.getLength() / s : n = this.defaultDivisions);
                    for (var i = 0; i <= n; i++)
                        l.push(this.getPoint(i / n));
                    return l
                },
                getRandomPoint: function(n) {
                    return n === void 0 && (n = new o),
                    this.getPoint(Math.random(), n)
                },
                getSpacedPoints: function(n, s, l) {
                    l === void 0 && (l = []),
                    n || (s ? n = this.getLength() / s : n = this.defaultDivisions);
                    for (var i = 0; i <= n; i++) {
                        var h = this.getUtoTmapping(i / n, null, n);
                        l.push(this.getPoint(h))
                    }
                    return l
                },
                getStartPoint: function(n) {
                    return n === void 0 && (n = new o),
                    this.getPointAt(0, n)
                },
                getTangent: function(n, s) {
                    s === void 0 && (s = new o);
                    var l = 1e-4
                      , i = n - l
                      , h = n + l;
                    return i < 0 && (i = 0),
                    h > 1 && (h = 1),
                    this.getPoint(i, this._tmpVec2A),
                    this.getPoint(h, s),
                    s.subtract(this._tmpVec2A).normalize()
                },
                getTangentAt: function(n, s) {
                    var l = this.getUtoTmapping(n);
                    return this.getTangent(l, s)
                },
                getTFromDistance: function(n, s) {
                    return n <= 0 ? 0 : this.getUtoTmapping(0, n, s)
                },
                getUtoTmapping: function(n, s, l) {
                    var i = this.getLengths(l), h = 0, u = i.length, d;
                    s ? d = Math.min(s, i[u - 1]) : d = n * i[u - 1];
                    for (var v = 0, p = u - 1, g; v <= p; )
                        if (h = Math.floor(v + (p - v) / 2),
                        g = i[h] - d,
                        g < 0)
                            v = h + 1;
                        else if (g > 0)
                            p = h - 1;
                        else {
                            p = h;
                            break
                        }
                    if (h = p,
                    i[h] === d)
                        return h / (u - 1);
                    var m = i[h]
                      , x = i[h + 1]
                      , T = x - m
                      , E = (d - m) / T;
                    return (h + E) / (u - 1)
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0,
                    this.getLengths()
                }
            });
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                ADD: t(968),
                COMPLETE: t(969),
                FILE_COMPLETE: t(970),
                FILE_KEY_COMPLETE: t(971),
                FILE_LOAD_ERROR: t(972),
                FILE_LOAD: t(973),
                FILE_PROGRESS: t(974),
                POST_PROCESS: t(975),
                PROGRESS: t(976),
                START: t(977)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4)
              , f = function(r, o, a) {
                a === void 0 && (a = new e);
                var n = r.x1
                  , s = r.y1
                  , l = r.x2
                  , i = r.y2
                  , h = o.x1
                  , u = o.y1
                  , d = o.x2
                  , v = o.y2
                  , p = (d - h) * (s - u) - (v - u) * (n - h)
                  , g = (l - n) * (s - u) - (i - s) * (n - h)
                  , m = (v - u) * (l - n) - (d - h) * (i - s);
                if (m === 0)
                    return !1;
                var x = p / m
                  , T = g / m;
                return x >= 0 && x <= 1 && T >= 0 && T <= 1 ? (a.x = n + x * (l - n),
                a.y = s + x * (i - s),
                !0) : !1
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return Math.atan2(e.y2 - e.y1, e.x2 - e.x1)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(18)
              , f = function(r, o, a) {
                return r = e(r, 0, 1),
                (a - o) * r + o
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                return e && e.hasOwnProperty(f) ? e[f] : r
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                CREATED: 0,
                INIT: 1,
                DELAY: 2,
                OFFSET_DELAY: 3,
                PENDING_RENDER: 4,
                PLAYING_FORWARD: 5,
                PLAYING_BACKWARD: 6,
                HOLD_DELAY: 7,
                REPEAT_DELAY: 8,
                COMPLETE: 9,
                PENDING_ADD: 20,
                PAUSED: 21,
                LOOP_DELAY: 22,
                ACTIVE: 23,
                COMPLETE_DELAY: 24,
                PENDING_REMOVE: 25,
                REMOVED: 26
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(315)
              , r = new e({
                initialize: function(a, n) {
                    this.parent = a,
                    this.events = n,
                    n || (this.events = a.events ? a.events : a),
                    this.list = {},
                    this.values = {},
                    this._frozen = !1,
                    !a.hasOwnProperty("sys") && this.events && this.events.once(f.DESTROY, this.destroy, this)
                },
                get: function(o) {
                    var a = this.list;
                    if (Array.isArray(o)) {
                        for (var n = [], s = 0; s < o.length; s++)
                            n.push(a[o[s]]);
                        return n
                    } else
                        return a[o]
                },
                getAll: function() {
                    var o = {};
                    for (var a in this.list)
                        this.list.hasOwnProperty(a) && (o[a] = this.list[a]);
                    return o
                },
                query: function(o) {
                    var a = {};
                    for (var n in this.list)
                        this.list.hasOwnProperty(n) && n.match(o) && (a[n] = this.list[n]);
                    return a
                },
                set: function(o, a) {
                    if (this._frozen)
                        return this;
                    if (typeof o == "string")
                        return this.setValue(o, a);
                    for (var n in o)
                        this.setValue(n, o[n]);
                    return this
                },
                inc: function(o, a) {
                    if (this._frozen)
                        return this;
                    a === void 0 && (a = 1);
                    var n = this.get(o);
                    return n === void 0 && (n = 0),
                    this.set(o, n + a),
                    this
                },
                toggle: function(o) {
                    return this._frozen ? this : (this.set(o, !this.get(o)),
                    this)
                },
                setValue: function(o, a) {
                    if (this._frozen)
                        return this;
                    if (this.has(o))
                        this.values[o] = a;
                    else {
                        var n = this
                          , s = this.list
                          , l = this.events
                          , i = this.parent;
                        Object.defineProperty(this.values, o, {
                            enumerable: !0,
                            configurable: !0,
                            get: function() {
                                return s[o]
                            },
                            set: function(h) {
                                if (!n._frozen) {
                                    var u = s[o];
                                    s[o] = h,
                                    l.emit(f.CHANGE_DATA, i, o, h, u),
                                    l.emit(f.CHANGE_DATA_KEY + o, i, h, u)
                                }
                            }
                        }),
                        s[o] = a,
                        l.emit(f.SET_DATA, i, o, a)
                    }
                    return this
                },
                each: function(o, a) {
                    for (var n = [this.parent, null, void 0], s = 1; s < arguments.length; s++)
                        n.push(arguments[s]);
                    for (var l in this.list)
                        n[1] = l,
                        n[2] = this.list[l],
                        o.apply(a, n);
                    return this
                },
                merge: function(o, a) {
                    a === void 0 && (a = !0);
                    for (var n in o)
                        o.hasOwnProperty(n) && (a || !a && !this.has(n)) && this.setValue(n, o[n]);
                    return this
                },
                remove: function(o) {
                    if (this._frozen)
                        return this;
                    if (Array.isArray(o))
                        for (var a = 0; a < o.length; a++)
                            this.removeValue(o[a]);
                    else
                        return this.removeValue(o);
                    return this
                },
                removeValue: function(o) {
                    if (this.has(o)) {
                        var a = this.list[o];
                        delete this.list[o],
                        delete this.values[o],
                        this.events.emit(f.REMOVE_DATA, this.parent, o, a)
                    }
                    return this
                },
                pop: function(o) {
                    var a = void 0;
                    return !this._frozen && this.has(o) && (a = this.list[o],
                    delete this.list[o],
                    delete this.values[o],
                    this.events.emit(f.REMOVE_DATA, this.parent, o, a)),
                    a
                },
                has: function(o) {
                    return this.list.hasOwnProperty(o)
                },
                setFreeze: function(o) {
                    return this._frozen = o,
                    this
                },
                reset: function() {
                    for (var o in this.list)
                        delete this.list[o],
                        delete this.values[o];
                    return this._frozen = !1,
                    this
                },
                destroy: function() {
                    this.reset(),
                    this.events.off(f.CHANGE_DATA),
                    this.events.off(f.SET_DATA),
                    this.events.off(f.REMOVE_DATA),
                    this.parent = null
                },
                freeze: {
                    get: function() {
                        return this._frozen
                    },
                    set: function(o) {
                        this._frozen = !!o
                    }
                },
                count: {
                    get: function() {
                        var o = 0;
                        for (var a in this.list)
                            this.list[a] !== void 0 && o++;
                        return o
                    }
                }
            });
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = new e({
                initialize: function(o) {
                    if (this.entries = {},
                    this.size = 0,
                    Array.isArray(o))
                        for (var a = 0; a < o.length; a++)
                            this.set(o[a][0], o[a][1])
                },
                set: function(r, o) {
                    return this.has(r) || this.size++,
                    this.entries[r] = o,
                    this
                },
                get: function(r) {
                    if (this.has(r))
                        return this.entries[r]
                },
                getArray: function() {
                    var r = []
                      , o = this.entries;
                    for (var a in o)
                        r.push(o[a]);
                    return r
                },
                has: function(r) {
                    return this.entries.hasOwnProperty(r)
                },
                delete: function(r) {
                    return this.has(r) && (delete this.entries[r],
                    this.size--),
                    this
                },
                clear: function() {
                    return Object.keys(this.entries).forEach(function(r) {
                        delete this.entries[r]
                    }, this),
                    this.size = 0,
                    this
                },
                keys: function() {
                    return Object.keys(this.entries)
                },
                values: function() {
                    var r = []
                      , o = this.entries;
                    for (var a in o)
                        r.push(o[a]);
                    return r
                },
                dump: function() {
                    var r = this.entries;
                    console.group("Map");
                    for (var o in r)
                        console.log(o, r[o]);
                    console.groupEnd()
                },
                each: function(r) {
                    var o = this.entries;
                    for (var a in o)
                        if (r(a, o[a]) === !1)
                            break;
                    return this
                },
                contains: function(r) {
                    var o = this.entries;
                    for (var a in o)
                        if (o[a] === r)
                            return !0;
                    return !1
                },
                merge: function(r, o) {
                    o === void 0 && (o = !1);
                    var a = this.entries
                      , n = r.entries;
                    for (var s in n)
                        a.hasOwnProperty(s) && o ? a[s] = n[s] : this.set(s, n[s]);
                    return this
                }
            });
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                return e << 16 | f << 8 | r
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                ENTER_FULLSCREEN: t(800),
                FULLSCREEN_FAILED: t(801),
                FULLSCREEN_UNSUPPORTED: t(802),
                LEAVE_FULLSCREEN: t(803),
                ORIENTATION_CHANGE: t(804),
                RESIZE: t(805)
            }
        }
        , function(c, S, t) {
            (function(e) {
                /**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2020 Photon Storm Ltd.
* @license      {@link https://opensource.org/licenses/MIT|MIT License}
*/
                var f = {
                    android: !1,
                    chromeOS: !1,
                    cordova: !1,
                    crosswalk: !1,
                    desktop: !1,
                    ejecta: !1,
                    electron: !1,
                    iOS: !1,
                    iOSVersion: 0,
                    iPad: !1,
                    iPhone: !1,
                    kindle: !1,
                    linux: !1,
                    macOS: !1,
                    node: !1,
                    nodeWebkit: !1,
                    pixelRatio: 1,
                    webApp: !1,
                    windows: !1,
                    windowsPhone: !1
                };
                function r() {
                    if (typeof importScripts == "function")
                        return f;
                    var o = navigator.userAgent;
                    /Windows/.test(o) ? f.windows = !0 : /Mac OS/.test(o) && !/like Mac OS/.test(o) ? navigator.maxTouchPoints && navigator.maxTouchPoints > 2 ? (f.iOS = !0,
                    f.iPad = !0,
                    navigator.appVersion.match(/Version\/(\d+)/),
                    f.iOSVersion = parseInt(RegExp.$1, 10)) : f.macOS = !0 : /Android/.test(o) ? f.android = !0 : /Linux/.test(o) ? f.linux = !0 : /iP[ao]d|iPhone/i.test(o) ? (f.iOS = !0,
                    navigator.appVersion.match(/OS (\d+)/),
                    f.iOSVersion = parseInt(RegExp.$1, 10),
                    f.iPhone = o.toLowerCase().indexOf("iphone") !== -1,
                    f.iPad = o.toLowerCase().indexOf("ipad") !== -1) : /Kindle/.test(o) || /\bKF[A-Z][A-Z]+/.test(o) || /Silk.*Mobile Safari/.test(o) ? f.kindle = !0 : /CrOS/.test(o) && (f.chromeOS = !0),
                    (/Windows Phone/i.test(o) || /IEMobile/i.test(o)) && (f.android = !1,
                    f.iOS = !1,
                    f.macOS = !1,
                    f.windows = !0,
                    f.windowsPhone = !0);
                    var a = /Silk/.test(o);
                    return (f.windows || f.macOS || f.linux && !a || f.chromeOS) && (f.desktop = !0),
                    (f.windowsPhone || /Windows NT/i.test(o) && /Touch/i.test(o)) && (f.desktop = !1),
                    navigator.standalone && (f.webApp = !0),
                    typeof importScripts != "function" && (window.cordova !== void 0 && (f.cordova = !0),
                    window.ejecta !== void 0 && (f.ejecta = !0)),
                    typeof e < "u" && e.versions && e.versions.node && (f.node = !0),
                    f.node && typeof e.versions == "object" && (f.nodeWebkit = !!e.versions["node-webkit"],
                    f.electron = !!e.versions.electron),
                    /Crosswalk/.test(o) && (f.crosswalk = !0),
                    f.pixelRatio = window.devicePixelRatio || 1,
                    f
                }
                c.exports = r()
            }
            ).call(this, t(807))
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                ADD: t(861),
                ERROR: t(862),
                LOAD: t(863),
                READY: t(864),
                REMOVE: t(865)
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                BYTE: {
                    enum: 5120,
                    size: 1
                },
                UNSIGNED_BYTE: {
                    enum: 5121,
                    size: 1
                },
                SHORT: {
                    enum: 5122,
                    size: 2
                },
                UNSIGNED_SHORT: {
                    enum: 5123,
                    size: 2
                },
                INT: {
                    enum: 5124,
                    size: 4
                },
                UNSIGNED_INT: {
                    enum: 5125,
                    size: 4
                },
                FLOAT: {
                    enum: 5126,
                    size: 4
                }
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(59)
              , r = t(2)
              , o = t(878)
              , a = t(879)
              , n = t(25)
              , s = t(12)
              , l = t(107)
              , i = t(58)
              , h = new e({
                Extends: i,
                initialize: function(d) {
                    var v = d.game.renderer
                      , p = r(d, "fragShader", o);
                    d.fragShader = s.parseFragmentShaderMaxTextures(p, v.maxTextures),
                    d.vertShader = r(d, "vertShader", a),
                    d.attributes = r(d, "attributes", [{
                        name: "inPosition",
                        size: 2
                    }, {
                        name: "inTexCoord",
                        size: 2
                    }, {
                        name: "inTexId"
                    }, {
                        name: "inTintEffect"
                    }, {
                        name: "inTint",
                        size: 4,
                        type: l.UNSIGNED_BYTE,
                        normalized: !0
                    }]),
                    i.call(this, d),
                    this._tempMatrix1 = new n,
                    this._tempMatrix2 = new n,
                    this._tempMatrix3 = new n,
                    this.calcMatrix = new n,
                    this.tempTriangle = [{
                        x: 0,
                        y: 0,
                        width: 0
                    }, {
                        x: 0,
                        y: 0,
                        width: 0
                    }, {
                        x: 0,
                        y: 0,
                        width: 0
                    }, {
                        x: 0,
                        y: 0,
                        width: 0
                    }],
                    this.strokeTint = {
                        TL: 0,
                        TR: 0,
                        BL: 0,
                        BR: 0
                    },
                    this.fillTint = {
                        TL: 0,
                        TR: 0,
                        BL: 0,
                        BR: 0
                    },
                    this.currentFrame = {
                        u0: 0,
                        v0: 0,
                        u1: 1,
                        v1: 1
                    },
                    this.firstQuad = [0, 0, 0, 0, 0],
                    this.prevQuad = [0, 0, 0, 0, 0],
                    this.polygonCache = []
                },
                boot: function() {
                    i.prototype.boot.call(this),
                    this.currentShader.set1iv("uMainSampler", this.renderer.textureIndexes)
                },
                batchSprite: function(u, d, v) {
                    this.manager.set(this, u);
                    var p = this._tempMatrix1
                      , g = this._tempMatrix2
                      , m = this._tempMatrix3
                      , x = u.frame
                      , T = x.glTexture
                      , E = x.u0
                      , P = x.v0
                      , M = x.u1
                      , L = x.v1
                      , R = x.x
                      , O = x.y
                      , F = x.cutWidth
                      , B = x.cutHeight
                      , N = x.customPivot
                      , Y = u.displayOriginX
                      , z = u.displayOriginY
                      , W = -Y + R
                      , b = -z + O;
                    if (u.isCropped) {
                        var D = u._crop;
                        (D.flipX !== u.flipX || D.flipY !== u.flipY) && x.updateCropUVs(D, u.flipX, u.flipY),
                        E = D.u0,
                        P = D.v0,
                        M = D.u1,
                        L = D.v1,
                        F = D.width,
                        B = D.height,
                        R = D.x,
                        O = D.y,
                        W = -Y + R,
                        b = -z + O
                    }
                    var I = 1
                      , G = 1;
                    u.flipX && (N || (W += -x.realWidth + Y * 2),
                    I = -1),
                    (u.flipY || x.source.isGLTexture && !T.flipY) && (N || (b += -x.realHeight + z * 2),
                    G = -1),
                    g.applyITRS(u.x, u.y, u.rotation, u.scaleX * I, u.scaleY * G),
                    p.copyFrom(d.matrix),
                    v ? (p.multiplyWithOffset(v, -d.scrollX * u.scrollFactorX, -d.scrollY * u.scrollFactorY),
                    g.e = u.x,
                    g.f = u.y) : (g.e -= d.scrollX * u.scrollFactorX,
                    g.f -= d.scrollY * u.scrollFactorY),
                    p.multiply(g, m);
                    var w = W + F
                      , U = b + B
                      , X = d.roundPixels
                      , V = m.getXRound(W, b, X)
                      , H = m.getYRound(W, b, X)
                      , J = m.getXRound(W, U, X)
                      , $ = m.getYRound(W, U, X)
                      , _ = m.getXRound(w, U, X)
                      , nt = m.getYRound(w, U, X)
                      , K = m.getXRound(w, b, X)
                      , Z = m.getYRound(w, b, X)
                      , j = s.getTintAppendFloatAlpha
                      , Q = d.alpha
                      , tt = j(u.tintTopLeft, Q * u._alphaTL)
                      , et = j(u.tintTopRight, Q * u._alphaTR)
                      , it = j(u.tintBottomLeft, Q * u._alphaBL)
                      , k = j(u.tintBottomRight, Q * u._alphaBR);
                    this.shouldFlush(6) && this.flush();
                    var st = this.setGameObject(u, x);
                    this.manager.preBatch(u),
                    this.batchQuad(u, V, H, J, $, _, nt, K, Z, E, P, M, L, tt, et, it, k, u.tintFill, T, st),
                    this.manager.postBatch(u)
                },
                batchTexture: function(u, d, v, p, g, m, x, T, E, P, M, L, R, O, F, B, N, Y, z, W, b, D, I, G, w, U, X, V, H, J, $, _) {
                    this.manager.set(this, u);
                    var nt = this._tempMatrix1
                      , K = this._tempMatrix2
                      , Z = this._tempMatrix3
                      , j = Y / v + X
                      , Q = z / p + V
                      , tt = (Y + W) / v + X
                      , et = (z + b) / p + V
                      , it = x
                      , k = T
                      , st = -B
                      , q = -N;
                    if (u.isCropped) {
                        var rt = u._crop
                          , ot = rt.width
                          , lt = rt.height;
                        it = ot,
                        k = lt,
                        x = ot,
                        T = lt,
                        Y = rt.x,
                        z = rt.y;
                        var at = Y
                          , ht = z;
                        L && (at = W - rt.x - ot),
                        R && (ht = b - rt.y - lt),
                        j = at / v + X,
                        Q = ht / p + V,
                        tt = (at + ot) / v + X,
                        et = (ht + lt) / p + V,
                        st = -B + Y,
                        q = -N + z
                    }
                    R = R ^ (!$ && d.isRenderTexture ? 1 : 0),
                    L && (it *= -1,
                    st += x),
                    R && (k *= -1,
                    q += T);
                    var dt = st + it
                      , ut = q + k;
                    K.applyITRS(g, m, M, E, P),
                    nt.copyFrom(H.matrix),
                    J ? (nt.multiplyWithOffset(J, -H.scrollX * O, -H.scrollY * F),
                    K.e = g,
                    K.f = m) : (K.e -= H.scrollX * O,
                    K.f -= H.scrollY * F),
                    nt.multiply(K, Z);
                    var ft = H.roundPixels
                      , mt = Z.getXRound(st, q, ft)
                      , Gt = Z.getYRound(st, q, ft)
                      , jt = Z.getXRound(st, ut, ft)
                      , Yt = Z.getYRound(st, ut, ft)
                      , $t = Z.getXRound(dt, ut, ft)
                      , Ct = Z.getYRound(dt, ut, ft)
                      , Rt = Z.getXRound(dt, q, ft)
                      , Gi = Z.getYRound(dt, q, ft);
                    _ === void 0 && (_ = this.renderer.setTexture2D(d)),
                    u && this.manager.preBatch(u),
                    this.batchQuad(u, mt, Gt, jt, Yt, $t, Ct, Rt, Gi, j, Q, tt, et, D, I, G, w, U, d, _),
                    u && this.manager.postBatch(u)
                },
                batchTextureFrame: function(u, d, v, p, g, m, x) {
                    this.manager.set(this);
                    var T = this._tempMatrix1.copyFrom(m)
                      , E = this._tempMatrix2
                      , P = d + u.width
                      , M = v + u.height;
                    x ? T.multiply(x, E) : E = T;
                    var L = E.getX(d, v)
                      , R = E.getY(d, v)
                      , O = E.getX(d, M)
                      , F = E.getY(d, M)
                      , B = E.getX(P, M)
                      , N = E.getY(P, M)
                      , Y = E.getX(P, v)
                      , z = E.getY(P, v)
                      , W = this.renderer.setTextureSource(u.source);
                    p = s.getTintAppendFloatAlpha(p, g),
                    this.batchQuad(null, L, R, O, F, B, N, Y, z, u.u0, u.v0, u.u1, u.v1, p, p, p, p, 0, u.glTexture, W)
                },
                batchFillRect: function(u, d, v, p, g, m) {
                    this.renderer.pipelines.set(this);
                    var x = this.calcMatrix;
                    m && m.multiply(g, x);
                    var T = u + v
                      , E = d + p
                      , P = x.getX(u, d)
                      , M = x.getY(u, d)
                      , L = x.getX(u, E)
                      , R = x.getY(u, E)
                      , O = x.getX(T, E)
                      , F = x.getY(T, E)
                      , B = x.getX(T, d)
                      , N = x.getY(T, d)
                      , Y = this.fillTint;
                    this.batchQuad(null, P, M, L, R, O, F, B, N, 0, 0, 1, 1, Y.TL, Y.TR, Y.BL, Y.BR, 2)
                },
                batchFillTriangle: function(u, d, v, p, g, m, x, T) {
                    this.renderer.pipelines.set(this);
                    var E = this.calcMatrix;
                    T && T.multiply(x, E);
                    var P = E.getX(u, d)
                      , M = E.getY(u, d)
                      , L = E.getX(v, p)
                      , R = E.getY(v, p)
                      , O = E.getX(g, m)
                      , F = E.getY(g, m)
                      , B = this.fillTint;
                    this.batchTri(null, P, M, L, R, O, F, 0, 0, 1, 1, B.TL, B.TR, B.BL, 2)
                },
                batchStrokeTriangle: function(u, d, v, p, g, m, x, T, E) {
                    var P = this.tempTriangle;
                    P[0].x = u,
                    P[0].y = d,
                    P[0].width = x,
                    P[1].x = v,
                    P[1].y = p,
                    P[1].width = x,
                    P[2].x = g,
                    P[2].y = m,
                    P[2].width = x,
                    P[3].x = u,
                    P[3].y = d,
                    P[3].width = x,
                    this.batchStrokePath(P, x, !1, T, E)
                },
                batchFillPath: function(u, d, v) {
                    this.renderer.pipelines.set(this);
                    var p = this.calcMatrix;
                    v && v.multiply(d, p);
                    for (var g = u.length, m = this.polygonCache, x, T, E = this.fillTint.TL, P = this.fillTint.TR, M = this.fillTint.BL, L = 0; L < g; ++L)
                        T = u[L],
                        m.push(T.x, T.y);
                    x = f(m),
                    g = x.length;
                    for (var R = 0; R < g; R += 3) {
                        var O = x[R + 0] * 2
                          , F = x[R + 1] * 2
                          , B = x[R + 2] * 2
                          , N = m[O + 0]
                          , Y = m[O + 1]
                          , z = m[F + 0]
                          , W = m[F + 1]
                          , b = m[B + 0]
                          , D = m[B + 1]
                          , I = p.getX(N, Y)
                          , G = p.getY(N, Y)
                          , w = p.getX(z, W)
                          , U = p.getY(z, W)
                          , X = p.getX(b, D)
                          , V = p.getY(b, D);
                        this.batchTri(null, I, G, w, U, X, V, 0, 0, 1, 1, E, P, M, 2)
                    }
                    m.length = 0
                },
                batchStrokePath: function(u, d, v, p, g) {
                    this.renderer.pipelines.set(this),
                    this.prevQuad[4] = 0,
                    this.firstQuad[4] = 0;
                    for (var m = u.length - 1, x = 0; x < m; x++) {
                        var T = u[x]
                          , E = u[x + 1];
                        this.batchLine(T.x, T.y, E.x, E.y, T.width / 2, E.width / 2, d, x, !v && x === m - 1, p, g)
                    }
                },
                batchLine: function(u, d, v, p, g, m, x, T, E, P, M) {
                    this.renderer.pipelines.set(this);
                    var L = this.calcMatrix;
                    M && M.multiply(P, L);
                    var R = v - u
                      , O = p - d
                      , F = Math.sqrt(R * R + O * O)
                      , B = g * (p - d) / F
                      , N = g * (u - v) / F
                      , Y = m * (p - d) / F
                      , z = m * (u - v) / F
                      , W = v - Y
                      , b = p - z
                      , D = u - B
                      , I = d - N
                      , G = v + Y
                      , w = p + z
                      , U = u + B
                      , X = d + N
                      , V = L.getX(W, b)
                      , H = L.getY(W, b)
                      , J = L.getX(D, I)
                      , $ = L.getY(D, I)
                      , _ = L.getX(G, w)
                      , nt = L.getY(G, w)
                      , K = L.getX(U, X)
                      , Z = L.getY(U, X)
                      , j = this.strokeTint
                      , Q = j.TL
                      , tt = j.TR
                      , et = j.BL
                      , it = j.BR;
                    if (this.batchQuad(null, K, Z, J, $, V, H, _, nt, 0, 0, 1, 1, Q, tt, et, it, 2),
                    !(x <= 2)) {
                        var k = this.prevQuad
                          , st = this.firstQuad;
                        T > 0 && k[4] ? this.batchQuad(null, K, Z, J, $, k[0], k[1], k[2], k[3], 0, 0, 1, 1, Q, tt, et, it, 2) : (st[0] = K,
                        st[1] = Z,
                        st[2] = J,
                        st[3] = $,
                        st[4] = 1),
                        E && st[4] ? this.batchQuad(null, V, H, _, nt, st[0], st[1], st[2], st[3], 0, 0, 1, 1, Q, tt, et, it, 2) : (k[0] = V,
                        k[1] = H,
                        k[2] = _,
                        k[3] = nt,
                        k[4] = 1)
                    }
                }
            });
            c.exports = h
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(18)
              , r = t(17)
              , o = new e({
                initialize: function(n, s, l, i, h, u, d) {
                    this.texture = n,
                    this.name = s,
                    this.source = n.source[l],
                    this.sourceIndex = l,
                    this.glTexture = this.source.glTexture,
                    this.cutX,
                    this.cutY,
                    this.cutWidth,
                    this.cutHeight,
                    this.x = 0,
                    this.y = 0,
                    this.width,
                    this.height,
                    this.halfWidth,
                    this.halfHeight,
                    this.centerX,
                    this.centerY,
                    this.pivotX = 0,
                    this.pivotY = 0,
                    this.customPivot = !1,
                    this.rotated = !1,
                    this.autoRound = -1,
                    this.customData = {},
                    this.u0 = 0,
                    this.v0 = 0,
                    this.u1 = 0,
                    this.v1 = 0,
                    this.data = {
                        cut: {
                            x: 0,
                            y: 0,
                            w: 0,
                            h: 0,
                            r: 0,
                            b: 0
                        },
                        trim: !1,
                        sourceSize: {
                            w: 0,
                            h: 0
                        },
                        spriteSourceSize: {
                            x: 0,
                            y: 0,
                            w: 0,
                            h: 0,
                            r: 0,
                            b: 0
                        },
                        radius: 0,
                        drawImage: {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        }
                    },
                    this.setSize(u, d, i, h)
                },
                setSize: function(a, n, s, l) {
                    s === void 0 && (s = 0),
                    l === void 0 && (l = 0),
                    this.cutX = s,
                    this.cutY = l,
                    this.cutWidth = a,
                    this.cutHeight = n,
                    this.width = a,
                    this.height = n,
                    this.halfWidth = Math.floor(a * .5),
                    this.halfHeight = Math.floor(n * .5),
                    this.centerX = Math.floor(a / 2),
                    this.centerY = Math.floor(n / 2);
                    var i = this.data
                      , h = i.cut;
                    h.x = s,
                    h.y = l,
                    h.w = a,
                    h.h = n,
                    h.r = s + a,
                    h.b = l + n,
                    i.sourceSize.w = a,
                    i.sourceSize.h = n,
                    i.spriteSourceSize.w = a,
                    i.spriteSourceSize.h = n,
                    i.radius = .5 * Math.sqrt(a * a + n * n);
                    var u = i.drawImage;
                    return u.x = s,
                    u.y = l,
                    u.width = a,
                    u.height = n,
                    this.updateUVs()
                },
                setTrim: function(a, n, s, l, i, h) {
                    var u = this.data
                      , d = u.spriteSourceSize;
                    return u.trim = !0,
                    u.sourceSize.w = a,
                    u.sourceSize.h = n,
                    d.x = s,
                    d.y = l,
                    d.w = i,
                    d.h = h,
                    d.r = s + i,
                    d.b = l + h,
                    this.x = s,
                    this.y = l,
                    this.width = i,
                    this.height = h,
                    this.halfWidth = i * .5,
                    this.halfHeight = h * .5,
                    this.centerX = Math.floor(i / 2),
                    this.centerY = Math.floor(h / 2),
                    this.updateUVs()
                },
                setCropUVs: function(a, n, s, l, i, h, u) {
                    var d = this.cutX
                      , v = this.cutY
                      , p = this.cutWidth
                      , g = this.cutHeight
                      , m = this.realWidth
                      , x = this.realHeight;
                    n = f(n, 0, m),
                    s = f(s, 0, x),
                    l = f(l, 0, m - n),
                    i = f(i, 0, x - s);
                    var T = d + n
                      , E = v + s
                      , P = l
                      , M = i
                      , L = this.data;
                    if (L.trim) {
                        var R = L.spriteSourceSize;
                        l = f(l, 0, p - n),
                        i = f(i, 0, g - s);
                        var O = n + l
                          , F = s + i
                          , B = !(R.r < n || R.b < s || R.x > O || R.y > F);
                        if (B) {
                            var N = Math.max(R.x, n)
                              , Y = Math.max(R.y, s)
                              , z = Math.min(R.r, O) - N
                              , W = Math.min(R.b, F) - Y;
                            P = z,
                            M = W,
                            h ? T = d + (p - (N - R.x) - z) : T = d + (N - R.x),
                            u ? E = v + (g - (Y - R.y) - W) : E = v + (Y - R.y),
                            n = N,
                            s = Y,
                            l = z,
                            i = W
                        } else
                            T = 0,
                            E = 0,
                            P = 0,
                            M = 0
                    } else
                        h && (T = d + (p - n - l)),
                        u && (E = v + (g - s - i));
                    var b = this.source.width
                      , D = this.source.height;
                    return a.u0 = Math.max(0, T / b),
                    a.v0 = Math.max(0, E / D),
                    a.u1 = Math.min(1, (T + P) / b),
                    a.v1 = Math.min(1, (E + M) / D),
                    a.x = n,
                    a.y = s,
                    a.cx = T,
                    a.cy = E,
                    a.cw = P,
                    a.ch = M,
                    a.width = l,
                    a.height = i,
                    a.flipX = h,
                    a.flipY = u,
                    a
                },
                updateCropUVs: function(a, n, s) {
                    return this.setCropUVs(a, a.x, a.y, a.width, a.height, n, s)
                },
                setUVs: function(a, n, s, l, i, h) {
                    var u = this.data.drawImage;
                    return u.width = a,
                    u.height = n,
                    this.u0 = s,
                    this.v0 = l,
                    this.u1 = i,
                    this.v1 = h,
                    this
                },
                updateUVs: function() {
                    var a = this.cutX
                      , n = this.cutY
                      , s = this.cutWidth
                      , l = this.cutHeight
                      , i = this.data.drawImage;
                    i.width = s,
                    i.height = l;
                    var h = this.source.width
                      , u = this.source.height;
                    return this.u0 = a / h,
                    this.v0 = n / u,
                    this.u1 = (a + s) / h,
                    this.v1 = (n + l) / u,
                    this
                },
                updateUVsInverted: function() {
                    var a = this.source.width
                      , n = this.source.height;
                    return this.u0 = (this.cutX + this.cutHeight) / a,
                    this.v0 = this.cutY / n,
                    this.u1 = this.cutX / a,
                    this.v1 = (this.cutY + this.cutWidth) / n,
                    this
                },
                clone: function() {
                    var a = new o(this.texture,this.name,this.sourceIndex);
                    return a.cutX = this.cutX,
                    a.cutY = this.cutY,
                    a.cutWidth = this.cutWidth,
                    a.cutHeight = this.cutHeight,
                    a.x = this.x,
                    a.y = this.y,
                    a.width = this.width,
                    a.height = this.height,
                    a.halfWidth = this.halfWidth,
                    a.halfHeight = this.halfHeight,
                    a.centerX = this.centerX,
                    a.centerY = this.centerY,
                    a.rotated = this.rotated,
                    a.data = r(!0, a.data, this.data),
                    a.updateUVs(),
                    a
                },
                destroy: function() {
                    this.source = null,
                    this.texture = null,
                    this.glTexture = null,
                    this.customData = null,
                    this.data = null
                },
                realWidth: {
                    get: function() {
                        return this.data.sourceSize.w
                    }
                },
                realHeight: {
                    get: function() {
                        return this.data.sourceSize.h
                    }
                },
                radius: {
                    get: function() {
                        return this.data.radius
                    }
                },
                trimmed: {
                    get: function() {
                        return this.data.trim
                    }
                },
                canvasData: {
                    get: function() {
                        return this.data.drawImage
                    }
                }
            });
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(208)
              , f = t(0)
              , r = t(1)
              , o = t(79)
              , a = new f({
                initialize: function(s) {
                    this.parent = s,
                    this.list = [],
                    this.position = 0,
                    this.addCallback = r,
                    this.removeCallback = r,
                    this._sortKey = ""
                },
                add: function(n, s) {
                    return s ? e.Add(this.list, n) : e.Add(this.list, n, 0, this.addCallback, this)
                },
                addAt: function(n, s, l) {
                    return l ? e.AddAt(this.list, n, s) : e.AddAt(this.list, n, s, 0, this.addCallback, this)
                },
                getAt: function(n) {
                    return this.list[n]
                },
                getIndex: function(n) {
                    return this.list.indexOf(n)
                },
                sort: function(n, s) {
                    return n ? (s === void 0 && (s = function(l, i) {
                        return l[n] - i[n]
                    }
                    ),
                    o(this.list, s),
                    this) : this
                },
                getByName: function(n) {
                    return e.GetFirst(this.list, "name", n)
                },
                getRandom: function(n, s) {
                    return e.GetRandom(this.list, n, s)
                },
                getFirst: function(n, s, l, i) {
                    return e.GetFirst(this.list, n, s, l, i)
                },
                getAll: function(n, s, l, i) {
                    return e.GetAll(this.list, n, s, l, i)
                },
                count: function(n, s) {
                    return e.CountAllMatching(this.list, n, s)
                },
                swap: function(n, s) {
                    e.Swap(this.list, n, s)
                },
                moveTo: function(n, s) {
                    return e.MoveTo(this.list, n, s)
                },
                moveAbove: function(n, s) {
                    return e.MoveAbove(this.list, n, s)
                },
                moveBelow: function(n, s) {
                    return e.MoveBelow(this.list, n, s)
                },
                remove: function(n, s) {
                    return s ? e.Remove(this.list, n) : e.Remove(this.list, n, this.removeCallback, this)
                },
                removeAt: function(n, s) {
                    return s ? e.RemoveAt(this.list, n) : e.RemoveAt(this.list, n, this.removeCallback, this)
                },
                removeBetween: function(n, s, l) {
                    return l ? e.RemoveBetween(this.list, n, s) : e.RemoveBetween(this.list, n, s, this.removeCallback, this)
                },
                removeAll: function(n) {
                    for (var s = this.list.length; s--; )
                        this.remove(this.list[s], n);
                    return this
                },
                bringToTop: function(n) {
                    return e.BringToTop(this.list, n)
                },
                sendToBack: function(n) {
                    return e.SendToBack(this.list, n)
                },
                moveUp: function(n) {
                    return e.MoveUp(this.list, n),
                    n
                },
                moveDown: function(n) {
                    return e.MoveDown(this.list, n),
                    n
                },
                reverse: function() {
                    return this.list.reverse(),
                    this
                },
                shuffle: function() {
                    return e.Shuffle(this.list),
                    this
                },
                replace: function(n, s) {
                    return e.Replace(this.list, n, s)
                },
                exists: function(n) {
                    return this.list.indexOf(n) > -1
                },
                setAll: function(n, s, l, i) {
                    return e.SetAll(this.list, n, s, l, i),
                    this
                },
                each: function(n, s) {
                    for (var l = [null], i = 2; i < arguments.length; i++)
                        l.push(arguments[i]);
                    for (i = 0; i < this.list.length; i++)
                        l[0] = this.list[i],
                        n.apply(s, l)
                },
                shutdown: function() {
                    this.removeAll(),
                    this.list = []
                },
                destroy: function() {
                    this.removeAll(),
                    this.parent = null,
                    this.addCallback = null,
                    this.removeCallback = null
                },
                length: {
                    get: function() {
                        return this.list.length
                    }
                },
                first: {
                    get: function() {
                        return this.position = 0,
                        this.list.length > 0 ? this.list[0] : null
                    }
                },
                last: {
                    get: function() {
                        return this.list.length > 0 ? (this.position = this.list.length - 1,
                        this.list[this.position]) : null
                    }
                },
                next: {
                    get: function() {
                        return this.position < this.list.length ? (this.position++,
                        this.list[this.position]) : null
                    }
                },
                previous: {
                    get: function() {
                        return this.position > 0 ? (this.position--,
                        this.list[this.position]) : null
                    }
                }
            });
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(112)
              , r = t(445)
              , o = t(446)
              , a = t(56)
              , n = t(180)
              , s = new e({
                initialize: function(i, h, u, d) {
                    i === void 0 && (i = 0),
                    h === void 0 && (h = 0),
                    u === void 0 && (u = 0),
                    d === void 0 && (d = 0),
                    this.type = a.ELLIPSE,
                    this.x = i,
                    this.y = h,
                    this.width = u,
                    this.height = d
                },
                contains: function(l, i) {
                    return f(this, l, i)
                },
                getPoint: function(l, i) {
                    return r(this, l, i)
                },
                getPoints: function(l, i, h) {
                    return o(this, l, i, h)
                },
                getRandomPoint: function(l) {
                    return n(this, l)
                },
                setTo: function(l, i, h, u) {
                    return this.x = l,
                    this.y = i,
                    this.width = h,
                    this.height = u,
                    this
                },
                setEmpty: function() {
                    return this.width = 0,
                    this.height = 0,
                    this
                },
                setPosition: function(l, i) {
                    return i === void 0 && (i = l),
                    this.x = l,
                    this.y = i,
                    this
                },
                setSize: function(l, i) {
                    return i === void 0 && (i = l),
                    this.width = l,
                    this.height = i,
                    this
                },
                isEmpty: function() {
                    return this.width <= 0 || this.height <= 0
                },
                getMinorRadius: function() {
                    return Math.min(this.width, this.height) / 2
                },
                getMajorRadius: function() {
                    return Math.max(this.width, this.height) / 2
                },
                left: {
                    get: function() {
                        return this.x - this.width / 2
                    },
                    set: function(l) {
                        this.x = l + this.width / 2
                    }
                },
                right: {
                    get: function() {
                        return this.x + this.width / 2
                    },
                    set: function(l) {
                        this.x = l - this.width / 2
                    }
                },
                top: {
                    get: function() {
                        return this.y - this.height / 2
                    },
                    set: function(l) {
                        this.y = l + this.height / 2
                    }
                },
                bottom: {
                    get: function() {
                        return this.y + this.height / 2
                    },
                    set: function(l) {
                        this.y = l - this.height / 2
                    }
                }
            });
            c.exports = s
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                if (e.width <= 0 || e.height <= 0)
                    return !1;
                var o = (f - e.x) / e.width
                  , a = (r - e.y) / e.height;
                return o *= o,
                a *= a,
                o + a < .25
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(275)
              , f = t(0)
              , r = t(75)
              , o = t(9)
              , a = t(207)
              , n = t(2)
              , s = t(6)
              , l = t(7)
              , i = t(437)
              , h = t(149)
              , u = t(73)
              , d = new f({
                Extends: o,
                initialize: function(p, g, m) {
                    o.call(this),
                    m ? g && !Array.isArray(g) && (g = [g]) : Array.isArray(g) ? l(g[0]) && (m = g,
                    g = null) : l(g) && (m = g,
                    g = null),
                    this.scene = p,
                    this.children = new h,
                    this.isParent = !0,
                    this.type = "Group",
                    this.classType = n(m, "classType", u),
                    this.name = n(m, "name", ""),
                    this.active = n(m, "active", !0),
                    this.maxSize = n(m, "maxSize", -1),
                    this.defaultKey = n(m, "defaultKey", null),
                    this.defaultFrame = n(m, "defaultFrame", null),
                    this.runChildUpdate = n(m, "runChildUpdate", !1),
                    this.createCallback = n(m, "createCallback", null),
                    this.removeCallback = n(m, "removeCallback", null),
                    this.createMultipleCallback = n(m, "createMultipleCallback", null),
                    this.internalCreateCallback = n(m, "internalCreateCallback", null),
                    this.internalRemoveCallback = n(m, "internalRemoveCallback", null),
                    g && this.addMultiple(g),
                    m && this.createMultiple(m),
                    this.on(r.ADDED_TO_SCENE, this.addedToScene, this),
                    this.on(r.REMOVED_FROM_SCENE, this.removedFromScene, this)
                },
                addedToScene: function() {
                    this.scene.sys.updateList.add(this)
                },
                removedFromScene: function() {
                    this.scene.sys.updateList.remove(this)
                },
                create: function(v, p, g, m, x, T) {
                    if (v === void 0 && (v = 0),
                    p === void 0 && (p = 0),
                    g === void 0 && (g = this.defaultKey),
                    m === void 0 && (m = this.defaultFrame),
                    x === void 0 && (x = !0),
                    T === void 0 && (T = !0),
                    this.isFull())
                        return null;
                    var E = new this.classType(this.scene,v,p,g,m);
                    return E.addToDisplayList(this.scene.sys.displayList),
                    E.addToUpdateList(),
                    E.visible = x,
                    E.setActive(T),
                    this.add(E),
                    E
                },
                createMultiple: function(v) {
                    if (this.isFull())
                        return [];
                    Array.isArray(v) || (v = [v]);
                    var p = [];
                    if (v[0].key)
                        for (var g = 0; g < v.length; g++) {
                            var m = this.createFromConfig(v[g]);
                            p = p.concat(m)
                        }
                    return p
                },
                createFromConfig: function(v) {
                    if (this.isFull())
                        return [];
                    this.classType = n(v, "classType", this.classType);
                    var p = n(v, "key", void 0)
                      , g = n(v, "frame", null)
                      , m = n(v, "visible", !0)
                      , x = n(v, "active", !0)
                      , T = [];
                    if (p === void 0)
                        return T;
                    Array.isArray(p) || (p = [p]),
                    Array.isArray(g) || (g = [g]);
                    var E = n(v, "repeat", 0)
                      , P = n(v, "randomKey", !1)
                      , M = n(v, "randomFrame", !1)
                      , L = n(v, "yoyo", !1)
                      , R = n(v, "quantity", !1)
                      , O = n(v, "frameQuantity", 1)
                      , F = n(v, "max", 0)
                      , B = i(p, g, {
                        max: F,
                        qty: R || O,
                        random: P,
                        randomB: M,
                        repeat: E,
                        yoyo: L
                    });
                    v.createCallback && (this.createCallback = v.createCallback),
                    v.removeCallback && (this.removeCallback = v.removeCallback);
                    for (var N = 0; N < B.length; N++) {
                        var Y = this.create(0, 0, B[N].a, B[N].b, m, x);
                        if (!Y)
                            break;
                        T.push(Y)
                    }
                    var z = s(v, "setXY.x", 0)
                      , W = s(v, "setXY.y", 0)
                      , b = s(v, "setXY.stepX", 0)
                      , D = s(v, "setXY.stepY", 0);
                    e.SetXY(T, z, W, b, D);
                    var I = s(v, "setRotation.value", 0)
                      , G = s(v, "setRotation.step", 0);
                    e.SetRotation(T, I, G);
                    var w = s(v, "setScale.x", 1)
                      , U = s(v, "setScale.y", w)
                      , X = s(v, "setScale.stepX", 0)
                      , V = s(v, "setScale.stepY", 0);
                    e.SetScale(T, w, U, X, V);
                    var H = s(v, "setOrigin.x", .5)
                      , J = s(v, "setOrigin.y", H)
                      , $ = s(v, "setOrigin.stepX", 0)
                      , _ = s(v, "setOrigin.stepY", 0);
                    e.SetOrigin(T, H, J, $, _);
                    var nt = s(v, "setAlpha.value", 1)
                      , K = s(v, "setAlpha.step", 0);
                    e.SetAlpha(T, nt, K);
                    var Z = s(v, "setDepth.value", 0)
                      , j = s(v, "setDepth.step", 0);
                    e.SetDepth(T, Z, j);
                    var Q = s(v, "setScrollFactor.x", 1)
                      , tt = s(v, "setScrollFactor.y", Q)
                      , et = s(v, "setScrollFactor.stepX", 0)
                      , it = s(v, "setScrollFactor.stepY", 0);
                    e.SetScrollFactor(T, Q, tt, et, it);
                    var k = n(v, "hitArea", null)
                      , st = n(v, "hitAreaCallback", null);
                    k && e.SetHitArea(T, k, st);
                    var q = n(v, "gridAlign", !1);
                    return q && e.GridAlign(T, q),
                    this.createMultipleCallback && this.createMultipleCallback.call(this, T),
                    T
                },
                preUpdate: function(v, p) {
                    if (!(!this.runChildUpdate || this.children.size === 0))
                        for (var g = this.children.entries.slice(), m = 0; m < g.length; m++) {
                            var x = g[m];
                            x.active && x.update(v, p)
                        }
                },
                add: function(v, p) {
                    return p === void 0 && (p = !1),
                    this.isFull() ? this : (this.children.set(v),
                    this.internalCreateCallback && this.internalCreateCallback.call(this, v),
                    this.createCallback && this.createCallback.call(this, v),
                    p && (v.addToDisplayList(this.scene.sys.displayList),
                    v.addToUpdateList()),
                    v.on(r.DESTROY, this.remove, this),
                    this)
                },
                addMultiple: function(v, p) {
                    if (p === void 0 && (p = !1),
                    Array.isArray(v))
                        for (var g = 0; g < v.length; g++)
                            this.add(v[g], p);
                    return this
                },
                remove: function(v, p, g) {
                    return p === void 0 && (p = !1),
                    g === void 0 && (g = !1),
                    this.children.contains(v) ? (this.children.delete(v),
                    this.internalRemoveCallback && this.internalRemoveCallback.call(this, v),
                    this.removeCallback && this.removeCallback.call(this, v),
                    v.off(r.DESTROY, this.remove, this),
                    g ? v.destroy() : p && (v.removeFromDisplayList(),
                    v.removeFromUpdateList()),
                    this) : this
                },
                clear: function(v, p) {
                    v === void 0 && (v = !1),
                    p === void 0 && (p = !1);
                    for (var g = this.children, m = 0; m < g.size; m++) {
                        var x = g.entries[m];
                        x.off(r.DESTROY, this.remove, this),
                        p ? x.destroy() : v && (x.removeFromDisplayList(),
                        x.removeFromUpdateList())
                    }
                    return this.children.clear(),
                    this
                },
                contains: function(v) {
                    return this.children.contains(v)
                },
                getChildren: function() {
                    return this.children.entries
                },
                getLength: function() {
                    return this.children.size
                },
                getMatching: function(v, p, g, m) {
                    return a(this.children.entries, v, p, g, m)
                },
                getFirst: function(v, p, g, m, x, T, E) {
                    return this.getHandler(!0, 1, v, p, g, m, x, T, E)
                },
                getFirstNth: function(v, p, g, m, x, T, E, P) {
                    return this.getHandler(!0, v, p, g, m, x, T, E, P)
                },
                getLast: function(v, p, g, m, x, T, E) {
                    return this.getHandler(!1, 1, v, p, g, m, x, T, E)
                },
                getLastNth: function(v, p, g, m, x, T, E, P) {
                    return this.getHandler(!1, v, p, g, m, x, T, E, P)
                },
                getHandler: function(v, p, g, m, x, T, E, P, M) {
                    g === void 0 && (g = !1),
                    m === void 0 && (m = !1);
                    var L, R, O = 0, F = this.children.entries;
                    if (v)
                        for (R = 0; R < F.length; R++)
                            if (L = F[R],
                            L.active === g) {
                                if (O++,
                                O === p)
                                    break
                            } else
                                L = null;
                    else
                        for (R = F.length - 1; R >= 0; R--)
                            if (L = F[R],
                            L.active === g) {
                                if (O++,
                                O === p)
                                    break
                            } else
                                L = null;
                    return L ? (typeof x == "number" && (L.x = x),
                    typeof T == "number" && (L.y = T),
                    L) : m ? this.create(x, T, E, P, M) : null
                },
                get: function(v, p, g, m, x) {
                    return this.getFirst(!1, !0, v, p, g, m, x)
                },
                getFirstAlive: function(v, p, g, m, x, T) {
                    return this.getFirst(!0, v, p, g, m, x, T)
                },
                getFirstDead: function(v, p, g, m, x, T) {
                    return this.getFirst(!1, v, p, g, m, x, T)
                },
                playAnimation: function(v, p) {
                    return e.PlayAnimation(this.children.entries, v, p),
                    this
                },
                isFull: function() {
                    return this.maxSize === -1 ? !1 : this.children.size >= this.maxSize
                },
                countActive: function(v) {
                    v === void 0 && (v = !0);
                    for (var p = 0, g = 0; g < this.children.size; g++)
                        this.children.entries[g].active === v && p++;
                    return p
                },
                getTotalUsed: function() {
                    return this.countActive()
                },
                getTotalFree: function() {
                    var v = this.getTotalUsed()
                      , p = this.maxSize === -1 ? 999999999999 : this.maxSize;
                    return p - v
                },
                setActive: function(v) {
                    return this.active = v,
                    this
                },
                setName: function(v) {
                    return this.name = v,
                    this
                },
                propertyValueSet: function(v, p, g, m, x) {
                    return e.PropertyValueSet(this.children.entries, v, p, g, m, x),
                    this
                },
                propertyValueInc: function(v, p, g, m, x) {
                    return e.PropertyValueInc(this.children.entries, v, p, g, m, x),
                    this
                },
                setX: function(v, p) {
                    return e.SetX(this.children.entries, v, p),
                    this
                },
                setY: function(v, p) {
                    return e.SetY(this.children.entries, v, p),
                    this
                },
                setXY: function(v, p, g, m) {
                    return e.SetXY(this.children.entries, v, p, g, m),
                    this
                },
                incX: function(v, p) {
                    return e.IncX(this.children.entries, v, p),
                    this
                },
                incY: function(v, p) {
                    return e.IncY(this.children.entries, v, p),
                    this
                },
                incXY: function(v, p, g, m) {
                    return e.IncXY(this.children.entries, v, p, g, m),
                    this
                },
                shiftPosition: function(v, p, g) {
                    return e.ShiftPosition(this.children.entries, v, p, g),
                    this
                },
                angle: function(v, p) {
                    return e.Angle(this.children.entries, v, p),
                    this
                },
                rotate: function(v, p) {
                    return e.Rotate(this.children.entries, v, p),
                    this
                },
                rotateAround: function(v, p) {
                    return e.RotateAround(this.children.entries, v, p),
                    this
                },
                rotateAroundDistance: function(v, p, g) {
                    return e.RotateAroundDistance(this.children.entries, v, p, g),
                    this
                },
                setAlpha: function(v, p) {
                    return e.SetAlpha(this.children.entries, v, p),
                    this
                },
                setTint: function(v, p, g, m) {
                    return e.SetTint(this.children.entries, v, p, g, m),
                    this
                },
                setOrigin: function(v, p, g, m) {
                    return e.SetOrigin(this.children.entries, v, p, g, m),
                    this
                },
                scaleX: function(v, p) {
                    return e.ScaleX(this.children.entries, v, p),
                    this
                },
                scaleY: function(v, p) {
                    return e.ScaleY(this.children.entries, v, p),
                    this
                },
                scaleXY: function(v, p, g, m) {
                    return e.ScaleXY(this.children.entries, v, p, g, m),
                    this
                },
                setDepth: function(v, p) {
                    return e.SetDepth(this.children.entries, v, p),
                    this
                },
                setBlendMode: function(v) {
                    return e.SetBlendMode(this.children.entries, v),
                    this
                },
                setHitArea: function(v, p) {
                    return e.SetHitArea(this.children.entries, v, p),
                    this
                },
                shuffle: function() {
                    return e.Shuffle(this.children.entries),
                    this
                },
                kill: function(v) {
                    this.children.contains(v) && v.setActive(!1)
                },
                killAndHide: function(v) {
                    this.children.contains(v) && (v.setActive(!1),
                    v.setVisible(!1))
                },
                setVisible: function(v, p, g) {
                    return e.SetVisible(this.children.entries, v, p, g),
                    this
                },
                toggleVisible: function() {
                    return e.ToggleVisible(this.children.entries),
                    this
                },
                destroy: function(v, p) {
                    v === void 0 && (v = !1),
                    p === void 0 && (p = !1),
                    !(!this.scene || this.ignoreDestroy) && (this.emit(r.DESTROY, this),
                    this.removeAllListeners(),
                    this.scene.sys.updateList.remove(this),
                    this.clear(p, v),
                    this.scene = void 0,
                    this.children = void 0)
                }
            });
            c.exports = d
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(12)
              , f = function(r, o, a, n, s, l) {
                for (var i = e.getTintAppendFloatAlpha(a.fillColor, a.fillAlpha * n), h = a.pathData, u = a.pathIndexes, d = 0; d < u.length; d += 3) {
                    var v = u[d] * 2
                      , p = u[d + 1] * 2
                      , g = u[d + 2] * 2
                      , m = h[v + 0] - s
                      , x = h[v + 1] - l
                      , T = h[p + 0] - s
                      , E = h[p + 1] - l
                      , P = h[g + 0] - s
                      , M = h[g + 1] - l
                      , L = o.getX(m, x)
                      , R = o.getY(m, x)
                      , O = o.getX(T, E)
                      , F = o.getY(T, E)
                      , B = o.getX(P, M)
                      , N = o.getY(P, M);
                    r.batchTri(a, L, R, O, F, B, N, 0, 0, 1, 1, i, i, i, 2)
                }
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                var o = e.x3 - e.x1
                  , a = e.y3 - e.y1
                  , n = e.x2 - e.x1
                  , s = e.y2 - e.y1
                  , l = f - e.x1
                  , i = r - e.y1
                  , h = o * o + a * a
                  , u = o * n + a * s
                  , d = o * l + a * i
                  , v = n * n + s * s
                  , p = n * l + s * i
                  , g = h * v - u * u
                  , m = g === 0 ? 0 : 1 / g
                  , x = (v * d - u * p) * m
                  , T = (h * p - u * d) * m;
                return x >= 0 && T >= 0 && x + T < 1
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(10)
              , r = t(3);
            function o(n, s, l, i) {
                var h = n - l
                  , u = s - i
                  , d = h * h + u * u;
                return Math.sqrt(d)
            }
            var a = new e({
                initialize: function(s, l, i) {
                    this.vertex1 = s,
                    this.vertex2 = l,
                    this.vertex3 = i,
                    this.bounds = new f,
                    this._inCenter = new r
                },
                getInCenter: function(n) {
                    n === void 0 && (n = !0);
                    var s = this.vertex1, l = this.vertex2, i = this.vertex3, h, u, d, v, p, g;
                    n ? (h = s.x,
                    u = s.y,
                    d = l.x,
                    v = l.y,
                    p = i.x,
                    g = i.y) : (h = s.vx,
                    u = s.vy,
                    d = l.vx,
                    v = l.vy,
                    p = i.vx,
                    g = i.vy);
                    var m = o(p, g, d, v)
                      , x = o(h, u, p, g)
                      , T = o(d, v, h, u)
                      , E = m + x + T;
                    return this._inCenter.set((h * m + d * x + p * T) / E, (u * m + v * x + g * T) / E)
                },
                contains: function(n, s, l) {
                    var i = this.vertex1
                      , h = this.vertex2
                      , u = this.vertex3
                      , d = i.vx
                      , v = i.vy
                      , p = h.vx
                      , g = h.vy
                      , m = u.vx
                      , x = u.vy;
                    if (l) {
                        var T = l.a
                          , E = l.b
                          , P = l.c
                          , M = l.d
                          , L = l.e
                          , R = l.f;
                        d = i.vx * T + i.vy * P + L,
                        v = i.vx * E + i.vy * M + R,
                        p = h.vx * T + h.vy * P + L,
                        g = h.vx * E + h.vy * M + R,
                        m = u.vx * T + u.vy * P + L,
                        x = u.vx * E + u.vy * M + R
                    }
                    var O = m - d
                      , F = x - v
                      , B = p - d
                      , N = g - v
                      , Y = n - d
                      , z = s - v
                      , W = O * O + F * F
                      , b = O * B + F * N
                      , D = O * Y + F * z
                      , I = B * B + N * N
                      , G = B * Y + N * z
                      , w = W * I - b * b
                      , U = w === 0 ? 0 : 1 / w
                      , X = (I * D - b * G) * U
                      , V = (W * G - b * D) * U;
                    return X >= 0 && V >= 0 && X + V < 1
                },
                isCounterClockwise: function(n) {
                    var s = this.vertex1
                      , l = this.vertex2
                      , i = this.vertex3
                      , h = (l.vx - s.vx) * (i.vy - s.vy) - (l.vy - s.vy) * (i.vx - s.vx);
                    return n <= 0 ? h >= 0 : h < 0
                },
                load: function(n, s, l, i, h) {
                    return l = this.vertex1.load(n, s, l, i, h),
                    l = this.vertex2.load(n, s, l, i, h),
                    l = this.vertex3.load(n, s, l, i, h),
                    l
                },
                transformCoordinatesLocal: function(n, s, l, i) {
                    return this.vertex1.transformCoordinatesLocal(n, s, l, i),
                    this.vertex2.transformCoordinatesLocal(n, s, l, i),
                    this.vertex3.transformCoordinatesLocal(n, s, l, i),
                    this
                },
                updateBounds: function() {
                    var n = this.vertex1
                      , s = this.vertex2
                      , l = this.vertex3
                      , i = this.bounds;
                    return i.x = Math.min(n.vx, s.vx, l.vx),
                    i.y = Math.min(n.vy, s.vy, l.vy),
                    i.width = Math.max(n.vx, s.vx, l.vx) - i.x,
                    i.height = Math.max(n.vy, s.vy, l.vy) - i.y,
                    this
                },
                isInView: function(n, s, l, i, h, u, d, v, p, g, m) {
                    var x = this.vertex1.update(h, u, d, v, p, g, m, i)
                      , T = this.vertex2.update(h, u, d, v, p, g, m, i)
                      , E = this.vertex3.update(h, u, d, v, p, g, m, i);
                    if (x.ta <= 0 && T.ta <= 0 && E.ta <= 0 || s && !this.isCounterClockwise(l))
                        return !1;
                    var P = this.bounds;
                    P.x = Math.min(x.tx, T.tx, E.tx),
                    P.y = Math.min(x.ty, T.ty, E.ty),
                    P.width = Math.max(x.tx, T.tx, E.tx) - P.x,
                    P.height = Math.max(x.ty, T.ty, E.ty) - P.y;
                    var M = n.x + n.width
                      , L = n.y + n.height;
                    return P.width <= 0 || P.height <= 0 || n.width <= 0 || n.height <= 0 ? !1 : !(P.right < n.x || P.bottom < n.y || P.x > M || P.y > L)
                },
                translate: function(n, s) {
                    s === void 0 && (s = 0);
                    var l = this.vertex1
                      , i = this.vertex2
                      , h = this.vertex3;
                    return l.x += n,
                    l.y += s,
                    i.x += n,
                    i.y += s,
                    h.x += n,
                    h.y += s,
                    this
                },
                x: {
                    get: function() {
                        return this.getInCenter().x
                    },
                    set: function(n) {
                        var s = this.getInCenter();
                        this.translate(n - s.x, 0)
                    }
                },
                y: {
                    get: function() {
                        return this.getInCenter().y
                    },
                    set: function(n) {
                        var s = this.getInCenter();
                        this.translate(0, n - s.y)
                    }
                },
                alpha: {
                    get: function() {
                        var n = this.vertex1
                          , s = this.vertex2
                          , l = this.vertex3;
                        return (n.alpha + s.alpha + l.alpha) / 3
                    },
                    set: function(n) {
                        this.vertex1.alpha = n,
                        this.vertex2.alpha = n,
                        this.vertex3.alpha = n
                    }
                },
                depth: {
                    get: function() {
                        var n = this.vertex1
                          , s = this.vertex2
                          , l = this.vertex3;
                        return (n.vz + s.vz + l.vz) / 3
                    }
                },
                destroy: function() {
                    this.vertex1 = null,
                    this.vertex2 = null,
                    this.vertex3 = null
                }
            });
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(12)
              , r = t(39)
              , o = new e({
                Extends: r,
                initialize: function(n, s, l, i, h, u, d, v, p, g) {
                    u === void 0 && (u = 16777215),
                    d === void 0 && (d = 1),
                    v === void 0 && (v = 0),
                    p === void 0 && (p = 0),
                    g === void 0 && (g = 0),
                    r.call(this, n, s, l),
                    this.vx = 0,
                    this.vy = 0,
                    this.vz = 0,
                    this.nx = v,
                    this.ny = p,
                    this.nz = g,
                    this.u = i,
                    this.v = h,
                    this.color = u,
                    this.alpha = d,
                    this.tx = 0,
                    this.ty = 0,
                    this.ta = 0
                },
                setUVs: function(a, n) {
                    return this.u = a,
                    this.v = n,
                    this
                },
                transformCoordinatesLocal: function(a, n, s, l) {
                    var i = this.x
                      , h = this.y
                      , u = this.z
                      , d = a.val
                      , v = i * d[0] + h * d[4] + u * d[8] + d[12]
                      , p = i * d[1] + h * d[5] + u * d[9] + d[13]
                      , g = i * d[2] + h * d[6] + u * d[10] + d[14]
                      , m = i * d[3] + h * d[7] + u * d[11] + d[15];
                    this.vx = v / m * n,
                    this.vy = -(p / m) * s,
                    l <= 0 ? this.vz = g / m : this.vz = -(g / m)
                },
                update: function(a, n, s, l, i, h, u, d) {
                    var v = this.vx * a + this.vy * s + i
                      , p = this.vx * n + this.vy * l + h;
                    return u && (v = Math.round(v),
                    p = Math.round(p)),
                    this.tx = v,
                    this.ty = p,
                    this.ta = this.alpha * d,
                    this
                },
                load: function(a, n, s, l, i) {
                    return a[++s] = this.tx,
                    a[++s] = this.ty,
                    a[++s] = this.u,
                    a[++s] = this.v,
                    a[++s] = l,
                    a[++s] = i,
                    n[++s] = f.getTintAppendFloatAlpha(this.color, this.ta),
                    s
                }
            });
            c.exports = o
        }
        , function(c, S, t) {
            var e = {};
            c.exports = e;
            var f = t(166)
              , r = t(32)
              , o = t(84)
              , a = t(41);
            (function() {
                e.create = function(n) {
                    return r.extend({
                        id: r.nextId(),
                        type: "composite",
                        parent: null,
                        isModified: !1,
                        bodies: [],
                        constraints: [],
                        composites: [],
                        label: "Composite",
                        plugin: {}
                    }, n)
                }
                ,
                e.setModified = function(n, s, l, i) {
                    if (f.trigger(n, "compositeModified", n),
                    n.isModified = s,
                    l && n.parent && e.setModified(n.parent, s, l, i),
                    i)
                        for (var h = 0; h < n.composites.length; h++) {
                            var u = n.composites[h];
                            e.setModified(u, s, l, i)
                        }
                }
                ,
                e.add = function(n, s) {
                    var l = [].concat(s);
                    f.trigger(n, "beforeAdd", {
                        object: s
                    });
                    for (var i = 0; i < l.length; i++) {
                        var h = l[i];
                        switch (h.type) {
                        case "body":
                            if (h.parent !== h) {
                                r.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)");
                                break
                            }
                            e.addBody(n, h);
                            break;
                        case "constraint":
                            e.addConstraint(n, h);
                            break;
                        case "composite":
                            e.addComposite(n, h);
                            break;
                        case "mouseConstraint":
                            e.addConstraint(n, h.constraint);
                            break
                        }
                    }
                    return f.trigger(n, "afterAdd", {
                        object: s
                    }),
                    n
                }
                ,
                e.remove = function(n, s, l) {
                    var i = [].concat(s);
                    f.trigger(n, "beforeRemove", {
                        object: s
                    });
                    for (var h = 0; h < i.length; h++) {
                        var u = i[h];
                        switch (u.type) {
                        case "body":
                            e.removeBody(n, u, l);
                            break;
                        case "constraint":
                            e.removeConstraint(n, u, l);
                            break;
                        case "composite":
                            e.removeComposite(n, u, l);
                            break;
                        case "mouseConstraint":
                            e.removeConstraint(n, u.constraint);
                            break
                        }
                    }
                    return f.trigger(n, "afterRemove", {
                        object: s
                    }),
                    n
                }
                ,
                e.addComposite = function(n, s) {
                    return n.composites.push(s),
                    s.parent = n,
                    e.setModified(n, !0, !0, !1),
                    n
                }
                ,
                e.removeComposite = function(n, s, l) {
                    var i = n.composites.indexOf(s);
                    if (i !== -1 && (e.removeCompositeAt(n, i),
                    e.setModified(n, !0, !0, !1)),
                    l)
                        for (var h = 0; h < n.composites.length; h++)
                            e.removeComposite(n.composites[h], s, !0);
                    return n
                }
                ,
                e.removeCompositeAt = function(n, s) {
                    return n.composites.splice(s, 1),
                    e.setModified(n, !0, !0, !1),
                    n
                }
                ,
                e.addBody = function(n, s) {
                    return n.bodies.push(s),
                    e.setModified(n, !0, !0, !1),
                    n
                }
                ,
                e.removeBody = function(n, s, l) {
                    var i = n.bodies.indexOf(s);
                    if (i !== -1 && (e.removeBodyAt(n, i),
                    e.setModified(n, !0, !0, !1)),
                    l)
                        for (var h = 0; h < n.composites.length; h++)
                            e.removeBody(n.composites[h], s, !0);
                    return n
                }
                ,
                e.removeBodyAt = function(n, s) {
                    return n.bodies.splice(s, 1),
                    e.setModified(n, !0, !0, !1),
                    n
                }
                ,
                e.addConstraint = function(n, s) {
                    return n.constraints.push(s),
                    e.setModified(n, !0, !0, !1),
                    n
                }
                ,
                e.removeConstraint = function(n, s, l) {
                    var i = n.constraints.indexOf(s);
                    if (i !== -1 && e.removeConstraintAt(n, i),
                    l)
                        for (var h = 0; h < n.composites.length; h++)
                            e.removeConstraint(n.composites[h], s, !0);
                    return n
                }
                ,
                e.removeConstraintAt = function(n, s) {
                    return n.constraints.splice(s, 1),
                    e.setModified(n, !0, !0, !1),
                    n
                }
                ,
                e.clear = function(n, s, l) {
                    if (l)
                        for (var i = 0; i < n.composites.length; i++)
                            e.clear(n.composites[i], s, !0);
                    return s ? n.bodies = n.bodies.filter(function(h) {
                        return h.isStatic
                    }) : n.bodies.length = 0,
                    n.constraints.length = 0,
                    n.composites.length = 0,
                    e.setModified(n, !0, !0, !1),
                    n
                }
                ,
                e.allBodies = function(n) {
                    for (var s = [].concat(n.bodies), l = 0; l < n.composites.length; l++)
                        s = s.concat(e.allBodies(n.composites[l]));
                    return s
                }
                ,
                e.allConstraints = function(n) {
                    for (var s = [].concat(n.constraints), l = 0; l < n.composites.length; l++)
                        s = s.concat(e.allConstraints(n.composites[l]));
                    return s
                }
                ,
                e.allComposites = function(n) {
                    for (var s = [].concat(n.composites), l = 0; l < n.composites.length; l++)
                        s = s.concat(e.allComposites(n.composites[l]));
                    return s
                }
                ,
                e.get = function(n, s, l) {
                    var i, h;
                    switch (l) {
                    case "body":
                        i = e.allBodies(n);
                        break;
                    case "constraint":
                        i = e.allConstraints(n);
                        break;
                    case "composite":
                        i = e.allComposites(n).concat(n);
                        break
                    }
                    return i ? (h = i.filter(function(u) {
                        return u.id.toString() === s.toString()
                    }),
                    h.length === 0 ? null : h[0]) : null
                }
                ,
                e.move = function(n, s, l) {
                    return e.remove(n, s),
                    e.add(l, s),
                    n
                }
                ,
                e.rebase = function(n) {
                    for (var s = e.allBodies(n).concat(e.allConstraints(n)).concat(e.allComposites(n)), l = 0; l < s.length; l++)
                        s[l].id = r.nextId();
                    return e.setModified(n, !0, !0, !1),
                    n
                }
                ,
                e.translate = function(n, s, l) {
                    for (var i = l ? e.allBodies(n) : n.bodies, h = 0; h < i.length; h++)
                        a.translate(i[h], s);
                    return e.setModified(n, !0, !0, !1),
                    n
                }
                ,
                e.rotate = function(n, s, l, i) {
                    for (var h = Math.cos(s), u = Math.sin(s), d = i ? e.allBodies(n) : n.bodies, v = 0; v < d.length; v++) {
                        var p = d[v]
                          , g = p.position.x - l.x
                          , m = p.position.y - l.y;
                        a.setPosition(p, {
                            x: l.x + (g * h - m * u),
                            y: l.y + (g * u + m * h)
                        }),
                        a.rotate(p, s)
                    }
                    return e.setModified(n, !0, !0, !1),
                    n
                }
                ,
                e.scale = function(n, s, l, i, h) {
                    for (var u = h ? e.allBodies(n) : n.bodies, d = 0; d < u.length; d++) {
                        var v = u[d]
                          , p = v.position.x - i.x
                          , g = v.position.y - i.y;
                        a.setPosition(v, {
                            x: i.x + p * s,
                            y: i.y + g * l
                        }),
                        a.scale(v, s, l)
                    }
                    return e.setModified(n, !0, !0, !1),
                    n
                }
                ,
                e.bounds = function(n) {
                    for (var s = e.allBodies(n), l = [], i = 0; i < s.length; i += 1) {
                        var h = s[i];
                        l.push(h.bounds.min, h.bounds.max)
                    }
                    return o.create(l)
                }
            }
            )()
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                return e >= 0 && e < r.width && f >= 0 && f < r.height
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(29)
              , r = t(2)
              , o = new e({
                initialize: function(n) {
                    n === void 0 && (n = {}),
                    this.name = r(n, "name", "layer"),
                    this.x = r(n, "x", 0),
                    this.y = r(n, "y", 0),
                    this.width = r(n, "width", 0),
                    this.height = r(n, "height", 0),
                    this.tileWidth = r(n, "tileWidth", 0),
                    this.tileHeight = r(n, "tileHeight", 0),
                    this.baseTileWidth = r(n, "baseTileWidth", this.tileWidth),
                    this.baseTileHeight = r(n, "baseTileHeight", this.tileHeight),
                    this.orientation = r(n, "orientation", f.ORTHOGONAL),
                    this.widthInPixels = r(n, "widthInPixels", this.width * this.baseTileWidth),
                    this.heightInPixels = r(n, "heightInPixels", this.height * this.baseTileHeight),
                    this.alpha = r(n, "alpha", 1),
                    this.visible = r(n, "visible", !0),
                    this.properties = r(n, "properties", []),
                    this.indexes = r(n, "indexes", []),
                    this.collideIndexes = r(n, "collideIndexes", []),
                    this.callbacks = r(n, "callbacks", []),
                    this.bodies = r(n, "bodies", []),
                    this.data = r(n, "data", []),
                    this.tilemapLayer = r(n, "tilemapLayer", null),
                    this.hexSideLength = r(n, "hexSideLength", 0)
                }
            });
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(29)
              , r = t(2)
              , o = new e({
                initialize: function(n) {
                    n === void 0 && (n = {}),
                    this.name = r(n, "name", "map"),
                    this.width = r(n, "width", 0),
                    this.height = r(n, "height", 0),
                    this.infinite = r(n, "infinite", !1),
                    this.tileWidth = r(n, "tileWidth", 0),
                    this.tileHeight = r(n, "tileHeight", 0),
                    this.widthInPixels = r(n, "widthInPixels", this.width * this.tileWidth),
                    this.heightInPixels = r(n, "heightInPixels", this.height * this.tileHeight),
                    this.format = r(n, "format", null),
                    this.orientation = r(n, "orientation", f.ORTHOGONAL),
                    this.renderOrder = r(n, "renderOrder", "right-down"),
                    this.version = r(n, "version", "1"),
                    this.properties = r(n, "properties", {}),
                    this.layers = r(n, "layers", []),
                    this.images = r(n, "images", []),
                    this.objects = r(n, "objects", {}),
                    this.collision = r(n, "collision", {}),
                    this.tilesets = r(n, "tilesets", []),
                    this.imageCollections = r(n, "imageCollections", []),
                    this.tiles = r(n, "tiles", []),
                    this.hexSideLength = r(n, "hexSideLength", 0)
                }
            });
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = new e({
                initialize: function(o, a, n, s, l, i, h, u) {
                    (n === void 0 || n <= 0) && (n = 32),
                    (s === void 0 || s <= 0) && (s = 32),
                    l === void 0 && (l = 0),
                    i === void 0 && (i = 0),
                    h === void 0 && (h = {}),
                    u === void 0 && (u = {}),
                    this.name = o,
                    this.firstgid = a,
                    this.tileWidth = n,
                    this.tileHeight = s,
                    this.tileMargin = l,
                    this.tileSpacing = i,
                    this.tileProperties = h,
                    this.tileData = u,
                    this.image = null,
                    this.glTexture = null,
                    this.rows = 0,
                    this.columns = 0,
                    this.total = 0,
                    this.texCoordinates = []
                },
                getTileProperties: function(r) {
                    return this.containsTileIndex(r) ? this.tileProperties[r - this.firstgid] : null
                },
                getTileData: function(r) {
                    return this.containsTileIndex(r) ? this.tileData[r - this.firstgid] : null
                },
                getTileCollisionGroup: function(r) {
                    var o = this.getTileData(r);
                    return o && o.objectgroup ? o.objectgroup : null
                },
                containsTileIndex: function(r) {
                    return r >= this.firstgid && r < this.firstgid + this.total
                },
                getTileTextureCoordinates: function(r) {
                    return this.containsTileIndex(r) ? this.texCoordinates[r - this.firstgid] : null
                },
                setImage: function(r) {
                    return this.image = r,
                    this.glTexture = r.get().source.glTexture,
                    this.updateTileData(this.image.source[0].width, this.image.source[0].height),
                    this
                },
                setTileSize: function(r, o) {
                    return r !== void 0 && (this.tileWidth = r),
                    o !== void 0 && (this.tileHeight = o),
                    this.image && this.updateTileData(this.image.source[0].width, this.image.source[0].height),
                    this
                },
                setSpacing: function(r, o) {
                    return r !== void 0 && (this.tileMargin = r),
                    o !== void 0 && (this.tileSpacing = o),
                    this.image && this.updateTileData(this.image.source[0].width, this.image.source[0].height),
                    this
                },
                updateTileData: function(r, o) {
                    var a = (o - this.tileMargin * 2 + this.tileSpacing) / (this.tileHeight + this.tileSpacing)
                      , n = (r - this.tileMargin * 2 + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
                    (a % 1 !== 0 || n % 1 !== 0) && console.warn("Image tile area not tile size multiple in: " + this.name),
                    a = Math.floor(a),
                    n = Math.floor(n),
                    this.rows = a,
                    this.columns = n,
                    this.total = a * n,
                    this.texCoordinates.length = 0;
                    for (var s = this.tileMargin, l = this.tileMargin, i = 0; i < this.rows; i++) {
                        for (var h = 0; h < this.columns; h++)
                            this.texCoordinates.push({
                                x: s,
                                y: l
                            }),
                            s += this.tileWidth + this.tileSpacing;
                        s = this.tileMargin,
                        l += this.tileHeight + this.tileSpacing
                    }
                    return this
                }
            });
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                TOP_LEFT: 0,
                TOP_CENTER: 1,
                TOP_RIGHT: 2,
                LEFT_TOP: 3,
                LEFT_CENTER: 4,
                LEFT_BOTTOM: 5,
                CENTER: 6,
                RIGHT_TOP: 7,
                RIGHT_CENTER: 8,
                RIGHT_BOTTOM: 9,
                BOTTOM_LEFT: 10,
                BOTTOM_CENTER: 11,
                BOTTOM_RIGHT: 12
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                return r === void 0 && (r = 1e-4),
                Math.abs(e - f) < r
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(11)
              , r = t(15)
              , o = t(1068)
              , a = new e({
                Extends: r,
                Mixins: [f.Alpha, f.BlendMode, f.Depth, f.Flip, f.GetBounds, f.Mask, f.Origin, f.Pipeline, f.ScrollFactor, f.Size, f.TextureCrop, f.Tint, f.Transform, f.Visible, o],
                initialize: function(s, l, i, h, u) {
                    r.call(this, s, "Image"),
                    this._crop = this.resetCropObject(),
                    this.setTexture(h, u),
                    this.setPosition(l, i),
                    this.setSizeToFrame(),
                    this.setOriginFromFrame(),
                    this.initPipeline()
                }
            });
            c.exports = a
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return e.hasOwnProperty(f)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(77)
              , f = function(r, o) {
                var a = e(r);
                for (var n in o)
                    a.hasOwnProperty(n) || (a[n] = o[n]);
                return a
            };
            c.exports = f
        }
        , function(c, S, t) {
            var e = {};
            c.exports = e;
            var f = t(64)
              , r = t(83)
              , o = t(165)
              , a = t(84)
              , n = t(271)
              , s = t(32);
            (function() {
                e._warming = .4,
                e._torqueDampen = 1,
                e._minLength = 1e-6,
                e.create = function(l) {
                    var i = l;
                    i.bodyA && !i.pointA && (i.pointA = {
                        x: 0,
                        y: 0
                    }),
                    i.bodyB && !i.pointB && (i.pointB = {
                        x: 0,
                        y: 0
                    });
                    var h = i.bodyA ? r.add(i.bodyA.position, i.pointA) : i.pointA
                      , u = i.bodyB ? r.add(i.bodyB.position, i.pointB) : i.pointB
                      , d = r.magnitude(r.sub(h, u));
                    i.length = typeof i.length < "u" ? i.length : d,
                    i.id = i.id || s.nextId(),
                    i.label = i.label || "Constraint",
                    i.type = "constraint",
                    i.stiffness = i.stiffness || (i.length > 0 ? 1 : .7),
                    i.damping = i.damping || 0,
                    i.angularStiffness = i.angularStiffness || 0,
                    i.angleA = i.bodyA ? i.bodyA.angle : i.angleA,
                    i.angleB = i.bodyB ? i.bodyB.angle : i.angleB,
                    i.plugin = {};
                    var v = {
                        visible: !0,
                        type: "line",
                        anchors: !0,
                        lineColor: null,
                        lineOpacity: null,
                        lineThickness: null,
                        pinSize: null,
                        anchorColor: null,
                        anchorSize: null
                    };
                    return i.length === 0 && i.stiffness > .1 ? (v.type = "pin",
                    v.anchors = !1) : i.stiffness < .9 && (v.type = "spring"),
                    i.render = s.extend(v, i.render),
                    i
                }
                ,
                e.preSolveAll = function(l) {
                    for (var i = 0; i < l.length; i += 1) {
                        var h = l[i]
                          , u = h.constraintImpulse;
                        h.isStatic || u.x === 0 && u.y === 0 && u.angle === 0 || (h.position.x += u.x,
                        h.position.y += u.y,
                        h.angle += u.angle)
                    }
                }
                ,
                e.solveAll = function(l, i) {
                    for (var h = 0; h < l.length; h += 1) {
                        var u = l[h]
                          , d = !u.bodyA || u.bodyA && u.bodyA.isStatic
                          , v = !u.bodyB || u.bodyB && u.bodyB.isStatic;
                        (d || v) && e.solve(l[h], i)
                    }
                    for (h = 0; h < l.length; h += 1)
                        u = l[h],
                        d = !u.bodyA || u.bodyA && u.bodyA.isStatic,
                        v = !u.bodyB || u.bodyB && u.bodyB.isStatic,
                        !d && !v && e.solve(l[h], i)
                }
                ,
                e.solve = function(l, i) {
                    var h = l.bodyA
                      , u = l.bodyB
                      , d = l.pointA
                      , v = l.pointB;
                    if (!(!h && !u)) {
                        h && !h.isStatic && (r.rotate(d, h.angle - l.angleA, d),
                        l.angleA = h.angle),
                        u && !u.isStatic && (r.rotate(v, u.angle - l.angleB, v),
                        l.angleB = u.angle);
                        var p = d
                          , g = v;
                        if (h && (p = r.add(h.position, d)),
                        u && (g = r.add(u.position, v)),
                        !(!p || !g)) {
                            var m = r.sub(p, g)
                              , x = r.magnitude(m);
                            x < e._minLength && (x = e._minLength);
                            var T = (x - l.length) / x, E = l.stiffness < 1 ? l.stiffness * i : l.stiffness, P = r.mult(m, T * E), M = (h ? h.inverseMass : 0) + (u ? u.inverseMass : 0), L = (h ? h.inverseInertia : 0) + (u ? u.inverseInertia : 0), R = M + L, O, F, B, N, Y;
                            if (l.damping) {
                                var z = r.create();
                                B = r.div(m, x),
                                Y = r.sub(u && r.sub(u.position, u.positionPrev) || z, h && r.sub(h.position, h.positionPrev) || z),
                                N = r.dot(B, Y)
                            }
                            h && !h.isStatic && (F = h.inverseMass / M,
                            h.constraintImpulse.x -= P.x * F,
                            h.constraintImpulse.y -= P.y * F,
                            h.position.x -= P.x * F,
                            h.position.y -= P.y * F,
                            l.damping && (h.positionPrev.x -= l.damping * B.x * N * F,
                            h.positionPrev.y -= l.damping * B.y * N * F),
                            O = r.cross(d, P) / R * e._torqueDampen * h.inverseInertia * (1 - l.angularStiffness),
                            h.constraintImpulse.angle -= O,
                            h.angle -= O),
                            u && !u.isStatic && (F = u.inverseMass / M,
                            u.constraintImpulse.x += P.x * F,
                            u.constraintImpulse.y += P.y * F,
                            u.position.x += P.x * F,
                            u.position.y += P.y * F,
                            l.damping && (u.positionPrev.x += l.damping * B.x * N * F,
                            u.positionPrev.y += l.damping * B.y * N * F),
                            O = r.cross(v, P) / R * e._torqueDampen * u.inverseInertia * (1 - l.angularStiffness),
                            u.constraintImpulse.angle += O,
                            u.angle += O)
                        }
                    }
                }
                ,
                e.postSolveAll = function(l) {
                    for (var i = 0; i < l.length; i++) {
                        var h = l[i]
                          , u = h.constraintImpulse;
                        if (!(h.isStatic || u.x === 0 && u.y === 0 && u.angle === 0)) {
                            o.set(h, !1);
                            for (var d = 0; d < h.parts.length; d++) {
                                var v = h.parts[d];
                                f.translate(v.vertices, u),
                                d > 0 && (v.position.x += u.x,
                                v.position.y += u.y),
                                u.angle !== 0 && (f.rotate(v.vertices, u.angle, h.position),
                                n.rotate(v.axes, u.angle),
                                d > 0 && r.rotateAbout(v.position, u.angle, h.position, v.position)),
                                a.update(v.bounds, v.vertices, h.velocity)
                            }
                            u.angle *= e._warming,
                            u.x *= e._warming,
                            u.y *= e._warming
                        }
                    }
                }
                ,
                e.pointAWorld = function(l) {
                    return {
                        x: (l.bodyA ? l.bodyA.position.x : 0) + l.pointA.x,
                        y: (l.bodyA ? l.bodyA.position.y : 0) + l.pointA.y
                    }
                }
                ,
                e.pointBWorld = function(l) {
                    return {
                        x: (l.bodyB ? l.bodyB.position.x : 0) + l.pointB.x,
                        y: (l.bodyB ? l.bodyB.position.y : 0) + l.pointB.y
                    }
                }
            }
            )()
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(35)
              , f = t(65)
              , r = t(66)
              , o = t(0)
              , a = t(11)
              , n = t(15)
              , s = t(10)
              , l = t(57)
              , i = new o({
                Extends: n,
                Mixins: [a.Depth, a.GetBounds, a.Origin, a.Transform, a.ScrollFactor, a.Visible],
                initialize: function(u, d, v, p, g) {
                    p === void 0 && (p = 1),
                    g === void 0 && (g = p),
                    n.call(this, u, "Zone"),
                    this.setPosition(d, v),
                    this.width = p,
                    this.height = g,
                    this.blendMode = e.NORMAL,
                    this.updateDisplayOrigin()
                },
                displayWidth: {
                    get: function() {
                        return this.scaleX * this.width
                    },
                    set: function(h) {
                        this.scaleX = h / this.width
                    }
                },
                displayHeight: {
                    get: function() {
                        return this.scaleY * this.height
                    },
                    set: function(h) {
                        this.scaleY = h / this.height
                    }
                },
                setSize: function(h, u, d) {
                    d === void 0 && (d = !0),
                    this.width = h,
                    this.height = u,
                    this.updateDisplayOrigin();
                    var v = this.input;
                    return d && v && !v.customHitArea && (v.hitArea.width = h,
                    v.hitArea.height = u),
                    this
                },
                setDisplaySize: function(h, u) {
                    return this.displayWidth = h,
                    this.displayHeight = u,
                    this
                },
                setCircleDropZone: function(h) {
                    return this.setDropZone(new f(0,0,h), r)
                },
                setRectangleDropZone: function(h, u) {
                    return this.setDropZone(new s(0,0,h,u), l)
                },
                setDropZone: function(h, u) {
                    return h === void 0 ? this.setRectangleDropZone(this.width, this.height) : this.input || this.setInteractive(h, u, !0),
                    this
                },
                setAlpha: function() {},
                setBlendMode: function() {},
                renderCanvas: function(h, u, d) {
                    d.addToRenderList(u)
                },
                renderWebGL: function(h, u, d) {
                    d.addToRenderList(u)
                }
            });
            c.exports = i
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return 2 * (e.width + e.height)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                for (var f = e.length - 1; f > 0; f--) {
                    var r = Math.floor(Math.random() * (f + 1))
                      , o = e[f];
                    e[f] = e[r],
                    e[r] = o
                }
                return e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                ADD_ANIMATION: t(724),
                ANIMATION_COMPLETE: t(725),
                ANIMATION_COMPLETE_KEY: t(726),
                ANIMATION_REPEAT: t(727),
                ANIMATION_RESTART: t(728),
                ANIMATION_START: t(729),
                ANIMATION_STOP: t(730),
                ANIMATION_UPDATE: t(731),
                PAUSE_ALL: t(732),
                REMOVE_ANIMATION: t(733),
                RESUME_ALL: t(734)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(11)
              , r = t(36)
              , o = t(9)
              , a = t(37)
              , n = t(10)
              , s = t(25)
              , l = t(187)
              , i = t(3)
              , h = new e({
                Extends: o,
                Mixins: [f.Alpha, f.Visible],
                initialize: function(d, v, p, g) {
                    d === void 0 && (d = 0),
                    v === void 0 && (v = 0),
                    p === void 0 && (p = 0),
                    g === void 0 && (g = 0),
                    o.call(this),
                    this.scene,
                    this.sceneManager,
                    this.scaleManager,
                    this.cameraManager,
                    this.id = 0,
                    this.name = "",
                    this.roundPixels = !1,
                    this.useBounds = !1,
                    this.worldView = new n,
                    this.dirty = !0,
                    this._x = d,
                    this._y = v,
                    this._width = p,
                    this._height = g,
                    this._bounds = new n,
                    this._scrollX = 0,
                    this._scrollY = 0,
                    this._zoomX = 1,
                    this._zoomY = 1,
                    this._rotation = 0,
                    this.matrix = new s,
                    this.transparent = !0,
                    this.backgroundColor = l("rgba(0,0,0,0)"),
                    this.disableCull = !1,
                    this.culledObjects = [],
                    this.midPoint = new i(p / 2,g / 2),
                    this.originX = .5,
                    this.originY = .5,
                    this._customViewport = !1,
                    this.mask = null,
                    this._maskCamera = null,
                    this.renderList = []
                },
                addToRenderList: function(u) {
                    this.renderList.push(u)
                },
                setOrigin: function(u, d) {
                    return u === void 0 && (u = .5),
                    d === void 0 && (d = u),
                    this.originX = u,
                    this.originY = d,
                    this
                },
                getScroll: function(u, d, v) {
                    v === void 0 && (v = new i);
                    var p = this.width * .5
                      , g = this.height * .5;
                    return v.x = u - p,
                    v.y = d - g,
                    this.useBounds && (v.x = this.clampX(v.x),
                    v.y = this.clampY(v.y)),
                    v
                },
                centerOnX: function(u) {
                    var d = this.width * .5;
                    return this.midPoint.x = u,
                    this.scrollX = u - d,
                    this.useBounds && (this.scrollX = this.clampX(this.scrollX)),
                    this
                },
                centerOnY: function(u) {
                    var d = this.height * .5;
                    return this.midPoint.y = u,
                    this.scrollY = u - d,
                    this.useBounds && (this.scrollY = this.clampY(this.scrollY)),
                    this
                },
                centerOn: function(u, d) {
                    return this.centerOnX(u),
                    this.centerOnY(d),
                    this
                },
                centerToBounds: function() {
                    if (this.useBounds) {
                        var u = this._bounds
                          , d = this.width * .5
                          , v = this.height * .5;
                        this.midPoint.set(u.centerX, u.centerY),
                        this.scrollX = u.centerX - d,
                        this.scrollY = u.centerY - v
                    }
                    return this
                },
                centerToSize: function() {
                    return this.scrollX = this.width * .5,
                    this.scrollY = this.height * .5,
                    this
                },
                cull: function(u) {
                    if (this.disableCull)
                        return u;
                    var d = this.matrix.matrix
                      , v = d[0]
                      , p = d[1]
                      , g = d[2]
                      , m = d[3]
                      , x = v * m - p * g;
                    if (!x)
                        return u;
                    var T = d[4]
                      , E = d[5]
                      , P = this.scrollX
                      , M = this.scrollY
                      , L = this.width
                      , R = this.height
                      , O = this.y
                      , F = O + R
                      , B = this.x
                      , N = B + L
                      , Y = this.culledObjects
                      , z = u.length;
                    x = 1 / x,
                    Y.length = 0;
                    for (var W = 0; W < z; ++W) {
                        var b = u[W];
                        if (!b.hasOwnProperty("width") || b.parentContainer) {
                            Y.push(b);
                            continue
                        }
                        var D = b.width
                          , I = b.height
                          , G = b.x - P * b.scrollFactorX - D * b.originX
                          , w = b.y - M * b.scrollFactorY - I * b.originY
                          , U = G * v + w * g + T
                          , X = G * p + w * m + E
                          , V = (G + D) * v + (w + I) * g + T
                          , H = (G + D) * p + (w + I) * m + E;
                        V > B && U < N && H > O && X < F && Y.push(b)
                    }
                    return Y
                },
                getWorldPoint: function(u, d, v) {
                    v === void 0 && (v = new i);
                    var p = this.matrix.matrix
                      , g = p[0]
                      , m = p[1]
                      , x = p[2]
                      , T = p[3]
                      , E = p[4]
                      , P = p[5]
                      , M = g * T - m * x;
                    if (!M)
                        return v.x = u,
                        v.y = d,
                        v;
                    M = 1 / M;
                    var L = T * M
                      , R = -m * M
                      , O = -x * M
                      , F = g * M
                      , B = (x * P - T * E) * M
                      , N = (m * E - g * P) * M
                      , Y = Math.cos(this.rotation)
                      , z = Math.sin(this.rotation)
                      , W = this.zoomX
                      , b = this.zoomY
                      , D = this.scrollX
                      , I = this.scrollY
                      , G = u + (D * Y - I * z) * W
                      , w = d + (D * z + I * Y) * b;
                    return v.x = G * L + w * O + B,
                    v.y = G * R + w * F + N,
                    v
                },
                ignore: function(u) {
                    var d = this.id;
                    Array.isArray(u) || (u = [u]);
                    for (var v = 0; v < u.length; v++) {
                        var p = u[v];
                        Array.isArray(p) ? this.ignore(p) : p.isParent ? this.ignore(p.getChildren()) : p.cameraFilter |= d
                    }
                    return this
                },
                preRender: function() {
                    this.renderList.length = 0;
                    var u = this.width
                      , d = this.height
                      , v = u * .5
                      , p = d * .5
                      , g = this.zoomX
                      , m = this.zoomY
                      , x = this.matrix
                      , T = u * this.originX
                      , E = d * this.originY
                      , P = this.scrollX
                      , M = this.scrollY;
                    this.useBounds && (P = this.clampX(P),
                    M = this.clampY(M)),
                    this.roundPixels && (T = Math.round(T),
                    E = Math.round(E)),
                    this.scrollX = P,
                    this.scrollY = M;
                    var L = P + v
                      , R = M + p;
                    this.midPoint.set(L, R);
                    var O = u / g
                      , F = d / m;
                    this.worldView.setTo(L - O / 2, R - F / 2, O, F),
                    x.applyITRS(this.x + T, this.y + E, this.rotation, g, m),
                    x.translate(-T, -E)
                },
                clampX: function(u) {
                    var d = this._bounds
                      , v = this.displayWidth
                      , p = d.x + (v - this.width) / 2
                      , g = Math.max(p, p + d.width - v);
                    return u < p ? u = p : u > g && (u = g),
                    u
                },
                clampY: function(u) {
                    var d = this._bounds
                      , v = this.displayHeight
                      , p = d.y + (v - this.height) / 2
                      , g = Math.max(p, p + d.height - v);
                    return u < p ? u = p : u > g && (u = g),
                    u
                },
                removeBounds: function() {
                    return this.useBounds = !1,
                    this.dirty = !0,
                    this._bounds.setEmpty(),
                    this
                },
                setAngle: function(u) {
                    return u === void 0 && (u = 0),
                    this.rotation = r(u),
                    this
                },
                setBackgroundColor: function(u) {
                    return u === void 0 && (u = "rgba(0,0,0,0)"),
                    this.backgroundColor = l(u),
                    this.transparent = this.backgroundColor.alpha === 0,
                    this
                },
                setBounds: function(u, d, v, p, g) {
                    return g === void 0 && (g = !1),
                    this._bounds.setTo(u, d, v, p),
                    this.dirty = !0,
                    this.useBounds = !0,
                    g ? this.centerToBounds() : (this.scrollX = this.clampX(this.scrollX),
                    this.scrollY = this.clampY(this.scrollY)),
                    this
                },
                getBounds: function(u) {
                    u === void 0 && (u = new n);
                    var d = this._bounds;
                    return u.setTo(d.x, d.y, d.width, d.height),
                    u
                },
                setName: function(u) {
                    return u === void 0 && (u = ""),
                    this.name = u,
                    this
                },
                setPosition: function(u, d) {
                    return d === void 0 && (d = u),
                    this.x = u,
                    this.y = d,
                    this
                },
                setRotation: function(u) {
                    return u === void 0 && (u = 0),
                    this.rotation = u,
                    this
                },
                setRoundPixels: function(u) {
                    return this.roundPixels = u,
                    this
                },
                setScene: function(u) {
                    this.scene && this._customViewport && this.sceneManager.customViewports--,
                    this.scene = u;
                    var d = u.sys;
                    return this.sceneManager = d.game.scene,
                    this.scaleManager = d.scale,
                    this.cameraManager = d.cameras,
                    this.updateSystem(),
                    this
                },
                setScroll: function(u, d) {
                    return d === void 0 && (d = u),
                    this.scrollX = u,
                    this.scrollY = d,
                    this
                },
                setSize: function(u, d) {
                    return d === void 0 && (d = u),
                    this.width = u,
                    this.height = d,
                    this
                },
                setViewport: function(u, d, v, p) {
                    return this.x = u,
                    this.y = d,
                    this.width = v,
                    this.height = p,
                    this
                },
                setZoom: function(u, d) {
                    return u === void 0 && (u = 1),
                    d === void 0 && (d = u),
                    u === 0 && (u = .001),
                    d === 0 && (d = .001),
                    this.zoomX = u,
                    this.zoomY = d,
                    this
                },
                setMask: function(u, d) {
                    return d === void 0 && (d = !0),
                    this.mask = u,
                    this._maskCamera = d ? this.cameraManager.default : this,
                    this
                },
                clearMask: function(u) {
                    return u === void 0 && (u = !1),
                    u && this.mask && this.mask.destroy(),
                    this.mask = null,
                    this
                },
                toJSON: function() {
                    var u = {
                        name: this.name,
                        x: this.x,
                        y: this.y,
                        width: this.width,
                        height: this.height,
                        zoom: this.zoom,
                        rotation: this.rotation,
                        roundPixels: this.roundPixels,
                        scrollX: this.scrollX,
                        scrollY: this.scrollY,
                        backgroundColor: this.backgroundColor.rgba
                    };
                    return this.useBounds && (u.bounds = {
                        x: this._bounds.x,
                        y: this._bounds.y,
                        width: this._bounds.width,
                        height: this._bounds.height
                    }),
                    u
                },
                update: function() {},
                updateSystem: function() {
                    if (this.scaleManager) {
                        var u = this._x !== 0 || this._y !== 0 || this.scaleManager.width !== this._width || this.scaleManager.height !== this._height
                          , d = this.sceneManager;
                        u && !this._customViewport ? d.customViewports++ : !u && this._customViewport && d.customViewports--,
                        this.dirty = !0,
                        this._customViewport = u
                    }
                },
                destroy: function() {
                    this.emit(a.DESTROY, this),
                    this.removeAllListeners(),
                    this.matrix.destroy(),
                    this.culledObjects = [],
                    this._customViewport && this.sceneManager.customViewports--,
                    this.renderList = [],
                    this._bounds = null,
                    this.scene = null,
                    this.scaleManager = null,
                    this.sceneManager = null,
                    this.cameraManager = null
                },
                x: {
                    get: function() {
                        return this._x
                    },
                    set: function(u) {
                        this._x = u,
                        this.updateSystem()
                    }
                },
                y: {
                    get: function() {
                        return this._y
                    },
                    set: function(u) {
                        this._y = u,
                        this.updateSystem()
                    }
                },
                width: {
                    get: function() {
                        return this._width
                    },
                    set: function(u) {
                        this._width = u,
                        this.updateSystem()
                    }
                },
                height: {
                    get: function() {
                        return this._height
                    },
                    set: function(u) {
                        this._height = u,
                        this.updateSystem()
                    }
                },
                scrollX: {
                    get: function() {
                        return this._scrollX
                    },
                    set: function(u) {
                        this._scrollX = u,
                        this.dirty = !0
                    }
                },
                scrollY: {
                    get: function() {
                        return this._scrollY
                    },
                    set: function(u) {
                        this._scrollY = u,
                        this.dirty = !0
                    }
                },
                zoom: {
                    get: function() {
                        return (this._zoomX + this._zoomY) / 2
                    },
                    set: function(u) {
                        this._zoomX = u,
                        this._zoomY = u,
                        this.dirty = !0
                    }
                },
                zoomX: {
                    get: function() {
                        return this._zoomX
                    },
                    set: function(u) {
                        this._zoomX = u,
                        this.dirty = !0
                    }
                },
                zoomY: {
                    get: function() {
                        return this._zoomY
                    },
                    set: function(u) {
                        this._zoomY = u,
                        this.dirty = !0
                    }
                },
                rotation: {
                    get: function() {
                        return this._rotation
                    },
                    set: function(u) {
                        this._rotation = u,
                        this.dirty = !0
                    }
                },
                centerX: {
                    get: function() {
                        return this.x + .5 * this.width
                    }
                },
                centerY: {
                    get: function() {
                        return this.y + .5 * this.height
                    }
                },
                displayWidth: {
                    get: function() {
                        return this.width / this.zoomX
                    }
                },
                displayHeight: {
                    get: function() {
                        return this.height / this.zoomY
                    }
                }
            });
            c.exports = h
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(334)
              , f = t(335)
              , r = t(336)
              , o = t(337)
              , a = t(338)
              , n = t(339)
              , s = t(340)
              , l = t(341)
              , i = t(342)
              , h = t(343)
              , u = t(344)
              , d = t(345);
            c.exports = {
                Power0: s,
                Power1: l.Out,
                Power2: o.Out,
                Power3: i.Out,
                Power4: h.Out,
                Linear: s,
                Quad: l.Out,
                Cubic: o.Out,
                Quart: i.Out,
                Quint: h.Out,
                Sine: u.Out,
                Expo: n.Out,
                Circ: r.Out,
                Elastic: a.Out,
                Back: e.Out,
                Bounce: f.Out,
                Stepped: d,
                "Quad.easeIn": l.In,
                "Cubic.easeIn": o.In,
                "Quart.easeIn": i.In,
                "Quint.easeIn": h.In,
                "Sine.easeIn": u.In,
                "Expo.easeIn": n.In,
                "Circ.easeIn": r.In,
                "Elastic.easeIn": a.In,
                "Back.easeIn": e.In,
                "Bounce.easeIn": f.In,
                "Quad.easeOut": l.Out,
                "Cubic.easeOut": o.Out,
                "Quart.easeOut": i.Out,
                "Quint.easeOut": h.Out,
                "Sine.easeOut": u.Out,
                "Expo.easeOut": n.Out,
                "Circ.easeOut": r.Out,
                "Elastic.easeOut": a.Out,
                "Back.easeOut": e.Out,
                "Bounce.easeOut": f.Out,
                "Quad.easeInOut": l.InOut,
                "Cubic.easeInOut": o.InOut,
                "Quart.easeInOut": i.InOut,
                "Quint.easeInOut": h.InOut,
                "Sine.easeInOut": u.InOut,
                "Expo.easeInOut": n.InOut,
                "Circ.easeInOut": r.InOut,
                "Elastic.easeInOut": a.InOut,
                "Back.easeInOut": e.InOut,
                "Bounce.easeInOut": f.InOut
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                return (f - e) * r + e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(105)
              , f = {
                chrome: !1,
                chromeVersion: 0,
                edge: !1,
                firefox: !1,
                firefoxVersion: 0,
                ie: !1,
                ieVersion: 0,
                mobileSafari: !1,
                opera: !1,
                safari: !1,
                safariVersion: 0,
                silk: !1,
                trident: !1,
                tridentVersion: 0
            };
            function r() {
                var o = navigator.userAgent;
                return /Edge\/\d+/.test(o) ? f.edge = !0 : /Chrome\/(\d+)/.test(o) && !e.windowsPhone ? (f.chrome = !0,
                f.chromeVersion = parseInt(RegExp.$1, 10)) : /Firefox\D+(\d+)/.test(o) ? (f.firefox = !0,
                f.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(o) && e.iOS ? f.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(o) ? (f.ie = !0,
                f.ieVersion = parseInt(RegExp.$1, 10)) : /Opera/.test(o) ? f.opera = !0 : /Safari/.test(o) && !e.windowsPhone ? f.safari = !0 : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(o) && (f.ie = !0,
                f.trident = !0,
                f.tridentVersion = parseInt(RegExp.$1, 10),
                f.ieVersion = parseInt(RegExp.$3, 10)),
                /Silk/.test(o) && (f.silk = !0),
                f
            }
            c.exports = r()
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return Math.random() * (f - e) + e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return e > 0 && (e & e - 1) === 0 && f > 0 && (f & f - 1) === 0
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                return r === void 0 && (r = 0),
                f === 0 ? e : (e -= r,
                e = f * Math.ceil(e / f),
                o ? (r + e) / f : r + e)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = new e({
                initialize: function(o, a, n, s) {
                    this.x = 0,
                    this.y = 0,
                    this.z = 0,
                    this.w = 0,
                    typeof o == "object" ? (this.x = o.x || 0,
                    this.y = o.y || 0,
                    this.z = o.z || 0,
                    this.w = o.w || 0) : (this.x = o || 0,
                    this.y = a || 0,
                    this.z = n || 0,
                    this.w = s || 0)
                },
                clone: function() {
                    return new f(this.x,this.y,this.z,this.w)
                },
                copy: function(r) {
                    return this.x = r.x,
                    this.y = r.y,
                    this.z = r.z || 0,
                    this.w = r.w || 0,
                    this
                },
                equals: function(r) {
                    return this.x === r.x && this.y === r.y && this.z === r.z && this.w === r.w
                },
                set: function(r, o, a, n) {
                    return typeof r == "object" ? (this.x = r.x || 0,
                    this.y = r.y || 0,
                    this.z = r.z || 0,
                    this.w = r.w || 0) : (this.x = r || 0,
                    this.y = o || 0,
                    this.z = a || 0,
                    this.w = n || 0),
                    this
                },
                add: function(r) {
                    return this.x += r.x,
                    this.y += r.y,
                    this.z += r.z || 0,
                    this.w += r.w || 0,
                    this
                },
                subtract: function(r) {
                    return this.x -= r.x,
                    this.y -= r.y,
                    this.z -= r.z || 0,
                    this.w -= r.w || 0,
                    this
                },
                scale: function(r) {
                    return this.x *= r,
                    this.y *= r,
                    this.z *= r,
                    this.w *= r,
                    this
                },
                length: function() {
                    var r = this.x
                      , o = this.y
                      , a = this.z
                      , n = this.w;
                    return Math.sqrt(r * r + o * o + a * a + n * n)
                },
                lengthSq: function() {
                    var r = this.x
                      , o = this.y
                      , a = this.z
                      , n = this.w;
                    return r * r + o * o + a * a + n * n
                },
                normalize: function() {
                    var r = this.x
                      , o = this.y
                      , a = this.z
                      , n = this.w
                      , s = r * r + o * o + a * a + n * n;
                    return s > 0 && (s = 1 / Math.sqrt(s),
                    this.x = r * s,
                    this.y = o * s,
                    this.z = a * s,
                    this.w = n * s),
                    this
                },
                dot: function(r) {
                    return this.x * r.x + this.y * r.y + this.z * r.z + this.w * r.w
                },
                lerp: function(r, o) {
                    o === void 0 && (o = 0);
                    var a = this.x
                      , n = this.y
                      , s = this.z
                      , l = this.w;
                    return this.x = a + o * (r.x - a),
                    this.y = n + o * (r.y - n),
                    this.z = s + o * (r.z - s),
                    this.w = l + o * (r.w - l),
                    this
                },
                multiply: function(r) {
                    return this.x *= r.x,
                    this.y *= r.y,
                    this.z *= r.z || 1,
                    this.w *= r.w || 1,
                    this
                },
                divide: function(r) {
                    return this.x /= r.x,
                    this.y /= r.y,
                    this.z /= r.z || 1,
                    this.w /= r.w || 1,
                    this
                },
                distance: function(r) {
                    var o = r.x - this.x
                      , a = r.y - this.y
                      , n = r.z - this.z || 0
                      , s = r.w - this.w || 0;
                    return Math.sqrt(o * o + a * a + n * n + s * s)
                },
                distanceSq: function(r) {
                    var o = r.x - this.x
                      , a = r.y - this.y
                      , n = r.z - this.z || 0
                      , s = r.w - this.w || 0;
                    return o * o + a * a + n * n + s * s
                },
                negate: function() {
                    return this.x = -this.x,
                    this.y = -this.y,
                    this.z = -this.z,
                    this.w = -this.w,
                    this
                },
                transformMat4: function(r) {
                    var o = this.x
                      , a = this.y
                      , n = this.z
                      , s = this.w
                      , l = r.val;
                    return this.x = l[0] * o + l[4] * a + l[8] * n + l[12] * s,
                    this.y = l[1] * o + l[5] * a + l[9] * n + l[13] * s,
                    this.z = l[2] * o + l[6] * a + l[10] * n + l[14] * s,
                    this.w = l[3] * o + l[7] * a + l[11] * n + l[15] * s,
                    this
                },
                transformQuat: function(r) {
                    var o = this.x
                      , a = this.y
                      , n = this.z
                      , s = r.x
                      , l = r.y
                      , i = r.z
                      , h = r.w
                      , u = h * o + l * n - i * a
                      , d = h * a + i * o - s * n
                      , v = h * n + s * a - l * o
                      , p = -s * o - l * a - i * n;
                    return this.x = u * h + p * -s + d * -i - v * -l,
                    this.y = d * h + p * -l + v * -s - u * -i,
                    this.z = v * h + p * -i + u * -l - d * -s,
                    this
                },
                reset: function() {
                    return this.x = 0,
                    this.y = 0,
                    this.z = 0,
                    this.w = 0,
                    this
                }
            });
            f.prototype.sub = f.prototype.subtract,
            f.prototype.mul = f.prototype.multiply,
            f.prototype.div = f.prototype.divide,
            f.prototype.dist = f.prototype.distance,
            f.prototype.distSq = f.prototype.distanceSq,
            f.prototype.len = f.prototype.length,
            f.prototype.lenSq = f.prototype.lengthSq,
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(91)
              , r = new e({
                initialize: function(a, n, s, l, i, h, u) {
                    l === void 0 && (l = 1),
                    i === void 0 && (i = 0),
                    h === void 0 && (h = !0),
                    u === void 0 && (u = !1),
                    this.renderer = a,
                    this.framebuffer = null,
                    this.texture = null,
                    this.width = 0,
                    this.height = 0,
                    this.scale = l,
                    this.minFilter = i,
                    this.autoClear = h,
                    this.autoResize = !1,
                    this.resize(n, s),
                    u && this.setAutoResize(!0)
                },
                setAutoResize: function(o) {
                    return o && !this.autoResize ? (this.renderer.on(f.RESIZE, this.resize, this),
                    this.autoResize = !0) : !o && this.autoResize && (this.renderer.off(f.RESIZE, this.resize, this),
                    this.autoResize = !1),
                    this
                },
                resize: function(o, a) {
                    var n = o * this.scale
                      , s = a * this.scale;
                    if (n !== this.width || s !== this.height) {
                        var l = this.renderer;
                        l.deleteFramebuffer(this.framebuffer),
                        l.deleteTexture(this.texture),
                        o *= this.scale,
                        a *= this.scale,
                        o = Math.round(o),
                        a = Math.round(a),
                        o <= 0 && (o = 1),
                        a <= 0 && (a = 1),
                        this.texture = l.createTextureFromSource(null, o, a, this.minFilter),
                        this.framebuffer = l.createFramebuffer(o, a, this.texture, !1),
                        this.width = o,
                        this.height = a
                    }
                    return this
                },
                bind: function(o, a, n) {
                    if (o === void 0 && (o = !1),
                    o && this.renderer.flush(),
                    a && n && this.resize(a, n),
                    this.renderer.pushFramebuffer(this.framebuffer, !1, !1, !1),
                    o && this.adjustViewport(),
                    this.autoClear) {
                        var s = this.renderer.gl;
                        s.clearColor(0, 0, 0, 0),
                        s.clear(s.COLOR_BUFFER_BIT)
                    }
                },
                adjustViewport: function() {
                    var o = this.renderer.gl;
                    o.viewport(0, 0, this.width, this.height),
                    o.disable(o.SCISSOR_TEST)
                },
                clear: function() {
                    var o = this.renderer
                      , a = o.gl;
                    o.pushFramebuffer(this.framebuffer),
                    a.disable(a.SCISSOR_TEST),
                    a.clearColor(0, 0, 0, 0),
                    a.clear(a.COLOR_BUFFER_BIT),
                    o.popFramebuffer(),
                    o.resetScissor()
                },
                unbind: function(o) {
                    o === void 0 && (o = !1);
                    var a = this.renderer;
                    return o && a.flush(),
                    a.popFramebuffer()
                },
                destroy: function() {
                    var o = this.renderer;
                    o.deleteFramebuffer(this.framebuffer),
                    o.deleteTexture(this.texture),
                    o.off(f.RESIZE, this.resize, this),
                    this.renderer = null,
                    this.framebuffer = null,
                    this.texture = null
                }
            });
            c.exports = r
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                var r;
                if (f)
                    typeof f == "string" ? r = document.getElementById(f) : typeof f == "object" && f.nodeType === 1 && (r = f);
                else if (e.parentElement || f === null)
                    return e;
                return r || (r = document.body),
                r.appendChild(e),
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                BACKSPACE: 8,
                TAB: 9,
                ENTER: 13,
                SHIFT: 16,
                CTRL: 17,
                ALT: 18,
                PAUSE: 19,
                CAPS_LOCK: 20,
                ESC: 27,
                SPACE: 32,
                PAGE_UP: 33,
                PAGE_DOWN: 34,
                END: 35,
                HOME: 36,
                LEFT: 37,
                UP: 38,
                RIGHT: 39,
                DOWN: 40,
                PRINT_SCREEN: 42,
                INSERT: 45,
                DELETE: 46,
                ZERO: 48,
                ONE: 49,
                TWO: 50,
                THREE: 51,
                FOUR: 52,
                FIVE: 53,
                SIX: 54,
                SEVEN: 55,
                EIGHT: 56,
                NINE: 57,
                NUMPAD_ZERO: 96,
                NUMPAD_ONE: 97,
                NUMPAD_TWO: 98,
                NUMPAD_THREE: 99,
                NUMPAD_FOUR: 100,
                NUMPAD_FIVE: 101,
                NUMPAD_SIX: 102,
                NUMPAD_SEVEN: 103,
                NUMPAD_EIGHT: 104,
                NUMPAD_NINE: 105,
                NUMPAD_ADD: 107,
                NUMPAD_SUBTRACT: 109,
                A: 65,
                B: 66,
                C: 67,
                D: 68,
                E: 69,
                F: 70,
                G: 71,
                H: 72,
                I: 73,
                J: 74,
                K: 75,
                L: 76,
                M: 77,
                N: 78,
                O: 79,
                P: 80,
                Q: 81,
                R: 82,
                S: 83,
                T: 84,
                U: 85,
                V: 86,
                W: 87,
                X: 88,
                Y: 89,
                Z: 90,
                F1: 112,
                F2: 113,
                F3: 114,
                F4: 115,
                F5: 116,
                F6: 117,
                F7: 118,
                F8: 119,
                F9: 120,
                F10: 121,
                F11: 122,
                F12: 123,
                SEMICOLON: 186,
                PLUS: 187,
                COMMA: 188,
                MINUS: 189,
                PERIOD: 190,
                FORWARD_SLASH: 191,
                BACK_SLASH: 220,
                QUOTES: 222,
                BACKTICK: 192,
                OPEN_BRACKET: 219,
                CLOSED_BRACKET: 221,
                SEMICOLON_FIREFOX: 59,
                COLON: 58,
                COMMA_FIREFOX_WINDOWS: 60,
                COMMA_FIREFOX: 62,
                BRACKET_RIGHT_FIREFOX: 174,
                BRACKET_LEFT_FIREFOX: 175
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                PENDING: 0,
                INIT: 1,
                START: 2,
                LOADING: 3,
                CREATING: 4,
                RUNNING: 5,
                PAUSED: 6,
                SLEEPING: 7,
                SHUTDOWN: 8,
                DESTROYED: 9
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(77)
              , r = t(9)
              , o = t(70)
              , a = t(22)
              , n = t(1)
              , s = t(207)
              , l = t(428)
              , i = new e({
                Extends: r,
                initialize: function(u) {
                    r.call(this),
                    this.game = u,
                    this.jsonCache = u.cache.json,
                    this.sounds = [],
                    this.mute = !1,
                    this.volume = 1,
                    this.pauseOnBlur = !0,
                    this._rate = 1,
                    this._detune = 0,
                    this.locked = this.locked || !1,
                    this.unlocked = !1,
                    u.events.on(a.BLUR, this.onGameBlur, this),
                    u.events.on(a.FOCUS, this.onGameFocus, this),
                    u.events.on(a.PRE_STEP, this.update, this),
                    u.events.once(a.DESTROY, this.destroy, this)
                },
                add: n,
                addAudioSprite: function(h, u) {
                    u === void 0 && (u = {});
                    var d = this.add(h, u);
                    d.spritemap = this.jsonCache.get(h).spritemap;
                    for (var v in d.spritemap)
                        if (d.spritemap.hasOwnProperty(v)) {
                            var p = f(u)
                              , g = d.spritemap[v];
                            p.loop = g.hasOwnProperty("loop") ? g.loop : !1,
                            d.addMarker({
                                name: v,
                                start: g.start,
                                duration: g.end - g.start,
                                config: p
                            })
                        }
                    return d
                },
                get: function(h) {
                    return l(this.sounds, "key", h)
                },
                getAll: function(h) {
                    return s(this.sounds, "key", h)
                },
                play: function(h, u) {
                    var d = this.add(h);
                    return d.once(o.COMPLETE, d.destroy, d),
                    u ? u.name ? (d.addMarker(u),
                    d.play(u.name)) : d.play(u) : d.play()
                },
                playAudioSprite: function(h, u, d) {
                    var v = this.addAudioSprite(h);
                    return v.once(o.COMPLETE, v.destroy, v),
                    v.play(u, d)
                },
                remove: function(h) {
                    var u = this.sounds.indexOf(h);
                    return u !== -1 ? (h.destroy(),
                    this.sounds.splice(u, 1),
                    !0) : !1
                },
                removeAll: function() {
                    this.sounds.forEach(function(h) {
                        h.destroy()
                    }),
                    this.sounds.length = 0
                },
                removeByKey: function(h) {
                    for (var u = 0, d = this.sounds.length - 1; d >= 0; d--) {
                        var v = this.sounds[d];
                        v.key === h && (v.destroy(),
                        this.sounds.splice(d, 1),
                        u++)
                    }
                    return u
                },
                pauseAll: function() {
                    this.forEachActiveSound(function(h) {
                        h.pause()
                    }),
                    this.emit(o.PAUSE_ALL, this)
                },
                resumeAll: function() {
                    this.forEachActiveSound(function(h) {
                        h.resume()
                    }),
                    this.emit(o.RESUME_ALL, this)
                },
                stopAll: function() {
                    this.forEachActiveSound(function(h) {
                        h.stop()
                    }),
                    this.emit(o.STOP_ALL, this)
                },
                stopByKey: function(h) {
                    var u = 0;
                    return this.getAll(h).forEach(function(d) {
                        d.stop() && u++
                    }),
                    u
                },
                unlock: n,
                onBlur: n,
                onFocus: n,
                onGameBlur: function() {
                    this.pauseOnBlur && this.onBlur()
                },
                onGameFocus: function() {
                    this.pauseOnBlur && this.onFocus()
                },
                update: function(h, u) {
                    this.unlocked && (this.unlocked = !1,
                    this.locked = !1,
                    this.emit(o.UNLOCKED, this));
                    for (var d = this.sounds.length - 1; d >= 0; d--)
                        this.sounds[d].pendingRemove && this.sounds.splice(d, 1);
                    this.sounds.forEach(function(v) {
                        v.update(h, u)
                    })
                },
                destroy: function() {
                    this.game.events.off(a.BLUR, this.onGameBlur, this),
                    this.game.events.off(a.FOCUS, this.onGameFocus, this),
                    this.game.events.off(a.PRE_STEP, this.update, this),
                    this.removeAllListeners(),
                    this.removeAll(),
                    this.sounds.length = 0,
                    this.sounds = null,
                    this.game = null
                },
                forEachActiveSound: function(h, u) {
                    var d = this;
                    this.sounds.forEach(function(v, p) {
                        v && !v.pendingRemove && h.call(u || d, v, p, d.sounds)
                    })
                },
                setRate: function(h) {
                    return this.rate = h,
                    this
                },
                rate: {
                    get: function() {
                        return this._rate
                    },
                    set: function(h) {
                        this._rate = h,
                        this.forEachActiveSound(function(u) {
                            u.calculateRate()
                        }),
                        this.emit(o.GLOBAL_RATE, this, h)
                    }
                },
                setDetune: function(h) {
                    return this.detune = h,
                    this
                },
                detune: {
                    get: function() {
                        return this._detune
                    },
                    set: function(h) {
                        this._detune = h,
                        this.forEachActiveSound(function(u) {
                            u.calculateRate()
                        }),
                        this.emit(o.GLOBAL_DETUNE, this, h)
                    }
                }
            });
            c.exports = i
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(9)
              , r = t(70)
              , o = t(17)
              , a = t(1)
              , n = new e({
                Extends: f,
                initialize: function(l, i, h) {
                    f.call(this),
                    this.manager = l,
                    this.key = i,
                    this.isPlaying = !1,
                    this.isPaused = !1,
                    this.totalRate = 1,
                    this.duration = this.duration || 0,
                    this.totalDuration = this.totalDuration || 0,
                    this.config = {
                        mute: !1,
                        volume: 1,
                        rate: 1,
                        detune: 0,
                        seek: 0,
                        loop: !1,
                        delay: 0,
                        pan: 0
                    },
                    this.currentConfig = this.config,
                    this.config = o(this.config, h),
                    this.markers = {},
                    this.currentMarker = null,
                    this.pendingRemove = !1
                },
                addMarker: function(s) {
                    return !s || !s.name || typeof s.name != "string" ? !1 : this.markers[s.name] ? (console.error("addMarker " + s.name + " already exists in Sound"),
                    !1) : (s = o(!0, {
                        name: "",
                        start: 0,
                        duration: this.totalDuration - (s.start || 0),
                        config: {
                            mute: !1,
                            volume: 1,
                            rate: 1,
                            detune: 0,
                            seek: 0,
                            loop: !1,
                            delay: 0,
                            pan: 0
                        }
                    }, s),
                    this.markers[s.name] = s,
                    !0)
                },
                updateMarker: function(s) {
                    return !s || !s.name || typeof s.name != "string" ? !1 : this.markers[s.name] ? (this.markers[s.name] = o(!0, this.markers[s.name], s),
                    !0) : (console.warn("Audio Marker: " + s.name + " missing in Sound: " + this.key),
                    !1)
                },
                removeMarker: function(s) {
                    var l = this.markers[s];
                    return l ? (this.markers[s] = null,
                    l) : null
                },
                play: function(s, l) {
                    if (s === void 0 && (s = ""),
                    typeof s == "object" && (l = s,
                    s = ""),
                    typeof s != "string")
                        return !1;
                    if (!s)
                        this.currentMarker = null,
                        this.currentConfig = this.config,
                        this.duration = this.totalDuration;
                    else {
                        if (!this.markers[s])
                            return console.warn("Marker: " + s + " missing in Sound: " + this.key),
                            !1;
                        this.currentMarker = this.markers[s],
                        this.currentConfig = this.currentMarker.config,
                        this.duration = this.currentMarker.duration
                    }
                    return this.resetConfig(),
                    this.currentConfig = o(this.currentConfig, l),
                    this.isPlaying = !0,
                    this.isPaused = !1,
                    !0
                },
                pause: function() {
                    return this.isPaused || !this.isPlaying ? !1 : (this.isPlaying = !1,
                    this.isPaused = !0,
                    !0)
                },
                resume: function() {
                    return !this.isPaused || this.isPlaying ? !1 : (this.isPlaying = !0,
                    this.isPaused = !1,
                    !0)
                },
                stop: function() {
                    return !this.isPaused && !this.isPlaying ? !1 : (this.isPlaying = !1,
                    this.isPaused = !1,
                    this.resetConfig(),
                    !0)
                },
                applyConfig: function() {
                    this.mute = this.currentConfig.mute,
                    this.volume = this.currentConfig.volume,
                    this.rate = this.currentConfig.rate,
                    this.detune = this.currentConfig.detune,
                    this.loop = this.currentConfig.loop,
                    this.pan = this.currentConfig.pan
                },
                resetConfig: function() {
                    this.currentConfig.seek = 0,
                    this.currentConfig.delay = 0
                },
                update: a,
                calculateRate: function() {
                    var s = 1.0005777895065548
                      , l = this.currentConfig.detune + this.manager.detune
                      , i = Math.pow(s, l);
                    this.totalRate = this.currentConfig.rate * this.manager.rate * i
                },
                destroy: function() {
                    this.pendingRemove || (this.emit(r.DESTROY, this),
                    this.pendingRemove = !0,
                    this.manager = null,
                    this.key = "",
                    this.removeAllListeners(),
                    this.isPlaying = !1,
                    this.isPaused = !1,
                    this.config = null,
                    this.currentConfig = null,
                    this.markers = null,
                    this.currentMarker = null)
                }
            });
            c.exports = n
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(209)
              , f = t(435)
              , r = function(o, a) {
                if (a === void 0 && (a = 90),
                !e(o))
                    return null;
                if (typeof a != "string" && (a = (a % 360 + 360) % 360),
                a === 90 || a === -270 || a === "rotateLeft")
                    o = f(o),
                    o.reverse();
                else if (a === -90 || a === 270 || a === "rotateRight")
                    o.reverse(),
                    o = f(o);
                else if (Math.abs(a) === 180 || a === "rotate180") {
                    for (var n = 0; n < o.length; n++)
                        o[n].reverse();
                    o.reverse()
                }
                return o
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(18)
              , r = t(11)
              , o = t(15)
              , a = t(1043)
              , n = t(1044)
              , s = t(212)
              , l = t(10)
              , i = t(1045)
              , h = new e({
                Extends: o,
                Mixins: [r.Alpha, r.BlendMode, r.Depth, r.Mask, r.Origin, r.Pipeline, r.ScrollFactor, r.Texture, r.Tint, r.Transform, r.Visible, i],
                initialize: function(d, v, p, g, m, x, T) {
                    m === void 0 && (m = ""),
                    T === void 0 && (T = 0),
                    o.call(this, d, "BitmapText"),
                    this.font = g;
                    var E = this.scene.sys.cache.bitmapFont.get(g);
                    E || console.warn("Invalid BitmapText key: " + g),
                    this.fontData = E.data,
                    this._text = "",
                    this._fontSize = x || this.fontData.size,
                    this._letterSpacing = 0,
                    this._align = T,
                    this._bounds = a(),
                    this._dirty = !0,
                    this._maxWidth = 0,
                    this.wordWrapCharCode = 32,
                    this.charColors = [],
                    this.dropShadowX = 0,
                    this.dropShadowY = 0,
                    this.dropShadowColor = 0,
                    this.dropShadowAlpha = .5,
                    this.fromAtlas = E.fromAtlas,
                    this.setTexture(E.texture, E.frame),
                    this.setPosition(v, p),
                    this.setOrigin(0, 0),
                    this.initPipeline(),
                    this.setText(m)
                },
                setLeftAlign: function() {
                    return this._align = h.ALIGN_LEFT,
                    this._dirty = !0,
                    this
                },
                setCenterAlign: function() {
                    return this._align = h.ALIGN_CENTER,
                    this._dirty = !0,
                    this
                },
                setRightAlign: function() {
                    return this._align = h.ALIGN_RIGHT,
                    this._dirty = !0,
                    this
                },
                setFontSize: function(u) {
                    return this._fontSize = u,
                    this._dirty = !0,
                    this
                },
                setLetterSpacing: function(u) {
                    return u === void 0 && (u = 0),
                    this._letterSpacing = u,
                    this._dirty = !0,
                    this
                },
                setText: function(u) {
                    return !u && u !== 0 && (u = ""),
                    Array.isArray(u) && (u = u.join(`
`)),
                    u !== this.text && (this._text = u.toString(),
                    this._dirty = !0,
                    this.updateDisplayOrigin()),
                    this
                },
                setDropShadow: function(u, d, v, p) {
                    return u === void 0 && (u = 0),
                    d === void 0 && (d = 0),
                    v === void 0 && (v = 0),
                    p === void 0 && (p = .5),
                    this.dropShadowX = u,
                    this.dropShadowY = d,
                    this.dropShadowColor = v,
                    this.dropShadowAlpha = p,
                    this
                },
                setCharacterTint: function(u, d, v, p, g, m, x) {
                    u === void 0 && (u = 0),
                    d === void 0 && (d = 1),
                    v === void 0 && (v = !1),
                    p === void 0 && (p = -1),
                    g === void 0 && (g = p,
                    m = p,
                    x = p);
                    var T = this.text.length;
                    d === -1 && (d = T),
                    u < 0 && (u = T + u),
                    u = f(u, 0, T - 1);
                    for (var E = f(u + d, u, T), P = this.charColors, M = u; M < E; M++) {
                        var L = P[M];
                        if (p === -1)
                            P[M] = null;
                        else {
                            var R = v ? 1 : 0;
                            L ? (L.tintEffect = R,
                            L.tintTL = p,
                            L.tintTR = g,
                            L.tintBL = m,
                            L.tintBR = x) : P[M] = {
                                tintEffect: R,
                                tintTL: p,
                                tintTR: g,
                                tintBL: m,
                                tintBR: x
                            }
                        }
                    }
                    return this
                },
                setWordTint: function(u, d, v, p, g, m, x) {
                    d === void 0 && (d = 1);
                    for (var T = this.getTextBounds(), E = T.words, P = typeof u == "number", M = 0, L = 0; L < E.length; L++) {
                        var R = E[L];
                        if ((P && L === u || !P && R.word === u) && (this.setCharacterTint(R.i, R.word.length, v, p, g, m, x),
                        M++,
                        M === d))
                            return this
                    }
                    return this
                },
                getTextBounds: function(u) {
                    var d = this._bounds;
                    return (this._dirty || u || this.scaleX !== d.scaleX || this.scaleY !== d.scaleY) && (a(this, u, !0, d),
                    this._dirty = !1),
                    d
                },
                getCharacterAt: function(u, d, v) {
                    for (var p = this.getLocalPoint(u, d, null, v), g = this.getTextBounds(), m = g.characters, x = new l, T = 0; T < m.length; T++) {
                        var E = m[T];
                        if (x.setTo(E.x, E.t, E.r - E.x, E.b),
                        x.contains(p.x, p.y))
                            return E
                    }
                    return null
                },
                updateDisplayOrigin: function() {
                    return this._dirty = !0,
                    this.getTextBounds(!1),
                    this
                },
                setFont: function(u, d, v) {
                    if (d === void 0 && (d = this._fontSize),
                    v === void 0 && (v = this._align),
                    u !== this.font) {
                        var p = this.scene.sys.cache.bitmapFont.get(u);
                        p && (this.font = u,
                        this.fontData = p.data,
                        this._fontSize = d,
                        this._align = v,
                        this.fromAtlas = p.fromAtlas === !0,
                        this.setTexture(p.texture, p.frame),
                        a(this, !1, !0, this._bounds))
                    }
                    return this
                },
                setMaxWidth: function(u, d) {
                    return this._maxWidth = u,
                    this._dirty = !0,
                    d !== void 0 && (this.wordWrapCharCode = d),
                    this
                },
                align: {
                    set: function(u) {
                        this._align = u,
                        this._dirty = !0
                    },
                    get: function() {
                        return this._align
                    }
                },
                text: {
                    set: function(u) {
                        this.setText(u)
                    },
                    get: function() {
                        return this._text
                    }
                },
                fontSize: {
                    set: function(u) {
                        this._fontSize = u,
                        this._dirty = !0
                    },
                    get: function() {
                        return this._fontSize
                    }
                },
                letterSpacing: {
                    set: function(u) {
                        this._letterSpacing = u,
                        this._dirty = !0
                    },
                    get: function() {
                        return this._letterSpacing
                    }
                },
                maxWidth: {
                    set: function(u) {
                        this._maxWidth = u,
                        this._dirty = !0
                    },
                    get: function() {
                        return this._maxWidth
                    }
                },
                width: {
                    get: function() {
                        return this.getTextBounds(!1),
                        this._bounds.global.width
                    }
                },
                height: {
                    get: function() {
                        return this.getTextBounds(!1),
                        this._bounds.global.height
                    }
                },
                toJSON: function() {
                    var u = r.ToJSON(this)
                      , d = {
                        font: this.font,
                        text: this.text,
                        fontSize: this.fontSize,
                        letterSpacing: this.letterSpacing,
                        align: this.align
                    };
                    return u.data = d,
                    u
                },
                preDestroy: function() {
                    this.charColors.length = 0,
                    this._bounds = null,
                    this.fontData = null
                }
            });
            h.ALIGN_LEFT = 0,
            h.ALIGN_CENTER = 1,
            h.ALIGN_RIGHT = 2,
            h.ParseFromAtlas = n,
            h.ParseXMLBitmapFont = s,
            c.exports = h
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = new e({
                initialize: function(o) {
                    if (this.entries = [],
                    Array.isArray(o))
                        for (var a = 0; a < o.length; a++)
                            this.set(o[a])
                },
                set: function(r) {
                    return this.entries.indexOf(r) === -1 && this.entries.push(r),
                    this
                },
                get: function(r, o) {
                    for (var a = 0; a < this.entries.length; a++) {
                        var n = this.entries[a];
                        if (n[r] === o)
                            return n
                    }
                },
                getArray: function() {
                    return this.entries.slice(0)
                },
                delete: function(r) {
                    var o = this.entries.indexOf(r);
                    return o > -1 && this.entries.splice(o, 1),
                    this
                },
                dump: function() {
                    console.group("Set");
                    for (var r = 0; r < this.entries.length; r++) {
                        var o = this.entries[r];
                        console.log(o)
                    }
                    console.groupEnd()
                },
                each: function(r, o) {
                    var a, n = this.entries.slice(), s = n.length;
                    if (o)
                        for (a = 0; a < s && r.call(o, n[a], a) !== !1; a++)
                            ;
                    else
                        for (a = 0; a < s && r(n[a], a) !== !1; a++)
                            ;
                    return this
                },
                iterate: function(r, o) {
                    var a, n = this.entries.length;
                    if (o)
                        for (a = 0; a < n && r.call(o, this.entries[a], a) !== !1; a++)
                            ;
                    else
                        for (a = 0; a < n && r(this.entries[a], a) !== !1; a++)
                            ;
                    return this
                },
                iterateLocal: function(r) {
                    var o, a = [];
                    for (o = 1; o < arguments.length; o++)
                        a.push(arguments[o]);
                    var n = this.entries.length;
                    for (o = 0; o < n; o++) {
                        var s = this.entries[o];
                        s[r].apply(s, a)
                    }
                    return this
                },
                clear: function() {
                    return this.entries.length = 0,
                    this
                },
                contains: function(r) {
                    return this.entries.indexOf(r) > -1
                },
                union: function(r) {
                    var o = new f;
                    return r.entries.forEach(function(a) {
                        o.set(a)
                    }),
                    this.entries.forEach(function(a) {
                        o.set(a)
                    }),
                    o
                },
                intersect: function(r) {
                    var o = new f;
                    return this.entries.forEach(function(a) {
                        r.contains(a) && o.set(a)
                    }),
                    o
                },
                difference: function(r) {
                    var o = new f;
                    return this.entries.forEach(function(a) {
                        r.contains(a) || o.set(a)
                    }),
                    o
                },
                size: {
                    get: function() {
                        return this.entries.length
                    },
                    set: function(r) {
                        return r < this.entries.length ? this.entries.length = r : this.entries.length
                    }
                }
            });
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(11)
              , r = t(15)
              , o = t(189)
              , a = t(92)
              , n = t(1182)
              , s = new e({
                Extends: r,
                Mixins: [f.AlphaSingle, f.BlendMode, f.Depth, f.GetBounds, f.Mask, f.Pipeline, f.ScrollFactor, f.Transform, f.Visible, n],
                initialize: function(i, h, u, d, v, p, g) {
                    d === void 0 && (d = 16777215),
                    v === void 0 && (v = 128),
                    p === void 0 && (p = 1),
                    g === void 0 && (g = .1),
                    r.call(this, i, "PointLight"),
                    this.initPipeline(a.POINTLIGHT_PIPELINE),
                    this.setPosition(h, u),
                    this.color = o(d),
                    this.intensity = p,
                    this.attenuation = g,
                    this.width = v * 2,
                    this.height = v * 2,
                    this._radius = v
                },
                radius: {
                    get: function() {
                        return this._radius
                    },
                    set: function(l) {
                        this._radius = l,
                        this.width = l * 2,
                        this.height = l * 2
                    }
                },
                originX: {
                    get: function() {
                        return .5
                    }
                },
                originY: {
                    get: function() {
                        return .5
                    }
                },
                displayOriginX: {
                    get: function() {
                        return this._radius
                    }
                },
                displayOriginY: {
                    get: function() {
                        return this._radius
                    }
                }
            });
            c.exports = s
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                var r = f.width / 2
                  , o = f.height / 2
                  , a = Math.abs(e.x - f.x - r)
                  , n = Math.abs(e.y - f.y - o)
                  , s = r + e.radius
                  , l = o + e.radius;
                if (a > s || n > l)
                    return !1;
                if (a <= r || n <= o)
                    return !0;
                var i = a - r
                  , h = n - o
                  , u = i * i
                  , d = h * h
                  , v = e.radius * e.radius;
                return u + d <= v
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return e.width <= 0 || e.height <= 0 || f.width <= 0 || f.height <= 0 ? !1 : !(e.right < f.x || e.bottom < f.y || e.x > f.right || e.y > f.bottom)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(6)
              , f = {}
              , r = {};
            r.register = function(o, a, n, s, l) {
                f[o] = {
                    plugin: a,
                    mapping: n,
                    settingsKey: s,
                    configKey: l
                }
            }
            ,
            r.getPlugin = function(o) {
                return f[o]
            }
            ,
            r.install = function(o) {
                var a = o.scene.sys
                  , n = a.settings.input
                  , s = a.game.config;
                for (var l in f) {
                    var i = f[l].plugin
                      , h = f[l].mapping
                      , u = f[l].settingsKey
                      , d = f[l].configKey;
                    e(n, u, s[d]) && (o[h] = new i(o))
                }
            }
            ,
            r.remove = function(o) {
                f.hasOwnProperty(o) && delete f[o]
            }
            ,
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                ANY_KEY_DOWN: t(1323),
                ANY_KEY_UP: t(1324),
                COMBO_MATCH: t(1325),
                DOWN: t(1326),
                KEY_DOWN: t(1327),
                KEY_UP: t(1328),
                UP: t(1329)
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return e.url ? e.url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? e.url : f + e.url : !1
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o, a, n) {
                return e === void 0 && (e = ""),
                f === void 0 && (f = !0),
                r === void 0 && (r = ""),
                o === void 0 && (o = ""),
                a === void 0 && (a = 0),
                n === void 0 && (n = !1),
                {
                    responseType: e,
                    async: f,
                    user: r,
                    password: o,
                    timeout: a,
                    headers: void 0,
                    header: void 0,
                    headerValue: void 0,
                    requestedWith: !1,
                    overrideMimeType: void 0,
                    withCredentials: n
                }
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(243)
              , r = t(73)
              , o = new e({
                Extends: r,
                Mixins: [f.Acceleration, f.Angular, f.Bounce, f.Debug, f.Drag, f.Enable, f.Friction, f.Gravity, f.Immovable, f.Mass, f.Pushable, f.Size, f.Velocity],
                initialize: function(n, s, l, i, h) {
                    r.call(this, n, s, l, i, h),
                    this.body = null
                }
            });
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(119)
              , f = function(r, o, a, n) {
                if (a === void 0 && (a = !1),
                e(r, o, n)) {
                    var s = n.data[o][r] || null;
                    return s ? s.index === -1 ? a ? s : null : s : null
                } else
                    return null
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                var a = e.data, n = e.width, s = e.height, l = e.tilemapLayer, i = Math.max(0, f.left), h = Math.min(n, f.right), u = Math.max(0, f.top), d = Math.min(s, f.bottom), v, p, g;
                if (r === 0)
                    for (p = u; p < d; p++)
                        for (v = i; a[p] && v < h; v++)
                            g = a[p][v],
                            !(!g || g.index === -1 || !g.visible || g.alpha === 0) && o.push(g);
                else if (r === 1)
                    for (p = u; p < d; p++)
                        for (v = h; a[p] && v >= i; v--)
                            g = a[p][v],
                            !(!g || g.index === -1 || !g.visible || g.alpha === 0) && o.push(g);
                else if (r === 2)
                    for (p = d; p >= u; p--)
                        for (v = i; a[p] && v < h; v++)
                            g = a[p][v],
                            !(!g || g.index === -1 || !g.visible || g.alpha === 0) && o.push(g);
                else if (r === 3)
                    for (p = d; p >= u; p--)
                        for (v = h; a[p] && v >= i; v--)
                            g = a[p][v],
                            !(!g || g.index === -1 || !g.visible || g.alpha === 0) && o.push(g);
                return l.tilesDrawn = o.length,
                l.tilesTotal = n * s,
                o
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                var o = r.collideIndexes.indexOf(e);
                f && o === -1 ? r.collideIndexes.push(e) : !f && o !== -1 && r.collideIndexes.splice(o, 1)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Seth Berrier <berriers@uwstout.edu>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(2)
              , f = function(r, o, a) {
                if (!o)
                    return {
                        i: 0,
                        layers: r.layers,
                        name: "",
                        opacity: 1,
                        visible: !0,
                        x: 0,
                        y: 0
                    };
                var n = o.x + e(o, "startx", 0) * r.tilewidth + e(o, "offsetx", 0)
                  , s = o.y + e(o, "starty", 0) * r.tileheight + e(o, "offsety", 0);
                return {
                    i: 0,
                    layers: o.layers,
                    name: a.name + o.name + "/",
                    opacity: a.opacity * o.opacity,
                    visible: a.visible && o.visible,
                    x: a.x + n,
                    y: a.y + s
                }
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                var o;
                if (e.hasOwnProperty(f)) {
                    var a = typeof e[f];
                    a === "function" ? o = function(n, s, l, i, h, u) {
                        return e[f](n, s, l, i, h, u)
                    }
                    : o = function() {
                        return e[f]
                    }
                } else
                    typeof r == "function" ? o = r : o = function() {
                        return r
                    }
                    ;
                return o
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(265)
              , f = t(13)
              , r = t(99)
              , o = t(80)
              , a = t(162)
              , n = t(583)
              , s = t(263)
              , l = t(6)
              , i = t(264)
              , h = t(266)
              , u = t(268)
              , d = function(v, p, g) {
                g === void 0 && (g = e);
                for (var m = g.targets ? g.targets : s(p), x = n(p), T = a(p, "delay", g.delay), E = a(p, "duration", g.duration), P = l(p, "easeParams", g.easeParams), M = o(l(p, "ease", g.ease), P), L = a(p, "hold", g.hold), R = a(p, "repeat", g.repeat), O = a(p, "repeatDelay", g.repeatDelay), F = r(p, "yoyo", g.yoyo), B = r(p, "flipX", g.flipX), N = r(p, "flipY", g.flipY), Y = [], z = 0; z < x.length; z++)
                    for (var W = x[z].key, b = x[z].value, D = 0; D < m.length; D++) {
                        var I = i(W, b)
                          , G = u(m[D], D, W, I.getEnd, I.getStart, I.getActive, o(l(b, "ease", M), l(b, "easeParams", P)), a(b, "delay", T), a(b, "duration", E), r(b, "yoyo", F), a(b, "hold", L), a(b, "repeat", R), a(b, "repeatDelay", O), r(b, "flipX", B), r(b, "flipY", N));
                        Y.push(G)
                    }
                var w = new h(v,Y,m);
                w.offset = f(p, "offset", null),
                w.completeDelay = f(p, "completeDelay", 0),
                w.loop = Math.round(f(p, "loop", 0)),
                w.loopDelay = Math.round(f(p, "loopDelay", 0)),
                w.paused = r(p, "paused", !1),
                w.useFrames = r(p, "useFrames", !1);
                for (var U = l(p, "callbackScope", w), X = [w, null], V = h.TYPES, H = 0; H < V.length; H++) {
                    var J = V[H]
                      , $ = l(p, J, !1);
                    if ($) {
                        var _ = l(p, J + "Scope", U)
                          , nt = l(p, J + "Params", []);
                        w.setCallback(J, $, X.concat(nt), _)
                    }
                }
                return w
            };
            c.exports = d
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(102)
              , r = t(2)
              , o = t(132)
              , a = t(185)
              , n = new e({
                initialize: function(l) {
                    this.parent = l,
                    this.animationManager = l.scene.sys.anims,
                    this.animationManager.on(o.REMOVE_ANIMATION, this.globalRemove, this),
                    this.textureManager = this.animationManager.textureManager,
                    this.anims = null,
                    this.isPlaying = !1,
                    this.hasStarted = !1,
                    this.currentAnim = null,
                    this.currentFrame = null,
                    this.nextAnim = null,
                    this.nextAnimsQueue = [],
                    this.timeScale = 1,
                    this.frameRate = 0,
                    this.duration = 0,
                    this.msPerFrame = 0,
                    this.skipMissedFrames = !0,
                    this.delay = 0,
                    this.repeat = 0,
                    this.repeatDelay = 0,
                    this.yoyo = !1,
                    this.showOnStart = !1,
                    this.hideOnComplete = !1,
                    this.forward = !0,
                    this.inReverse = !1,
                    this.accumulator = 0,
                    this.nextTick = 0,
                    this.delayCounter = 0,
                    this.repeatCounter = 0,
                    this.pendingRepeat = !1,
                    this._paused = !1,
                    this._wasPlaying = !1,
                    this._pendingStop = 0,
                    this._pendingStopValue
                },
                chain: function(s) {
                    var l = this.parent;
                    if (s === void 0)
                        return this.nextAnimsQueue.length = 0,
                        this.nextAnim = null,
                        l;
                    Array.isArray(s) || (s = [s]);
                    for (var i = 0; i < s.length; i++) {
                        var h = s[i];
                        this.nextAnim === null ? this.nextAnim = h : this.nextAnimsQueue.push(h)
                    }
                    return this.parent
                },
                getName: function() {
                    return this.currentAnim ? this.currentAnim.key : ""
                },
                getFrameName: function() {
                    return this.currentFrame ? this.currentFrame.textureFrame : ""
                },
                load: function(s) {
                    this.isPlaying && this.stop();
                    var l = this.animationManager
                      , i = typeof s == "string" ? s : r(s, "key", null)
                      , h = this.exists(i) ? this.get(i) : l.get(i);
                    if (!h)
                        console.warn("Missing animation: " + i);
                    else {
                        this.currentAnim = h;
                        var u = h.getTotalFrames()
                          , d = r(s, "frameRate", h.frameRate)
                          , v = r(s, "duration", h.duration);
                        h.calculateDuration(this, u, v, d),
                        this.delay = r(s, "delay", h.delay),
                        this.repeat = r(s, "repeat", h.repeat),
                        this.repeatDelay = r(s, "repeatDelay", h.repeatDelay),
                        this.yoyo = r(s, "yoyo", h.yoyo),
                        this.showOnStart = r(s, "showOnStart", h.showOnStart),
                        this.hideOnComplete = r(s, "hideOnComplete", h.hideOnComplete),
                        this.skipMissedFrames = r(s, "skipMissedFrames", h.skipMissedFrames),
                        this.timeScale = r(s, "timeScale", this.timeScale);
                        var p = r(s, "startFrame", 0);
                        p > h.getTotalFrames() && (p = 0);
                        var g = h.frames[p];
                        p === 0 && !this.forward && (g = h.getLastFrame()),
                        this.currentFrame = g
                    }
                    return this.parent
                },
                pause: function(s) {
                    return this._paused || (this._paused = !0,
                    this._wasPlaying = this.isPlaying,
                    this.isPlaying = !1),
                    s !== void 0 && this.setCurrentFrame(s),
                    this.parent
                },
                resume: function(s) {
                    return this._paused && (this._paused = !1,
                    this.isPlaying = this._wasPlaying),
                    s !== void 0 && this.setCurrentFrame(s),
                    this.parent
                },
                playAfterDelay: function(s, l) {
                    if (!this.isPlaying)
                        this.delayCounter = l,
                        this.play(s, !0);
                    else {
                        var i = this.nextAnim
                          , h = this.nextAnimsQueue;
                        i && h.unshift(i),
                        this.nextAnim = s,
                        this._pendingStop = 1,
                        this._pendingStopValue = l
                    }
                    return this.parent
                },
                playAfterRepeat: function(s, l) {
                    if (l === void 0 && (l = 1),
                    !this.isPlaying)
                        this.play(s);
                    else {
                        var i = this.nextAnim
                          , h = this.nextAnimsQueue;
                        i && h.unshift(i),
                        this.repeatCounter !== -1 && l > this.repeatCounter && (l = this.repeatCounter),
                        this.nextAnim = s,
                        this._pendingStop = 2,
                        this._pendingStopValue = l
                    }
                    return this.parent
                },
                play: function(s, l) {
                    l === void 0 && (l = !1);
                    var i = this.currentAnim
                      , h = this.parent
                      , u = typeof s == "string" ? s : s.key;
                    if (l && this.isPlaying && i.key === u)
                        return h;
                    if (i && this.isPlaying) {
                        var d = this.animationManager.getMix(i.key, s);
                        if (d > 0)
                            return this.playAfterDelay(s, d)
                    }
                    return this.forward = !0,
                    this.inReverse = !1,
                    this._paused = !1,
                    this._wasPlaying = !0,
                    this.startAnimation(s)
                },
                playReverse: function(s, l) {
                    l === void 0 && (l = !1);
                    var i = typeof s == "string" ? s : s.key;
                    return l && this.isPlaying && this.currentAnim.key === i ? this.parent : (this.forward = !1,
                    this.inReverse = !0,
                    this._paused = !1,
                    this._wasPlaying = !0,
                    this.startAnimation(s))
                },
                startAnimation: function(s) {
                    this.load(s);
                    var l = this.currentAnim
                      , i = this.parent;
                    return l && (this.repeatCounter = this.repeat === -1 ? Number.MAX_VALUE : this.repeat,
                    l.getFirstTick(this),
                    this.isPlaying = !0,
                    this.pendingRepeat = !1,
                    this.hasStarted = !1,
                    this._pendingStop = 0,
                    this._pendingStopValue = 0,
                    this._paused = !1,
                    this.delayCounter += this.delay,
                    this.delayCounter === 0 && this.handleStart()),
                    i
                },
                handleStart: function() {
                    this.showOnStart && this.parent.setVisible(!0),
                    this.setCurrentFrame(this.currentFrame),
                    this.hasStarted = !0,
                    this.emitEvents(o.ANIMATION_START)
                },
                handleRepeat: function() {
                    this.pendingRepeat = !1,
                    this.emitEvents(o.ANIMATION_REPEAT)
                },
                handleStop: function() {
                    this._pendingStop = 0,
                    this.isPlaying = !1,
                    this.emitEvents(o.ANIMATION_STOP)
                },
                handleComplete: function() {
                    this._pendingStop = 0,
                    this.isPlaying = !1,
                    this.hideOnComplete && this.parent.setVisible(!1),
                    this.emitEvents(o.ANIMATION_COMPLETE, o.ANIMATION_COMPLETE_KEY)
                },
                emitEvents: function(s, l) {
                    var i = this.currentAnim
                      , h = this.currentFrame
                      , u = this.parent
                      , d = h.textureFrame;
                    u.emit(s, i, h, u, d),
                    l && u.emit(l + i.key, i, h, u, d)
                },
                reverse: function() {
                    return this.isPlaying && (this.inReverse = !this.inReverse,
                    this.forward = !this.forward),
                    this.parent
                },
                getProgress: function() {
                    var s = this.currentFrame;
                    if (!s)
                        return 0;
                    var l = s.progress;
                    return this.inReverse && (l *= -1),
                    l
                },
                setProgress: function(s) {
                    return this.forward || (s = 1 - s),
                    this.setCurrentFrame(this.currentAnim.getFrameByProgress(s)),
                    this.parent
                },
                setRepeat: function(s) {
                    return this.repeatCounter = s === -1 ? Number.MAX_VALUE : s,
                    this.parent
                },
                globalRemove: function(s, l) {
                    l === void 0 && (l = this.currentAnim),
                    this.isPlaying && l.key === this.currentAnim.key && (this.stop(),
                    this.setCurrentFrame(this.currentAnim.frames[0]))
                },
                restart: function(s, l) {
                    s === void 0 && (s = !1),
                    l === void 0 && (l = !1);
                    var i = this.currentAnim
                      , h = this.parent;
                    return i ? (l && (this.repeatCounter = this.repeat === -1 ? Number.MAX_VALUE : this.repeat),
                    i.getFirstTick(this),
                    this.emitEvents(o.ANIMATION_RESTART),
                    this.isPlaying = !0,
                    this.pendingRepeat = !1,
                    this.hasStarted = !s,
                    this._pendingStop = 0,
                    this._pendingStopValue = 0,
                    this._paused = !1,
                    this.setCurrentFrame(i.frames[0]),
                    this.parent) : h
                },
                complete: function() {
                    if (this._pendingStop = 0,
                    this.isPlaying = !1,
                    this.currentAnim && this.handleComplete(),
                    this.nextAnim) {
                        var s = this.nextAnim;
                        this.nextAnim = this.nextAnimsQueue.length > 0 ? this.nextAnimsQueue.shift() : null,
                        this.play(s)
                    }
                    return this.parent
                },
                stop: function() {
                    if (this._pendingStop = 0,
                    this.isPlaying = !1,
                    this.currentAnim && this.handleStop(),
                    this.nextAnim) {
                        var s = this.nextAnim;
                        this.nextAnim = this.nextAnimsQueue.shift(),
                        this.play(s)
                    }
                    return this.parent
                },
                stopAfterDelay: function(s) {
                    return this._pendingStop = 1,
                    this._pendingStopValue = s,
                    this.parent
                },
                stopAfterRepeat: function(s) {
                    return s === void 0 && (s = 1),
                    this.repeatCounter !== -1 && s > this.repeatCounter && (s = this.repeatCounter),
                    this._pendingStop = 2,
                    this._pendingStopValue = s,
                    this.parent
                },
                stopOnFrame: function(s) {
                    return this._pendingStop = 3,
                    this._pendingStopValue = s,
                    this.parent
                },
                getTotalFrames: function() {
                    return this.currentAnim ? this.currentAnim.getTotalFrames() : 0
                },
                update: function(s, l) {
                    var i = this.currentAnim;
                    if (!(!this.isPlaying || !i || i.paused)) {
                        if (this.accumulator += l * this.timeScale,
                        this._pendingStop === 1 && (this._pendingStopValue -= l,
                        this._pendingStopValue <= 0))
                            return this.stop();
                        if (!this.hasStarted)
                            this.accumulator >= this.delayCounter && (this.accumulator -= this.delayCounter,
                            this.handleStart());
                        else if (this.accumulator >= this.nextTick && (this.forward ? i.nextFrame(this) : i.previousFrame(this),
                        this.isPlaying && this._pendingStop === 0 && this.skipMissedFrames && this.accumulator > this.nextTick)) {
                            var h = 0;
                            do
                                this.forward ? i.nextFrame(this) : i.previousFrame(this),
                                h++;
                            while (this.isPlaying && this.accumulator > this.nextTick && h < 60)
                        }
                    }
                },
                setCurrentFrame: function(s) {
                    var l = this.parent;
                    return this.currentFrame = s,
                    l.texture = s.frame.texture,
                    l.frame = s.frame,
                    l.isCropped && l.frame.updateCropUVs(l._crop, l.flipX, l.flipY),
                    s.setAlpha && (l.alpha = s.alpha),
                    l.setSizeToFrame(),
                    l._originComponent && (s.frame.customPivot ? l.setOrigin(s.frame.pivotX, s.frame.pivotY) : l.updateDisplayOrigin()),
                    this.isPlaying && this.hasStarted && (this.emitEvents(o.ANIMATION_UPDATE),
                    this._pendingStop === 3 && this._pendingStopValue === s && this.stop()),
                    l
                },
                nextFrame: function() {
                    return this.currentAnim && this.currentAnim.nextFrame(this),
                    this.parent
                },
                previousFrame: function() {
                    return this.currentAnim && this.currentAnim.previousFrame(this),
                    this.parent
                },
                get: function(s) {
                    return this.anims ? this.anims.get(s) : null
                },
                exists: function(s) {
                    return this.anims ? this.anims.has(s) : !1
                },
                create: function(s) {
                    var l = s.key
                      , i = !1;
                    return l && (i = this.get(l),
                    i || (i = new a(this,l,s),
                    this.anims || (this.anims = new f),
                    this.anims.set(l, i))),
                    i
                },
                generateFrameNames: function(s, l) {
                    return this.animationManager.generateFrameNames(s, l)
                },
                generateFrameNumbers: function(s, l) {
                    return this.animationManager.generateFrameNumbers(s, l)
                },
                remove: function(s) {
                    var l = this.get(s);
                    return l && (this.currentAnim === l && this.stop(),
                    this.anims.delete(s)),
                    l
                },
                destroy: function() {
                    this.animationManager.off(o.REMOVE_ANIMATION, this.globalRemove, this),
                    this.anims && this.anims.clear(),
                    this.animationManager = null,
                    this.parent = null,
                    this.nextAnim = null,
                    this.nextAnimsQueue.length = 0,
                    this.currentAnim = null,
                    this.currentFrame = null
                },
                isPaused: {
                    get: function() {
                        return this._paused
                    }
                }
            });
            c.exports = n
        }
        , function(c, S, t) {
            var e = {};
            c.exports = e;
            var f = t(166);
            (function() {
                e._motionWakeThreshold = .18,
                e._motionSleepThreshold = .08,
                e._minBias = .9,
                e.update = function(r, o) {
                    for (var a = o * o * o, n = 0; n < r.length; n++) {
                        var s = r[n]
                          , l = s.speed * s.speed + s.angularSpeed * s.angularSpeed;
                        if (s.force.x !== 0 || s.force.y !== 0) {
                            e.set(s, !1);
                            continue
                        }
                        var i = Math.min(s.motion, l)
                          , h = Math.max(s.motion, l);
                        s.motion = e._minBias * i + (1 - e._minBias) * h,
                        s.sleepThreshold > 0 && s.motion < e._motionSleepThreshold * a ? (s.sleepCounter += 1,
                        s.sleepCounter >= s.sleepThreshold && e.set(s, !0)) : s.sleepCounter > 0 && (s.sleepCounter -= 1)
                    }
                }
                ,
                e.afterCollisions = function(r, o) {
                    for (var a = o * o * o, n = 0; n < r.length; n++) {
                        var s = r[n];
                        if (s.isActive) {
                            var l = s.collision
                              , i = l.bodyA.parent
                              , h = l.bodyB.parent;
                            if (!(i.isSleeping && h.isSleeping || i.isStatic || h.isStatic) && (i.isSleeping || h.isSleeping)) {
                                var u = i.isSleeping && !i.isStatic ? i : h
                                  , d = u === i ? h : i;
                                !u.isStatic && d.motion > e._motionWakeThreshold * a && e.set(u, !1)
                            }
                        }
                    }
                }
                ,
                e.set = function(r, o) {
                    var a = r.isSleeping;
                    o ? (r.isSleeping = !0,
                    r.sleepCounter = r.sleepThreshold,
                    r.positionImpulse.x = 0,
                    r.positionImpulse.y = 0,
                    r.positionPrev.x = r.position.x,
                    r.positionPrev.y = r.position.y,
                    r.anglePrev = r.angle,
                    r.speed = 0,
                    r.angularSpeed = 0,
                    r.motion = 0,
                    a || f.trigger(r, "sleepStart")) : (r.isSleeping = !1,
                    r.sleepCounter = 0,
                    a && f.trigger(r, "sleepEnd"))
                }
            }
            )()
        }
        , function(c, S, t) {
            var e = {};
            c.exports = e;
            var f = t(32);
            (function() {
                e.on = function(r, o, a) {
                    for (var n = o.split(" "), s, l = 0; l < n.length; l++)
                        s = n[l],
                        r.events = r.events || {},
                        r.events[s] = r.events[s] || [],
                        r.events[s].push(a);
                    return a
                }
                ,
                e.off = function(r, o, a) {
                    if (!o) {
                        r.events = {};
                        return
                    }
                    typeof o == "function" && (a = o,
                    o = f.keys(r.events).join(" "));
                    for (var n = o.split(" "), s = 0; s < n.length; s++) {
                        var l = r.events[n[s]]
                          , i = [];
                        if (a && l)
                            for (var h = 0; h < l.length; h++)
                                l[h] !== a && i.push(l[h]);
                        r.events[n[s]] = i
                    }
                }
                ,
                e.trigger = function(r, o, a) {
                    var n, s, l, i, h = r.events;
                    if (h && f.keys(h).length > 0) {
                        a || (a = {}),
                        n = o.split(" ");
                        for (var u = 0; u < n.length; u++)
                            if (s = n[u],
                            l = h[s],
                            l) {
                                i = f.clone(a, !1),
                                i.name = s,
                                i.source = r;
                                for (var d = 0; d < l.length; d++)
                                    l[d].apply(r, [i])
                            }
                    }
                }
            }
            )()
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(175)
              , f = t(92)
              , r = t(74)
              , o = {
                defaultPipeline: null,
                pipeline: null,
                hasPostPipeline: !1,
                postPipelines: null,
                pipelineData: null,
                initPipeline: function(a) {
                    a === void 0 && (a = f.MULTI_PIPELINE);
                    var n = this.scene.sys.renderer;
                    if (!n)
                        return !1;
                    var s = n.pipelines;
                    if (this.postPipelines = [],
                    this.pipelineData = {},
                    s) {
                        var l = s.get(a);
                        if (l)
                            return this.defaultPipeline = l,
                            this.pipeline = l,
                            !0
                    }
                    return !1
                },
                setPipeline: function(a, n, s) {
                    var l = this.scene.sys.renderer;
                    if (!l)
                        return this;
                    var i = l.pipelines;
                    if (i) {
                        var h = i.get(a);
                        h && (this.pipeline = h),
                        n && (this.pipelineData = s ? e(n) : n)
                    }
                    return this
                },
                setPostPipeline: function(a, n, s) {
                    var l = this.scene.sys.renderer;
                    if (!l)
                        return this;
                    var i = l.pipelines;
                    if (i) {
                        Array.isArray(a) || (a = [a]);
                        for (var h = 0; h < a.length; h++) {
                            var u = i.getPostPipeline(a[h], this);
                            u && this.postPipelines.push(u)
                        }
                        n && (this.pipelineData = s ? e(n) : n)
                    }
                    return this.hasPostPipeline = this.postPipelines.length > 0,
                    this
                },
                setPipelineData: function(a, n) {
                    var s = this.pipelineData;
                    return n === void 0 ? delete s[a] : s[a] = n,
                    this
                },
                getPostPipeline: function(a) {
                    for (var n = this.postPipelines, s = [], l = 0; l < n.length; l++) {
                        var i = n[l];
                        (typeof a == "string" && i.name === a || i instanceof a) && s.push(i)
                    }
                    return s.length === 1 ? s[0] : s
                },
                resetPipeline: function(a, n) {
                    return a === void 0 && (a = !1),
                    n === void 0 && (n = !1),
                    this.pipeline = this.defaultPipeline,
                    a && (this.postPipelines = [],
                    this.hasPostPipeline = !1),
                    n && (this.pipelineData = {}),
                    this.pipeline !== null
                },
                resetPostPipeline: function(a) {
                    a === void 0 && (a = !1);
                    for (var n = this.postPipelines, s = 0; s < n.length; s++)
                        n[s].destroy();
                    this.postPipelines = [],
                    this.hasPostPipeline = !1,
                    a && (this.pipelineData = {})
                },
                removePostPipeline: function(a) {
                    for (var n = this.postPipelines, s = n.length - 1; s >= 0; s--) {
                        var l = n[s];
                        (typeof a == "string" && l.name === a || typeof a != "string" && l instanceof a) && (l.destroy(),
                        r(n, s))
                    }
                    return this.hasPostPipeline = this.postPipelines.length > 0,
                    this
                },
                getPipelineName: function() {
                    return this.pipeline.name
                }
            };
            c.exports = o
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                DEFAULT: 0,
                LINEAR: 0,
                NEAREST: 1
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4)
              , f = function(r, o, a) {
                return a === void 0 && (a = new e),
                a.x = r.x + r.radius * Math.cos(o),
                a.y = r.y + r.radius * Math.sin(o),
                a
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4)
              , f = function(r, o) {
                o === void 0 && (o = new e);
                var a = 2 * Math.PI * Math.random()
                  , n = Math.random() + Math.random()
                  , s = n > 1 ? 2 - n : n
                  , l = s * Math.cos(a)
                  , i = s * Math.sin(a);
                return o.x = r.x + l * r.radius,
                o.y = r.y + i * r.radius,
                o
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(130)
              , f = t(4)
              , r = function(o, a, n) {
                if (n === void 0 && (n = new f),
                a <= 0 || a >= 1)
                    return n.x = o.x,
                    n.y = o.y,
                    n;
                var s = e(o) * a;
                return a > .5 ? (s -= o.width + o.height,
                s <= o.width ? (n.x = o.right - s,
                n.y = o.bottom) : (n.x = o.x,
                n.y = o.bottom - (s - o.width))) : s <= o.width ? (n.x = o.x + s,
                n.y = o.y) : (n.x = o.right,
                n.y = o.y + (s - o.width)),
                n
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(67)
              , f = t(4)
              , r = function(o, a, n, s) {
                s === void 0 && (s = []),
                !a && n > 0 && (a = e(o) / n);
                for (var l = o.x1, i = o.y1, h = o.x2, u = o.y2, d = 0; d < a; d++) {
                    var v = d / a
                      , p = l + (h - l) * v
                      , g = i + (u - i) * v;
                    s.push(new f(p,g))
                }
                return s
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4)
              , f = function(r, o) {
                o === void 0 && (o = new e);
                var a = Math.random();
                return o.x = r.x1 + a * (r.x2 - r.x1),
                o.y = r.y1 + a * (r.y2 - r.y1),
                o
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4)
              , f = function(r, o) {
                return o === void 0 && (o = new e),
                o.x = r.x + Math.random() * r.width,
                o.y = r.y + Math.random() * r.height,
                o
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                var f, r, o;
                if (typeof e != "object" || e === null)
                    return e;
                f = Array.isArray(e) ? [] : {};
                for (o in e)
                    r = e[o],
                    f[o] = t(r);
                return f
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                var f = {
                    name: e.name,
                    type: e.type,
                    x: e.x,
                    y: e.y,
                    depth: e.depth,
                    scale: {
                        x: e.scaleX,
                        y: e.scaleY
                    },
                    origin: {
                        x: e.originX,
                        y: e.originY
                    },
                    flipX: e.flipX,
                    flipY: e.flipY,
                    rotation: e.rotation,
                    alpha: e.alpha,
                    visible: e.visible,
                    blendMode: e.blendMode,
                    textureKey: "",
                    frameKey: "",
                    data: {}
                };
                return e.texture && (f.textureKey = e.texture.key,
                f.frameKey = e.frame.name),
                f
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(3)
              , f = function(r, o, a, n, s, l, i, h) {
                h === void 0 && (h = new e);
                var u = Math.sin(s)
                  , d = Math.cos(s)
                  , v = d * l
                  , p = u * l
                  , g = -u * i
                  , m = d * i
                  , x = 1 / (v * m + g * -p);
                return h.x = m * x * r + -g * x * o + (n * g - a * m) * x,
                h.y = v * x * o + -p * x * r + (-n * v + a * p) * x,
                h
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                f === void 0 && (f = 1);
                for (var r = null, o = 0; o < f; o++)
                    r = e.shift(),
                    e.push(r);
                return r
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                f === void 0 && (f = 1);
                for (var r = null, o = 0; o < f; o++)
                    r = e.pop(),
                    e.unshift(r);
                return r
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4)
              , f = function(r, o) {
                o === void 0 && (o = new e);
                var a = Math.random() * Math.PI * 2
                  , n = Math.sqrt(Math.random());
                return o.x = r.x + n * Math.cos(a) * r.width / 2,
                o.y = r.y + n * Math.sin(a) * r.height / 2,
                o
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4)
              , f = function(r, o) {
                o === void 0 && (o = new e);
                var a = r.x2 - r.x1
                  , n = r.y2 - r.y1
                  , s = r.x3 - r.x1
                  , l = r.y3 - r.y1
                  , i = Math.random()
                  , h = Math.random();
                return i + h >= 1 && (i = 1 - i,
                h = 1 - h),
                o.x = r.x1 + (a * i + s * h),
                o.y = r.y1 + (n * i + l * h),
                o
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o, a) {
                var n = o + Math.atan2(e.y - r, e.x - f);
                return e.x = f + a * Math.cos(n),
                e.y = r + a * Math.sin(n),
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                return e = Math.max(0, Math.min(1, (e - f) / (r - f))),
                e * e * e * (e * (e * 6 - 15) + 10)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                return e <= f ? 0 : e >= r ? 1 : (e = (e - f) / (r - f),
                e * e * (3 - 2 * e))
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(18)
              , f = t(0)
              , r = t(132)
              , o = t(318)
              , a = t(319)
              , n = t(6)
              , s = t(320)
              , l = new f({
                initialize: function(h, u, d) {
                    this.manager = h,
                    this.key = u,
                    this.type = "frame",
                    this.frames = this.getFrames(h.textureManager, n(d, "frames", []), n(d, "defaultTextureKey", null), n(d, "sortFrames", !0)),
                    this.frameRate = n(d, "frameRate", null),
                    this.duration = n(d, "duration", null),
                    this.msPerFrame,
                    this.skipMissedFrames = n(d, "skipMissedFrames", !0),
                    this.delay = n(d, "delay", 0),
                    this.repeat = n(d, "repeat", 0),
                    this.repeatDelay = n(d, "repeatDelay", 0),
                    this.yoyo = n(d, "yoyo", !1),
                    this.showOnStart = n(d, "showOnStart", !1),
                    this.hideOnComplete = n(d, "hideOnComplete", !1),
                    this.paused = !1,
                    this.calculateDuration(this, this.getTotalFrames(), this.duration, this.frameRate),
                    this.manager.on && (this.manager.on(r.PAUSE_ALL, this.pause, this),
                    this.manager.on(r.RESUME_ALL, this.resume, this))
                },
                getTotalFrames: function() {
                    return this.frames.length
                },
                calculateDuration: function(i, h, u, d) {
                    u === null && d === null ? (i.frameRate = 24,
                    i.duration = 24 / h * 1e3) : u && d === null ? (i.duration = u,
                    i.frameRate = h / (u / 1e3)) : (i.frameRate = d,
                    i.duration = h / d * 1e3),
                    i.msPerFrame = 1e3 / i.frameRate
                },
                addFrame: function(i) {
                    return this.addFrameAt(this.frames.length, i)
                },
                addFrameAt: function(i, h) {
                    var u = this.getFrames(this.manager.textureManager, h);
                    if (u.length > 0) {
                        if (i === 0)
                            this.frames = u.concat(this.frames);
                        else if (i === this.frames.length)
                            this.frames = this.frames.concat(u);
                        else {
                            var d = this.frames.slice(0, i)
                              , v = this.frames.slice(i);
                            this.frames = d.concat(u, v)
                        }
                        this.updateFrameSequence()
                    }
                    return this
                },
                checkFrame: function(i) {
                    return i >= 0 && i < this.frames.length
                },
                getFirstTick: function(i) {
                    i.accumulator = 0,
                    i.nextTick = i.msPerFrame + i.currentFrame.duration
                },
                getFrameAt: function(i) {
                    return this.frames[i]
                },
                getFrames: function(i, h, u, d) {
                    d === void 0 && (d = !0);
                    var v = [], p, g, m = 1, x, T;
                    if (typeof h == "string") {
                        T = h;
                        var E = i.get(T)
                          , P = E.getFrameNames();
                        d && s(P),
                        h = [],
                        P.forEach(function(B) {
                            h.push({
                                key: T,
                                frame: B
                            })
                        })
                    }
                    if (!Array.isArray(h) || h.length === 0)
                        return v;
                    for (x = 0; x < h.length; x++) {
                        var M = h[x]
                          , L = n(M, "key", u);
                        if (L) {
                            var R = n(M, "frame", 0)
                              , O = i.getFrame(L, R);
                            g = new a(L,R,m,O),
                            g.duration = n(M, "duration", 0),
                            g.isFirst = !p,
                            p && (p.nextFrame = g,
                            g.prevFrame = p),
                            v.push(g),
                            p = g,
                            m++
                        }
                    }
                    if (v.length > 0) {
                        g.isLast = !0,
                        g.nextFrame = v[0],
                        v[0].prevFrame = g;
                        var F = 1 / (v.length - 1);
                        for (x = 0; x < v.length; x++)
                            v[x].progress = x * F
                    }
                    return v
                },
                getNextTick: function(i) {
                    i.accumulator -= i.nextTick,
                    i.nextTick = i.msPerFrame + i.currentFrame.duration
                },
                getFrameByProgress: function(i) {
                    return i = e(i, 0, 1),
                    o(i, this.frames, "progress")
                },
                nextFrame: function(i) {
                    var h = i.currentFrame;
                    h.isLast ? i.yoyo ? this.handleYoyoFrame(i, !1) : i.repeatCounter > 0 ? i.inReverse && i.forward ? i.forward = !1 : this.repeatAnimation(i) : i.complete() : this.updateAndGetNextTick(i, h.nextFrame)
                },
                handleYoyoFrame: function(i, h) {
                    if (h || (h = !1),
                    i.inReverse === !h && i.repeatCounter > 0) {
                        (i.repeatDelay === 0 || i.pendingRepeat) && (i.forward = h),
                        this.repeatAnimation(i);
                        return
                    }
                    if (i.inReverse !== h && i.repeatCounter === 0) {
                        i.complete();
                        return
                    }
                    i.forward = h;
                    var u = h ? i.currentFrame.nextFrame : i.currentFrame.prevFrame;
                    this.updateAndGetNextTick(i, u)
                },
                getLastFrame: function() {
                    return this.frames[this.frames.length - 1]
                },
                previousFrame: function(i) {
                    var h = i.currentFrame;
                    h.isFirst ? i.yoyo ? this.handleYoyoFrame(i, !0) : i.repeatCounter > 0 ? i.inReverse && !i.forward ? this.repeatAnimation(i) : (i.forward = !0,
                    this.repeatAnimation(i)) : i.complete() : this.updateAndGetNextTick(i, h.prevFrame)
                },
                updateAndGetNextTick: function(i, h) {
                    i.setCurrentFrame(h),
                    this.getNextTick(i)
                },
                removeFrame: function(i) {
                    var h = this.frames.indexOf(i);
                    return h !== -1 && this.removeFrameAt(h),
                    this
                },
                removeFrameAt: function(i) {
                    return this.frames.splice(i, 1),
                    this.updateFrameSequence(),
                    this
                },
                repeatAnimation: function(i) {
                    if (i._pendingStop === 2) {
                        if (i._pendingStopValue === 0)
                            return i.stop();
                        i._pendingStopValue--
                    }
                    i.repeatDelay > 0 && !i.pendingRepeat ? (i.pendingRepeat = !0,
                    i.accumulator -= i.nextTick,
                    i.nextTick += i.repeatDelay) : (i.repeatCounter--,
                    i.forward ? i.setCurrentFrame(i.currentFrame.nextFrame) : i.setCurrentFrame(i.currentFrame.prevFrame),
                    i.isPlaying && (this.getNextTick(i),
                    i.handleRepeat()))
                },
                toJSON: function() {
                    var i = {
                        key: this.key,
                        type: this.type,
                        frames: [],
                        frameRate: this.frameRate,
                        duration: this.duration,
                        skipMissedFrames: this.skipMissedFrames,
                        delay: this.delay,
                        repeat: this.repeat,
                        repeatDelay: this.repeatDelay,
                        yoyo: this.yoyo,
                        showOnStart: this.showOnStart,
                        hideOnComplete: this.hideOnComplete
                    };
                    return this.frames.forEach(function(h) {
                        i.frames.push(h.toJSON())
                    }),
                    i
                },
                updateFrameSequence: function() {
                    for (var i = this.frames.length, h = 1 / (i - 1), u, d = 0; d < i; d++)
                        u = this.frames[d],
                        u.index = d + 1,
                        u.isFirst = !1,
                        u.isLast = !1,
                        u.progress = d * h,
                        d === 0 ? (u.isFirst = !0,
                        i === 1 ? (u.isLast = !0,
                        u.nextFrame = u,
                        u.prevFrame = u) : (u.isLast = !1,
                        u.prevFrame = this.frames[i - 1],
                        u.nextFrame = this.frames[d + 1])) : d === i - 1 && i > 1 ? (u.isLast = !0,
                        u.prevFrame = this.frames[i - 2],
                        u.nextFrame = this.frames[0]) : i > 1 && (u.prevFrame = this.frames[d - 1],
                        u.nextFrame = this.frames[d + 1]);
                    return this
                },
                pause: function() {
                    return this.paused = !0,
                    this
                },
                resume: function() {
                    return this.paused = !1,
                    this
                },
                destroy: function() {
                    this.manager.off && (this.manager.off(r.PAUSE_ALL, this.pause, this),
                    this.manager.off(r.RESUME_ALL, this.resume, this)),
                    this.manager.remove(this.key);
                    for (var i = 0; i < this.frames.length; i++)
                        this.frames[i].destroy();
                    this.frames = [],
                    this.manager = null
                }
            });
            c.exports = l
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                f === void 0 && (f = 0),
                r === void 0 && (r = " "),
                o === void 0 && (o = 3),
                e = e.toString();
                var a = 0;
                if (f + 1 >= e.length)
                    switch (o) {
                    case 1:
                        e = new Array(f + 1 - e.length).join(r) + e;
                        break;
                    case 3:
                        var n = Math.ceil((a = f - e.length) / 2)
                          , s = a - n;
                        e = new Array(s + 1).join(r) + e + new Array(n + 1).join(r);
                        break;
                    default:
                        e = e + new Array(f + 1 - e.length).join(r);
                        break
                    }
                return e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(327)
              , f = t(189)
              , r = t(331)
              , o = t(332)
              , a = function(n) {
                var s = typeof n;
                switch (s) {
                case "string":
                    return n.substr(0, 3).toLowerCase() === "rgb" ? o(n) : e(n);
                case "number":
                    return f(n);
                case "object":
                    return r(n)
                }
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(103);
            function f(o, a, n, s) {
                var l = (o + a * 6) % 6
                  , i = Math.min(l, 4 - l, 1);
                return Math.round(255 * (s - s * n * Math.max(0, i)))
            }
            var r = function(o, a, n, s) {
                a === void 0 && (a = 1),
                n === void 0 && (n = 1);
                var l = f(5, o, a, n)
                  , i = f(3, o, a, n)
                  , h = f(1, o, a, n);
                return s ? s.setTo ? s.setTo(l, i, h, s.alpha, !1) : (s.r = l,
                s.g = i,
                s.b = h,
                s.color = e(l, i, h),
                s) : {
                    r: l,
                    g: i,
                    b: h,
                    color: e(l, i, h)
                }
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(38)
              , f = t(330)
              , r = function(o) {
                var a = f(o);
                return new e(a.r,a.g,a.b,a.a)
            };
            c.exports = r
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                return e.x = f - e.width / 2,
                e.y = r - e.height / 2,
                e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(105)
              , f = t(136)
              , r = t(31)
              , o = {
                canvas: !1,
                canvasBitBltShift: null,
                file: !1,
                fileSystem: !1,
                getUserMedia: !0,
                littleEndian: !1,
                localStorage: !1,
                pointerLock: !1,
                support32bit: !1,
                vibration: !1,
                webGL: !1,
                worker: !1
            };
            function a() {
                var s = new ArrayBuffer(4)
                  , l = new Uint8Array(s)
                  , i = new Uint32Array(s);
                return l[0] = 161,
                l[1] = 178,
                l[2] = 195,
                l[3] = 212,
                i[0] === 3569595041 ? !0 : i[0] === 2712847316 ? !1 : null
            }
            function n() {
                if (typeof importScripts == "function")
                    return o;
                o.canvas = !!window.CanvasRenderingContext2D;
                try {
                    o.localStorage = !!localStorage.getItem
                } catch {
                    o.localStorage = !1
                }
                o.file = !!window.File && !!window.FileReader && !!window.FileList && !!window.Blob,
                o.fileSystem = !!window.requestFileSystem;
                var s = !1
                  , l = function() {
                    if (window.WebGLRenderingContext)
                        try {
                            var i = r.createWebGL(this)
                              , h = i.getContext("webgl") || i.getContext("experimental-webgl")
                              , u = r.create2D(this)
                              , d = u.getContext("2d")
                              , v = d.createImageData(1, 1);
                            return s = v.data instanceof Uint8ClampedArray,
                            r.remove(i),
                            r.remove(u),
                            !!h
                        } catch {
                            return !1
                        }
                    return !1
                };
                return o.webGL = l(),
                o.worker = !!window.Worker,
                o.pointerLock = "pointerLockElement"in document || "mozPointerLockElement"in document || "webkitPointerLockElement"in document,
                navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia,
                window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL,
                o.getUserMedia = o.getUserMedia && !!navigator.getUserMedia && !!window.URL,
                f.firefox && f.firefoxVersion < 21 && (o.getUserMedia = !1),
                !e.iOS && (f.ie || f.firefox || f.chrome) && (o.canvasBitBltShift = !0),
                (f.safari || f.mobileSafari) && (o.canvasBitBltShift = !1),
                navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate,
                navigator.vibrate && (o.vibration = !0),
                typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && typeof Uint32Array < "u" && (o.littleEndian = a()),
                o.support32bit = typeof ArrayBuffer < "u" && typeof Uint8ClampedArray < "u" && typeof Int32Array < "u" && o.littleEndian !== null && s,
                o
            }
            c.exports = n()
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = ""
              , e = function() {
                var f = function(n) {
                    for (var s = ["i", "webkitI", "msI", "mozI", "oI"], l = 0; l < s.length; l++) {
                        var i = s[l] + "mageSmoothingEnabled";
                        if (i in n)
                            return i
                    }
                    return null
                }
                  , r = function(n) {
                    return t === "" && (t = f(n)),
                    t && (n[t] = !0),
                    n
                }
                  , o = function(n) {
                    return t === "" && (t = f(n)),
                    t && (n[t] = !1),
                    n
                }
                  , a = function(n) {
                    return t !== null ? n[t] : null
                };
                return {
                    disable: o,
                    enable: r,
                    getPrefix: f,
                    isEnabled: a
                }
            };
            c.exports = e()
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(14)
              , f = t(17)
              , r = {
                Angle: t(812),
                Distance: t(821),
                Easing: t(826),
                Fuzzy: t(827),
                Interpolation: t(830),
                Pow2: t(835),
                Snap: t(837),
                RandomDataGenerator: t(839),
                Average: t(840),
                Bernstein: t(356),
                Between: t(195),
                CatmullRom: t(194),
                CeilTo: t(841),
                Clamp: t(18),
                DegToRad: t(36),
                Difference: t(842),
                Euler: t(843),
                Factorial: t(357),
                FloatBetween: t(137),
                FloorTo: t(844),
                FromPercent: t(98),
                GetSpeed: t(845),
                IsEven: t(846),
                IsEvenStrict: t(847),
                Linear: t(135),
                MaxAdd: t(848),
                Median: t(849),
                MinSub: t(850),
                Percent: t(851),
                RadToDeg: t(196),
                RandomXY: t(852),
                RandomXYZ: t(853),
                RandomXYZW: t(854),
                Rotate: t(362),
                RotateAround: t(308),
                RotateAroundDistance: t(182),
                RotateTo: t(855),
                RoundAwayFromZero: t(363),
                RoundTo: t(856),
                SinCosTableGenerator: t(857),
                SmootherStep: t(183),
                SmoothStep: t(184),
                ToXY: t(858),
                TransformXY: t(177),
                Within: t(859),
                Wrap: t(68),
                Vector2: t(3),
                Vector3: t(39),
                Vector4: t(140),
                Matrix3: t(364),
                Matrix4: t(69),
                Quaternion: t(365),
                RotateVec3: t(860)
            };
            r = f(!1, r, e),
            c.exports = r
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o, a) {
                var n = (o - f) * .5
                  , s = (a - r) * .5
                  , l = e * e
                  , i = e * l;
                return (2 * r - 2 * o + n + s) * i + (-3 * r + 3 * o - 2 * n - s) * l + n * e + r
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return Math.floor(Math.random() * (f - e + 1) + e)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(14)
              , f = function(r) {
                return r * e.RAD_TO_DEG
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = {
                Global: ["game", "anims", "cache", "plugins", "registry", "scale", "sound", "textures", "renderer"],
                CoreScene: ["EventEmitter", "CameraManager", "GameObjectCreator", "GameObjectFactory", "ScenePlugin", "DisplayList", "UpdateList"],
                DefaultScene: ["Clock", "DataManagerPlugin", "InputPlugin", "Loader", "TweenManager", "LightsPlugin"]
            };
            c.exports = e
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = new e({
                initialize: function() {
                    this._matrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
                    this.alpha = 1,
                    this._dirty = !0,
                    this._data
                },
                set: function(r) {
                    return this._matrix = r,
                    this._dirty = !0,
                    this
                },
                reset: function() {
                    var r = this._matrix;
                    return r[0] = 1,
                    r[1] = 0,
                    r[2] = 0,
                    r[3] = 0,
                    r[4] = 0,
                    r[5] = 0,
                    r[6] = 1,
                    r[7] = 0,
                    r[8] = 0,
                    r[9] = 0,
                    r[10] = 0,
                    r[11] = 0,
                    r[12] = 1,
                    r[13] = 0,
                    r[14] = 0,
                    r[15] = 0,
                    r[16] = 0,
                    r[17] = 0,
                    r[18] = 1,
                    r[19] = 0,
                    this._dirty = !0,
                    this
                },
                getData: function() {
                    if (this._dirty) {
                        var r = new Float32Array(this._matrix);
                        r[4] /= 255,
                        r[9] /= 255,
                        r[14] /= 255,
                        r[19] /= 255,
                        this._data = r,
                        this._dirty = !1
                    }
                    return this._data
                },
                brightness: function(r, o) {
                    r === void 0 && (r = 0),
                    o === void 0 && (o = !1);
                    var a = r;
                    return this.multiply([a, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 1, 0], o)
                },
                saturate: function(r, o) {
                    r === void 0 && (r = 0),
                    o === void 0 && (o = !1);
                    var a = r * 2 / 3 + 1
                      , n = (a - 1) * -.5;
                    return this.multiply([a, n, n, 0, 0, n, a, n, 0, 0, n, n, a, 0, 0, 0, 0, 0, 1, 0], o)
                },
                desaturate: function(r) {
                    return r === void 0 && (r = !1),
                    this.saturate(-1, r)
                },
                hue: function(r, o) {
                    r === void 0 && (r = 0),
                    o === void 0 && (o = !1),
                    r = r / 180 * Math.PI;
                    var a = Math.cos(r)
                      , n = Math.sin(r)
                      , s = .213
                      , l = .715
                      , i = .072;
                    return this.multiply([s + a * (1 - s) + n * -s, l + a * -l + n * -l, i + a * -i + n * (1 - i), 0, 0, s + a * -s + n * .143, l + a * (1 - l) + n * .14, i + a * -i + n * -.283, 0, 0, s + a * -s + n * -(1 - s), l + a * -l + n * l, i + a * (1 - i) + n * i, 0, 0, 0, 0, 0, 1, 0], o)
                },
                grayscale: function(r, o) {
                    return r === void 0 && (r = 1),
                    o === void 0 && (o = !1),
                    this.saturate(-r, o)
                },
                blackWhite: function(r) {
                    return r === void 0 && (r = !1),
                    this.multiply([.3, .6, .1, 0, 0, .3, .6, .1, 0, 0, .3, .6, .1, 0, 0, 0, 0, 0, 1, 0], r)
                },
                contrast: function(r, o) {
                    r === void 0 && (r = 0),
                    o === void 0 && (o = !1);
                    var a = r + 1
                      , n = -.5 * (a - 1);
                    return this.multiply([a, 0, 0, 0, n, 0, a, 0, 0, n, 0, 0, a, 0, n, 0, 0, 0, 1, 0], o)
                },
                negative: function(r) {
                    return r === void 0 && (r = !1),
                    this.multiply([-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0], r)
                },
                desaturateLuminance: function(r) {
                    return r === void 0 && (r = !1),
                    this.multiply([.2764723, .929708, .0938197, 0, -37.1, .2764723, .929708, .0938197, 0, -37.1, .2764723, .929708, .0938197, 0, -37.1, 0, 0, 0, 1, 0], r)
                },
                sepia: function(r) {
                    return r === void 0 && (r = !1),
                    this.multiply([.393, .7689999, .18899999, 0, 0, .349, .6859999, .16799999, 0, 0, .272, .5339999, .13099999, 0, 0, 0, 0, 0, 1, 0], r)
                },
                night: function(r, o) {
                    return r === void 0 && (r = .1),
                    o === void 0 && (o = !1),
                    this.multiply([r * -2, -r, 0, 0, 0, -r, 0, r, 0, 0, 0, r, r * 2, 0, 0, 0, 0, 0, 1, 0], o)
                },
                lsd: function(r) {
                    return r === void 0 && (r = !1),
                    this.multiply([2, -.4, .5, 0, 0, -.5, 2, -.4, 0, 0, -.4, -.5, 3, 0, 0, 0, 0, 0, 1, 0], r)
                },
                brown: function(r) {
                    return r === void 0 && (r = !1),
                    this.multiply([.5997023498159715, .34553243048391263, -.2708298674538042, 0, 47.43192855600873, -.037703249837783157, .8609577587992641, .15059552388459913, 0, -36.96841498319127, .24113635128153335, -.07441037908422492, .44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0], r)
                },
                vintagePinhole: function(r) {
                    return r === void 0 && (r = !1),
                    this.multiply([.6279345635605994, .3202183420819367, -.03965408211312453, 0, 9.651285835294123, .02578397704808868, .6441188644374771, .03259127616149294, 0, 7.462829176470591, .0466055556782719, -.0851232987247891, .5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0], r)
                },
                kodachrome: function(r) {
                    return r === void 0 && (r = !1),
                    this.multiply([1.1285582396593525, -.3967382283601348, -.03992559172921793, 0, 63.72958762196502, -.16404339962244616, 1.0835251566291304, -.05498805115633132, 0, 24.732407896706203, -.16786010706155763, -.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0], r)
                },
                technicolor: function(r) {
                    return r === void 0 && (r = !1),
                    this.multiply([1.9125277891456083, -.8545344976951645, -.09155508482755585, 0, 11.793603434377337, -.3087833385928097, 1.7658908555458428, -.10601743074722245, 0, -70.35205161461398, -.231103377548616, -.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0], r)
                },
                polaroid: function(r) {
                    return r === void 0 && (r = !1),
                    this.multiply([1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0], r)
                },
                shiftToBGR: function(r) {
                    return r === void 0 && (r = !1),
                    this.multiply([0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], r)
                },
                multiply: function(r, o) {
                    o || this.reset();
                    for (var a = this._matrix, n = [], s = 0; s < 20; s++)
                        n[s] = a[s];
                    return a[0] = n[0] * r[0] + n[1] * r[5] + n[2] * r[10] + n[3] * r[15],
                    a[1] = n[0] * r[1] + n[1] * r[6] + n[2] * r[11] + n[3] * r[16],
                    a[2] = n[0] * r[2] + n[1] * r[7] + n[2] * r[12] + n[3] * r[17],
                    a[3] = n[0] * r[3] + n[1] * r[8] + n[2] * r[13] + n[3] * r[18],
                    a[4] = n[0] * r[4] + n[1] * r[9] + n[2] * r[14] + n[3] * r[19] + n[4],
                    a[5] = n[5] * r[0] + n[6] * r[5] + n[7] * r[10] + n[8] * r[15],
                    a[6] = n[5] * r[1] + n[6] * r[6] + n[7] * r[11] + n[8] * r[16],
                    a[7] = n[5] * r[2] + n[6] * r[7] + n[7] * r[12] + n[8] * r[17],
                    a[8] = n[5] * r[3] + n[6] * r[8] + n[7] * r[13] + n[8] * r[18],
                    a[9] = n[5] * r[4] + n[6] * r[9] + n[7] * r[14] + n[8] * r[19] + n[9],
                    a[10] = n[10] * r[0] + n[11] * r[5] + n[12] * r[10] + n[13] * r[15],
                    a[11] = n[10] * r[1] + n[11] * r[6] + n[12] * r[11] + n[13] * r[16],
                    a[12] = n[10] * r[2] + n[11] * r[7] + n[12] * r[12] + n[13] * r[17],
                    a[13] = n[10] * r[3] + n[11] * r[8] + n[12] * r[13] + n[13] * r[18],
                    a[14] = n[10] * r[4] + n[11] * r[9] + n[12] * r[14] + n[13] * r[19] + n[14],
                    a[15] = n[15] * r[0] + n[16] * r[5] + n[17] * r[10] + n[18] * r[15],
                    a[16] = n[15] * r[1] + n[16] * r[6] + n[17] * r[11] + n[18] * r[16],
                    a[17] = n[15] * r[2] + n[16] * r[7] + n[17] * r[12] + n[18] * r[17],
                    a[18] = n[15] * r[3] + n[16] * r[8] + n[17] * r[13] + n[18] * r[18],
                    a[19] = n[15] * r[4] + n[16] * r[9] + n[17] * r[14] + n[18] * r[19] + n[19],
                    this._dirty = !0,
                    this
                }
            });
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(10)
              , f = t(14)
              , r = function(o, a) {
                if (a === void 0 && (a = new e),
                o.length === 0)
                    return a;
                for (var n = Number.MAX_VALUE, s = Number.MAX_VALUE, l = f.MIN_SAFE_INTEGER, i = f.MIN_SAFE_INTEGER, h, u, d, v = 0; v < o.length; v++)
                    h = o[v],
                    Array.isArray(h) ? (u = h[0],
                    d = h[1]) : (u = h.x,
                    d = h.y),
                    n = Math.min(n, u),
                    s = Math.min(s, d),
                    l = Math.max(l, u),
                    i = Math.max(i, d);
                return a.x = n,
                a.y = s,
                a.width = l - n,
                a.height = i - s,
                a
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(1)
              , r = new e({
                initialize: function(a, n, s) {
                    this._rgb = [0, 0, 0],
                    this.onChangeCallback = f,
                    this.dirty = !1,
                    this.set(a, n, s)
                },
                set: function(o, a, n) {
                    return o === void 0 && (o = 0),
                    a === void 0 && (a = 0),
                    n === void 0 && (n = 0),
                    this._rgb = [o, a, n],
                    this.onChange(),
                    this
                },
                equals: function(o, a, n) {
                    var s = this._rgb;
                    return s.r === o && s.g === a && s.b === n
                },
                onChange: function() {
                    this.dirty = !0;
                    var o = this._rgb;
                    this.onChangeCallback.call(this, o[0], o[1], o[2])
                },
                r: {
                    get: function() {
                        return this._rgb[0]
                    },
                    set: function(o) {
                        this._rgb[0] = o,
                        this.onChange()
                    }
                },
                g: {
                    get: function() {
                        return this._rgb[1]
                    },
                    set: function(o) {
                        this._rgb[1] = o,
                        this.onChange()
                    }
                },
                b: {
                    get: function() {
                        return this._rgb[2]
                    },
                    set: function(o) {
                        this._rgb[2] = o,
                        this.onChange()
                    }
                },
                destroy: function() {
                    this.onChangeCallback = null
                }
            });
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = {
                CENTER: t(403),
                ORIENTATION: t(404),
                SCALE_MODE: t(405),
                ZOOM: t(406)
            };
            c.exports = e
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                e.parentNode && e.parentNode.removeChild(e)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                MOUSE_DOWN: 0,
                MOUSE_MOVE: 1,
                MOUSE_UP: 2,
                TOUCH_START: 3,
                TOUCH_MOVE: 4,
                TOUCH_END: 5,
                POINTER_LOCK_CHANGE: 6,
                TOUCH_CANCEL: 7,
                MOUSE_WHEEL: 8
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(144)
              , r = t(197)
              , o = t(20)
              , a = t(419)
              , n = t(420)
              , s = t(33)
              , l = t(1)
              , i = t(421)
              , h = new e({
                initialize: function(d, v) {
                    this.scene = d,
                    this.game,
                    this.renderer,
                    this.config = v,
                    this.settings = i.create(v),
                    this.canvas,
                    this.context,
                    this.anims,
                    this.cache,
                    this.plugins,
                    this.registry,
                    this.scale,
                    this.sound,
                    this.textures,
                    this.add,
                    this.cameras,
                    this.displayList,
                    this.events,
                    this.make,
                    this.scenePlugin,
                    this.updateList,
                    this.sceneUpdate = l
                },
                init: function(u) {
                    this.settings.status = f.INIT,
                    this.sceneUpdate = l,
                    this.game = u,
                    this.renderer = u.renderer,
                    this.canvas = u.canvas,
                    this.context = u.context;
                    var d = u.plugins;
                    this.plugins = d,
                    d.addToScene(this, r.Global, [r.CoreScene, n(this), a(this)]),
                    this.events.emit(o.BOOT, this),
                    this.settings.isBooted = !0
                },
                step: function(u, d) {
                    var v = this.events;
                    v.emit(o.PRE_UPDATE, u, d),
                    v.emit(o.UPDATE, u, d),
                    this.sceneUpdate.call(this.scene, u, d),
                    v.emit(o.POST_UPDATE, u, d)
                },
                render: function(u) {
                    var d = this.displayList;
                    d.depthSort(),
                    this.events.emit(o.PRE_RENDER, u),
                    this.cameras.render(u, d),
                    this.events.emit(o.RENDER, u)
                },
                queueDepthSort: function() {
                    this.displayList.queueDepthSort()
                },
                depthSort: function() {
                    this.displayList.depthSort()
                },
                pause: function(u) {
                    var d = this.events
                      , v = this.settings;
                    return this.settings.active && (v.status = f.PAUSED,
                    v.active = !1,
                    d.emit(o.PAUSE, this, u)),
                    this
                },
                resume: function(u) {
                    var d = this.events
                      , v = this.settings;
                    return this.settings.active || (v.status = f.RUNNING,
                    v.active = !0,
                    d.emit(o.RESUME, this, u)),
                    this
                },
                sleep: function(u) {
                    var d = this.events
                      , v = this.settings;
                    return v.status = f.SLEEPING,
                    v.active = !1,
                    v.visible = !1,
                    d.emit(o.SLEEP, this, u),
                    this
                },
                wake: function(u) {
                    var d = this.events
                      , v = this.settings;
                    return v.status = f.RUNNING,
                    v.active = !0,
                    v.visible = !0,
                    d.emit(o.WAKE, this, u),
                    v.isTransition && d.emit(o.TRANSITION_WAKE, v.transitionFrom, v.transitionDuration),
                    this
                },
                getData: function() {
                    return this.settings.data
                },
                isSleeping: function() {
                    return this.settings.status === f.SLEEPING
                },
                isActive: function() {
                    return this.settings.status === f.RUNNING
                },
                isPaused: function() {
                    return this.settings.status === f.PAUSED
                },
                isTransitioning: function() {
                    return this.settings.isTransition || this.scenePlugin._target !== null
                },
                isTransitionOut: function() {
                    return this.scenePlugin._target !== null && this.scenePlugin._duration > 0
                },
                isTransitionIn: function() {
                    return this.settings.isTransition
                },
                isVisible: function() {
                    return this.settings.visible
                },
                setVisible: function(u) {
                    return this.settings.visible = u,
                    this
                },
                setActive: function(u, d) {
                    return u ? this.resume(d) : this.pause(d)
                },
                start: function(u) {
                    var d = this.events
                      , v = this.settings;
                    u && (v.data = u),
                    v.status = f.START,
                    v.active = !0,
                    v.visible = !0,
                    d.emit(o.START, this),
                    d.emit(o.READY, this, u)
                },
                shutdown: function(u) {
                    var d = this.events
                      , v = this.settings;
                    d.off(o.TRANSITION_INIT),
                    d.off(o.TRANSITION_START),
                    d.off(o.TRANSITION_COMPLETE),
                    d.off(o.TRANSITION_OUT),
                    v.status = f.SHUTDOWN,
                    v.active = !1,
                    v.visible = !1,
                    this.renderer === s.WEBGL && this.renderer.resetTextures(!0),
                    d.emit(o.SHUTDOWN, this, u)
                },
                destroy: function() {
                    var u = this.events
                      , d = this.settings;
                    d.status = f.DESTROYED,
                    d.active = !1,
                    d.visible = !1,
                    u.emit(o.DESTROY, this),
                    u.removeAllListeners();
                    for (var v = ["scene", "game", "anims", "cache", "plugins", "registry", "sound", "textures", "add", "camera", "displayList", "events", "make", "scenePlugin", "updateList"], p = 0; p < v.length; p++)
                        this[v[p]] = null
                }
            });
            c.exports = h
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e && e[0].toUpperCase() + e.slice(1)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(33)
              , f = t(0)
              , r = t(109)
              , o = t(424)
              , a = "Texture.frame missing: "
              , n = new f({
                initialize: function(l, i, h, u, d) {
                    Array.isArray(h) || (h = [h]),
                    this.manager = l,
                    this.key = i,
                    this.source = [],
                    this.dataSource = [],
                    this.frames = {},
                    this.customData = {},
                    this.firstFrame = "__BASE",
                    this.frameTotal = 0;
                    for (var v = 0; v < h.length; v++)
                        this.source.push(new o(this,h[v],u,d))
                },
                add: function(s, l, i, h, u, d) {
                    if (this.has(s))
                        return null;
                    var v = new r(this,s,l,i,h,u,d);
                    return this.frames[s] = v,
                    this.firstFrame === "__BASE" && (this.firstFrame = s),
                    this.frameTotal++,
                    v
                },
                remove: function(s) {
                    if (this.has(s)) {
                        var l = this.get(s);
                        return l.destroy(),
                        delete this.frames[s],
                        !0
                    }
                    return !1
                },
                has: function(s) {
                    return this.frames[s]
                },
                get: function(s) {
                    s || (s = this.firstFrame);
                    var l = this.frames[s];
                    return l || (console.warn(a + s),
                    l = this.frames[this.firstFrame]),
                    l
                },
                getTextureSourceIndex: function(s) {
                    for (var l = 0; l < this.source.length; l++)
                        if (this.source[l] === s)
                            return l;
                    return -1
                },
                getFramesFromTextureSource: function(s, l) {
                    l === void 0 && (l = !1);
                    var i = [];
                    for (var h in this.frames)
                        if (!(h === "__BASE" && !l)) {
                            var u = this.frames[h];
                            u.sourceIndex === s && i.push(u)
                        }
                    return i
                },
                getFrameNames: function(s) {
                    s === void 0 && (s = !1);
                    var l = Object.keys(this.frames);
                    if (!s) {
                        var i = l.indexOf("__BASE");
                        i !== -1 && l.splice(i, 1)
                    }
                    return l
                },
                getSourceImage: function(s) {
                    (s == null || this.frameTotal === 1) && (s = "__BASE");
                    var l = this.frames[s];
                    return l ? l.source.image : (console.warn(a + s),
                    this.frames.__BASE.source.image)
                },
                getDataSourceImage: function(s) {
                    (s == null || this.frameTotal === 1) && (s = "__BASE");
                    var l = this.frames[s], i;
                    return l ? i = l.sourceIndex : (console.warn(a + s),
                    i = this.frames.__BASE.sourceIndex),
                    this.dataSource[i].image
                },
                setDataSource: function(s) {
                    Array.isArray(s) || (s = [s]);
                    for (var l = 0; l < s.length; l++) {
                        var i = this.source[l];
                        this.dataSource.push(new o(this,s[l],i.width,i.height))
                    }
                },
                setFilter: function(s) {
                    var l;
                    for (l = 0; l < this.source.length; l++)
                        this.source[l].setFilter(s);
                    for (l = 0; l < this.dataSource.length; l++)
                        this.dataSource[l].setFilter(s)
                },
                destroy: function() {
                    var s;
                    for (s = 0; s < this.source.length; s++)
                        this.source[s].destroy();
                    for (s = 0; s < this.dataSource.length; s++)
                        this.dataSource[s].destroy();
                    for (var l in this.frames) {
                        var i = this.frames[l];
                        i.destroy()
                    }
                    this.source = [],
                    this.dataSource = [],
                    this.frames = {},
                    this.manager.removeKey(this.key);
                    var h = this.manager.game.renderer;
                    h && h.type === e.WEBGL && h.resetTextures(!0),
                    this.manager = null
                }
            });
            c.exports = n
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(78)
              , f = function(r, o, a, n, s) {
                n === void 0 && (n = 0),
                s === void 0 && (s = r.length);
                var l = [];
                if (e(r, n, s))
                    for (var i = n; i < s; i++) {
                        var h = r[i];
                        (!o || o && a === void 0 && h.hasOwnProperty(o) || o && a !== void 0 && h[o] === a) && l.push(h)
                    }
                return l
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Matrix: t(1013),
                Add: t(1021),
                AddAt: t(1022),
                BringToTop: t(1023),
                CountAllMatching: t(1024),
                Each: t(1025),
                EachInRange: t(1026),
                FindClosestInSorted: t(318),
                GetAll: t(207),
                GetFirst: t(428),
                GetRandom: t(210),
                MoveDown: t(1027),
                MoveTo: t(1028),
                MoveUp: t(1029),
                MoveAbove: t(1030),
                MoveBelow: t(1031),
                NumberArray: t(322),
                NumberArrayStep: t(1032),
                QuickSelect: t(436),
                Range: t(437),
                Remove: t(93),
                RemoveAt: t(1033),
                RemoveBetween: t(1034),
                RemoveRandomElement: t(1035),
                Replace: t(1036),
                RotateLeft: t(178),
                RotateRight: t(179),
                SafeRange: t(78),
                SendToBack: t(1037),
                SetAll: t(1038),
                Shuffle: t(131),
                SortByDigits: t(320),
                SpliceOne: t(74),
                StableSort: t(79),
                Swap: t(1039)
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                if (!Array.isArray(e) || e.length < 2 || !Array.isArray(e[0]))
                    return !1;
                for (var f = e[0].length, r = 1; r < e.length; r++)
                    if (e[r].length !== f)
                        return !1;
                return !0
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                f === void 0 && (f = 0),
                r === void 0 && (r = e.length);
                var o = f + Math.floor(Math.random() * r);
                return e[o] === void 0 ? null : e[o]
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(9)
              , r = t(438)
              , o = new e({
                Extends: f,
                initialize: function() {
                    f.call(this),
                    this._pending = [],
                    this._active = [],
                    this._destroy = [],
                    this._toProcess = 0,
                    this.checkQueue = !1
                },
                add: function(a) {
                    return this._pending.push(a),
                    this._toProcess++,
                    a
                },
                remove: function(a) {
                    return this._destroy.push(a),
                    this._toProcess++,
                    a
                },
                removeAll: function() {
                    for (var a = this._active, n = this._destroy, s = a.length; s--; )
                        n.push(a[s]),
                        this._toProcess++;
                    return this
                },
                update: function() {
                    if (this._toProcess === 0)
                        return this._active;
                    var a = this._destroy, n = this._active, s, l;
                    for (s = 0; s < a.length; s++) {
                        l = a[s];
                        var i = n.indexOf(l);
                        i !== -1 && (n.splice(i, 1),
                        this.emit(r.PROCESS_QUEUE_REMOVE, l))
                    }
                    for (a.length = 0,
                    a = this._pending,
                    s = 0; s < a.length; s++)
                        l = a[s],
                        (!this.checkQueue || this.checkQueue && n.indexOf(l) === -1) && (n.push(l),
                        this.emit(r.PROCESS_QUEUE_ADD, l));
                    return a.length = 0,
                    this._toProcess = 0,
                    n
                },
                getActive: function() {
                    return this._active
                },
                length: {
                    get: function() {
                        return this._active.length
                    }
                },
                destroy: function() {
                    this._toProcess = 0,
                    this._pending = [],
                    this._active = [],
                    this._destroy = []
                }
            });
            c.exports = o
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            function t(f, r) {
                return parseInt(f.getAttribute(r), 10)
            }
            var e = function(f, r, o, a, n) {
                o === void 0 && (o = 0),
                a === void 0 && (a = 0);
                var s = r.cutX
                  , l = r.cutY
                  , i = r.source.width
                  , h = r.source.height
                  , u = r.sourceIndex
                  , d = {}
                  , v = f.getElementsByTagName("info")[0]
                  , p = f.getElementsByTagName("common")[0];
                d.font = v.getAttribute("face"),
                d.size = t(v, "size"),
                d.lineHeight = t(p, "lineHeight") + a,
                d.chars = {};
                var g = f.getElementsByTagName("char")
                  , m = r !== void 0 && r.trimmed;
                if (m)
                    var x = r.height
                      , T = r.width;
                for (var E = 0; E < g.length; E++) {
                    var P = g[E]
                      , M = t(P, "id")
                      , L = String.fromCharCode(M)
                      , R = t(P, "x")
                      , O = t(P, "y")
                      , F = t(P, "width")
                      , B = t(P, "height");
                    m && (R < T && (T = R),
                    O < x && (x = O)),
                    m && x !== 0 && T !== 0 && (R -= r.x,
                    O -= r.y);
                    var N = (s + R) / i
                      , Y = (l + O) / h
                      , z = (s + R + F) / i
                      , W = (l + O + B) / h;
                    if (d.chars[M] = {
                        x: R,
                        y: O,
                        width: F,
                        height: B,
                        centerX: Math.floor(F / 2),
                        centerY: Math.floor(B / 2),
                        xOffset: t(P, "xoffset"),
                        yOffset: t(P, "yoffset"),
                        xAdvance: t(P, "xadvance") + o,
                        data: {},
                        kerning: {},
                        u0: N,
                        v0: Y,
                        u1: z,
                        v1: W
                    },
                    n && F !== 0 && B !== 0) {
                        var b = n.add(L, u, R, O, F, B);
                        b && b.setUVs(F, B, N, Y, z, W)
                    }
                }
                var D = f.getElementsByTagName("kerning");
                for (E = 0; E < D.length; E++) {
                    var I = D[E]
                      , G = t(I, "first")
                      , w = t(I, "second")
                      , U = t(I, "amount");
                    d.chars[w].kerning[G] = U
                }
                return d
            };
            c.exports = e
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1049)
              , f = t(440)
              , r = t(0)
              , o = t(11)
              , a = t(109)
              , n = t(15)
              , s = t(110)
              , l = new r({
                Extends: n,
                Mixins: [o.Alpha, o.BlendMode, o.Depth, o.Mask, o.Pipeline, o.ScrollFactor, o.Size, o.Texture, o.Transform, o.Visible, e],
                initialize: function(h, u, d, v, p) {
                    n.call(this, h, "Blitter"),
                    this.setTexture(v, p),
                    this.setPosition(u, d),
                    this.initPipeline(),
                    this.children = new s,
                    this.renderList = [],
                    this.dirty = !1
                },
                create: function(i, h, u, d, v) {
                    d === void 0 && (d = !0),
                    v === void 0 && (v = this.children.length),
                    u === void 0 ? u = this.frame : u instanceof a || (u = this.texture.get(u));
                    var p = new f(this,i,h,u,d);
                    return this.children.addAt(p, v, !1),
                    this.dirty = !0,
                    p
                },
                createFromCallback: function(i, h, u, d) {
                    for (var v = this.createMultiple(h, u, d), p = 0; p < v.length; p++) {
                        var g = v[p];
                        i.call(this, g, p)
                    }
                    return v
                },
                createMultiple: function(i, h, u) {
                    h === void 0 && (h = this.frame.name),
                    u === void 0 && (u = !0),
                    Array.isArray(h) || (h = [h]);
                    var d = []
                      , v = this;
                    return h.forEach(function(p) {
                        for (var g = 0; g < i; g++)
                            d.push(v.create(0, 0, p, u))
                    }),
                    d
                },
                childCanRender: function(i) {
                    return i.visible && i.alpha > 0
                },
                getRenderList: function() {
                    return this.dirty && (this.renderList = this.children.list.filter(this.childCanRender, this),
                    this.dirty = !1),
                    this.renderList
                },
                clear: function() {
                    this.children.removeAll(),
                    this.dirty = !0
                },
                preDestroy: function() {
                    this.children.destroy(),
                    this.renderList = []
                }
            });
            c.exports = l
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(208)
              , f = t(35)
              , r = t(0)
              , o = t(11)
              , a = t(75)
              , n = t(15)
              , s = t(10)
              , l = t(1052)
              , i = t(441)
              , h = t(3)
              , u = new r({
                Extends: n,
                Mixins: [o.AlphaSingle, o.BlendMode, o.ComputedSize, o.Depth, o.Mask, o.Pipeline, o.Transform, o.Visible, l],
                initialize: function(v, p, g, m) {
                    n.call(this, v, "Container"),
                    this.list = [],
                    this.exclusive = !0,
                    this.maxSize = -1,
                    this.position = 0,
                    this.localTransform = new o.TransformMatrix,
                    this.tempTransformMatrix = new o.TransformMatrix,
                    this._sortKey = "",
                    this._sysEvents = v.sys.events,
                    this.scrollFactorX = 1,
                    this.scrollFactorY = 1,
                    this.initPipeline(),
                    this.setPosition(p, g),
                    this.clearAlpha(),
                    this.setBlendMode(f.SKIP_CHECK),
                    m && this.add(m)
                },
                originX: {
                    get: function() {
                        return .5
                    }
                },
                originY: {
                    get: function() {
                        return .5
                    }
                },
                displayOriginX: {
                    get: function() {
                        return this.width * .5
                    }
                },
                displayOriginY: {
                    get: function() {
                        return this.height * .5
                    }
                },
                setExclusive: function(d) {
                    return d === void 0 && (d = !0),
                    this.exclusive = d,
                    this
                },
                getBounds: function(d) {
                    if (d === void 0 && (d = new s),
                    d.setTo(this.x, this.y, 0, 0),
                    this.parentContainer) {
                        var v = this.parentContainer.getBoundsTransformMatrix()
                          , p = v.transformPoint(this.x, this.y);
                        d.setTo(p.x, p.y, 0, 0)
                    }
                    if (this.list.length > 0) {
                        var g = this.list
                          , m = new s
                          , x = !1;
                        d.setEmpty();
                        for (var T = 0; T < g.length; T++) {
                            var E = g[T];
                            E.getBounds && (E.getBounds(m),
                            x ? i(m, d, d) : (d.setTo(m.x, m.y, m.width, m.height),
                            x = !0))
                        }
                    }
                    return d
                },
                addHandler: function(d) {
                    d.once(a.DESTROY, this.remove, this),
                    this.exclusive && (d.parentContainer && d.parentContainer.remove(d),
                    d.removeFromDisplayList(),
                    d.parentContainer = this)
                },
                removeHandler: function(d) {
                    d.off(a.DESTROY, this.remove),
                    this.exclusive && (d.parentContainer = null,
                    d.addToDisplayList())
                },
                pointToContainer: function(d, v) {
                    v === void 0 && (v = new h),
                    this.parentContainer ? this.parentContainer.pointToContainer(d, v) : v = new h(d.x,d.y);
                    var p = this.tempTransformMatrix;
                    return p.applyITRS(this.x, this.y, this.rotation, this.scaleX, this.scaleY),
                    p.invert(),
                    p.transformPoint(d.x, d.y, v),
                    v
                },
                getBoundsTransformMatrix: function() {
                    return this.getWorldTransformMatrix(this.tempTransformMatrix, this.localTransform)
                },
                add: function(d) {
                    return e.Add(this.list, d, this.maxSize, this.addHandler, this),
                    this
                },
                addAt: function(d, v) {
                    return e.AddAt(this.list, d, v, this.maxSize, this.addHandler, this),
                    this
                },
                getAt: function(d) {
                    return this.list[d]
                },
                getIndex: function(d) {
                    return this.list.indexOf(d)
                },
                sort: function(d, v) {
                    return d ? (v === void 0 && (v = function(p, g) {
                        return p[d] - g[d]
                    }
                    ),
                    e.StableSort(this.list, v),
                    this) : this
                },
                getByName: function(d) {
                    return e.GetFirst(this.list, "name", d)
                },
                getRandom: function(d, v) {
                    return e.GetRandom(this.list, d, v)
                },
                getFirst: function(d, v, p, g) {
                    return e.GetFirst(this.list, d, v, p, g)
                },
                getAll: function(d, v, p, g) {
                    return e.GetAll(this.list, d, v, p, g)
                },
                count: function(d, v, p, g) {
                    return e.CountAllMatching(this.list, d, v, p, g)
                },
                swap: function(d, v) {
                    return e.Swap(this.list, d, v),
                    this
                },
                moveTo: function(d, v) {
                    return e.MoveTo(this.list, d, v),
                    this
                },
                moveAbove: function(d, v) {
                    return e.MoveAbove(this.list, d, v),
                    this
                },
                moveBelow: function(d, v) {
                    return e.MoveBelow(this.list, d, v),
                    this
                },
                remove: function(d, v) {
                    var p = e.Remove(this.list, d, this.removeHandler, this);
                    if (v && p) {
                        Array.isArray(p) || (p = [p]);
                        for (var g = 0; g < p.length; g++)
                            p[g].destroy()
                    }
                    return this
                },
                removeAt: function(d, v) {
                    var p = e.RemoveAt(this.list, d, this.removeHandler, this);
                    return v && p && p.destroy(),
                    this
                },
                removeBetween: function(d, v, p) {
                    var g = e.RemoveBetween(this.list, d, v, this.removeHandler, this);
                    if (p)
                        for (var m = 0; m < g.length; m++)
                            g[m].destroy();
                    return this
                },
                removeAll: function(d) {
                    var v = e.RemoveBetween(this.list, 0, this.list.length, this.removeHandler, this);
                    if (d)
                        for (var p = 0; p < v.length; p++)
                            v[p].destroy();
                    return this
                },
                bringToTop: function(d) {
                    return e.BringToTop(this.list, d),
                    this
                },
                sendToBack: function(d) {
                    return e.SendToBack(this.list, d),
                    this
                },
                moveUp: function(d) {
                    return e.MoveUp(this.list, d),
                    this
                },
                moveDown: function(d) {
                    return e.MoveDown(this.list, d),
                    this
                },
                reverse: function() {
                    return this.list.reverse(),
                    this
                },
                shuffle: function() {
                    return e.Shuffle(this.list),
                    this
                },
                replace: function(d, v, p) {
                    var g = e.Replace(this.list, d, v);
                    return g && (this.addHandler(v),
                    this.removeHandler(d),
                    p && d.destroy()),
                    this
                },
                exists: function(d) {
                    return this.list.indexOf(d) > -1
                },
                setAll: function(d, v, p, g) {
                    return e.SetAll(this.list, d, v, p, g),
                    this
                },
                each: function(d, v) {
                    var p = [null], g, m = this.list.slice(), x = m.length;
                    for (g = 2; g < arguments.length; g++)
                        p.push(arguments[g]);
                    for (g = 0; g < x; g++)
                        p[0] = m[g],
                        d.apply(v, p);
                    return this
                },
                iterate: function(d, v) {
                    var p = [null], g;
                    for (g = 2; g < arguments.length; g++)
                        p.push(arguments[g]);
                    for (g = 0; g < this.list.length; g++)
                        p[0] = this.list[g],
                        d.apply(v, p);
                    return this
                },
                setScrollFactor: function(d, v, p) {
                    return v === void 0 && (v = d),
                    p === void 0 && (p = !1),
                    this.scrollFactorX = d,
                    this.scrollFactorY = v,
                    p && (e.SetAll(this.list, "scrollFactorX", d),
                    e.SetAll(this.list, "scrollFactorY", v)),
                    this
                },
                length: {
                    get: function() {
                        return this.list.length
                    }
                },
                first: {
                    get: function() {
                        return this.position = 0,
                        this.list.length > 0 ? this.list[0] : null
                    }
                },
                last: {
                    get: function() {
                        return this.list.length > 0 ? (this.position = this.list.length - 1,
                        this.list[this.position]) : null
                    }
                },
                next: {
                    get: function() {
                        return this.position < this.list.length ? (this.position++,
                        this.list[this.position]) : null
                    }
                },
                previous: {
                    get: function() {
                        return this.position > 0 ? (this.position--,
                        this.list[this.position]) : null
                    }
                },
                preDestroy: function() {
                    this.removeAll(!!this.exclusive),
                    this.localTransform.destroy(),
                    this.tempTransformMatrix.destroy(),
                    this.list = []
                }
            });
            c.exports = u
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(148)
              , f = t(0)
              , r = t(1057)
              , o = new f({
                Extends: e,
                Mixins: [r],
                initialize: function(n, s, l, i, h, u, d) {
                    e.call(this, n, s, l, i, h, u, d),
                    this.type = "DynamicBitmapText",
                    this.scrollX = 0,
                    this.scrollY = 0,
                    this.cropWidth = 0,
                    this.cropHeight = 0,
                    this.displayCallback,
                    this.callbackData = {
                        parent: this,
                        color: 0,
                        tint: {
                            topLeft: 0,
                            topRight: 0,
                            bottomLeft: 0,
                            bottomRight: 0
                        },
                        index: 0,
                        charCode: 0,
                        x: 0,
                        y: 0,
                        scale: 0,
                        rotation: 0,
                        data: 0
                    }
                },
                setSize: function(a, n) {
                    return this.cropWidth = a,
                    this.cropHeight = n,
                    this
                },
                setDisplayCallback: function(a) {
                    return this.displayCallback = a,
                    this
                },
                setScrollX: function(a) {
                    return this.scrollX = a,
                    this
                },
                setScrollY: function(a) {
                    return this.scrollY = a,
                    this
                }
            });
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(133)
              , f = t(0)
              , r = t(217)
              , o = t(303)
              , a = t(304)
              , n = t(305)
              , s = t(309)
              , l = t(167)
              , i = t(312)
              , h = t(313)
              , u = t(314)
              , d = t(111)
              , v = t(15)
              , p = t(2)
              , g = t(6)
              , m = t(14)
              , x = t(1063)
              , T = new f({
                Extends: v,
                Mixins: [o, a, n, s, l, h, u, i, x],
                initialize: function(P, M) {
                    var L = g(M, "x", 0)
                      , R = g(M, "y", 0);
                    v.call(this, P, "Graphics"),
                    this.setPosition(L, R),
                    this.initPipeline(),
                    this.displayOriginX = 0,
                    this.displayOriginY = 0,
                    this.commandBuffer = [],
                    this.defaultFillColor = -1,
                    this.defaultFillAlpha = 1,
                    this.defaultStrokeWidth = 1,
                    this.defaultStrokeColor = -1,
                    this.defaultStrokeAlpha = 1,
                    this._lineWidth = 1,
                    this.setDefaultStyles(M)
                },
                setDefaultStyles: function(E) {
                    return g(E, "lineStyle", null) && (this.defaultStrokeWidth = g(E, "lineStyle.width", 1),
                    this.defaultStrokeColor = g(E, "lineStyle.color", 16777215),
                    this.defaultStrokeAlpha = g(E, "lineStyle.alpha", 1),
                    this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha)),
                    g(E, "fillStyle", null) && (this.defaultFillColor = g(E, "fillStyle.color", 16777215),
                    this.defaultFillAlpha = g(E, "fillStyle.alpha", 1),
                    this.fillStyle(this.defaultFillColor, this.defaultFillAlpha)),
                    this
                },
                lineStyle: function(E, P, M) {
                    return M === void 0 && (M = 1),
                    this.commandBuffer.push(r.LINE_STYLE, E, P, M),
                    this._lineWidth = E,
                    this
                },
                fillStyle: function(E, P) {
                    return P === void 0 && (P = 1),
                    this.commandBuffer.push(r.FILL_STYLE, E, P),
                    this
                },
                fillGradientStyle: function(E, P, M, L, R, O, F, B) {
                    return R === void 0 && (R = 1),
                    O === void 0 && (O = R),
                    F === void 0 && (F = R),
                    B === void 0 && (B = R),
                    this.commandBuffer.push(r.GRADIENT_FILL_STYLE, R, O, F, B, E, P, M, L),
                    this
                },
                lineGradientStyle: function(E, P, M, L, R, O) {
                    return O === void 0 && (O = 1),
                    this.commandBuffer.push(r.GRADIENT_LINE_STYLE, E, O, P, M, L, R),
                    this
                },
                beginPath: function() {
                    return this.commandBuffer.push(r.BEGIN_PATH),
                    this
                },
                closePath: function() {
                    return this.commandBuffer.push(r.CLOSE_PATH),
                    this
                },
                fillPath: function() {
                    return this.commandBuffer.push(r.FILL_PATH),
                    this
                },
                fill: function() {
                    return this.commandBuffer.push(r.FILL_PATH),
                    this
                },
                strokePath: function() {
                    return this.commandBuffer.push(r.STROKE_PATH),
                    this
                },
                stroke: function() {
                    return this.commandBuffer.push(r.STROKE_PATH),
                    this
                },
                fillCircleShape: function(E) {
                    return this.fillCircle(E.x, E.y, E.radius)
                },
                strokeCircleShape: function(E) {
                    return this.strokeCircle(E.x, E.y, E.radius)
                },
                fillCircle: function(E, P, M) {
                    return this.beginPath(),
                    this.arc(E, P, M, 0, m.PI2),
                    this.fillPath(),
                    this
                },
                strokeCircle: function(E, P, M) {
                    return this.beginPath(),
                    this.arc(E, P, M, 0, m.PI2),
                    this.strokePath(),
                    this
                },
                fillRectShape: function(E) {
                    return this.fillRect(E.x, E.y, E.width, E.height)
                },
                strokeRectShape: function(E) {
                    return this.strokeRect(E.x, E.y, E.width, E.height)
                },
                fillRect: function(E, P, M, L) {
                    return this.commandBuffer.push(r.FILL_RECT, E, P, M, L),
                    this
                },
                strokeRect: function(E, P, M, L) {
                    var R = this._lineWidth / 2
                      , O = E - R
                      , F = E + R;
                    return this.beginPath(),
                    this.moveTo(E, P),
                    this.lineTo(E, P + L),
                    this.strokePath(),
                    this.beginPath(),
                    this.moveTo(E + M, P),
                    this.lineTo(E + M, P + L),
                    this.strokePath(),
                    this.beginPath(),
                    this.moveTo(O, P),
                    this.lineTo(F + M, P),
                    this.strokePath(),
                    this.beginPath(),
                    this.moveTo(O, P + L),
                    this.lineTo(F + M, P + L),
                    this.strokePath(),
                    this
                },
                fillRoundedRect: function(E, P, M, L, R) {
                    R === void 0 && (R = 20);
                    var O = R
                      , F = R
                      , B = R
                      , N = R;
                    return typeof R != "number" && (O = p(R, "tl", 20),
                    F = p(R, "tr", 20),
                    B = p(R, "bl", 20),
                    N = p(R, "br", 20)),
                    this.beginPath(),
                    this.moveTo(E + O, P),
                    this.lineTo(E + M - F, P),
                    this.arc(E + M - F, P + F, F, -m.TAU, 0),
                    this.lineTo(E + M, P + L - N),
                    this.arc(E + M - N, P + L - N, N, 0, m.TAU),
                    this.lineTo(E + B, P + L),
                    this.arc(E + B, P + L - B, B, m.TAU, Math.PI),
                    this.lineTo(E, P + O),
                    this.arc(E + O, P + O, O, -Math.PI, -m.TAU),
                    this.fillPath(),
                    this
                },
                strokeRoundedRect: function(E, P, M, L, R) {
                    R === void 0 && (R = 20);
                    var O = R
                      , F = R
                      , B = R
                      , N = R;
                    return typeof R != "number" && (O = p(R, "tl", 20),
                    F = p(R, "tr", 20),
                    B = p(R, "bl", 20),
                    N = p(R, "br", 20)),
                    this.beginPath(),
                    this.moveTo(E + O, P),
                    this.lineTo(E + M - F, P),
                    this.moveTo(E + M - F, P),
                    this.arc(E + M - F, P + F, F, -m.TAU, 0),
                    this.lineTo(E + M, P + L - N),
                    this.moveTo(E + M, P + L - N),
                    this.arc(E + M - N, P + L - N, N, 0, m.TAU),
                    this.lineTo(E + B, P + L),
                    this.moveTo(E + B, P + L),
                    this.arc(E + B, P + L - B, B, m.TAU, Math.PI),
                    this.lineTo(E, P + O),
                    this.moveTo(E, P + O),
                    this.arc(E + O, P + O, O, -Math.PI, -m.TAU),
                    this.strokePath(),
                    this
                },
                fillPointShape: function(E, P) {
                    return this.fillPoint(E.x, E.y, P)
                },
                fillPoint: function(E, P, M) {
                    return !M || M < 1 ? M = 1 : (E -= M / 2,
                    P -= M / 2),
                    this.commandBuffer.push(r.FILL_RECT, E, P, M, M),
                    this
                },
                fillTriangleShape: function(E) {
                    return this.fillTriangle(E.x1, E.y1, E.x2, E.y2, E.x3, E.y3)
                },
                strokeTriangleShape: function(E) {
                    return this.strokeTriangle(E.x1, E.y1, E.x2, E.y2, E.x3, E.y3)
                },
                fillTriangle: function(E, P, M, L, R, O) {
                    return this.commandBuffer.push(r.FILL_TRIANGLE, E, P, M, L, R, O),
                    this
                },
                strokeTriangle: function(E, P, M, L, R, O) {
                    return this.commandBuffer.push(r.STROKE_TRIANGLE, E, P, M, L, R, O),
                    this
                },
                strokeLineShape: function(E) {
                    return this.lineBetween(E.x1, E.y1, E.x2, E.y2)
                },
                lineBetween: function(E, P, M, L) {
                    return this.beginPath(),
                    this.moveTo(E, P),
                    this.lineTo(M, L),
                    this.strokePath(),
                    this
                },
                lineTo: function(E, P) {
                    return this.commandBuffer.push(r.LINE_TO, E, P),
                    this
                },
                moveTo: function(E, P) {
                    return this.commandBuffer.push(r.MOVE_TO, E, P),
                    this
                },
                strokePoints: function(E, P, M, L) {
                    P === void 0 && (P = !1),
                    M === void 0 && (M = !1),
                    L === void 0 && (L = E.length),
                    this.beginPath(),
                    this.moveTo(E[0].x, E[0].y);
                    for (var R = 1; R < L; R++)
                        this.lineTo(E[R].x, E[R].y);
                    return P && this.lineTo(E[0].x, E[0].y),
                    M && this.closePath(),
                    this.strokePath(),
                    this
                },
                fillPoints: function(E, P, M, L) {
                    P === void 0 && (P = !1),
                    M === void 0 && (M = !1),
                    L === void 0 && (L = E.length),
                    this.beginPath(),
                    this.moveTo(E[0].x, E[0].y);
                    for (var R = 1; R < L; R++)
                        this.lineTo(E[R].x, E[R].y);
                    return P && this.lineTo(E[0].x, E[0].y),
                    M && this.closePath(),
                    this.fillPath(),
                    this
                },
                strokeEllipseShape: function(E, P) {
                    P === void 0 && (P = 32);
                    var M = E.getPoints(P);
                    return this.strokePoints(M, !0)
                },
                strokeEllipse: function(E, P, M, L, R) {
                    R === void 0 && (R = 32);
                    var O = new d(E,P,M,L)
                      , F = O.getPoints(R);
                    return this.strokePoints(F, !0)
                },
                fillEllipseShape: function(E, P) {
                    P === void 0 && (P = 32);
                    var M = E.getPoints(P);
                    return this.fillPoints(M, !0)
                },
                fillEllipse: function(E, P, M, L, R) {
                    R === void 0 && (R = 32);
                    var O = new d(E,P,M,L)
                      , F = O.getPoints(R);
                    return this.fillPoints(F, !0)
                },
                arc: function(E, P, M, L, R, O, F) {
                    return O === void 0 && (O = !1),
                    F === void 0 && (F = 0),
                    this.commandBuffer.push(r.ARC, E, P, M, L, R, O, F),
                    this
                },
                slice: function(E, P, M, L, R, O, F) {
                    return O === void 0 && (O = !1),
                    F === void 0 && (F = 0),
                    this.commandBuffer.push(r.BEGIN_PATH),
                    this.commandBuffer.push(r.MOVE_TO, E, P),
                    this.commandBuffer.push(r.ARC, E, P, M, L, R, O, F),
                    this.commandBuffer.push(r.CLOSE_PATH),
                    this
                },
                save: function() {
                    return this.commandBuffer.push(r.SAVE),
                    this
                },
                restore: function() {
                    return this.commandBuffer.push(r.RESTORE),
                    this
                },
                translateCanvas: function(E, P) {
                    return this.commandBuffer.push(r.TRANSLATE, E, P),
                    this
                },
                scaleCanvas: function(E, P) {
                    return this.commandBuffer.push(r.SCALE, E, P),
                    this
                },
                rotateCanvas: function(E) {
                    return this.commandBuffer.push(r.ROTATE, E),
                    this
                },
                clear: function() {
                    return this.commandBuffer.length = 0,
                    this.defaultFillColor > -1 && this.fillStyle(this.defaultFillColor, this.defaultFillAlpha),
                    this.defaultStrokeColor > -1 && this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha),
                    this
                },
                generateTexture: function(E, P, M) {
                    var L = this.scene.sys
                      , R = L.game.renderer;
                    P === void 0 && (P = L.scale.width),
                    M === void 0 && (M = L.scale.height),
                    T.TargetCamera.setScene(this.scene),
                    T.TargetCamera.setViewport(0, 0, P, M),
                    T.TargetCamera.scrollX = this.x,
                    T.TargetCamera.scrollY = this.y;
                    var O, F;
                    if (typeof E == "string")
                        if (L.textures.exists(E)) {
                            O = L.textures.get(E);
                            var B = O.getSourceImage();
                            B instanceof HTMLCanvasElement && (F = B.getContext("2d"))
                        } else
                            O = L.textures.createCanvas(E, P, M),
                            F = O.getSourceImage().getContext("2d");
                    else
                        E instanceof HTMLCanvasElement && (F = E.getContext("2d"));
                    return F && (this.renderCanvas(R, this, T.TargetCamera, null, F, !1),
                    O && O.refresh()),
                    this
                },
                preDestroy: function() {
                    this.commandBuffer = []
                }
            });
            T.TargetCamera = new e,
            c.exports = T
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                ARC: 0,
                BEGIN_PATH: 1,
                CLOSE_PATH: 2,
                FILL_RECT: 3,
                LINE_TO: 4,
                MOVE_TO: 5,
                LINE_STYLE: 6,
                FILL_STYLE: 7,
                FILL_PATH: 8,
                STROKE_PATH: 9,
                FILL_TRIANGLE: 10,
                STROKE_TRIANGLE: 11,
                SAVE: 14,
                RESTORE: 15,
                TRANSLATE: 16,
                SCALE: 17,
                ROTATE: 18,
                GRADIENT_FILL_STYLE: 21,
                GRADIENT_LINE_STYLE: 22
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4)
              , f = function(r, o, a) {
                a === void 0 && (a = new e);
                var n = r.width / 2
                  , s = r.height / 2;
                return a.x = r.x + n * Math.cos(o),
                a.y = r.y + s * Math.sin(o),
                a
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(35)
              , f = t(0)
              , r = t(11)
              , o = t(176)
              , a = t(101)
              , n = t(9)
              , s = t(75)
              , l = t(110)
              , i = t(1071)
              , h = t(20)
              , u = t(79)
              , d = new f({
                Extends: l,
                Mixins: [r.AlphaSingle, r.BlendMode, r.Depth, r.Mask, r.Pipeline, r.Visible, n, i],
                initialize: function(p, g) {
                    l.call(this, p),
                    n.call(this),
                    this.scene = p,
                    this.displayList = null,
                    this.type = "Layer",
                    this.state = 0,
                    this.parentContainer = null,
                    this.name = "",
                    this.active = !0,
                    this.tabIndex = -1,
                    this.data = null,
                    this.renderFlags = 15,
                    this.cameraFilter = 0,
                    this.input = null,
                    this.body = null,
                    this.ignoreDestroy = !1,
                    this.systems = p.sys,
                    this.events = p.sys.events,
                    this.sortChildrenFlag = !1,
                    this.addCallback = this.addChildCallback,
                    this.removeCallback = this.removeChildCallback,
                    this.initPipeline(),
                    this.clearAlpha(),
                    this.setBlendMode(e.SKIP_CHECK),
                    g && this.add(g),
                    p.sys.queueDepthSort()
                },
                setActive: function(v) {
                    return this.active = v,
                    this
                },
                setName: function(v) {
                    return this.name = v,
                    this
                },
                setState: function(v) {
                    return this.state = v,
                    this
                },
                setDataEnabled: function() {
                    return this.data || (this.data = new a(this)),
                    this
                },
                setData: function(v, p) {
                    return this.data || (this.data = new a(this)),
                    this.data.set(v, p),
                    this
                },
                incData: function(v, p) {
                    return this.data || (this.data = new a(this)),
                    this.data.inc(v, p),
                    this
                },
                toggleData: function(v) {
                    return this.data || (this.data = new a(this)),
                    this.data.toggle(v),
                    this
                },
                getData: function(v) {
                    return this.data || (this.data = new a(this)),
                    this.data.get(v)
                },
                setInteractive: function() {
                    return this
                },
                disableInteractive: function() {
                    return this
                },
                removeInteractive: function() {
                    return this
                },
                addedToScene: function() {},
                removedFromScene: function() {},
                update: function() {},
                toJSON: function() {
                    return o(this)
                },
                willRender: function(v) {
                    return !(this.renderFlags !== 15 || this.list.length === 0 || this.cameraFilter !== 0 && this.cameraFilter & v.id)
                },
                getIndexList: function() {
                    for (var v = this, p = this.parentContainer, g = []; p && (g.unshift(p.getIndex(v)),
                    v = p,
                    p.parentContainer); )
                        p = p.parentContainer;
                    return g.unshift(this.displayList.getIndex(v)),
                    g
                },
                addChildCallback: function(v) {
                    v.displayList && v.displayList !== this && v.removeFromDisplayList(),
                    v.displayList || (this.queueDepthSort(),
                    v.displayList = this,
                    v.emit(s.ADDED_TO_SCENE, v, this.scene),
                    this.events.emit(h.ADDED_TO_SCENE, v, this.scene))
                },
                removeChildCallback: function(v) {
                    this.queueDepthSort(),
                    v.displayList = null,
                    v.emit(s.REMOVED_FROM_SCENE, v, this.scene),
                    this.events.emit(h.REMOVED_FROM_SCENE, v, this.scene)
                },
                queueDepthSort: function() {
                    this.sortChildrenFlag = !0
                },
                depthSort: function() {
                    this.sortChildrenFlag && (u(this.list, this.sortByDepth),
                    this.sortChildrenFlag = !1)
                },
                sortByDepth: function(v, p) {
                    return v._depth - p._depth
                },
                getChildren: function() {
                    return this.list
                },
                destroy: function() {
                    if (!(!this.scene || this.ignoreDestroy)) {
                        this.emit(s.DESTROY, this);
                        for (var v = this.list.length; v--; )
                            this.list[v].destroy();
                        this.removeAllListeners(),
                        this.resetPostPipeline(!0),
                        this.displayList && (this.displayList.remove(this, !0),
                        this.displayList.queueDepthSort()),
                        this.data && (this.data.destroy(),
                        this.data = void 0),
                        this.active = !1,
                        this.visible = !1,
                        this.list = void 0,
                        this.scene = void 0,
                        this.displayList = void 0,
                        this.systems = void 0,
                        this.events = void 0
                    }
                }
            });
            c.exports = d
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(11)
              , r = t(15)
              , o = t(450)
              , a = t(110)
              , n = t(452)
              , s = t(1075)
              , l = new e({
                Extends: r,
                Mixins: [f.Depth, f.Mask, f.Pipeline, f.Transform, f.Visible, s],
                initialize: function(h, u, d, v) {
                    if (r.call(this, h, "ParticleEmitterManager"),
                    this.blendMode = -1,
                    this.timeScale = 1,
                    this.texture = null,
                    this.frame = null,
                    this.frameNames = [],
                    d !== null && (typeof d == "object" || Array.isArray(d)) && (v = d,
                    d = null),
                    this.setTexture(u, d),
                    this.initPipeline(),
                    this.emitters = new a(this),
                    this.wells = new a(this),
                    v) {
                        Array.isArray(v) || (v = [v]);
                        for (var p = 0; p < v.length; p++)
                            this.createEmitter(v[p])
                    }
                },
                addedToScene: function() {
                    this.scene.sys.updateList.add(this)
                },
                removedFromScene: function() {
                    this.scene.sys.updateList.remove(this)
                },
                setTexture: function(i, h) {
                    return this.texture = this.scene.sys.textures.get(i),
                    this.setFrame(h)
                },
                setFrame: function(i) {
                    this.frame = this.texture.get(i);
                    var h = this.texture.getFramesFromTextureSource(this.frame.sourceIndex)
                      , u = [];
                    return h.forEach(function(d) {
                        u.push(d.name)
                    }),
                    this.frameNames = u,
                    this.defaultFrame = this.frame,
                    this
                },
                setEmitterFrames: function(i, h) {
                    Array.isArray(i) || (i = [i]);
                    var u = h.frames;
                    u.length = 0;
                    for (var d = 0; d < i.length; d++) {
                        var v = i[d];
                        this.frameNames.indexOf(v) !== -1 && u.push(this.texture.get(v))
                    }
                    return u.length > 0 ? h.defaultFrame = u[0] : h.defaultFrame = this.defaultFrame,
                    this
                },
                addEmitter: function(i) {
                    return this.emitters.add(i)
                },
                createEmitter: function(i) {
                    return this.addEmitter(new n(this,i))
                },
                removeEmitter: function(i) {
                    return this.emitters.remove(i, !0)
                },
                addGravityWell: function(i) {
                    return this.wells.add(i)
                },
                createGravityWell: function(i) {
                    return this.addGravityWell(new o(i))
                },
                emitParticle: function(i, h, u) {
                    for (var d = this.emitters.list, v = 0; v < d.length; v++) {
                        var p = d[v];
                        p.active && p.emitParticle(i, h, u)
                    }
                    return this
                },
                emitParticleAt: function(i, h, u) {
                    return this.emitParticle(u, i, h)
                },
                pause: function() {
                    return this.active = !1,
                    this
                },
                resume: function() {
                    return this.active = !0,
                    this
                },
                getProcessors: function() {
                    return this.wells.getAll("active", !0)
                },
                preUpdate: function(i, h) {
                    h *= this.timeScale;
                    for (var u = this.emitters.list, d = 0; d < u.length; d++) {
                        var v = u[d];
                        v.active && v.preUpdate(i, h)
                    }
                },
                setAlpha: function() {},
                setScrollFactor: function() {},
                setBlendMode: function() {}
            });
            c.exports = l
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(35)
              , f = t(133)
              , r = t(31)
              , o = t(0)
              , a = t(11)
              , n = t(33)
              , s = t(109)
              , l = t(15)
              , i = t(1)
              , h = t(92)
              , u = t(1079)
              , d = t(141)
              , v = t(12)
              , p = t(222)
              , g = new o({
                Extends: l,
                Mixins: [a.Alpha, a.BlendMode, a.ComputedSize, a.Crop, a.Depth, a.Flip, a.GetBounds, a.Mask, a.Origin, a.Pipeline, a.ScrollFactor, a.Tint, a.Transform, a.Visible, u],
                initialize: function(x, T, E, P, M, L, R) {
                    T === void 0 && (T = 0),
                    E === void 0 && (E = 0),
                    P === void 0 && (P = 32),
                    M === void 0 && (M = 32),
                    l.call(this, x, "RenderTexture"),
                    this.renderer = x.sys.renderer,
                    this.textureManager = x.sys.textures,
                    this.globalTint = 16777215,
                    this.globalAlpha = 1,
                    this.canvas = null,
                    this.dirty = !1,
                    this._crop = this.resetCropObject(),
                    this.texture = null,
                    this.frame = null,
                    this._saved = !1,
                    L === void 0 ? (this.canvas = r.create2D(this, P, M),
                    this.texture = x.sys.textures.addCanvas(p(), this.canvas),
                    this.frame = this.texture.get()) : (this.texture = x.sys.textures.get(L),
                    this.frame = this.texture.get(R),
                    this.canvas = this.frame.source.image,
                    this._saved = !0,
                    this.dirty = !0,
                    this.width = this.frame.cutWidth,
                    this.height = this.frame.cutHeight),
                    this.context = this.canvas.getContext("2d"),
                    this._eraseMode = !1,
                    this.camera = new f(0,0,P,M),
                    this.renderTarget = null;
                    var O = this.renderer;
                    O ? O.type === n.WEBGL ? (this.drawGameObject = this.batchGameObjectWebGL,
                    this.renderTarget = new d(O,P,M,1,0,!1)) : O.type === n.CANVAS && (this.drawGameObject = this.batchGameObjectCanvas) : this.drawGameObject = i,
                    this.camera.setScene(x),
                    this.setPosition(T, E),
                    L === void 0 && this.setSize(P, M),
                    this.setOrigin(0, 0),
                    this.initPipeline(h.SINGLE_PIPELINE)
                },
                setSize: function(m, x) {
                    return this.resize(m, x)
                },
                resize: function(m, x) {
                    x === void 0 && (x = m);
                    var T = this.frame;
                    if (m !== this.width || x !== this.height) {
                        if (T.name === "__BASE") {
                            this.canvas.width = m,
                            this.canvas.height = x,
                            this.texture.width = m,
                            this.texture.height = x;
                            var E = this.renderTarget;
                            E && (E.resize(m, x),
                            T.glTexture = E.texture,
                            T.source.isRenderTexture = !0,
                            T.source.isGLTexture = !0,
                            T.source.glTexture = E.texture),
                            this.camera.setSize(m, x),
                            T.source.width = m,
                            T.source.height = x,
                            T.setSize(m, x),
                            this.width = m,
                            this.height = x
                        }
                    } else {
                        var P = this.texture.getSourceImage();
                        T.cutX + m > P.width && (m = P.width - T.cutX),
                        T.cutY + x > P.height && (x = P.height - T.cutY),
                        T.setSize(m, x, T.cutX, T.cutY)
                    }
                    this.updateDisplayOrigin();
                    var M = this.input;
                    return M && !M.customHitArea && (M.hitArea.width = m,
                    M.hitArea.height = x),
                    this
                },
                setGlobalTint: function(m) {
                    return this.globalTint = m,
                    this
                },
                setGlobalAlpha: function(m) {
                    return this.globalAlpha = m,
                    this
                },
                saveTexture: function(m) {
                    return this.textureManager.renameTexture(this.texture.key, m),
                    this._saved = !0,
                    this.texture
                },
                fill: function(m, x, T, E, P, M) {
                    var L = this.frame
                      , R = this.camera
                      , O = this.renderer;
                    x === void 0 && (x = 1),
                    T === void 0 && (T = 0),
                    E === void 0 && (E = 0),
                    P === void 0 && (P = L.cutWidth),
                    M === void 0 && (M = L.cutHeight);
                    var F = (m >> 16 & 255) / 255
                      , B = (m >> 8 & 255) / 255
                      , N = (m & 255) / 255
                      , Y = this.renderTarget;
                    if (R.preRender(),
                    Y) {
                        Y.bind(!0);
                        var z = this.pipeline;
                        z.manager.set(z);
                        var W = Y.width
                          , b = Y.height
                          , D = O.width
                          , I = O.height
                          , G = D / W
                          , w = I / b;
                        z.drawFillRect(T * G, E * w, P * G, M * w, v.getTintFromFloats(N, B, F, 1), x),
                        Y.unbind(!0)
                    } else {
                        var U = this.context;
                        O.setContext(U),
                        U.fillStyle = "rgba(" + F + "," + B + "," + N + "," + x + ")",
                        U.fillRect(T + L.cutX, E + L.cutY, P, M),
                        O.setContext()
                    }
                    return this.dirty = !0,
                    this
                },
                clear: function() {
                    if (this.dirty) {
                        var m = this.renderTarget;
                        if (m)
                            m.clear();
                        else {
                            var x = this.context;
                            x.save(),
                            x.setTransform(1, 0, 0, 1, 0, 0),
                            x.clearRect(this.frame.cutX, this.frame.cutY, this.frame.cutWidth, this.frame.cutHeight),
                            x.restore()
                        }
                        this.dirty = !1
                    }
                    return this
                },
                erase: function(m, x, T) {
                    return this._eraseMode = !0,
                    this.draw(m, x, T, 1, 16777215),
                    this._eraseMode = !1,
                    this
                },
                draw: function(m, x, T, E, P) {
                    return this.beginDraw(),
                    this.batchDraw(m, x, T, E, P),
                    this.endDraw(),
                    this
                },
                drawFrame: function(m, x, T, E, P, M) {
                    return this.beginDraw(),
                    this.batchDrawFrame(m, x, T, E, P, M),
                    this.endDraw(),
                    this
                },
                beginDraw: function() {
                    var m = this.camera
                      , x = this.renderer
                      , T = this.renderTarget;
                    return m.preRender(),
                    T ? x.beginCapture(T.width, T.height) : x.setContext(this.context),
                    this
                },
                batchDraw: function(m, x, T, E, P) {
                    return E === void 0 && (E = this.globalAlpha),
                    P === void 0 ? P = (this.globalTint >> 16) + (this.globalTint & 65280) + ((this.globalTint & 255) << 16) : P = (P >> 16) + (P & 65280) + ((P & 255) << 16),
                    Array.isArray(m) || (m = [m]),
                    this.batchList(m, x, T, E, P),
                    this
                },
                batchDrawFrame: function(m, x, T, E, P, M) {
                    T === void 0 && (T = 0),
                    E === void 0 && (E = 0),
                    P === void 0 && (P = this.globalAlpha),
                    M === void 0 ? M = (this.globalTint >> 16) + (this.globalTint & 65280) + ((this.globalTint & 255) << 16) : M = (M >> 16) + (M & 65280) + ((M & 255) << 16);
                    var L = this.textureManager.getFrame(m, x);
                    return L && (this.renderTarget ? this.pipeline.batchTextureFrame(L, T, E, M, P, this.camera.matrix, null) : this.batchTextureFrame(L, T + this.frame.cutX, E + this.frame.cutY, P, M)),
                    this
                },
                endDraw: function(m) {
                    m === void 0 && (m = this._eraseMode);
                    var x = this.renderer
                      , T = this.renderTarget;
                    if (T) {
                        var E = x.endCapture()
                          , P = x.pipelines.setUtility();
                        P.blitFrame(E, T, 1, !1, !1, m),
                        x.resetScissor(),
                        x.resetViewport()
                    } else
                        x.setContext();
                    return this.dirty = !0,
                    this
                },
                batchList: function(m, x, T, E, P) {
                    for (var M = 0; M < m.length; M++) {
                        var L = m[M];
                        !L || L === this || (L.renderWebGL || L.renderCanvas ? this.drawGameObject(L, x, T) : L.isParent || L.list ? this.batchGroup(L.getChildren(), x, T) : typeof L == "string" ? this.batchTextureFrameKey(L, null, x, T, E, P) : L instanceof s ? this.batchTextureFrame(L, x, T, E, P) : Array.isArray(L) && this.batchList(L, x, T, E, P))
                    }
                },
                batchGroup: function(m, x, T) {
                    x === void 0 && (x = 0),
                    T === void 0 && (T = 0),
                    x += this.frame.cutX,
                    T += this.frame.cutY;
                    for (var E = 0; E < m.length; E++) {
                        var P = m[E];
                        if (P.willRender(this.camera)) {
                            var M = P.x + x
                              , L = P.y + T;
                            this.drawGameObject(P, M, L)
                        }
                    }
                },
                batchGameObjectWebGL: function(m, x, T) {
                    x === void 0 && (x = m.x),
                    T === void 0 && (T = m.y);
                    var E = m.x
                      , P = m.y;
                    m.setPosition(x + this.frame.cutX, T + this.frame.cutY),
                    m.renderDirect ? m.renderDirect(this.renderer, m, this.camera) : m.renderWebGL(this.renderer, m, this.camera),
                    m.setPosition(E, P)
                },
                batchGameObjectCanvas: function(m, x, T) {
                    x === void 0 && (x = m.x),
                    T === void 0 && (T = m.y);
                    var E = m.x
                      , P = m.y;
                    if (this._eraseMode) {
                        var M = m.blendMode;
                        m.blendMode = e.ERASE
                    }
                    m.setPosition(x + this.frame.cutX, T + this.frame.cutY),
                    m.renderCanvas(this.renderer, m, this.camera, null),
                    m.setPosition(E, P),
                    this._eraseMode && (m.blendMode = M)
                },
                batchTextureFrameKey: function(m, x, T, E, P, M) {
                    var L = this.textureManager.getFrame(m, x);
                    L && this.batchTextureFrame(L, T, E, P, M)
                },
                batchTextureFrame: function(m, x, T, E, P) {
                    x === void 0 && (x = 0),
                    T === void 0 && (T = 0),
                    x += this.frame.cutX,
                    T += this.frame.cutY;
                    var M = this.renderTarget;
                    if (M)
                        this.pipeline.batchTextureFrame(m, x, T, P, E, this.camera.matrix, null);
                    else {
                        var L = this.context
                          , R = m.canvasData
                          , O = m.source.image
                          , F = this.camera.matrix;
                        L.save(),
                        L.globalCompositeOperation = this._eraseMode ? "destination-out" : "source-over",
                        L.globalAlpha = E,
                        F.setToContext(L),
                        L.drawImage(O, R.x, R.y, R.width, R.height, x, T, R.width, R.height),
                        L.restore()
                    }
                },
                snapshotArea: function(m, x, T, E, P, M, L) {
                    return this.renderTarget ? this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, P, !1, m, x, T, E, M, L) : this.renderer.snapshotCanvas(this.canvas, P, !1, m, x, T, E, M, L),
                    this
                },
                snapshot: function(m, x, T) {
                    return this.renderTarget ? this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, m, !1, 0, 0, this.width, this.height, x, T) : this.renderer.snapshotCanvas(this.canvas, m, !1, 0, 0, this.width, this.height, x, T),
                    this
                },
                snapshotPixel: function(m, x, T) {
                    return this.renderTarget ? this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, T, !0, m, x) : this.renderer.snapshotCanvas(this.canvas, T, !0, m, x),
                    this
                },
                preDestroy: function() {
                    this._saved || (r.remove(this.canvas),
                    this.renderTarget && this.renderTarget.destroy(),
                    this.texture.destroy(),
                    this.camera.destroy(),
                    this.canvas = null,
                    this.context = null,
                    this.texture = null)
                }
            });
            c.exports = g
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function() {
                return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(e) {
                    var f = Math.random() * 16 | 0
                      , r = e === "x" ? f : f & 3 | 8;
                    return r.toString(16)
                })
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(164)
              , f = t(0)
              , r = t(11)
              , o = t(15)
              , a = t(92)
              , n = t(1085)
              , s = t(3)
              , l = new f({
                Extends: o,
                Mixins: [r.AlphaSingle, r.BlendMode, r.Depth, r.Flip, r.Mask, r.Pipeline, r.Size, r.Texture, r.Transform, r.Visible, r.ScrollFactor, n],
                initialize: function(h, u, d, v, p, g, m, x, T) {
                    v === void 0 && (v = "__DEFAULT"),
                    g === void 0 && (g = 2),
                    m === void 0 && (m = !0),
                    o.call(this, h, "Rope"),
                    this.anims = new e(this),
                    this.points = g,
                    this.vertices,
                    this.uv,
                    this.colors,
                    this.alphas,
                    this.tintFill = v === "__DEFAULT",
                    this.dirty = !1,
                    this.horizontal = m,
                    this._flipX = !1,
                    this._flipY = !1,
                    this._perp = new s,
                    this.debugCallback = null,
                    this.debugGraphic = null,
                    this.setTexture(v, p),
                    this.setPosition(u, d),
                    this.setSizeToFrame(),
                    this.initPipeline(a.ROPE_PIPELINE),
                    Array.isArray(g) && this.resizeArrays(g.length),
                    this.setPoints(g, x, T),
                    this.updateVertices()
                },
                addedToScene: function() {
                    this.scene.sys.updateList.add(this)
                },
                removedFromScene: function() {
                    this.scene.sys.updateList.remove(this)
                },
                preUpdate: function(i, h) {
                    var u = this.anims.currentFrame;
                    this.anims.update(i, h),
                    this.anims.currentFrame !== u && (this.updateUVs(),
                    this.updateVertices())
                },
                play: function(i, h, u) {
                    return this.anims.play(i, h, u),
                    this
                },
                setDirty: function() {
                    return this.dirty = !0,
                    this
                },
                setHorizontal: function(i, h, u) {
                    return i === void 0 && (i = this.points.length),
                    this.horizontal ? this : (this.horizontal = !0,
                    this.setPoints(i, h, u))
                },
                setVertical: function(i, h, u) {
                    return i === void 0 && (i = this.points.length),
                    this.horizontal ? (this.horizontal = !1,
                    this.setPoints(i, h, u)) : this
                },
                setTintFill: function(i) {
                    return i === void 0 && (i = !1),
                    this.tintFill = i,
                    this
                },
                setAlphas: function(i, h) {
                    var u = this.points.length;
                    if (u < 1)
                        return this;
                    var d = this.alphas;
                    i === void 0 ? i = [1] : !Array.isArray(i) && h === void 0 && (i = [i]);
                    var v, p = 0;
                    if (h !== void 0)
                        for (v = 0; v < u; v++)
                            p = v * 2,
                            d[p] = i,
                            d[p + 1] = h;
                    else if (i.length === u)
                        for (v = 0; v < u; v++)
                            p = v * 2,
                            d[p] = i[v],
                            d[p + 1] = i[v];
                    else {
                        var g = i[0];
                        for (v = 0; v < u; v++)
                            p = v * 2,
                            i.length > p && (g = i[p]),
                            d[p] = g,
                            i.length > p + 1 && (g = i[p + 1]),
                            d[p + 1] = g
                    }
                    return this
                },
                setColors: function(i) {
                    var h = this.points.length;
                    if (h < 1)
                        return this;
                    var u = this.colors;
                    i === void 0 ? i = [16777215] : Array.isArray(i) || (i = [i]);
                    var d, v = 0;
                    if (i.length === h)
                        for (d = 0; d < h; d++)
                            v = d * 2,
                            u[v] = i[d],
                            u[v + 1] = i[d];
                    else {
                        var p = i[0];
                        for (d = 0; d < h; d++)
                            v = d * 2,
                            i.length > v && (p = i[v]),
                            u[v] = p,
                            i.length > v + 1 && (p = i[v + 1]),
                            u[v + 1] = p
                    }
                    return this
                },
                setPoints: function(i, h, u) {
                    if (i === void 0 && (i = 2),
                    typeof i == "number") {
                        var d = i;
                        d < 2 && (d = 2),
                        i = [];
                        var v, p, g;
                        if (this.horizontal)
                            for (g = -this.frame.halfWidth,
                            p = this.frame.width / (d - 1),
                            v = 0; v < d; v++)
                                i.push({
                                    x: g + v * p,
                                    y: 0
                                });
                        else
                            for (g = -this.frame.halfHeight,
                            p = this.frame.height / (d - 1),
                            v = 0; v < d; v++)
                                i.push({
                                    x: 0,
                                    y: g + v * p
                                })
                    }
                    var m = i.length
                      , x = this.points.length;
                    return m < 1 ? (console.warn("Rope: Not enough points given"),
                    this) : (m === 1 && (i.unshift({
                        x: 0,
                        y: 0
                    }),
                    m++),
                    x !== m && this.resizeArrays(m),
                    this.points = i,
                    this.updateUVs(),
                    h != null && this.setColors(h),
                    u != null && this.setAlphas(u),
                    this)
                },
                updateUVs: function() {
                    for (var i = this.uv, h = this.points.length, u = this.frame.u0, d = this.frame.v0, v = this.frame.u1, p = this.frame.v1, g = (v - u) / (h - 1), m = (p - d) / (h - 1), x = 0; x < h; x++) {
                        var T = x * 4, E, P, M, L;
                        this.horizontal ? (this._flipX ? (E = v - x * g,
                        M = v - x * g) : (E = u + x * g,
                        M = u + x * g),
                        this._flipY ? (P = p,
                        L = d) : (P = d,
                        L = p)) : (this._flipX ? (E = u,
                        M = v) : (E = v,
                        M = u),
                        this._flipY ? (P = p - x * m,
                        L = p - x * m) : (P = d + x * m,
                        L = d + x * m)),
                        i[T + 0] = E,
                        i[T + 1] = P,
                        i[T + 2] = M,
                        i[T + 3] = L
                    }
                    return this
                },
                resizeArrays: function(i) {
                    var h = this.colors
                      , u = this.alphas;
                    this.vertices = new Float32Array(i * 4),
                    this.uv = new Float32Array(i * 4),
                    h = new Uint32Array(i * 2),
                    u = new Float32Array(i * 2);
                    for (var d = 0; d < i * 2; d++)
                        h[d] = 16777215,
                        u[d] = 1;
                    return this.colors = h,
                    this.alphas = u,
                    this.dirty = !0,
                    this
                },
                updateVertices: function() {
                    var i = this._perp
                      , h = this.points
                      , u = this.vertices
                      , d = h.length;
                    if (this.dirty = !1,
                    !(d < 1)) {
                        for (var v, p = h[0], g = this.horizontal ? this.frame.halfHeight : this.frame.halfWidth, m = 0; m < d; m++) {
                            var x = h[m]
                              , T = m * 4;
                            m < d - 1 ? v = h[m + 1] : v = x,
                            i.x = v.y - p.y,
                            i.y = -(v.x - p.x);
                            var E = i.length();
                            i.x /= E,
                            i.y /= E,
                            i.x *= g,
                            i.y *= g,
                            u[T] = x.x + i.x,
                            u[T + 1] = x.y + i.y,
                            u[T + 2] = x.x - i.x,
                            u[T + 3] = x.y - i.y,
                            p = x
                        }
                        return this
                    }
                },
                setDebug: function(i, h) {
                    return this.debugGraphic = i,
                    !i && !h ? this.debugCallback = null : h ? this.debugCallback = h : this.debugCallback = this.renderDebugVerts,
                    this
                },
                renderDebugVerts: function(i, h, u) {
                    var d = i.debugGraphic
                      , v = u[0]
                      , p = u[1]
                      , g = u[2]
                      , m = u[3];
                    d.lineBetween(v, p, g, m);
                    for (var x = 4; x < h; x += 4) {
                        var T = u[x + 0]
                          , E = u[x + 1]
                          , P = u[x + 2]
                          , M = u[x + 3];
                        d.lineBetween(v, p, T, E),
                        d.lineBetween(g, m, P, M),
                        d.lineBetween(g, m, T, E),
                        d.lineBetween(T, E, P, M),
                        v = T,
                        p = E,
                        g = P,
                        m = M
                    }
                },
                preDestroy: function() {
                    this.anims.destroy(),
                    this.anims = void 0,
                    this.points = null,
                    this.vertices = null,
                    this.uv = null,
                    this.colors = null,
                    this.alphas = null,
                    this.debugCallback = null,
                    this.debugGraphic = null
                },
                flipX: {
                    get: function() {
                        return this._flipX
                    },
                    set: function(i) {
                        return this._flipX = i,
                        this.updateUVs()
                    }
                },
                flipY: {
                    get: function() {
                        return this._flipY
                    },
                    set: function(i) {
                        return this._flipY = i,
                        this.updateUVs()
                    }
                }
            });
            c.exports = l
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(142)
              , f = t(31)
              , r = t(0)
              , o = t(11)
              , a = t(22)
              , n = t(15)
              , s = t(458)
              , l = t(6)
              , i = t(202)
              , h = t(1088)
              , u = t(459)
              , d = new r({
                Extends: n,
                Mixins: [o.Alpha, o.BlendMode, o.ComputedSize, o.Crop, o.Depth, o.Flip, o.GetBounds, o.Mask, o.Origin, o.Pipeline, o.ScrollFactor, o.Tint, o.Transform, o.Visible, h],
                initialize: function(p, g, m, x, T) {
                    g === void 0 && (g = 0),
                    m === void 0 && (m = 0),
                    n.call(this, p, "Text"),
                    this.renderer = p.sys.renderer,
                    this.setPosition(g, m),
                    this.setOrigin(0, 0),
                    this.initPipeline(),
                    this.canvas = f.create(this),
                    this.context = this.canvas.getContext("2d"),
                    this.style = new u(this,T),
                    this.autoRound = !0,
                    this.splitRegExp = /(?:\r\n|\r|\n)/,
                    this._text = void 0,
                    this.padding = {
                        left: 0,
                        right: 0,
                        top: 0,
                        bottom: 0
                    },
                    this.width = 1,
                    this.height = 1,
                    this.lineSpacing = 0,
                    this.dirty = !1,
                    this.style.resolution === 0 && (this.style.resolution = 1),
                    this._crop = this.resetCropObject(),
                    this.texture = p.sys.textures.addCanvas(null, this.canvas, !0),
                    this.frame = this.texture.get(),
                    this.frame.source.resolution = this.style.resolution,
                    this.renderer && this.renderer.gl && (this.renderer.deleteTexture(this.frame.source.glTexture),
                    this.frame.source.glTexture = null),
                    this.initRTL(),
                    this.setText(x),
                    T && T.padding && this.setPadding(T.padding),
                    T && T.lineSpacing && this.setLineSpacing(T.lineSpacing),
                    p.sys.game.events.on(a.CONTEXT_RESTORED, function() {
                        this.dirty = !0
                    }, this)
                },
                initRTL: function() {
                    this.style.rtl && (this.canvas.dir = "rtl",
                    this.context.direction = "rtl",
                    this.canvas.style.display = "none",
                    e(this.canvas, this.scene.sys.canvas),
                    this.originX = 1)
                },
                runWordWrap: function(v) {
                    var p = this.style;
                    if (p.wordWrapCallback) {
                        var g = p.wordWrapCallback.call(p.wordWrapCallbackScope, v, this);
                        return Array.isArray(g) && (g = g.join(`
`)),
                        g
                    } else
                        return p.wordWrapWidth ? p.wordWrapUseAdvanced ? this.advancedWordWrap(v, this.context, this.style.wordWrapWidth) : this.basicWordWrap(v, this.context, this.style.wordWrapWidth) : v
                },
                advancedWordWrap: function(v, p, g) {
                    for (var m = "", x = v.replace(/ +/gi, " ").split(this.splitRegExp), T = x.length, E = 0; E < T; E++) {
                        var P = x[E]
                          , M = "";
                        P = P.replace(/^ *|\s*$/gi, "");
                        var L = p.measureText(P).width;
                        if (L < g) {
                            m += P + `
`;
                            continue
                        }
                        for (var R = g, O = P.split(" "), F = 0; F < O.length; F++) {
                            var B = O[F]
                              , N = B + " "
                              , Y = p.measureText(N).width;
                            if (Y > R) {
                                if (F === 0) {
                                    for (var z = N; z.length && (z = z.slice(0, -1),
                                    Y = p.measureText(z).width,
                                    !(Y <= R)); )
                                        ;
                                    if (!z.length)
                                        throw new Error("This text's wordWrapWidth setting is less than a single character!");
                                    var W = B.substr(z.length);
                                    O[F] = W,
                                    M += z
                                }
                                var b = O[F].length ? F : F + 1
                                  , D = O.slice(b).join(" ").replace(/[ \n]*$/gi, "");
                                x[E + 1] = D + " " + (x[E + 1] || ""),
                                T = x.length;
                                break
                            } else
                                M += N,
                                R -= Y
                        }
                        m += M.replace(/[ \n]*$/gi, "") + `
`
                    }
                    return m = m.replace(/[\s|\n]*$/gi, ""),
                    m
                },
                basicWordWrap: function(v, p, g) {
                    for (var m = "", x = v.split(this.splitRegExp), T = x.length - 1, E = p.measureText(" ").width, P = 0; P <= T; P++) {
                        for (var M = g, L = x[P].split(" "), R = L.length - 1, O = 0; O <= R; O++) {
                            var F = L[O]
                              , B = p.measureText(F).width
                              , N = B;
                            O < R && (N += E),
                            N > M && O > 0 && (m += `
`,
                            M = g),
                            m += F,
                            O < R ? (m += " ",
                            M -= N) : M -= B
                        }
                        P < T && (m += `
`)
                    }
                    return m
                },
                getWrappedText: function(v) {
                    v === void 0 && (v = this._text),
                    this.style.syncFont(this.canvas, this.context);
                    var p = this.runWordWrap(v);
                    return p.split(this.splitRegExp)
                },
                setText: function(v) {
                    return !v && v !== 0 && (v = ""),
                    Array.isArray(v) && (v = v.join(`
`)),
                    v !== this._text && (this._text = v.toString(),
                    this.updateText()),
                    this
                },
                setStyle: function(v) {
                    return this.style.setStyle(v)
                },
                setFont: function(v) {
                    return this.style.setFont(v)
                },
                setFontFamily: function(v) {
                    return this.style.setFontFamily(v)
                },
                setFontSize: function(v) {
                    return this.style.setFontSize(v)
                },
                setFontStyle: function(v) {
                    return this.style.setFontStyle(v)
                },
                setFixedSize: function(v, p) {
                    return this.style.setFixedSize(v, p)
                },
                setBackgroundColor: function(v) {
                    return this.style.setBackgroundColor(v)
                },
                setFill: function(v) {
                    return this.style.setFill(v)
                },
                setColor: function(v) {
                    return this.style.setColor(v)
                },
                setStroke: function(v, p) {
                    return this.style.setStroke(v, p)
                },
                setShadow: function(v, p, g, m, x, T) {
                    return this.style.setShadow(v, p, g, m, x, T)
                },
                setShadowOffset: function(v, p) {
                    return this.style.setShadowOffset(v, p)
                },
                setShadowColor: function(v) {
                    return this.style.setShadowColor(v)
                },
                setShadowBlur: function(v) {
                    return this.style.setShadowBlur(v)
                },
                setShadowStroke: function(v) {
                    return this.style.setShadowStroke(v)
                },
                setShadowFill: function(v) {
                    return this.style.setShadowFill(v)
                },
                setWordWrapWidth: function(v, p) {
                    return this.style.setWordWrapWidth(v, p)
                },
                setWordWrapCallback: function(v, p) {
                    return this.style.setWordWrapCallback(v, p)
                },
                setAlign: function(v) {
                    return this.style.setAlign(v)
                },
                setResolution: function(v) {
                    return this.style.setResolution(v)
                },
                setLineSpacing: function(v) {
                    return this.lineSpacing = v,
                    this.updateText()
                },
                setPadding: function(v, p, g, m) {
                    if (typeof v == "object") {
                        var x = v
                          , T = l(x, "x", null);
                        T !== null ? (v = T,
                        g = T) : (v = l(x, "left", 0),
                        g = l(x, "right", v));
                        var E = l(x, "y", null);
                        E !== null ? (p = E,
                        m = E) : (p = l(x, "top", 0),
                        m = l(x, "bottom", p))
                    } else
                        v === void 0 && (v = 0),
                        p === void 0 && (p = v),
                        g === void 0 && (g = v),
                        m === void 0 && (m = p);
                    return this.padding.left = v,
                    this.padding.top = p,
                    this.padding.right = g,
                    this.padding.bottom = m,
                    this.updateText()
                },
                setMaxLines: function(v) {
                    return this.style.setMaxLines(v)
                },
                updateText: function() {
                    var v = this.canvas
                      , p = this.context
                      , g = this.style
                      , m = g.resolution
                      , x = g.metrics;
                    g.syncFont(v, p);
                    var T = this._text;
                    (g.wordWrapWidth || g.wordWrapCallback) && (T = this.runWordWrap(this._text));
                    var E = T.split(this.splitRegExp), P = s(this, x, E), M = this.padding, L;
                    g.fixedWidth === 0 ? (this.width = P.width + M.left + M.right,
                    L = P.width) : (this.width = g.fixedWidth,
                    L = this.width - M.left - M.right,
                    L < P.width && (L = P.width)),
                    g.fixedHeight === 0 ? this.height = P.height + M.top + M.bottom : this.height = g.fixedHeight;
                    var R = this.width
                      , O = this.height;
                    this.updateDisplayOrigin(),
                    R *= m,
                    O *= m,
                    R = Math.max(R, 1),
                    O = Math.max(O, 1),
                    v.width !== R || v.height !== O ? (v.width = R,
                    v.height = O,
                    this.frame.setSize(R, O),
                    g.syncFont(v, p)) : p.clearRect(0, 0, R, O),
                    p.save(),
                    p.scale(m, m),
                    g.backgroundColor && (p.fillStyle = g.backgroundColor,
                    p.fillRect(0, 0, R, O)),
                    g.syncStyle(v, p),
                    p.textBaseline = "alphabetic",
                    p.translate(M.left, M.top);
                    for (var F, B, N = 0; N < P.lines; N++) {
                        if (F = g.strokeThickness / 2,
                        B = g.strokeThickness / 2 + N * P.lineHeight + x.ascent,
                        N > 0 && (B += P.lineSpacing * N),
                        g.rtl)
                            F = R - F;
                        else if (g.align === "right")
                            F += L - P.lineWidths[N];
                        else if (g.align === "center")
                            F += (L - P.lineWidths[N]) / 2;
                        else if (g.align === "justify") {
                            var Y = .85;
                            if (P.lineWidths[N] / P.width >= Y) {
                                var z = P.width - P.lineWidths[N]
                                  , W = p.measureText(" ").width
                                  , b = E[N].trim()
                                  , D = b.split(" ");
                                z += (E[N].length - b.length) * W;
                                for (var I = Math.floor(z / W), G = 0; I > 0; )
                                    D[G] += " ",
                                    G = (G + 1) % (D.length - 1 || 1),
                                    --I;
                                E[N] = D.join(" ")
                            }
                        }
                        this.autoRound && (F = Math.round(F),
                        B = Math.round(B)),
                        g.strokeThickness && (this.style.syncShadow(p, g.shadowStroke),
                        p.strokeText(E[N], F, B)),
                        g.color && (this.style.syncShadow(p, g.shadowFill),
                        p.fillText(E[N], F, B))
                    }
                    p.restore(),
                    this.renderer && this.renderer.gl && (this.frame.source.glTexture = this.renderer.canvasToTexture(v, this.frame.source.glTexture, !0),
                    this.frame.glTexture = this.frame.source.glTexture),
                    this.dirty = !0;
                    var w = this.input;
                    return w && !w.customHitArea && (w.hitArea.width = this.width,
                    w.hitArea.height = this.height),
                    this
                },
                getTextMetrics: function() {
                    return this.style.getTextMetrics()
                },
                text: {
                    get: function() {
                        return this._text
                    },
                    set: function(v) {
                        this.setText(v)
                    }
                },
                toJSON: function() {
                    var v = o.ToJSON(this)
                      , p = {
                        autoRound: this.autoRound,
                        text: this._text,
                        style: this.style.toJSON(),
                        padding: {
                            left: this.padding.left,
                            right: this.padding.right,
                            top: this.padding.top,
                            bottom: this.padding.bottom
                        }
                    };
                    return v.data = p,
                    v
                },
                preDestroy: function() {
                    this.style.rtl && i(this.canvas),
                    f.remove(this.canvas),
                    this.texture.destroy()
                }
            });
            c.exports = d
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(31)
              , f = t(0)
              , r = t(11)
              , o = t(22)
              , a = t(15)
              , n = t(361)
              , s = t(192)
              , l = t(1091)
              , i = t(3)
              , h = 8
              , u = new f({
                Extends: a,
                Mixins: [r.Alpha, r.BlendMode, r.ComputedSize, r.Crop, r.Depth, r.Flip, r.GetBounds, r.Mask, r.Origin, r.Pipeline, r.ScrollFactor, r.Tint, r.Transform, r.Visible, l],
                initialize: function(v, p, g, m, x, T, E) {
                    var P = v.sys.renderer;
                    a.call(this, v, "TileSprite");
                    var M = v.sys.textures.get(T)
                      , L = M.get(E);
                    !m || !x ? (m = L.width,
                    x = L.height) : (m = Math.floor(m),
                    x = Math.floor(x)),
                    this._tilePosition = new i,
                    this._tileScale = new i(1,1),
                    this.dirty = !1,
                    this.renderer = P,
                    this.canvas = e.create(this, m, x),
                    this.context = this.canvas.getContext("2d"),
                    this.displayTexture = M,
                    this.displayFrame = L,
                    this._crop = this.resetCropObject(),
                    this.texture = v.sys.textures.addCanvas(null, this.canvas, !0),
                    this.frame = this.texture.get(),
                    this.potWidth = n(L.width),
                    this.potHeight = n(L.height),
                    this.fillCanvas = e.create2D(this, this.potWidth, this.potHeight),
                    this.fillContext = this.fillCanvas.getContext("2d"),
                    this.fillPattern = null,
                    this.setPosition(p, g),
                    this.setSize(m, x),
                    this.setFrame(E),
                    this.setOriginFromFrame(),
                    this.initPipeline(),
                    v.sys.game.events.on(o.CONTEXT_RESTORED, function(R) {
                        if (R) {
                            var O = R.gl;
                            this.dirty = !0,
                            this.fillPattern = null,
                            this.fillPattern = R.createTexture2D(0, O.LINEAR, O.LINEAR, O.REPEAT, O.REPEAT, O.RGBA, this.fillCanvas, this.potWidth, this.potHeight)
                        }
                    }, this)
                },
                setTexture: function(d, v) {
                    return this.displayTexture = this.scene.sys.textures.get(d),
                    this.setFrame(v)
                },
                setFrame: function(d) {
                    var v = this.displayTexture.get(d);
                    return this.potWidth = n(v.width),
                    this.potHeight = n(v.height),
                    this.canvas.width = 0,
                    !v.cutWidth || !v.cutHeight ? this.renderFlags &= ~h : this.renderFlags |= h,
                    this.displayFrame = v,
                    this.dirty = !0,
                    this.updateTileTexture(),
                    this
                },
                setTilePosition: function(d, v) {
                    return d !== void 0 && (this.tilePositionX = d),
                    v !== void 0 && (this.tilePositionY = v),
                    this
                },
                setTileScale: function(d, v) {
                    return d === void 0 && (d = this.tileScaleX),
                    v === void 0 && (v = d),
                    this.tileScaleX = d,
                    this.tileScaleY = v,
                    this
                },
                updateTileTexture: function() {
                    if (!(!this.dirty || !this.renderer)) {
                        var d = this.displayFrame;
                        if (d.source.isRenderTexture || d.source.isGLTexture) {
                            console.warn("TileSprites can only use Image or Canvas based textures"),
                            this.dirty = !1;
                            return
                        }
                        var v = this.fillContext
                          , p = this.fillCanvas
                          , g = this.potWidth
                          , m = this.potHeight;
                        (!this.renderer || !this.renderer.gl) && (g = d.cutWidth,
                        m = d.cutHeight),
                        v.clearRect(0, 0, g, m),
                        p.width = g,
                        p.height = m,
                        v.drawImage(d.source.image, d.cutX, d.cutY, d.cutWidth, d.cutHeight, 0, 0, g, m),
                        this.renderer && this.renderer.gl ? this.fillPattern = this.renderer.canvasToTexture(p, this.fillPattern) : this.fillPattern = v.createPattern(p, "repeat"),
                        this.updateCanvas(),
                        this.dirty = !1
                    }
                },
                updateCanvas: function() {
                    var d = this.canvas;
                    if ((d.width !== this.width || d.height !== this.height) && (d.width = this.width,
                    d.height = this.height,
                    this.frame.setSize(this.width, this.height),
                    this.updateDisplayOrigin(),
                    this.dirty = !0),
                    !this.dirty || this.renderer && this.renderer.gl) {
                        this.dirty = !1;
                        return
                    }
                    var v = this.context;
                    this.scene.sys.game.config.antialias || s.disable(v);
                    var p = this._tileScale.x
                      , g = this._tileScale.y
                      , m = this._tilePosition.x
                      , x = this._tilePosition.y;
                    v.clearRect(0, 0, this.width, this.height),
                    v.save(),
                    v.scale(p, g),
                    v.translate(-m, -x),
                    v.fillStyle = this.fillPattern,
                    v.fillRect(m, x, this.width / p, this.height / g),
                    v.restore(),
                    this.dirty = !1
                },
                preDestroy: function() {
                    this.renderer && this.renderer.gl && this.renderer.deleteTexture(this.fillPattern),
                    e.remove(this.canvas),
                    e.remove(this.fillCanvas),
                    this.fillPattern = null,
                    this.fillContext = null,
                    this.fillCanvas = null,
                    this.displayTexture = null,
                    this.displayFrame = null,
                    this.texture.destroy(),
                    this.renderer = null
                },
                tilePositionX: {
                    get: function() {
                        return this._tilePosition.x
                    },
                    set: function(d) {
                        this._tilePosition.x = d,
                        this.dirty = !0
                    }
                },
                tilePositionY: {
                    get: function() {
                        return this._tilePosition.y
                    },
                    set: function(d) {
                        this._tilePosition.y = d,
                        this.dirty = !0
                    }
                },
                tileScaleX: {
                    get: function() {
                        return this._tileScale.x
                    },
                    set: function(d) {
                        this._tileScale.x = d,
                        this.dirty = !0
                    }
                },
                tileScaleY: {
                    get: function() {
                        return this._tileScale.y
                    },
                    set: function(d) {
                        this._tileScale.y = d,
                        this.dirty = !0
                    }
                }
            });
            c.exports = u
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(18)
              , r = t(11)
              , o = t(75)
              , a = t(22)
              , n = t(51)
              , s = t(15)
              , l = t(70)
              , i = t(222)
              , h = t(1094)
              , u = t(14)
              , d = new e({
                Extends: s,
                Mixins: [r.Alpha, r.BlendMode, r.Depth, r.Flip, r.GetBounds, r.Mask, r.Origin, r.Pipeline, r.ScrollFactor, r.Size, r.TextureCrop, r.Tint, r.Transform, r.Visible, h],
                initialize: function(p, g, m, x) {
                    s.call(this, p, "Video"),
                    this.video = null,
                    this.videoTexture = null,
                    this.videoTextureSource = null,
                    this.snapshotTexture = null,
                    this.flipY = !1,
                    this._key = i(),
                    this.touchLocked = !0,
                    this.playWhenUnlocked = !1,
                    this.retryLimit = 20,
                    this.retry = 0,
                    this.retryInterval = 500,
                    this._retryID = null,
                    this._systemMuted = !1,
                    this._codeMuted = !1,
                    this._systemPaused = !1,
                    this._codePaused = !1,
                    this._callbacks = {
                        play: this.playHandler.bind(this),
                        error: this.loadErrorHandler.bind(this),
                        end: this.completeHandler.bind(this),
                        time: this.timeUpdateHandler.bind(this),
                        seeking: this.seekingHandler.bind(this),
                        seeked: this.seekedHandler.bind(this)
                    },
                    this._crop = this.resetCropObject(),
                    this.markers = {},
                    this._markerIn = -1,
                    this._markerOut = u.MAX_SAFE_INTEGER,
                    this._lastUpdate = 0,
                    this._cacheKey = "",
                    this._isSeeking = !1,
                    this.removeVideoElementOnDestroy = !1,
                    this.setPosition(g, m),
                    this.initPipeline(),
                    x && this.changeSource(x, !1);
                    var T = p.sys.game.events;
                    T.on(a.PAUSE, this.globalPause, this),
                    T.on(a.RESUME, this.globalResume, this);
                    var E = p.sys.sound;
                    E && E.on(l.GLOBAL_MUTE, this.globalMute, this)
                },
                addedToScene: function() {
                    this.scene.sys.updateList.add(this)
                },
                removedFromScene: function() {
                    this.scene.sys.updateList.remove(this)
                },
                play: function(v, p, g) {
                    if (this.touchLocked && this.playWhenUnlocked || this.isPlaying())
                        return this;
                    var m = this.video;
                    if (!m)
                        return console.warn("Video not loaded"),
                        this;
                    v === void 0 && (v = m.loop);
                    var x = this.scene.sys.sound;
                    x && x.mute && this.setMute(!0),
                    isNaN(p) || (this._markerIn = p),
                    !isNaN(g) && g > p && (this._markerOut = g),
                    m.loop = v;
                    var T = this._callbacks
                      , E = m.play();
                    return E !== void 0 ? E.then(this.playPromiseSuccessHandler.bind(this)).catch(this.playPromiseErrorHandler.bind(this)) : (m.addEventListener("playing", T.play, !0),
                    m.readyState < 2 && (this.retry = this.retryLimit,
                    this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval))),
                    m.addEventListener("ended", T.end, !0),
                    m.addEventListener("timeupdate", T.time, !0),
                    m.addEventListener("seeking", T.seeking, !0),
                    m.addEventListener("seeked", T.seeked, !0),
                    this
                },
                changeSource: function(v, p, g, m, x) {
                    p === void 0 && (p = !0);
                    var T = this.video;
                    T && this.stop();
                    var E = this.scene.sys.cache.video.get(v);
                    return E ? (this.video = E,
                    this._cacheKey = v,
                    this._codePaused = E.paused,
                    this._codeMuted = E.muted,
                    this.videoTexture ? (this.scene.sys.textures.remove(this._key),
                    this.videoTexture = this.scene.sys.textures.create(this._key, E, E.videoWidth, E.videoHeight),
                    this.videoTextureSource = this.videoTexture.source[0],
                    this.videoTexture.add("__BASE", 0, 0, 0, E.videoWidth, E.videoHeight),
                    this.setTexture(this.videoTexture),
                    this.setSizeToFrame(),
                    this.updateDisplayOrigin(),
                    this.emit(o.VIDEO_CREATED, this, E.videoWidth, E.videoHeight)) : this.updateTexture(),
                    E.currentTime = 0,
                    this._lastUpdate = 0,
                    p && this.play(g, m, x)) : this.video = null,
                    this
                },
                addMarker: function(v, p, g) {
                    return !isNaN(p) && p >= 0 && !isNaN(g) && (this.markers[v] = [p, g]),
                    this
                },
                playMarker: function(v, p) {
                    var g = this.markers[v];
                    return g && this.play(p, g[0], g[1]),
                    this
                },
                removeMarker: function(v) {
                    return delete this.markers[v],
                    this
                },
                snapshot: function(v, p) {
                    return v === void 0 && (v = this.width),
                    p === void 0 && (p = this.height),
                    this.snapshotArea(0, 0, this.width, this.height, v, p)
                },
                snapshotArea: function(v, p, g, m, x, T) {
                    v === void 0 && (v = 0),
                    p === void 0 && (p = 0),
                    g === void 0 && (g = this.width),
                    m === void 0 && (m = this.height),
                    x === void 0 && (x = g),
                    T === void 0 && (T = m);
                    var E = this.video
                      , P = this.snapshotTexture;
                    return P ? (P.setSize(x, T),
                    E && P.context.drawImage(E, v, p, g, m, 0, 0, x, T)) : (P = this.scene.sys.textures.createCanvas(i(), x, T),
                    this.snapshotTexture = P,
                    E && P.context.drawImage(E, v, p, g, m, 0, 0, x, T)),
                    P.update()
                },
                saveSnapshotTexture: function(v) {
                    return this.snapshotTexture ? this.scene.sys.textures.renameTexture(this.snapshotTexture.key, v) : this.snapshotTexture = this.scene.sys.textures.createCanvas(v, this.width, this.height),
                    this.snapshotTexture
                },
                loadURL: function(v, p, g) {
                    g === void 0 && (g = !1),
                    this.video && this.stop(),
                    this.videoTexture && this.scene.sys.textures.remove(this._key);
                    var m = document.createElement("video");
                    return m.controls = !1,
                    g && (m.muted = !0,
                    m.defaultMuted = !0,
                    m.setAttribute("autoplay", "autoplay")),
                    m.setAttribute("playsinline", "playsinline"),
                    m.setAttribute("preload", "auto"),
                    m.addEventListener("error", this._callbacks.error, !0),
                    m.src = v,
                    m.load(),
                    this.video = m,
                    this
                },
                loadMediaStream: function(v, p, g) {
                    g === void 0 && (g = !1),
                    this.video && this.stop(),
                    this.videoTexture && this.scene.sys.textures.remove(this._key);
                    var m = document.createElement("video");
                    m.controls = !1,
                    g && (m.muted = !0,
                    m.defaultMuted = !0,
                    m.setAttribute("autoplay", "autoplay")),
                    m.setAttribute("playsinline", "playsinline"),
                    m.setAttribute("preload", "auto"),
                    m.addEventListener("error", this._callbacks.error, !0);
                    try {
                        m.srcObject = v
                    } catch {
                        m.src = window.URL.createObjectURL(v)
                    }
                    return m.load(),
                    this.video = m,
                    this
                },
                playPromiseSuccessHandler: function() {
                    this._codePaused = !1,
                    this.touchLocked = !1,
                    this.emit(o.VIDEO_PLAY, this),
                    this._markerIn > -1 && (this.video.currentTime = this._markerIn)
                },
                playPromiseErrorHandler: function(v) {
                    this.scene.sys.input.once(n.POINTER_DOWN, this.unlockHandler, this),
                    this.touchLocked = !0,
                    this.playWhenUnlocked = !0,
                    this.emit(o.VIDEO_ERROR, this, v)
                },
                playHandler: function() {
                    this._codePaused = !1,
                    this.touchLocked = !1,
                    this.emit(o.VIDEO_PLAY, this),
                    this.video.removeEventListener("playing", this._callbacks.play, !0)
                },
                loadErrorHandler: function(v) {
                    this.stop(),
                    this.emit(o.VIDEO_ERROR, this, v)
                },
                unlockHandler: function() {
                    this.touchLocked = !1,
                    this.playWhenUnlocked = !1,
                    this.emit(o.VIDEO_UNLOCKED, this),
                    this._markerIn > -1 && (this.video.currentTime = this._markerIn),
                    this.video.play(),
                    this.emit(o.VIDEO_PLAY, this)
                },
                completeHandler: function() {
                    this.emit(o.VIDEO_COMPLETE, this)
                },
                timeUpdateHandler: function() {
                    this.video && this.video.currentTime < this._lastUpdate && (this.emit(o.VIDEO_LOOP, this),
                    this._lastUpdate = 0)
                },
                preUpdate: function() {
                    var v = this.video;
                    if (v) {
                        var p = v.currentTime;
                        p !== this._lastUpdate && (this._lastUpdate = p,
                        this.updateTexture(),
                        p >= this._markerOut && (v.loop ? (v.currentTime = this._markerIn,
                        this.updateTexture(),
                        this._lastUpdate = p,
                        this.emit(o.VIDEO_LOOP, this)) : (this.emit(o.VIDEO_COMPLETE, this),
                        this.stop())))
                    }
                },
                checkVideoProgress: function() {
                    this.video.readyState >= 2 ? this.updateTexture() : (this.retry--,
                    this.retry > 0 ? this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval) : this.emit(o.VIDEO_TIMEOUT, this))
                },
                updateTexture: function() {
                    var v = this.video
                      , p = v.videoWidth
                      , g = v.videoHeight;
                    if (!this.videoTexture)
                        this.videoTexture = this.scene.sys.textures.create(this._key, v, p, g),
                        this.videoTextureSource = this.videoTexture.source[0],
                        this.videoTexture.add("__BASE", 0, 0, 0, p, g),
                        this.setTexture(this.videoTexture),
                        this.setSizeToFrame(),
                        this.updateDisplayOrigin(),
                        this.emit(o.VIDEO_CREATED, this, p, g);
                    else {
                        var m = this.videoTextureSource;
                        m.source !== v && (m.source = v,
                        m.width = p,
                        m.height = g),
                        m.update()
                    }
                },
                getVideoKey: function() {
                    return this._cacheKey
                },
                seekTo: function(v) {
                    var p = this.video;
                    if (p) {
                        var g = p.duration;
                        if (g !== 1 / 0 && !isNaN(g)) {
                            var m = g * v;
                            this.setCurrentTime(m)
                        }
                    }
                    return this
                },
                getCurrentTime: function() {
                    return this.video ? this.video.currentTime : 0
                },
                setCurrentTime: function(v) {
                    var p = this.video;
                    if (p) {
                        if (typeof v == "string") {
                            var g = v[0]
                              , m = parseFloat(v.substr(1));
                            g === "+" ? v = p.currentTime + m : g === "-" && (v = p.currentTime - m)
                        }
                        p.currentTime = v,
                        this._lastUpdate = v
                    }
                    return this
                },
                isSeeking: function() {
                    return this._isSeeking
                },
                seekingHandler: function() {
                    this._isSeeking = !0,
                    this.emit(o.VIDEO_SEEKING, this)
                },
                seekedHandler: function() {
                    this._isSeeking = !1,
                    this.emit(o.VIDEO_SEEKED, this);
                    var v = this.video;
                    v && this.updateTexture()
                },
                getProgress: function() {
                    var v = this.video;
                    if (v) {
                        var p = v.currentTime
                          , g = v.duration;
                        if (g !== 1 / 0 && !isNaN(g))
                            return p / g
                    }
                    return 0
                },
                getDuration: function() {
                    return this.video ? this.video.duration : 0
                },
                setMute: function(v) {
                    v === void 0 && (v = !0),
                    this._codeMuted = v;
                    var p = this.video;
                    return p && (p.muted = this._systemMuted ? !0 : v),
                    this
                },
                isMuted: function() {
                    return this._codeMuted
                },
                globalMute: function(v, p) {
                    this._systemMuted = p;
                    var g = this.video;
                    g && (g.muted = this._codeMuted ? !0 : p)
                },
                globalPause: function() {
                    this._systemPaused = !0,
                    this.video && this.video.pause()
                },
                globalResume: function() {
                    this._systemPaused = !1,
                    this.video && !this._codePaused && this.video.play()
                },
                setPaused: function(v) {
                    v === void 0 && (v = !0);
                    var p = this.video;
                    return this._codePaused = v,
                    p && (v ? p.paused || p.pause() : v || p.paused && !this._systemPaused && p.play()),
                    this
                },
                getVolume: function() {
                    return this.video ? this.video.volume : 1
                },
                setVolume: function(v) {
                    return v === void 0 && (v = 1),
                    this.video && (this.video.volume = f(v, 0, 1)),
                    this
                },
                getPlaybackRate: function() {
                    return this.video ? this.video.playbackRate : 1
                },
                setPlaybackRate: function(v) {
                    return this.video && (this.video.playbackRate = v),
                    this
                },
                getLoop: function() {
                    return this.video ? this.video.loop : !1
                },
                setLoop: function(v) {
                    return v === void 0 && (v = !0),
                    this.video && (this.video.loop = v),
                    this
                },
                isPlaying: function() {
                    return this.video ? !(this.video.paused || this.video.ended) : !1
                },
                isPaused: function() {
                    return this.video && this.video.paused || this._codePaused || this._systemPaused
                },
                saveTexture: function(v, p) {
                    return p === void 0 && (p = !1),
                    this.videoTexture && this.scene.sys.textures.renameTexture(this._key, v),
                    this._key = v,
                    this.flipY = p,
                    this.videoTextureSource && this.videoTextureSource.setFlipY(p),
                    this.videoTexture
                },
                stop: function() {
                    var v = this.video;
                    if (v) {
                        var p = this._callbacks;
                        for (var g in p)
                            v.removeEventListener(g, p[g], !0);
                        v.pause()
                    }
                    return this._retryID && window.clearTimeout(this._retryID),
                    this.emit(o.VIDEO_STOP, this),
                    this
                },
                removeVideoElement: function() {
                    var v = this.video;
                    if (v) {
                        for (v.parentNode && v.parentNode.removeChild(v); v.hasChildNodes(); )
                            v.removeChild(v.firstChild);
                        v.removeAttribute("autoplay"),
                        v.removeAttribute("src"),
                        this.video = null
                    }
                },
                preDestroy: function() {
                    this.stop(),
                    this.removeVideoElementOnDestroy && this.removeVideoElement();
                    var v = this.scene.sys.game.events;
                    v.off(a.PAUSE, this.globalPause, this),
                    v.off(a.RESUME, this.globalResume, this);
                    var p = this.scene.sys.sound;
                    p && p.off(l.GLOBAL_MUTE, this.globalMute, this),
                    this._retryID && window.clearTimeout(this._retryID)
                }
            });
            c.exports = d
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(228)
              , r = t(470)
              , o = t(56)
              , a = new e({
                initialize: function(s) {
                    this.type = o.POLYGON,
                    this.area = 0,
                    this.points = [],
                    s && this.setTo(s)
                },
                contains: function(n, s) {
                    return f(this, n, s)
                },
                setTo: function(n) {
                    if (this.area = 0,
                    this.points = [],
                    typeof n == "string" && (n = n.split(" ")),
                    !Array.isArray(n))
                        return this;
                    for (var s, l = Number.MAX_VALUE, i = 0; i < n.length; i++)
                        s = {
                            x: 0,
                            y: 0
                        },
                        typeof n[i] == "number" || typeof n[i] == "string" ? (s.x = parseFloat(n[i]),
                        s.y = parseFloat(n[i + 1]),
                        i++) : Array.isArray(n[i]) ? (s.x = n[i][0],
                        s.y = n[i][1]) : (s.x = n[i].x,
                        s.y = n[i].y),
                        this.points.push(s),
                        s.y < l && (l = s.y);
                    return this.calculateArea(l),
                    this
                },
                calculateArea: function() {
                    if (this.points.length < 3)
                        return this.area = 0,
                        this.area;
                    for (var n = 0, s, l, i = 0; i < this.points.length - 1; i++)
                        s = this.points[i],
                        l = this.points[i + 1],
                        n += (l.x - s.x) * (s.y + l.y);
                    return s = this.points[0],
                    l = this.points[this.points.length - 1],
                    n += (s.x - l.x) * (l.y + s.y),
                    this.area = -n * .5,
                    this.area
                },
                getPoints: function(n, s, l) {
                    return r(this, n, s, l)
                }
            });
            c.exports = a
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                for (var o = !1, a = -1, n = e.points.length - 1; ++a < e.points.length; n = a) {
                    var s = e.points[a].x
                      , l = e.points[a].y
                      , i = e.points[n].x
                      , h = e.points[n].y;
                    (l <= r && r < h || h <= r && r < l) && f < (i - s) * (r - l) / (h - l) + s && (o = !o)
                }
                return o
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(11)
              , r = t(15)
              , o = t(2)
              , a = t(17)
              , n = t(478)
              , s = t(1176)
              , l = t(25)
              , i = new e({
                Extends: r,
                Mixins: [f.ComputedSize, f.Depth, f.GetBounds, f.Mask, f.Origin, f.ScrollFactor, f.Transform, f.Visible, s],
                initialize: function(u, d, v, p, g, m, x, T) {
                    v === void 0 && (v = 0),
                    p === void 0 && (p = 0),
                    g === void 0 && (g = 128),
                    m === void 0 && (m = 128),
                    r.call(this, u, "Shader"),
                    this.blendMode = -1,
                    this.shader;
                    var E = u.sys.renderer;
                    this.renderer = E,
                    this.gl = E.gl,
                    this.vertexData = new ArrayBuffer(6 * (Float32Array.BYTES_PER_ELEMENT * 2)),
                    this.vertexBuffer = E.createVertexBuffer(this.vertexData.byteLength, this.gl.STREAM_DRAW),
                    this.program = null,
                    this.bytes = new Uint8Array(this.vertexData),
                    this.vertexViewF32 = new Float32Array(this.vertexData),
                    this._tempMatrix1 = new l,
                    this._tempMatrix2 = new l,
                    this._tempMatrix3 = new l,
                    this.viewMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
                    this.projectionMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
                    this.uniforms = {},
                    this.pointer = null,
                    this._rendererWidth = E.width,
                    this._rendererHeight = E.height,
                    this._textureCount = 0,
                    this.framebuffer = null,
                    this.glTexture = null,
                    this.renderToTexture = !1,
                    this.texture = null,
                    this.setPosition(v, p),
                    this.setSize(g, m),
                    this.setOrigin(.5, .5),
                    this.setShader(d, x, T)
                },
                willRender: function(h) {
                    return this.renderToTexture ? !0 : !(r.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & h.id)
                },
                setRenderToTexture: function(h, u) {
                    if (u === void 0 && (u = !1),
                    !this.renderToTexture) {
                        var d = this.width
                          , v = this.height
                          , p = this.renderer;
                        this.glTexture = p.createTextureFromSource(null, d, v, 0),
                        this.glTexture.flipY = u,
                        this.framebuffer = p.createFramebuffer(d, v, this.glTexture, !1),
                        this._rendererWidth = d,
                        this._rendererHeight = v,
                        this.renderToTexture = !0,
                        this.projOrtho(0, this.width, this.height, 0),
                        h && (this.texture = this.scene.sys.textures.addGLTexture(h, this.glTexture, d, v))
                    }
                    return this.shader && (p.pipelines.clear(),
                    this.load(),
                    this.flush(),
                    p.pipelines.rebind()),
                    this
                },
                setShader: function(h, u, d) {
                    if (u === void 0 && (u = []),
                    typeof h == "string") {
                        var v = this.scene.sys.cache.shader;
                        if (!v.has(h))
                            return console.warn("Shader missing: " + h),
                            this;
                        this.shader = v.get(h)
                    } else
                        this.shader = h;
                    var p = this.gl
                      , g = this.renderer;
                    this.program && p.deleteProgram(this.program);
                    var m = g.createProgram(this.shader.vertexSrc, this.shader.fragmentSrc);
                    p.uniformMatrix4fv(p.getUniformLocation(m, "uViewMatrix"), !1, this.viewMatrix),
                    p.uniformMatrix4fv(p.getUniformLocation(m, "uProjectionMatrix"), !1, this.projectionMatrix),
                    p.uniform2f(p.getUniformLocation(m, "uResolution"), this.width, this.height),
                    this.program = m;
                    var x = new Date
                      , T = {
                        resolution: {
                            type: "2f",
                            value: {
                                x: this.width,
                                y: this.height
                            }
                        },
                        time: {
                            type: "1f",
                            value: 0
                        },
                        mouse: {
                            type: "2f",
                            value: {
                                x: this.width / 2,
                                y: this.height / 2
                            }
                        },
                        date: {
                            type: "4fv",
                            value: [x.getFullYear(), x.getMonth(), x.getDate(), x.getHours() * 60 * 60 + x.getMinutes() * 60 + x.getSeconds()]
                        },
                        sampleRate: {
                            type: "1f",
                            value: 44100
                        },
                        iChannel0: {
                            type: "sampler2D",
                            value: null,
                            textureData: {
                                repeat: !0
                            }
                        },
                        iChannel1: {
                            type: "sampler2D",
                            value: null,
                            textureData: {
                                repeat: !0
                            }
                        },
                        iChannel2: {
                            type: "sampler2D",
                            value: null,
                            textureData: {
                                repeat: !0
                            }
                        },
                        iChannel3: {
                            type: "sampler2D",
                            value: null,
                            textureData: {
                                repeat: !0
                            }
                        }
                    };
                    this.shader.uniforms ? this.uniforms = a(!0, {}, this.shader.uniforms, T) : this.uniforms = T;
                    for (var E = 0; E < 4; E++)
                        u[E] && this.setSampler2D("iChannel" + E, u[E], E, d);
                    return this.initUniforms(),
                    this.projOrtho(0, this._rendererWidth, this._rendererHeight, 0),
                    this
                },
                setPointer: function(h) {
                    return this.pointer = h,
                    this
                },
                projOrtho: function(h, u, d, v) {
                    var p = -1e3
                      , g = 1e3
                      , m = 1 / (h - u)
                      , x = 1 / (d - v)
                      , T = 1 / (p - g)
                      , E = this.projectionMatrix;
                    E[0] = -2 * m,
                    E[5] = -2 * x,
                    E[10] = 2 * T,
                    E[12] = (h + u) * m,
                    E[13] = (v + d) * x,
                    E[14] = (g + p) * T;
                    var P = this.program
                      , M = this.gl
                      , L = this.renderer;
                    L.setProgram(P),
                    M.uniformMatrix4fv(M.getUniformLocation(P, "uProjectionMatrix"), !1, this.projectionMatrix),
                    this._rendererWidth = u,
                    this._rendererHeight = d
                },
                initUniforms: function() {
                    var h = this.gl
                      , u = this.renderer.glFuncMap
                      , d = this.program;
                    this._textureCount = 0;
                    for (var v in this.uniforms) {
                        var p = this.uniforms[v]
                          , g = p.type
                          , m = u[g];
                        p.uniformLocation = h.getUniformLocation(d, v),
                        g !== "sampler2D" && (p.glMatrix = m.matrix,
                        p.glValueLength = m.length,
                        p.glFunc = m.func)
                    }
                },
                setSampler2DBuffer: function(h, u, d, v, p, g) {
                    p === void 0 && (p = 0),
                    g === void 0 && (g = {});
                    var m = this.uniforms[h];
                    return m.value = u,
                    g.width = d,
                    g.height = v,
                    m.textureData = g,
                    this._textureCount = p,
                    this.initSampler2D(m),
                    this
                },
                setSampler2D: function(h, u, d, v) {
                    d === void 0 && (d = 0);
                    var p = this.scene.sys.textures;
                    if (p.exists(u)) {
                        var g = p.getFrame(u);
                        if (g.glTexture && g.glTexture.isRenderTexture)
                            return this.setSampler2DBuffer(h, g.glTexture, g.width, g.height, d, v);
                        var m = this.uniforms[h]
                          , x = g.source;
                        m.textureKey = u,
                        m.source = x.image,
                        m.value = g.glTexture,
                        x.isGLTexture && (v || (v = {}),
                        v.width = x.width,
                        v.height = x.height),
                        v && (m.textureData = v),
                        this._textureCount = d,
                        this.initSampler2D(m)
                    }
                    return this
                },
                setUniform: function(h, u) {
                    return n(this.uniforms, h, u),
                    this
                },
                getUniform: function(h) {
                    return o(this.uniforms, h, null)
                },
                setChannel0: function(h, u) {
                    return this.setSampler2D("iChannel0", h, 0, u)
                },
                setChannel1: function(h, u) {
                    return this.setSampler2D("iChannel1", h, 1, u)
                },
                setChannel2: function(h, u) {
                    return this.setSampler2D("iChannel2", h, 2, u)
                },
                setChannel3: function(h, u) {
                    return this.setSampler2D("iChannel3", h, 3, u)
                },
                initSampler2D: function(h) {
                    if (h.value) {
                        var u = this.gl;
                        u.activeTexture(u.TEXTURE0 + this._textureCount),
                        u.bindTexture(u.TEXTURE_2D, h.value);
                        var d = h.textureData;
                        if (d && !h.value.isRenderTexture) {
                            var v = u[o(d, "magFilter", "linear").toUpperCase()]
                              , p = u[o(d, "minFilter", "linear").toUpperCase()]
                              , g = u[o(d, "wrapS", "repeat").toUpperCase()]
                              , m = u[o(d, "wrapT", "repeat").toUpperCase()]
                              , x = u[o(d, "format", "rgba").toUpperCase()];
                            if (d.repeat && (g = u.REPEAT,
                            m = u.REPEAT),
                            u.pixelStorei(u.UNPACK_FLIP_Y_WEBGL, !!d.flipY),
                            d.width) {
                                var T = o(d, "width", 512)
                                  , E = o(d, "height", 2)
                                  , P = o(d, "border", 0);
                                u.texImage2D(u.TEXTURE_2D, 0, x, T, E, P, x, u.UNSIGNED_BYTE, null)
                            } else
                                u.texImage2D(u.TEXTURE_2D, 0, x, u.RGBA, u.UNSIGNED_BYTE, h.source);
                            u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, v),
                            u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MIN_FILTER, p),
                            u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, g),
                            u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, m)
                        }
                        this.renderer.setProgram(this.program),
                        u.uniform1i(h.uniformLocation, this._textureCount),
                        this._textureCount++
                    }
                },
                syncUniforms: function() {
                    var h = this.gl, u = this.uniforms, d, v, p, g, m, x = 0;
                    for (var T in u)
                        d = u[T],
                        p = d.glFunc,
                        v = d.glValueLength,
                        g = d.uniformLocation,
                        m = d.value,
                        m !== null && (v === 1 ? d.glMatrix ? p.call(h, g, d.transpose, m) : p.call(h, g, m) : v === 2 ? p.call(h, g, m.x, m.y) : v === 3 ? p.call(h, g, m.x, m.y, m.z) : v === 4 ? p.call(h, g, m.x, m.y, m.z, m.w) : d.type === "sampler2D" && (h.activeTexture(h.TEXTURE0 + x),
                        h.bindTexture(h.TEXTURE_2D, m),
                        h.uniform1i(g, x),
                        x++))
                },
                load: function(h) {
                    var u = this.gl
                      , d = this.width
                      , v = this.height
                      , p = this.renderer
                      , g = this.program
                      , m = this.viewMatrix;
                    if (!this.renderToTexture) {
                        var x = -this._displayOriginX
                          , T = -this._displayOriginY;
                        m[0] = h[0],
                        m[1] = h[1],
                        m[4] = h[2],
                        m[5] = h[3],
                        m[8] = h[4],
                        m[9] = h[5],
                        m[12] = m[0] * x + m[4] * T,
                        m[13] = m[1] * x + m[5] * T
                    }
                    u.useProgram(g),
                    u.uniformMatrix4fv(u.getUniformLocation(g, "uViewMatrix"), !1, m),
                    u.uniform2f(u.getUniformLocation(g, "uResolution"), this.width, this.height);
                    var E = this.uniforms
                      , P = E.resolution;
                    P.value.x = d,
                    P.value.y = v,
                    E.time.value = p.game.loop.getDuration();
                    var M = this.pointer;
                    if (M) {
                        var L = E.mouse
                          , R = M.x / d
                          , O = 1 - M.y / v;
                        L.value.x = R.toFixed(2),
                        L.value.y = O.toFixed(2)
                    }
                    this.syncUniforms()
                },
                flush: function() {
                    var h = this.width
                      , u = this.height
                      , d = this.program
                      , v = this.gl
                      , p = this.vertexBuffer
                      , g = this.renderer
                      , m = Float32Array.BYTES_PER_ELEMENT * 2;
                    this.renderToTexture && (g.setFramebuffer(this.framebuffer),
                    v.clearColor(0, 0, 0, 0),
                    v.clear(v.COLOR_BUFFER_BIT)),
                    v.bindBuffer(v.ARRAY_BUFFER, p);
                    var x = v.getAttribLocation(d, "inPosition");
                    x !== -1 && (v.enableVertexAttribArray(x),
                    v.vertexAttribPointer(x, 2, v.FLOAT, !1, m, 0));
                    var T = this.vertexViewF32;
                    T[3] = u,
                    T[4] = h,
                    T[5] = u,
                    T[8] = h,
                    T[9] = u,
                    T[10] = h;
                    var E = 6;
                    v.bufferSubData(v.ARRAY_BUFFER, 0, this.bytes.subarray(0, E * m)),
                    v.drawArrays(v.TRIANGLES, 0, E),
                    this.renderToTexture && g.setFramebuffer(null, !1)
                },
                setAlpha: function() {},
                setBlendMode: function() {},
                preDestroy: function() {
                    var h = this.gl;
                    h.deleteProgram(this.program),
                    h.deleteBuffer(this.vertexBuffer),
                    this.renderToTexture && (this.renderer.deleteFramebuffer(this.framebuffer),
                    this.texture.destroy(),
                    this.framebuffer = null,
                    this.glTexture = null,
                    this.texture = null)
                }
            });
            c.exports = i
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(11)
              , r = t(36)
              , o = t(116)
              , a = t(15)
              , n = t(479)
              , s = t(480)
              , l = t(19)
              , i = t(69)
              , h = t(1179)
              , u = t(79)
              , d = t(39)
              , v = t(117)
              , p = new e({
                Extends: a,
                Mixins: [f.AlphaSingle, f.BlendMode, f.Depth, f.Mask, f.Pipeline, f.Size, f.Texture, f.Transform, f.Visible, f.ScrollFactor, h],
                initialize: function(m, x, T, E, P, M, L, R, O, F, B, N) {
                    x === void 0 && (x = 0),
                    T === void 0 && (T = 0),
                    E === void 0 && (E = "__WHITE"),
                    a.call(this, m, "Mesh"),
                    this.faces = [],
                    this.vertices = [],
                    this.tintFill = !1,
                    this.debugCallback = null,
                    this.debugGraphic = null,
                    this.hideCCW = !0,
                    this.modelPosition = new d,
                    this.modelScale = new d(1,1,1),
                    this.modelRotation = new d,
                    this.dirtyCache = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    this.transformMatrix = new i,
                    this.viewPosition = new d,
                    this.viewMatrix = new i,
                    this.projectionMatrix = new i,
                    this.totalRendered = 0,
                    this.totalFrame = 0,
                    this.ignoreDirtyCache = !1;
                    var Y = m.sys.renderer;
                    this.setPosition(x, T),
                    this.setTexture(E, P),
                    this.setSize(Y.width, Y.height),
                    this.initPipeline(),
                    this.setPerspective(Y.width, Y.height),
                    M && this.addVertices(M, L, R, O, F, B, N)
                },
                addedToScene: function() {
                    this.scene.sys.updateList.add(this)
                },
                removedFromScene: function() {
                    this.scene.sys.updateList.remove(this)
                },
                panX: function(g) {
                    return this.viewPosition.addScale(d.LEFT, g),
                    this.dirtyCache[10] = 1,
                    this
                },
                panY: function(g) {
                    return this.viewPosition.y += d.DOWN.y * g,
                    this.dirtyCache[10] = 1,
                    this
                },
                panZ: function(g) {
                    return this.viewPosition.z += g,
                    this.dirtyCache[10] = 1,
                    this
                },
                setPerspective: function(g, m, x, T, E) {
                    return x === void 0 && (x = 45),
                    T === void 0 && (T = .01),
                    E === void 0 && (E = 1e3),
                    this.projectionMatrix.perspective(r(x), g / m, T, E),
                    this.dirtyCache[10] = 1,
                    this.dirtyCache[11] = 0,
                    this
                },
                setOrtho: function(g, m, x, T) {
                    return g === void 0 && (g = this.scene.sys.renderer.getAspectRatio()),
                    m === void 0 && (m = 1),
                    x === void 0 && (x = -1e3),
                    T === void 0 && (T = 1e3),
                    this.projectionMatrix.ortho(-g, g, -m, m, x, T),
                    this.dirtyCache[10] = 1,
                    this.dirtyCache[11] = 1,
                    this
                },
                clear: function() {
                    return this.faces.forEach(function(g) {
                        g.destroy()
                    }),
                    this.faces = [],
                    this.vertices = [],
                    this
                },
                addVerticesFromObj: function(g, m, x, T, E, P, M, L, R) {
                    var O = this.scene.sys.cache.obj.get(g);
                    return O && s(O, this, m, x, T, E, P, M, L, R),
                    this
                },
                sortByDepth: function(g, m) {
                    return g.depth - m.depth
                },
                depthSort: function() {
                    return u(this.faces, this.sortByDepth),
                    this
                },
                addVertex: function(g, m, x, T, E, P, M) {
                    var L = new v(g,m,x,T,E,P,M);
                    return this.vertices.push(L),
                    L
                },
                addFace: function(g, m, x) {
                    var T = new o(g,m,x);
                    return this.faces.push(T),
                    this.dirtyCache[9] = -1,
                    T
                },
                addVertices: function(g, m, x, T, E, P, M) {
                    var L = n(g, m, x, T, E, P, M);
                    return L && (this.faces = this.faces.concat(L.faces),
                    this.vertices = this.vertices.concat(L.vertices)),
                    this.dirtyCache[9] = -1,
                    this
                },
                getFaceCount: function() {
                    return this.faces.length
                },
                getVertexCount: function() {
                    return this.vertices.length
                },
                getFace: function(g) {
                    return this.faces[g]
                },
                getFaceAt: function(g, m, x) {
                    x === void 0 && (x = this.scene.sys.cameras.main);
                    for (var T = l(this, x).calc, E = this.faces, P = [], M = 0; M < E.length; M++) {
                        var L = E[M];
                        L.contains(g, m, T) && P.push(L)
                    }
                    return u(P, this.sortByDepth)
                },
                setDebug: function(g, m) {
                    return this.debugGraphic = g,
                    !g && !m ? this.debugCallback = null : m ? this.debugCallback = m : this.debugCallback = this.renderDebug,
                    this
                },
                isDirty: function() {
                    var g = this.modelPosition
                      , m = this.modelRotation
                      , x = this.modelScale
                      , T = this.dirtyCache
                      , E = g.x
                      , P = g.y
                      , M = g.z
                      , L = m.x
                      , R = m.y
                      , O = m.z
                      , F = x.x
                      , B = x.y
                      , N = x.z
                      , Y = this.getFaceCount()
                      , z = T[0]
                      , W = T[1]
                      , b = T[2]
                      , D = T[3]
                      , I = T[4]
                      , G = T[5]
                      , w = T[6]
                      , U = T[7]
                      , X = T[8]
                      , V = T[9];
                    return T[0] = E,
                    T[1] = P,
                    T[2] = M,
                    T[3] = L,
                    T[4] = R,
                    T[5] = O,
                    T[6] = F,
                    T[7] = B,
                    T[8] = N,
                    T[9] = Y,
                    z !== E || W !== P || b !== M || D !== L || I !== R || G !== O || w !== F || U !== B || X !== N || V !== Y
                },
                preUpdate: function() {
                    this.totalRendered = this.totalFrame,
                    this.totalFrame = 0;
                    var g = this.dirtyCache;
                    if (!(!this.ignoreDirtyCache && !g[10] && !this.isDirty())) {
                        var m = this.width
                          , x = this.height
                          , T = this.viewMatrix
                          , E = this.viewPosition;
                        g[10] && (T.identity(),
                        T.translate(E),
                        T.invert(),
                        g[10] = 0);
                        var P = this.transformMatrix;
                        P.setWorldMatrix(this.modelRotation, this.modelPosition, this.modelScale, this.viewMatrix, this.projectionMatrix);
                        for (var M = E.z, L = this.faces, R = 0; R < L.length; R++)
                            L[R].transformCoordinatesLocal(P, m, x, M);
                        this.depthSort()
                    }
                },
                renderDebug: function(g, m) {
                    for (var x = g.debugGraphic, T = 0; T < m.length; T++) {
                        var E = m[T]
                          , P = E.vertex1.tx
                          , M = E.vertex1.ty
                          , L = E.vertex2.tx
                          , R = E.vertex2.ty
                          , O = E.vertex3.tx
                          , F = E.vertex3.ty;
                        x.strokeTriangle(P, M, L, R, O, F)
                    }
                },
                preDestroy: function() {
                    this.clear(),
                    this.debugCallback = null,
                    this.debugGraphic = null
                }
            });
            c.exports = p
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(50)
              , f = function(r, o) {
                return e(r.x, r.y, o.x, o.y) <= r.radius + o.radius
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4)
              , f = t(233)
              , r = function(o, a, n) {
                if (n === void 0 && (n = []),
                f(o, a)) {
                    var s = o.x1, l = o.y1, i = o.x2, h = o.y2, u = a.x, d = a.y, v = a.radius, p = i - s, g = h - l, m = s - u, x = l - d, T = p * p + g * g, E = 2 * (p * m + g * x), P = m * m + x * x - v * v, M = E * E - 4 * T * P, L, R;
                    if (M === 0) {
                        var O = -E / (2 * T);
                        L = s + O * p,
                        R = l + O * g,
                        O >= 0 && O <= 1 && n.push(new e(L,R))
                    } else if (M > 0) {
                        var F = (-E - Math.sqrt(M)) / (2 * T);
                        L = s + F * p,
                        R = l + F * g,
                        F >= 0 && F <= 1 && n.push(new e(L,R));
                        var B = (-E + Math.sqrt(M)) / (2 * T);
                        L = s + B * p,
                        R = l + B * g,
                        B >= 0 && B <= 1 && n.push(new e(L,R))
                    }
                }
                return n
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(66)
              , f = t(4)
              , r = new f
              , o = function(a, n, s) {
                if (s === void 0 && (s = r),
                e(n, a.x1, a.y1))
                    return s.x = a.x1,
                    s.y = a.y1,
                    !0;
                if (e(n, a.x2, a.y2))
                    return s.x = a.x2,
                    s.y = a.y2,
                    !0;
                var l = a.x2 - a.x1
                  , i = a.y2 - a.y1
                  , h = n.x - a.x1
                  , u = n.y - a.y1
                  , d = l * l + i * i
                  , v = l
                  , p = i;
                if (d > 0) {
                    var g = (h * l + u * i) / d;
                    v *= g,
                    p *= g
                }
                s.x = a.x1 + v,
                s.y = a.y1 + p;
                var m = v * v + p * p;
                return m <= d && v * l + p * i >= 0 && e(n, s.x, s.y)
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4)
              , f = t(96)
              , r = t(488)
              , o = function(a, n, s) {
                if (s === void 0 && (s = []),
                r(a, n))
                    for (var l = n.getLineA(), i = n.getLineB(), h = n.getLineC(), u = n.getLineD(), d = [new e, new e, new e, new e], v = [f(l, a, d[0]), f(i, a, d[1]), f(h, a, d[2]), f(u, a, d[3])], p = 0; p < 4; p++)
                        v[p] && s.push(d[p]);
                return s
            };
            c.exports = o
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                r === void 0 && (r = !1),
                o === void 0 && (o = []);
                for (var a = e.x3 - e.x1, n = e.y3 - e.y1, s = e.x2 - e.x1, l = e.y2 - e.y1, i = a * a + n * n, h = a * s + n * l, u = s * s + l * l, d = i * u - h * h, v = d === 0 ? 0 : 1 / d, p, g, m, x, T, E, P = e.x1, M = e.y1, L = 0; L < f.length && (m = f[L].x - P,
                x = f[L].y - M,
                T = a * m + n * x,
                E = s * m + l * x,
                p = (u * T - h * E) * v,
                g = (i * E - h * T) * v,
                !(p >= 0 && g >= 0 && p + g < 1 && (o.push({
                    x: f[L].x,
                    y: f[L].y
                }),
                r))); L++)
                    ;
                return o
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                var a = Math.cos(o)
                  , n = Math.sin(o)
                  , s = e.x1 - f
                  , l = e.y1 - r;
                return e.x1 = s * a - l * n + f,
                e.y1 = s * n + l * a + r,
                s = e.x2 - f,
                l = e.y2 - r,
                e.x2 = s * a - l * n + f,
                e.y2 = s * n + l * a + r,
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e.height === 0 ? NaN : e.width / e.height
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                var a = Math.cos(o)
                  , n = Math.sin(o)
                  , s = e.x1 - f
                  , l = e.y1 - r;
                return e.x1 = s * a - l * n + f,
                e.y1 = s * n + l * a + r,
                s = e.x2 - f,
                l = e.y2 - r,
                e.x2 = s * a - l * n + f,
                e.y2 = s * n + l * a + r,
                s = e.x3 - f,
                l = e.y3 - r,
                e.x3 = s * a - l * n + f,
                e.y3 = s * n + l * a + r,
                e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                BUTTON_DOWN: t(1310),
                BUTTON_UP: t(1311),
                CONNECTED: t(1312),
                DISCONNECTED: t(1313),
                GAMEPAD_BUTTON_DOWN: t(1314),
                GAMEPAD_BUTTON_UP: t(1315)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(17)
              , f = t(156)
              , r = function(o, a) {
                var n = o === void 0 ? f() : e({}, o);
                if (a)
                    for (var s in a)
                        a[s] !== void 0 && (n[s] = a[s]);
                return n
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(21)
              , r = t(23)
              , o = t(8)
              , a = t(2)
              , n = t(7)
              , s = t(408)
              , l = new e({
                Extends: r,
                initialize: function(h, u, d, v) {
                    var p = "xml";
                    if (n(u)) {
                        var g = u;
                        u = a(g, "key"),
                        d = a(g, "url"),
                        v = a(g, "xhrSettings"),
                        p = a(g, "extension", p)
                    }
                    var m = {
                        type: "xml",
                        cache: h.cacheManager.xml,
                        extension: p,
                        responseType: "text",
                        key: u,
                        url: d,
                        xhrSettings: v
                    };
                    r.call(this, h, m)
                },
                onProcess: function() {
                    this.state = f.FILE_PROCESSING,
                    this.data = s(this.xhrLoader.responseText),
                    this.data ? this.onProcessComplete() : (console.warn("Invalid XMLFile: " + this.key),
                    this.onProcessError())
                }
            });
            o.register("xml", function(i, h, u) {
                if (Array.isArray(i))
                    for (var d = 0; d < i.length; d++)
                        this.addFile(new l(this,i[d]));
                else
                    this.addFile(new l(this,i,h,u));
                return this
            }),
            c.exports = l
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(21)
              , r = t(23)
              , o = t(8)
              , a = t(2)
              , n = t(7)
              , s = new e({
                Extends: r,
                initialize: function(i, h, u, d) {
                    var v = "text"
                      , p = "txt"
                      , g = i.cacheManager.text;
                    if (n(h)) {
                        var m = h;
                        h = a(m, "key"),
                        u = a(m, "url"),
                        d = a(m, "xhrSettings"),
                        p = a(m, "extension", p),
                        v = a(m, "type", v),
                        g = a(m, "cache", g)
                    }
                    var x = {
                        type: v,
                        cache: g,
                        extension: p,
                        responseType: "text",
                        key: h,
                        url: u,
                        xhrSettings: d
                    };
                    r.call(this, i, x)
                },
                onProcess: function() {
                    this.state = f.FILE_PROCESSING,
                    this.data = this.xhrLoader.responseText,
                    this.onProcessComplete()
                }
            });
            o.register("text", function(l, i, h) {
                if (Array.isArray(l))
                    for (var u = 0; u < l.length; u++)
                        this.addFile(new s(this,l[u]));
                else
                    this.addFile(new s(this,l,i,h));
                return this
            }),
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Acceleration: t(1368),
                Angular: t(1369),
                Bounce: t(1370),
                Debug: t(1371),
                Drag: t(1372),
                Enable: t(1373),
                Friction: t(1374),
                Gravity: t(1375),
                Immovable: t(1376),
                Mass: t(1377),
                OverlapCirc: t(523),
                OverlapRect: t(244),
                Pushable: t(1378),
                Size: t(1379),
                Velocity: t(1380)
            }
        }
        , function(c, S) {
            var t = function(e, f, r, o, a, n, s) {
                n === void 0 && (n = !0),
                s === void 0 && (s = !1);
                var l = []
                  , i = []
                  , h = e.treeMinMax;
                if (h.minX = f,
                h.minY = r,
                h.maxX = f + o,
                h.maxY = r + a,
                s && (i = e.staticTree.search(h)),
                n && e.useTree)
                    l = e.tree.search(h);
                else if (n) {
                    var u = e.bodies
                      , d = {
                        position: {
                            x: f,
                            y: r
                        },
                        left: f,
                        top: r,
                        right: f + o,
                        bottom: r + a,
                        isCircle: !1
                    }
                      , v = e.intersects;
                    u.iterate(function(p) {
                        v(p, d) && l.push(p)
                    })
                }
                return i.concat(l)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                COLLIDE: t(1381),
                OVERLAP: t(1382),
                PAUSE: t(1383),
                RESUME: t(1384),
                TILE_COLLIDE: t(1385),
                TILE_OVERLAP: t(1386),
                WORLD_BOUNDS: t(1387),
                WORLD_STEP: t(1388)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(62)
              , f = function(r, o, a, n) {
                var s = 0
                  , l = r.deltaAbsX() + o.deltaAbsX() + n;
                return r._dx === 0 && o._dx === 0 ? (r.embedded = !0,
                o.embedded = !0) : r._dx > o._dx ? (s = r.right - o.x,
                s > l && !a || r.checkCollision.right === !1 || o.checkCollision.left === !1 ? s = 0 : (r.touching.none = !1,
                r.touching.right = !0,
                o.touching.none = !1,
                o.touching.left = !0,
                o.physicsType === e.STATIC_BODY && !a && (r.blocked.none = !1,
                r.blocked.right = !0),
                r.physicsType === e.STATIC_BODY && !a && (o.blocked.none = !1,
                o.blocked.left = !0))) : r._dx < o._dx && (s = r.x - o.width - o.x,
                -s > l && !a || r.checkCollision.left === !1 || o.checkCollision.right === !1 ? s = 0 : (r.touching.none = !1,
                r.touching.left = !0,
                o.touching.none = !1,
                o.touching.right = !0,
                o.physicsType === e.STATIC_BODY && !a && (r.blocked.none = !1,
                r.blocked.left = !0),
                r.physicsType === e.STATIC_BODY && !a && (o.blocked.none = !1,
                o.blocked.right = !0))),
                r.overlapX = s,
                o.overlapX = s,
                s
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(62)
              , f = function(r, o, a, n) {
                var s = 0
                  , l = r.deltaAbsY() + o.deltaAbsY() + n;
                return r._dy === 0 && o._dy === 0 ? (r.embedded = !0,
                o.embedded = !0) : r._dy > o._dy ? (s = r.bottom - o.y,
                s > l && !a || r.checkCollision.down === !1 || o.checkCollision.up === !1 ? s = 0 : (r.touching.none = !1,
                r.touching.down = !0,
                o.touching.none = !1,
                o.touching.up = !0,
                o.physicsType === e.STATIC_BODY && !a && (r.blocked.none = !1,
                r.blocked.down = !0),
                r.physicsType === e.STATIC_BODY && !a && (o.blocked.none = !1,
                o.blocked.up = !0))) : r._dy < o._dy && (s = r.y - o.bottom,
                -s > l && !a || r.checkCollision.up === !1 || o.checkCollision.down === !1 ? s = 0 : (r.touching.none = !1,
                r.touching.up = !0,
                o.touching.none = !1,
                o.touching.down = !0,
                o.physicsType === e.STATIC_BODY && !a && (r.blocked.none = !1,
                r.blocked.up = !0),
                r.physicsType === e.STATIC_BODY && !a && (o.blocked.none = !1,
                o.blocked.down = !0))),
                r.overlapY = s,
                o.overlapY = s,
                s
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return !(f.right <= e.left || f.bottom <= e.top || f.position.x >= e.right || f.position.y >= e.bottom)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Bounce: t(1495),
                Collision: t(1496),
                Force: t(1497),
                Friction: t(1498),
                Gravity: t(1499),
                Mass: t(1500),
                Sensor: t(1501),
                SetBody: t(1502),
                Sleep: t(1503),
                Static: t(1520),
                Transform: t(1521),
                Velocity: t(1522)
            }
        }
        , function(c, S) {
            var t = {};
            c.exports = t,
            function() {
                t.create = function(e, f) {
                    var r = e.bodyA
                      , o = e.bodyB
                      , a = {
                        id: t.id(r, o),
                        bodyA: r,
                        bodyB: o,
                        activeContacts: [],
                        separation: 0,
                        isActive: !0,
                        confirmedActive: !0,
                        isSensor: r.isSensor || o.isSensor,
                        timeCreated: f,
                        timeUpdated: f,
                        collision: null,
                        inverseMass: 0,
                        friction: 0,
                        frictionStatic: 0,
                        restitution: 0,
                        slop: 0
                    };
                    return t.update(a, e, f),
                    a
                }
                ,
                t.update = function(e, f, r) {
                    if (e.collision = f,
                    f.collided) {
                        var o = f.supports
                          , a = e.activeContacts
                          , n = f.parentA
                          , s = f.parentB;
                        e.inverseMass = n.inverseMass + s.inverseMass,
                        e.friction = Math.min(n.friction, s.friction),
                        e.frictionStatic = Math.max(n.frictionStatic, s.frictionStatic),
                        e.restitution = Math.max(n.restitution, s.restitution),
                        e.slop = Math.max(n.slop, s.slop);
                        for (var l = 0; l < o.length; l++)
                            a[l] = o[l].contact;
                        var i = o.length;
                        i < a.length && (a.length = i),
                        e.separation = f.depth,
                        t.setActive(e, !0, r)
                    } else
                        e.isActive === !0 && t.setActive(e, !1, r)
                }
                ,
                t.setActive = function(e, f, r) {
                    f ? (e.isActive = !0,
                    e.timeUpdated = r) : (e.isActive = !1,
                    e.activeContacts.length = 0)
                }
                ,
                t.id = function(e, f) {
                    return e.id < f.id ? "A" + e.id + "B" + f.id : "A" + f.id + "B" + e.id
                }
            }()
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                CalculateFacesAt: t(252),
                CalculateFacesWithin: t(63),
                CheckIsoBounds: t(541),
                Copy: t(1420),
                CreateFromTiles: t(1421),
                CullBounds: t(543),
                CullTiles: t(544),
                Fill: t(1422),
                FilterTiles: t(1423),
                FindByIndex: t(1424),
                FindTile: t(1425),
                ForEachTile: t(1426),
                GetCullTilesFunction: t(1427),
                GetTileAt: t(158),
                GetTileAtWorldXY: t(1428),
                GetTilesWithin: t(26),
                GetTilesWithinShape: t(1429),
                GetTilesWithinWorldXY: t(529),
                GetTileToWorldXFunction: t(1430),
                GetTileToWorldXYFunction: t(1431),
                GetTileToWorldYFunction: t(1432),
                GetWorldToTileXFunction: t(1433),
                GetWorldToTileXYFunction: t(1434),
                GetWorldToTileYFunction: t(1435),
                HasTileAt: t(562),
                HasTileAtWorldXY: t(1436),
                HexagonalCullBounds: t(546),
                HexagonalCullTiles: t(545),
                HexagonalTileToWorldXY: t(550),
                HexagonalTileToWorldY: t(554),
                HexagonalWorldToTileXY: t(556),
                HexagonalWorldToTileY: t(560),
                IsInLayerBounds: t(119),
                IsometricCullTiles: t(547),
                IsometricTileToWorldXY: t(551),
                IsometricWorldToTileXY: t(557),
                PutTileAt: t(257),
                PutTileAtWorldXY: t(1437),
                PutTilesAt: t(1438),
                Randomize: t(1439),
                RemoveTileAt: t(563),
                RemoveTileAtWorldXY: t(1440),
                RenderDebug: t(1441),
                ReplaceByIndex: t(542),
                RunCull: t(159),
                SetCollision: t(1442),
                SetCollisionBetween: t(1443),
                SetCollisionByExclusion: t(1444),
                SetCollisionByProperty: t(1445),
                SetCollisionFromCollisionGroup: t(1446),
                SetLayerCollisionIndex: t(160),
                SetTileCollision: t(72),
                SetTileIndexCallback: t(1447),
                SetTileLocationCallback: t(1448),
                Shuffle: t(1449),
                StaggeredCullBounds: t(549),
                StaggeredCullTiles: t(548),
                StaggeredTileToWorldXY: t(552),
                StaggeredTileToWorldY: t(555),
                StaggeredWorldToTileXY: t(558),
                StaggeredWorldToTileY: t(561),
                SwapByIndex: t(1450),
                TileToWorldX: t(253),
                TileToWorldXY: t(553),
                TileToWorldY: t(254),
                WeightedRandomize: t(1451),
                WorldToTileX: t(255),
                WorldToTileXY: t(559),
                WorldToTileY: t(256)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(158)
              , f = function(r, o, a) {
                var n = e(r, o, !0, a)
                  , s = e(r, o - 1, !0, a)
                  , l = e(r, o + 1, !0, a)
                  , i = e(r - 1, o, !0, a)
                  , h = e(r + 1, o, !0, a)
                  , u = n && n.collides;
                return u && (n.faceTop = !0,
                n.faceBottom = !0,
                n.faceLeft = !0,
                n.faceRight = !0),
                s && s.collides && (u && (n.faceTop = !1),
                s.faceBottom = !u),
                l && l.collides && (u && (n.faceBottom = !1),
                l.faceTop = !u),
                i && i.collides && (u && (n.faceLeft = !1),
                i.faceRight = !u),
                h && h.collides && (u && (n.faceRight = !1),
                h.faceLeft = !u),
                n && !n.collides && n.resetFaces(),
                n
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                var o = r.baseTileWidth
                  , a = r.tilemapLayer
                  , n = 0;
                return a && (f || (f = a.scene.cameras.main),
                n = a.x + f.scrollX * (1 - a.scrollFactorX),
                o *= a.scaleX),
                n + e * o
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                var o = r.baseTileHeight
                  , a = r.tilemapLayer
                  , n = 0;
                return a && (f || (f = a.scene.cameras.main),
                n = a.y + f.scrollY * (1 - a.scrollFactorY),
                o *= a.scaleY),
                n + e * o
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                f === void 0 && (f = !0);
                var a = o.baseTileWidth
                  , n = o.tilemapLayer;
                return n && (r || (r = n.scene.cameras.main),
                e = e - (n.x + r.scrollX * (1 - n.scrollFactorX)),
                a *= n.scaleX),
                f ? Math.floor(e / a) : e / a
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                f === void 0 && (f = !0);
                var a = o.baseTileHeight
                  , n = o.tilemapLayer;
                return n && (r || (r = n.scene.cameras.main),
                e = e - (n.y + r.scrollY * (1 - n.scrollFactorY)),
                a *= n.scaleY),
                f ? Math.floor(e / a) : e / a
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(85)
              , f = t(119)
              , r = t(252)
              , o = t(72)
              , a = function(n, s, l, i, h) {
                if (i === void 0 && (i = !0),
                !f(s, l, h))
                    return null;
                var u = h.data[l][s]
                  , d = u && u.collides;
                if (n instanceof e)
                    h.data[l][s] === null && (h.data[l][s] = new e(h,n.index,s,l,h.tileWidth,h.tileHeight)),
                    h.data[l][s].copy(n);
                else {
                    var v = n;
                    h.data[l][s] === null ? h.data[l][s] = new e(h,v,s,l,h.tileWidth,h.tileHeight) : h.data[l][s].index = v
                }
                var p = h.data[l][s]
                  , g = h.collideIndexes.indexOf(p.index) !== -1;
                return o(p, g),
                i && d !== p.collides && r(s, l, h),
                p
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(29)
              , f = function(r) {
                return r = r.toLowerCase(),
                r === "isometric" ? e.ISOMETRIC : r === "staggered" ? e.STAGGERED : r === "hexagonal" ? e.HEXAGONAL : e.ORTHOGONAL
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(40)
              , f = t(120)
              , r = t(121)
              , o = t(85)
              , a = function(n, s, l, i, h) {
                for (var u = new f({
                    tileWidth: l,
                    tileHeight: i
                }), d = new r({
                    name: n,
                    tileWidth: l,
                    tileHeight: i,
                    format: e.ARRAY_2D,
                    layers: [u]
                }), v = [], p = s.length, g = 0, m = 0; m < s.length; m++) {
                    v[m] = [];
                    for (var x = s[m], T = 0; T < x.length; T++) {
                        var E = parseInt(x[T], 10);
                        isNaN(E) || E === -1 ? v[m][T] = h ? null : new o(u,-1,T,m,l,i) : v[m][T] = new o(u,E,T,m,l,i)
                    }
                    g === 0 && (g = x.length)
                }
                return d.width = u.width = g,
                d.height = u.height = p,
                d.widthInPixels = u.widthInPixels = g * l,
                d.heightInPixels = u.heightInPixels = p * i,
                u.data = v,
                d
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(571)
              , f = t(261)
              , r = function(n) {
                return {
                    x: n.x,
                    y: n.y
                }
            }
              , o = ["id", "name", "type", "rotation", "properties", "visible", "x", "y", "width", "height"]
              , a = function(n, s, l) {
                s === void 0 && (s = 0),
                l === void 0 && (l = 0);
                var i = e(n, o);
                if (i.x += s,
                i.y += l,
                n.gid) {
                    var h = f(n.gid);
                    i.gid = h.gid,
                    i.flippedHorizontal = h.flippedHorizontal,
                    i.flippedVertical = h.flippedVertical,
                    i.flippedAntiDiagonal = h.flippedAntiDiagonal
                } else
                    n.polyline ? i.polyline = n.polyline.map(r) : n.polygon ? i.polygon = n.polygon.map(r) : n.ellipse ? i.ellipse = n.ellipse : n.text ? i.text = n.text : n.point ? i.point = !0 : i.rectangle = !0;
                return i
            };
            c.exports = a
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = 2147483648
              , e = 1073741824
              , f = 536870912
              , r = function(o) {
                var a = Boolean(o & t)
                  , n = Boolean(o & e)
                  , s = Boolean(o & f);
                o = o & ~(t | e | f);
                var l = 0
                  , i = !1;
                return a && n && s ? (l = Math.PI / 2,
                i = !0) : a && n && !s ? (l = Math.PI,
                i = !1) : a && !n && s ? (l = Math.PI / 2,
                i = !1) : a && !n && !s ? (l = 0,
                i = !0) : !a && n && s ? (l = 3 * Math.PI / 2,
                i = !1) : !a && n && !s ? (l = Math.PI,
                i = !0) : !a && !n && s ? (l = 3 * Math.PI / 2,
                i = !0) : !a && !n && !s && (l = 0,
                i = !1),
                {
                    gid: o,
                    flippedHorizontal: a,
                    flippedVertical: n,
                    flippedAntiDiagonal: s,
                    rotation: l,
                    flipped: i
                }
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(40)
              , f = t(121)
              , r = t(564)
              , o = t(580)
              , a = function(n, s, l, i, h, u, d, v) {
                l === void 0 && (l = 32),
                i === void 0 && (i = 32),
                h === void 0 && (h = 10),
                u === void 0 && (u = 10),
                v === void 0 && (v = !1);
                var p = null;
                if (Array.isArray(d)) {
                    var g = s !== void 0 ? s : "map";
                    p = r(g, e.ARRAY_2D, d, l, i, v)
                } else if (s !== void 0) {
                    var m = n.cache.tilemap.get(s);
                    m ? p = r(s, m.format, m.data, l, i, v) : console.warn("No map data found for key " + s)
                }
                return p === null && (p = new f({
                    tileWidth: l,
                    tileHeight: i,
                    width: h,
                    height: u
                })),
                new o(n,p)
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(6)
              , f = function(r) {
                var o = e(r, "targets", null);
                return o === null || (typeof o == "function" && (o = o.call()),
                Array.isArray(o) || (o = [o])),
                o
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            function t(a) {
                return !!a.getActive && typeof a.getActive == "function"
            }
            function e(a) {
                return !!a.getStart && typeof a.getStart == "function"
            }
            function f(a) {
                return !!a.getEnd && typeof a.getEnd == "function"
            }
            function r(a) {
                return e(a) || f(a) || t(a)
            }
            var o = function(a, n) {
                var s, l = function(E, P, M) {
                    return M
                }, i = function(E, P, M) {
                    return M
                }, h = null, u = typeof n;
                if (u === "number")
                    l = function() {
                        return n
                    }
                    ;
                else if (u === "string") {
                    var d = n[0]
                      , v = parseFloat(n.substr(2));
                    switch (d) {
                    case "+":
                        l = function(E, P, M) {
                            return M + v
                        }
                        ;
                        break;
                    case "-":
                        l = function(E, P, M) {
                            return M - v
                        }
                        ;
                        break;
                    case "*":
                        l = function(E, P, M) {
                            return M * v
                        }
                        ;
                        break;
                    case "/":
                        l = function(E, P, M) {
                            return M / v
                        }
                        ;
                        break;
                    default:
                        l = function() {
                            return parseFloat(n)
                        }
                    }
                } else if (u === "function")
                    l = n;
                else if (u === "object")
                    if (r(n))
                        t(n) && (h = n.getActive),
                        f(n) && (l = n.getEnd),
                        e(n) && (i = n.getStart);
                    else if (n.hasOwnProperty("value"))
                        s = o(a, n.value);
                    else {
                        var p = n.hasOwnProperty("to")
                          , g = n.hasOwnProperty("from")
                          , m = n.hasOwnProperty("start");
                        if (p && (g || m)) {
                            if (s = o(a, n.to),
                            m) {
                                var x = o(a, n.start);
                                s.getActive = x.getEnd
                            }
                            if (g) {
                                var T = o(a, n.from);
                                s.getStart = T.getEnd
                            }
                        }
                    }
                return s || (s = {
                    getActive: h,
                    getEnd: l,
                    getStart: i
                }),
                s
            };
            c.exports = o
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                targets: null,
                delay: 0,
                duration: 1e3,
                ease: "Power0",
                easeParams: null,
                hold: 0,
                repeat: 0,
                repeatDelay: 0,
                yoyo: !1,
                flipX: !1,
                flipY: !1
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(9)
              , r = t(267)
              , o = t(16)
              , a = t(5)
              , n = t(100)
              , s = t(14)
              , l = new e({
                Extends: f,
                initialize: function(h, u, d) {
                    f.call(this),
                    this.parent = h,
                    this.parentIsTimeline = h.hasOwnProperty("isTimeline"),
                    this.data = u,
                    this.totalData = u.length,
                    this.targets = d,
                    this.totalTargets = d.length,
                    this.useFrames = !1,
                    this.timeScale = 1,
                    this.loop = 0,
                    this.loopDelay = 0,
                    this.loopCounter = 0,
                    this.startDelay = 0,
                    this.hasStarted = !1,
                    this.isSeeking = !1,
                    this.completeDelay = 0,
                    this.countdown = 0,
                    this.offset = 0,
                    this.calculatedOffset = 0,
                    this.state = n.PENDING_ADD,
                    this._pausedState = n.INIT,
                    this.paused = !1,
                    this.elapsed = 0,
                    this.totalElapsed = 0,
                    this.duration = 0,
                    this.progress = 0,
                    this.totalDuration = 0,
                    this.totalProgress = 0,
                    this.callbacks = {
                        onActive: null,
                        onComplete: null,
                        onLoop: null,
                        onRepeat: null,
                        onStart: null,
                        onStop: null,
                        onUpdate: null,
                        onYoyo: null
                    },
                    this.callbackScope
                },
                getValue: function(i) {
                    return i === void 0 && (i = 0),
                    this.data[i].current
                },
                setTimeScale: function(i) {
                    return this.timeScale = i,
                    this
                },
                getTimeScale: function() {
                    return this.timeScale
                },
                isPlaying: function() {
                    return this.state === n.ACTIVE
                },
                isPaused: function() {
                    return this.state === n.PAUSED
                },
                hasTarget: function(i) {
                    return this.targets.indexOf(i) !== -1
                },
                updateTo: function(i, h, u) {
                    u === void 0 && (u = !1);
                    for (var d = 0; d < this.totalData; d++) {
                        var v = this.data[d];
                        v.key === i && (v.end = h,
                        u && (v.start = v.current))
                    }
                    return this
                },
                restart: function() {
                    return this.elapsed = 0,
                    this.progress = 0,
                    this.totalElapsed = 0,
                    this.totalProgress = 0,
                    this.state === n.ACTIVE ? this.seek(0) : this.state === n.REMOVED ? (this.seek(0),
                    this.parent.makeActive(this),
                    this) : this.state === n.PENDING_ADD ? this : this.play()
                },
                calcDuration: function() {
                    for (var i = 0, h = s.MAX_SAFE_INTEGER, u = this.data, d = 0; d < this.totalData; d++) {
                        var v = u[d];
                        v.t1 = v.duration + v.hold,
                        v.yoyo && (v.t1 += v.duration),
                        v.t2 = v.t1 + v.repeatDelay,
                        v.totalDuration = v.delay + v.t1,
                        v.repeat === -1 ? v.totalDuration += v.t2 * 999999999999 : v.repeat > 0 && (v.totalDuration += v.t2 * v.repeat),
                        v.totalDuration > i && (i = v.totalDuration),
                        v.delay < h && (h = v.delay)
                    }
                    this.duration = Math.max(i, .001),
                    this.loopCounter = this.loop === -1 ? 999999999999 : this.loop,
                    this.loopCounter > 0 ? this.totalDuration = this.duration + this.completeDelay + (this.duration + this.loopDelay) * this.loopCounter : this.totalDuration = this.duration + this.completeDelay,
                    this.startDelay = h
                },
                init: function() {
                    if (this.paused && !this.parentIsTimeline)
                        return this.state = n.PENDING_ADD,
                        this._pausedState = n.INIT,
                        !1;
                    for (var i = this.data, h = this.totalTargets, u = 0; u < this.totalData; u++) {
                        var d = i[u]
                          , v = d.target
                          , p = d.gen
                          , g = d.key
                          , m = d.index;
                        d.delay = p.delay(v, g, 0, m, h, this),
                        d.duration = Math.max(p.duration(v, g, 0, m, h, this), .001),
                        d.hold = p.hold(v, g, 0, m, h, this),
                        d.repeat = p.repeat(v, g, 0, m, h, this),
                        d.repeatDelay = p.repeatDelay(v, g, 0, m, h, this)
                    }
                    return this.calcDuration(),
                    this.progress = 0,
                    this.totalProgress = 0,
                    this.elapsed = 0,
                    this.totalElapsed = 0,
                    this.state = n.INIT,
                    !0
                },
                makeActive: function() {
                    this.parent.makeActive(this),
                    this.dispatchTweenEvent(r.TWEEN_ACTIVE, this.callbacks.onActive)
                },
                nextState: function() {
                    this.loopCounter > 0 ? (this.elapsed = 0,
                    this.progress = 0,
                    this.loopCounter--,
                    this.resetTweenData(!0),
                    this.loopDelay > 0 ? (this.countdown = this.loopDelay,
                    this.state = n.LOOP_DELAY) : (this.state = n.ACTIVE,
                    this.dispatchTweenEvent(r.TWEEN_LOOP, this.callbacks.onLoop))) : this.completeDelay > 0 ? (this.state = n.COMPLETE_DELAY,
                    this.countdown = this.completeDelay) : (this.state = n.PENDING_REMOVE,
                    this.dispatchTweenEvent(r.TWEEN_COMPLETE, this.callbacks.onComplete))
                },
                pause: function() {
                    return this.state === n.PAUSED ? this : (this.paused = !0,
                    this._pausedState = this.state,
                    this.state = n.PAUSED,
                    this)
                },
                play: function(i) {
                    i === void 0 && (i = !1);
                    var h = this.state;
                    return h === n.INIT && !this.parentIsTimeline ? (this.resetTweenData(!1),
                    this.state = n.ACTIVE,
                    this) : h === n.ACTIVE || h === n.PENDING_ADD && this._pausedState === n.PENDING_ADD ? this : !this.parentIsTimeline && (h === n.PENDING_REMOVE || h === n.REMOVED) ? (this.seek(0),
                    this.parent.makeActive(this),
                    this) : (this.parentIsTimeline ? (this.resetTweenData(i),
                    this.calculatedOffset === 0 ? this.state = n.ACTIVE : (this.countdown = this.calculatedOffset,
                    this.state = n.OFFSET_DELAY)) : this.paused ? (this.paused = !1,
                    this.makeActive()) : (this.resetTweenData(i),
                    this.state = n.ACTIVE,
                    this.makeActive()),
                    this)
                },
                resetTweenData: function(i) {
                    for (var h = this.data, u = this.totalData, d = this.totalTargets, v = 0; v < u; v++) {
                        var p = h[v]
                          , g = p.target
                          , m = p.key
                          , x = p.index;
                        p.progress = 0,
                        p.elapsed = 0,
                        p.repeatCounter = p.repeat === -1 ? 999999999999 : p.repeat,
                        i ? (p.start = p.getStartValue(g, m, p.start, x, d, this),
                        p.end = p.getEndValue(g, m, p.end, x, d, this),
                        p.current = p.start,
                        p.state = n.PLAYING_FORWARD) : p.state = n.PENDING_RENDER,
                        p.delay > 0 && (p.elapsed = p.delay,
                        p.state = n.DELAY),
                        p.getActiveValue && (g[m] = p.getActiveValue(p.target, p.key, p.start))
                    }
                },
                resume: function() {
                    return this.state === n.PAUSED ? (this.paused = !1,
                    this.state = this._pausedState) : this.play(),
                    this
                },
                seek: function(i, h) {
                    h === void 0 && (h = 16.6),
                    this.state === n.REMOVED && this.makeActive(),
                    this.elapsed = 0,
                    this.progress = 0,
                    this.totalElapsed = 0,
                    this.totalProgress = 0;
                    for (var u = this.data, d = this.totalTargets, v = 0; v < this.totalData; v++) {
                        var p = u[v]
                          , g = p.target
                          , m = p.gen
                          , x = p.key
                          , T = p.index;
                        p.progress = 0,
                        p.elapsed = 0,
                        p.repeatCounter = p.repeat === -1 ? 999999999999 : p.repeat,
                        p.delay = m.delay(g, x, 0, T, d, this),
                        p.duration = Math.max(m.duration(g, x, 0, T, d, this), .001),
                        p.hold = m.hold(g, x, 0, T, d, this),
                        p.repeat = m.repeat(g, x, 0, T, d, this),
                        p.repeatDelay = m.repeatDelay(g, x, 0, T, d, this),
                        p.current = p.start,
                        p.state = n.PLAYING_FORWARD,
                        this.updateTweenData(this, p, 0, T, d),
                        p.delay > 0 && (p.elapsed = p.delay,
                        p.state = n.DELAY)
                    }
                    this.calcDuration();
                    var E = !1;
                    this.state === n.PAUSED && (E = !0,
                    this.state = n.ACTIVE),
                    this.isSeeking = !0;
                    do
                        this.update(0, h);
                    while (this.totalProgress < i);
                    return this.isSeeking = !1,
                    E && (this.state = n.PAUSED),
                    this
                },
                setCallback: function(i, h, u, d) {
                    return this.callbacks[i] = {
                        func: h,
                        scope: d,
                        params: u
                    },
                    this
                },
                complete: function(i) {
                    return i === void 0 && (i = 0),
                    i ? (this.state = n.COMPLETE_DELAY,
                    this.countdown = i) : (this.state = n.PENDING_REMOVE,
                    this.dispatchTweenEvent(r.TWEEN_COMPLETE, this.callbacks.onComplete)),
                    this
                },
                remove: function() {
                    return this.parent.remove(this),
                    this
                },
                stop: function(i) {
                    return this.state === n.ACTIVE && i !== void 0 && this.seek(i),
                    this.state !== n.REMOVED && ((this.state === n.PAUSED || this.state === n.PENDING_ADD) && (this.parentIsTimeline ? (this.parent.manager._destroy.push(this),
                    this.parent.manager._toProcess++) : (this.parent._destroy.push(this),
                    this.parent._toProcess++)),
                    this.dispatchTweenEvent(r.TWEEN_STOP, this.callbacks.onStop),
                    this.removeAllListeners(),
                    this.state = n.PENDING_REMOVE),
                    this
                },
                update: function(i, h) {
                    if (this.state === n.PAUSED)
                        return !1;
                    switch (this.useFrames && (h = 1 * this.parent.timeScale),
                    h *= this.timeScale,
                    this.elapsed += h,
                    this.progress = Math.min(this.elapsed / this.duration, 1),
                    this.totalElapsed += h,
                    this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1),
                    this.state) {
                    case n.ACTIVE:
                        !this.hasStarted && !this.isSeeking && (this.startDelay -= h,
                        this.startDelay <= 0 && (this.hasStarted = !0,
                        this.dispatchTweenEvent(r.TWEEN_START, this.callbacks.onStart)));
                        for (var u = !1, d = 0; d < this.totalData; d++) {
                            var v = this.data[d];
                            this.updateTweenData(this, v, h) && (u = !0)
                        }
                        u || this.nextState();
                        break;
                    case n.LOOP_DELAY:
                        this.countdown -= h,
                        this.countdown <= 0 && (this.state = n.ACTIVE,
                        this.dispatchTweenEvent(r.TWEEN_LOOP, this.callbacks.onLoop));
                        break;
                    case n.OFFSET_DELAY:
                        this.countdown -= h,
                        this.countdown <= 0 && (this.state = n.ACTIVE);
                        break;
                    case n.COMPLETE_DELAY:
                        this.countdown -= h,
                        this.countdown <= 0 && (this.state = n.PENDING_REMOVE,
                        this.dispatchTweenEvent(r.TWEEN_COMPLETE, this.callbacks.onComplete));
                        break
                    }
                    return this.state === n.PENDING_REMOVE
                },
                dispatchTweenDataEvent: function(i, h, u) {
                    this.isSeeking || (this.emit(i, this, u.key, u.target, u.current, u.previous),
                    h && (h.params[1] = u.target,
                    h.func.apply(h.scope, h.params)))
                },
                dispatchTweenEvent: function(i, h) {
                    this.isSeeking || (this.emit(i, this, this.targets),
                    h && (h.params[1] = this.targets,
                    h.func.apply(h.scope, h.params)))
                },
                setStateFromEnd: function(i, h, u) {
                    return h.yoyo ? (h.elapsed = u,
                    h.progress = u / h.duration,
                    h.flipX && h.target.toggleFlipX(),
                    h.flipY && h.target.toggleFlipY(),
                    this.dispatchTweenDataEvent(r.TWEEN_YOYO, i.callbacks.onYoyo, h),
                    h.start = h.getStartValue(h.target, h.key, h.start, h.index, i.totalTargets, i),
                    n.PLAYING_BACKWARD) : h.repeatCounter > 0 ? (h.repeatCounter--,
                    h.elapsed = u,
                    h.progress = u / h.duration,
                    h.flipX && h.target.toggleFlipX(),
                    h.flipY && h.target.toggleFlipY(),
                    h.start = h.getStartValue(h.target, h.key, h.start, h.index, i.totalTargets, i),
                    h.end = h.getEndValue(h.target, h.key, h.start, h.index, i.totalTargets, i),
                    h.repeatDelay > 0 ? (h.elapsed = h.repeatDelay - u,
                    h.current = h.start,
                    h.target[h.key] = h.current,
                    n.REPEAT_DELAY) : (this.dispatchTweenDataEvent(r.TWEEN_REPEAT, i.callbacks.onRepeat, h),
                    n.PLAYING_FORWARD)) : n.COMPLETE
                },
                setStateFromStart: function(i, h, u) {
                    return h.repeatCounter > 0 ? (h.repeatCounter--,
                    h.elapsed = u,
                    h.progress = u / h.duration,
                    h.flipX && h.target.toggleFlipX(),
                    h.flipY && h.target.toggleFlipY(),
                    h.end = h.getEndValue(h.target, h.key, h.start, h.index, i.totalTargets, i),
                    h.repeatDelay > 0 ? (h.elapsed = h.repeatDelay - u,
                    h.current = h.start,
                    h.target[h.key] = h.current,
                    n.REPEAT_DELAY) : (this.dispatchTweenDataEvent(r.TWEEN_REPEAT, i.callbacks.onRepeat, h),
                    n.PLAYING_FORWARD)) : n.COMPLETE
                },
                updateTweenData: function(i, h, u) {
                    var d = h.target;
                    switch (h.state) {
                    case n.PLAYING_FORWARD:
                    case n.PLAYING_BACKWARD:
                        if (!d) {
                            h.state = n.COMPLETE;
                            break
                        }
                        var v = h.elapsed
                          , p = h.duration
                          , g = 0;
                        v += u,
                        v > p && (g = v - p,
                        v = p);
                        var m = h.state === n.PLAYING_FORWARD
                          , x = v / p;
                        if (h.elapsed = v,
                        h.progress = x,
                        h.previous = h.current,
                        x === 1)
                            m ? (h.current = h.end,
                            d[h.key] = h.end,
                            h.hold > 0 ? (h.elapsed = h.hold - g,
                            h.state = n.HOLD_DELAY) : h.state = this.setStateFromEnd(i, h, g)) : (h.current = h.start,
                            d[h.key] = h.start,
                            h.state = this.setStateFromStart(i, h, g));
                        else {
                            var T = m ? h.ease(x) : h.ease(1 - x);
                            h.current = h.start + (h.end - h.start) * T,
                            d[h.key] = h.current
                        }
                        this.dispatchTweenDataEvent(r.TWEEN_UPDATE, i.callbacks.onUpdate, h);
                        break;
                    case n.DELAY:
                        h.elapsed -= u,
                        h.elapsed <= 0 && (h.elapsed = Math.abs(h.elapsed),
                        h.state = n.PENDING_RENDER);
                        break;
                    case n.REPEAT_DELAY:
                        h.elapsed -= u,
                        h.elapsed <= 0 && (h.elapsed = Math.abs(h.elapsed),
                        h.state = n.PLAYING_FORWARD,
                        this.dispatchTweenDataEvent(r.TWEEN_REPEAT, i.callbacks.onRepeat, h));
                        break;
                    case n.HOLD_DELAY:
                        h.elapsed -= u,
                        h.elapsed <= 0 && (h.state = this.setStateFromEnd(i, h, Math.abs(h.elapsed)));
                        break;
                    case n.PENDING_RENDER:
                        d ? (h.start = h.getStartValue(d, h.key, d[h.key], h.index, i.totalTargets, i),
                        h.end = h.getEndValue(d, h.key, h.start, h.index, i.totalTargets, i),
                        h.current = h.start,
                        d[h.key] = h.start,
                        h.state = n.PLAYING_FORWARD) : h.state = n.COMPLETE;
                        break
                    }
                    return h.state !== n.COMPLETE
                }
            });
            l.TYPES = ["onActive", "onComplete", "onLoop", "onRepeat", "onStart", "onStop", "onUpdate", "onYoyo"],
            a.register("tween", function(i) {
                return this.scene.sys.tweens.add(i)
            }),
            o.register("tween", function(i) {
                return this.scene.sys.tweens.create(i)
            }),
            c.exports = l
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                TIMELINE_COMPLETE: t(1466),
                TIMELINE_LOOP: t(1467),
                TIMELINE_PAUSE: t(1468),
                TIMELINE_RESUME: t(1469),
                TIMELINE_START: t(1470),
                TIMELINE_UPDATE: t(1471),
                TWEEN_ACTIVE: t(1472),
                TWEEN_COMPLETE: t(1473),
                TWEEN_LOOP: t(1474),
                TWEEN_REPEAT: t(1475),
                TWEEN_START: t(1476),
                TWEEN_STOP: t(1477),
                TWEEN_UPDATE: t(1478),
                TWEEN_YOYO: t(1479)
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o, a, n, s, l, i, h, u, d, v, p, g) {
                return {
                    target: e,
                    index: f,
                    key: r,
                    getActiveValue: n,
                    getEndValue: o,
                    getStartValue: a,
                    ease: s,
                    duration: 0,
                    totalDuration: 0,
                    delay: 0,
                    yoyo: h,
                    hold: 0,
                    repeat: 0,
                    repeatDelay: 0,
                    flipX: p,
                    flipY: g,
                    progress: 0,
                    elapsed: 0,
                    repeatCounter: 0,
                    start: 0,
                    previous: 0,
                    current: 0,
                    end: 0,
                    t1: 0,
                    t2: 0,
                    gen: {
                        delay: l,
                        duration: i,
                        hold: u,
                        repeat: d,
                        repeatDelay: v
                    },
                    state: 0
                }
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(68)
              , f = function(r) {
                return e(r, -Math.PI, Math.PI)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(68)
              , f = function(r) {
                return e(r, -180, 180)
            };
            c.exports = f
        }
        , function(c, S, t) {
            var e = {};
            c.exports = e;
            var f = t(83)
              , r = t(32);
            (function() {
                e.fromVertices = function(o) {
                    for (var a = {}, n = 0; n < o.length; n++) {
                        var s = (n + 1) % o.length
                          , l = f.normalise({
                            x: o[s].y - o[n].y,
                            y: o[n].x - o[s].x
                        })
                          , i = l.y === 0 ? 1 / 0 : l.x / l.y;
                        i = i.toFixed(3).toString(),
                        a[i] = l
                    }
                    return r.values(a)
                }
                ,
                e.rotate = function(o, a) {
                    if (a !== 0)
                        for (var n = Math.cos(a), s = Math.sin(a), l = 0; l < o.length; l++) {
                            var i = o[l], h;
                            h = i.x * n - i.y * s,
                            i.y = i.x * s + i.y * n,
                            i.x = h
                        }
                }
            }
            )()
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                AFTER_ADD: t(1504),
                AFTER_REMOVE: t(1505),
                AFTER_UPDATE: t(1506),
                BEFORE_ADD: t(1507),
                BEFORE_REMOVE: t(1508),
                BEFORE_UPDATE: t(1509),
                COLLISION_ACTIVE: t(1510),
                COLLISION_END: t(1511),
                COLLISION_START: t(1512),
                DRAG_END: t(1513),
                DRAG: t(1514),
                DRAG_START: t(1515),
                PAUSE: t(1516),
                RESUME: t(1517),
                SLEEP_END: t(1518),
                SLEEP_START: t(1519)
            }
        }
        , function(c, S, t) {
            var e = {};
            c.exports = e;
            var f = t(274)
              , r = t(250)
              , o = t(84);
            (function() {
                e.collisions = function(a, n) {
                    for (var s = [], l = n.pairs.table, i = n.metrics, h = 0; h < a.length; h++) {
                        var u = a[h][0]
                          , d = a[h][1];
                        if (!((u.isStatic || u.isSleeping) && (d.isStatic || d.isSleeping)) && e.canCollide(u.collisionFilter, d.collisionFilter) && (i.midphaseTests += 1,
                        o.overlaps(u.bounds, d.bounds)))
                            for (var v = u.parts.length > 1 ? 1 : 0; v < u.parts.length; v++)
                                for (var p = u.parts[v], g = d.parts.length > 1 ? 1 : 0; g < d.parts.length; g++) {
                                    var m = d.parts[g];
                                    if (p === u && m === d || o.overlaps(p.bounds, m.bounds)) {
                                        var x = r.id(p, m), T = l[x], E;
                                        T && T.isActive ? E = T.collision : E = null;
                                        var P = f.collides(p, m, E);
                                        i.narrowphaseTests += 1,
                                        P.reused && (i.narrowReuseCount += 1),
                                        P.collided && (s.push(P),
                                        i.narrowDetections += 1)
                                    }
                                }
                    }
                    return s
                }
                ,
                e.canCollide = function(a, n) {
                    return a.group === n.group && a.group !== 0 ? a.group > 0 : (a.mask & n.category) !== 0 && (n.mask & a.category) !== 0
                }
            }
            )()
        }
        , function(c, S, t) {
            var e = {};
            c.exports = e;
            var f = t(64)
              , r = t(83);
            (function() {
                e.collides = function(o, a, n) {
                    var s, l, i, h, u = !1;
                    if (n) {
                        var d = o.parent
                          , v = a.parent
                          , p = d.speed * d.speed + d.angularSpeed * d.angularSpeed + v.speed * v.speed + v.angularSpeed * v.angularSpeed;
                        u = n && n.collided && p < .2,
                        h = n
                    } else
                        h = {
                            collided: !1,
                            bodyA: o,
                            bodyB: a
                        };
                    if (n && u) {
                        var g = h.axisBody
                          , m = g === o ? a : o
                          , x = [g.axes[n.axisNumber]];
                        if (i = e._overlapAxes(g.vertices, m.vertices, x),
                        h.reused = !0,
                        i.overlap <= 0)
                            return h.collided = !1,
                            h
                    } else {
                        if (s = e._overlapAxes(o.vertices, a.vertices, o.axes),
                        s.overlap <= 0 || (l = e._overlapAxes(a.vertices, o.vertices, a.axes),
                        l.overlap <= 0))
                            return h.collided = !1,
                            h;
                        s.overlap < l.overlap ? (i = s,
                        h.axisBody = o) : (i = l,
                        h.axisBody = a),
                        h.axisNumber = i.axisNumber
                    }
                    h.bodyA = o.id < a.id ? o : a,
                    h.bodyB = o.id < a.id ? a : o,
                    h.collided = !0,
                    h.depth = i.overlap,
                    h.parentA = h.bodyA.parent,
                    h.parentB = h.bodyB.parent,
                    o = h.bodyA,
                    a = h.bodyB,
                    r.dot(i.axis, r.sub(a.position, o.position)) < 0 ? h.normal = {
                        x: i.axis.x,
                        y: i.axis.y
                    } : h.normal = {
                        x: -i.axis.x,
                        y: -i.axis.y
                    },
                    h.tangent = r.perp(h.normal),
                    h.penetration = h.penetration || {},
                    h.penetration.x = h.normal.x * h.depth,
                    h.penetration.y = h.normal.y * h.depth;
                    var T = e._findSupports(o, a, h.normal)
                      , E = [];
                    if (f.contains(o.vertices, T[0]) && E.push(T[0]),
                    f.contains(o.vertices, T[1]) && E.push(T[1]),
                    E.length < 2) {
                        var P = e._findSupports(a, o, r.neg(h.normal));
                        f.contains(a.vertices, P[0]) && E.push(P[0]),
                        E.length < 2 && f.contains(a.vertices, P[1]) && E.push(P[1])
                    }
                    return E.length < 1 && (E = [T[0]]),
                    h.supports = E,
                    h
                }
                ,
                e._overlapAxes = function(o, a, n) {
                    for (var s = r._temp[0], l = r._temp[1], i = {
                        overlap: Number.MAX_VALUE
                    }, h, u, d = 0; d < n.length; d++) {
                        if (u = n[d],
                        e._projectToAxis(s, o, u),
                        e._projectToAxis(l, a, u),
                        h = Math.min(s.max - l.min, l.max - s.min),
                        h <= 0)
                            return i.overlap = h,
                            i;
                        h < i.overlap && (i.overlap = h,
                        i.axis = u,
                        i.axisNumber = d)
                    }
                    return i
                }
                ,
                e._projectToAxis = function(o, a, n) {
                    for (var s = r.dot(a[0], n), l = s, i = 1; i < a.length; i += 1) {
                        var h = r.dot(a[i], n);
                        h > l ? l = h : h < s && (s = h)
                    }
                    o.min = s,
                    o.max = l
                }
                ,
                e._findSupports = function(o, a, n) {
                    for (var s = Number.MAX_VALUE, l = r._temp[0], i = a.vertices, h = o.position, u, d, v, p, g = 0; g < i.length; g++)
                        d = i[g],
                        l.x = d.x - h.x,
                        l.y = d.y - h.y,
                        u = -r.dot(n, l),
                        u < s && (s = u,
                        v = d);
                    var m = v.index - 1 >= 0 ? v.index - 1 : i.length - 1;
                    d = i[m],
                    l.x = d.x - h.x,
                    l.y = d.y - h.y,
                    s = -r.dot(n, l),
                    p = d;
                    var x = (v.index + 1) % i.length;
                    return d = i[x],
                    l.x = d.x - h.x,
                    l.y = d.y - h.y,
                    u = -r.dot(n, l),
                    u < s && (p = d),
                    [v, p]
                }
            }
            )()
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                AlignTo: t(601),
                Angle: t(602),
                Call: t(603),
                GetFirst: t(604),
                GetLast: t(605),
                GridAlign: t(606),
                IncAlpha: t(678),
                IncX: t(679),
                IncXY: t(680),
                IncY: t(681),
                PlaceOnCircle: t(682),
                PlaceOnEllipse: t(683),
                PlaceOnLine: t(684),
                PlaceOnRectangle: t(685),
                PlaceOnTriangle: t(686),
                PlayAnimation: t(687),
                PropertyValueInc: t(46),
                PropertyValueSet: t(27),
                RandomCircle: t(688),
                RandomEllipse: t(689),
                RandomLine: t(690),
                RandomRectangle: t(691),
                RandomTriangle: t(692),
                Rotate: t(693),
                RotateAround: t(694),
                RotateAroundDistance: t(695),
                ScaleX: t(696),
                ScaleXY: t(697),
                ScaleY: t(698),
                SetAlpha: t(699),
                SetBlendMode: t(700),
                SetDepth: t(701),
                SetHitArea: t(702),
                SetOrigin: t(703),
                SetRotation: t(704),
                SetScale: t(705),
                SetScaleX: t(706),
                SetScaleY: t(707),
                SetScrollFactor: t(708),
                SetScrollFactorX: t(709),
                SetScrollFactorY: t(710),
                SetTint: t(711),
                SetVisible: t(712),
                SetX: t(713),
                SetXY: t(714),
                SetY: t(715),
                ShiftPosition: t(716),
                Shuffle: t(717),
                SmootherStep: t(718),
                SmoothStep: t(719),
                Spread: t(720),
                ToggleVisible: t(721),
                WrapInRectangle: t(722)
            }
        }
        , function(c, S, t) {
            /**
 * @author       samme
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(123)
              , f = [];
            f[e.BOTTOM_CENTER] = t(277),
            f[e.BOTTOM_LEFT] = t(278),
            f[e.BOTTOM_RIGHT] = t(279),
            f[e.LEFT_BOTTOM] = t(280),
            f[e.LEFT_CENTER] = t(281),
            f[e.LEFT_TOP] = t(282),
            f[e.RIGHT_BOTTOM] = t(283),
            f[e.RIGHT_CENTER] = t(284),
            f[e.RIGHT_TOP] = t(285),
            f[e.TOP_CENTER] = t(286),
            f[e.TOP_LEFT] = t(287),
            f[e.TOP_RIGHT] = t(288);
            var r = function(o, a, n, s, l) {
                return f[n](o, a, s, l)
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(42)
              , f = t(87)
              , r = t(88)
              , o = t(52)
              , a = function(n, s, l, i) {
                return l === void 0 && (l = 0),
                i === void 0 && (i = 0),
                r(n, f(s) + l),
                o(n, e(s) + i),
                n
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(42)
              , f = t(43)
              , r = t(53)
              , o = t(52)
              , a = function(n, s, l, i) {
                return l === void 0 && (l = 0),
                i === void 0 && (i = 0),
                r(n, f(s) - l),
                o(n, e(s) + i),
                n
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(42)
              , f = t(44)
              , r = t(54)
              , o = t(52)
              , a = function(n, s, l, i) {
                return l === void 0 && (l = 0),
                i === void 0 && (i = 0),
                r(n, f(s) + l),
                o(n, e(s) + i),
                n
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(42)
              , f = t(43)
              , r = t(55)
              , o = t(54)
              , a = function(n, s, l, i) {
                return l === void 0 && (l = 0),
                i === void 0 && (i = 0),
                o(n, f(s) - l),
                r(n, e(s) + i),
                n
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(89)
              , f = t(43)
              , r = t(90)
              , o = t(54)
              , a = function(n, s, l, i) {
                return l === void 0 && (l = 0),
                i === void 0 && (i = 0),
                o(n, f(s) - l),
                r(n, e(s) + i),
                n
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(43)
              , f = t(45)
              , r = t(54)
              , o = t(52)
              , a = function(n, s, l, i) {
                return l === void 0 && (l = 0),
                i === void 0 && (i = 0),
                r(n, e(s) - l),
                o(n, f(s) - i),
                n
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(42)
              , f = t(44)
              , r = t(55)
              , o = t(53)
              , a = function(n, s, l, i) {
                return l === void 0 && (l = 0),
                i === void 0 && (i = 0),
                o(n, f(s) + l),
                r(n, e(s) + i),
                n
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(89)
              , f = t(44)
              , r = t(90)
              , o = t(53)
              , a = function(n, s, l, i) {
                return l === void 0 && (l = 0),
                i === void 0 && (i = 0),
                o(n, f(s) + l),
                r(n, e(s) + i),
                n
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(44)
              , f = t(45)
              , r = t(53)
              , o = t(52)
              , a = function(n, s, l, i) {
                return l === void 0 && (l = 0),
                i === void 0 && (i = 0),
                r(n, e(s) + l),
                o(n, f(s) - i),
                n
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(87)
              , f = t(45)
              , r = t(55)
              , o = t(88)
              , a = function(n, s, l, i) {
                return l === void 0 && (l = 0),
                i === void 0 && (i = 0),
                o(n, e(s) + l),
                r(n, f(s) - i),
                n
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(43)
              , f = t(45)
              , r = t(55)
              , o = t(53)
              , a = function(n, s, l, i) {
                return l === void 0 && (l = 0),
                i === void 0 && (i = 0),
                o(n, e(s) - l),
                r(n, f(s) - i),
                n
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(44)
              , f = t(45)
              , r = t(55)
              , o = t(54)
              , a = function(n, s, l, i) {
                return l === void 0 && (l = 0),
                i === void 0 && (i = 0),
                o(n, e(s) + l),
                r(n, f(s) - i),
                n
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(123)
              , f = [];
            f[e.BOTTOM_CENTER] = t(290),
            f[e.BOTTOM_LEFT] = t(291),
            f[e.BOTTOM_RIGHT] = t(292),
            f[e.CENTER] = t(293),
            f[e.LEFT_CENTER] = t(295),
            f[e.RIGHT_CENTER] = t(296),
            f[e.TOP_CENTER] = t(297),
            f[e.TOP_LEFT] = t(298),
            f[e.TOP_RIGHT] = t(299),
            f[e.LEFT_BOTTOM] = f[e.BOTTOM_LEFT],
            f[e.LEFT_TOP] = f[e.TOP_LEFT],
            f[e.RIGHT_BOTTOM] = f[e.BOTTOM_RIGHT],
            f[e.RIGHT_TOP] = f[e.TOP_RIGHT];
            var r = function(o, a, n, s, l) {
                return f[n](o, a, s, l)
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(42)
              , f = t(87)
              , r = t(55)
              , o = t(88)
              , a = function(n, s, l, i) {
                return l === void 0 && (l = 0),
                i === void 0 && (i = 0),
                o(n, f(s) + l),
                r(n, e(s) + i),
                n
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(42)
              , f = t(43)
              , r = t(55)
              , o = t(53)
              , a = function(n, s, l, i) {
                return l === void 0 && (l = 0),
                i === void 0 && (i = 0),
                o(n, f(s) - l),
                r(n, e(s) + i),
                n
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(42)
              , f = t(44)
              , r = t(55)
              , o = t(54)
              , a = function(n, s, l, i) {
                return l === void 0 && (l = 0),
                i === void 0 && (i = 0),
                o(n, f(s) + l),
                r(n, e(s) + i),
                n
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(294)
              , f = t(87)
              , r = t(89)
              , o = function(a, n, s, l) {
                return s === void 0 && (s = 0),
                l === void 0 && (l = 0),
                e(a, f(n) + s, r(n) + l),
                a
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(88)
              , f = t(90)
              , r = function(o, a, n) {
                return e(o, a),
                f(o, n)
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(89)
              , f = t(43)
              , r = t(90)
              , o = t(53)
              , a = function(n, s, l, i) {
                return l === void 0 && (l = 0),
                i === void 0 && (i = 0),
                o(n, f(s) - l),
                r(n, e(s) + i),
                n
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(89)
              , f = t(44)
              , r = t(90)
              , o = t(54)
              , a = function(n, s, l, i) {
                return l === void 0 && (l = 0),
                i === void 0 && (i = 0),
                o(n, f(s) + l),
                r(n, e(s) + i),
                n
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(87)
              , f = t(45)
              , r = t(88)
              , o = t(52)
              , a = function(n, s, l, i) {
                return l === void 0 && (l = 0),
                i === void 0 && (i = 0),
                r(n, e(s) + l),
                o(n, f(s) - i),
                n
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(43)
              , f = t(45)
              , r = t(53)
              , o = t(52)
              , a = function(n, s, l, i) {
                return l === void 0 && (l = 0),
                i === void 0 && (i = 0),
                r(n, e(s) - l),
                o(n, f(s) - i),
                n
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(44)
              , f = t(45)
              , r = t(54)
              , o = t(52)
              , a = function(n, s, l, i) {
                return l === void 0 && (l = 0),
                i === void 0 && (i = 0),
                r(n, e(s) + l),
                o(n, f(s) - i),
                n
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(169)
              , f = t(98)
              , r = t(14)
              , o = t(4)
              , a = function(n, s, l) {
                l === void 0 && (l = new o);
                var i = f(s, 0, r.PI2);
                return e(n, i, l)
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(302)
              , f = t(169)
              , r = t(98)
              , o = t(14)
              , a = function(n, s, l, i) {
                i === void 0 && (i = []),
                !s && l > 0 && (s = e(n) / l);
                for (var h = 0; h < s; h++) {
                    var u = r(h / s, 0, o.PI2);
                    i.push(f(n, u))
                }
                return i
            };
            c.exports = a
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return 2 * (Math.PI * e.radius)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(18)
              , f = 2
              , r = {
                _alpha: 1,
                clearAlpha: function() {
                    return this.setAlpha(1)
                },
                setAlpha: function(o) {
                    return o === void 0 && (o = 1),
                    this.alpha = o,
                    this
                },
                alpha: {
                    get: function() {
                        return this._alpha
                    },
                    set: function(o) {
                        var a = e(o, 0, 1);
                        this._alpha = a,
                        a === 0 ? this.renderFlags &= ~f : this.renderFlags |= f
                    }
                }
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(35)
              , f = {
                _blendMode: e.NORMAL,
                blendMode: {
                    get: function() {
                        return this._blendMode
                    },
                    set: function(r) {
                        typeof r == "string" && (r = e[r]),
                        r |= 0,
                        r >= -1 && (this._blendMode = r)
                    }
                },
                setBlendMode: function(r) {
                    return this.blendMode = r,
                    this
                }
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                _depth: 0,
                depth: {
                    get: function() {
                        return this._depth
                    },
                    set: function(e) {
                        this.displayList && this.displayList.queueDepthSort(),
                        this._depth = e
                    }
                },
                setDepth: function(e) {
                    return e === void 0 && (e = 0),
                    this.depth = e,
                    this
                }
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(171)
              , f = t(130)
              , r = function(o, a, n, s) {
                s === void 0 && (s = []),
                !a && n > 0 && (a = f(o) / n);
                for (var l = 0; l < a; l++) {
                    var i = l / a;
                    s.push(e(o, i))
                }
                return s
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4)
              , f = function(r, o, a) {
                return a === void 0 && (a = new e),
                a.x = r.x1 + (r.x2 - r.x1) * o,
                a.y = r.y1 + (r.y2 - r.y1) * o,
                a
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                var a = Math.cos(o)
                  , n = Math.sin(o)
                  , s = e.x - f
                  , l = e.y - r;
                return e.x = s * a - l * n + f,
                e.y = s * n + l * a + r,
                e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(310)
              , f = t(311)
              , r = {
                mask: null,
                setMask: function(o) {
                    return this.mask = o,
                    this
                },
                clearMask: function(o) {
                    return o === void 0 && (o = !1),
                    o && this.mask && this.mask.destroy(),
                    this.mask = null,
                    this
                },
                createBitmapMask: function(o) {
                    return o === void 0 && (this.texture || this.shader) && (o = this),
                    new e(this.scene,o)
                },
                createGeometryMask: function(o) {
                    return o === void 0 && this.type === "Graphics" && (o = this),
                    new f(this.scene,o)
                }
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(22)
              , r = t(91)
              , o = new e({
                initialize: function(n, s) {
                    var l = n.sys.renderer;
                    this.renderer = l,
                    this.bitmapMask = s,
                    this.maskTexture = null,
                    this.mainTexture = null,
                    this.dirty = !0,
                    this.mainFramebuffer = null,
                    this.maskFramebuffer = null,
                    this.invertAlpha = !1,
                    this.isStencil = !1,
                    this.createMask(),
                    n.sys.game.events.on(f.CONTEXT_RESTORED, this.createMask, this),
                    l && l.on(r.RESIZE, this.createMask, this)
                },
                createMask: function() {
                    var a = this.renderer;
                    if (!(!a || !a.gl)) {
                        this.mainTexture && this.clearMask();
                        var n = a.width
                          , s = a.height
                          , l = (n & n - 1) === 0 && (s & s - 1) === 0
                          , i = a.gl
                          , h = l ? i.REPEAT : i.CLAMP_TO_EDGE
                          , u = i.LINEAR;
                        this.mainTexture = a.createTexture2D(0, u, u, h, h, i.RGBA, null, n, s),
                        this.maskTexture = a.createTexture2D(0, u, u, h, h, i.RGBA, null, n, s),
                        this.mainFramebuffer = a.createFramebuffer(n, s, this.mainTexture, !0),
                        this.maskFramebuffer = a.createFramebuffer(n, s, this.maskTexture, !0)
                    }
                },
                clearMask: function() {
                    var a = this.renderer;
                    !a || !a.gl || !this.mainTexture || (a.deleteTexture(this.mainTexture),
                    a.deleteTexture(this.maskTexture),
                    a.deleteFramebuffer(this.mainFramebuffer),
                    a.deleteFramebuffer(this.maskFramebuffer),
                    this.mainTexture = null,
                    this.maskTexture = null,
                    this.mainFramebuffer = null,
                    this.maskFramebuffer = null)
                },
                setBitmap: function(a) {
                    this.bitmapMask = a
                },
                preRenderWebGL: function(a, n, s) {
                    a.pipelines.BITMAPMASK_PIPELINE.beginMask(this, n, s)
                },
                postRenderWebGL: function(a, n) {
                    a.pipelines.BITMAPMASK_PIPELINE.endMask(this, n)
                },
                preRenderCanvas: function() {},
                postRenderCanvas: function() {},
                destroy: function() {
                    this.clearMask(),
                    this.renderer && this.renderer.off(r.RESIZE, this.createMask, this),
                    this.bitmapMask = null,
                    this.prevFramebuffer = null,
                    this.renderer = null
                }
            });
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = new e({
                initialize: function(o, a) {
                    this.geometryMask = a,
                    this.invertAlpha = !1,
                    this.isStencil = !0,
                    this.level = 0
                },
                setShape: function(r) {
                    return this.geometryMask = r,
                    this
                },
                setInvertAlpha: function(r) {
                    return r === void 0 && (r = !0),
                    this.invertAlpha = r,
                    this
                },
                preRenderWebGL: function(r, o, a) {
                    var n = r.gl;
                    r.flush(),
                    r.maskStack.length === 0 && (n.enable(n.STENCIL_TEST),
                    n.clear(n.STENCIL_BUFFER_BIT),
                    r.maskCount = 0),
                    r.currentCameraMask.mask !== this && (r.currentMask.mask = this),
                    r.maskStack.push({
                        mask: this,
                        camera: a
                    }),
                    this.applyStencil(r, a, !0),
                    r.maskCount++
                },
                applyStencil: function(r, o, a) {
                    var n = r.gl
                      , s = this.geometryMask
                      , l = r.maskCount;
                    n.colorMask(!1, !1, !1, !1),
                    a ? (n.stencilFunc(n.EQUAL, l, 255),
                    n.stencilOp(n.KEEP, n.KEEP, n.INCR)) : (n.stencilFunc(n.EQUAL, l + 1, 255),
                    n.stencilOp(n.KEEP, n.KEEP, n.DECR)),
                    s.renderWebGL(r, s, o),
                    r.flush(),
                    n.colorMask(!0, !0, !0, !0),
                    n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
                    a ? this.invertAlpha ? n.stencilFunc(n.NOTEQUAL, l + 1, 255) : n.stencilFunc(n.EQUAL, l + 1, 255) : this.invertAlpha ? n.stencilFunc(n.NOTEQUAL, l, 255) : n.stencilFunc(n.EQUAL, l, 255)
                },
                postRenderWebGL: function(r) {
                    var o = r.gl;
                    r.maskStack.pop(),
                    r.maskCount--,
                    r.flush();
                    var a = r.currentMask;
                    if (r.maskStack.length === 0)
                        a.mask = null,
                        o.disable(o.STENCIL_TEST);
                    else {
                        var n = r.maskStack[r.maskStack.length - 1];
                        n.mask.applyStencil(r, n.camera, !1),
                        r.currentCameraMask.mask !== n.mask ? (a.mask = n.mask,
                        a.camera = n.camera) : a.mask = null
                    }
                },
                preRenderCanvas: function(r, o, a) {
                    var n = this.geometryMask;
                    r.currentContext.save(),
                    n.renderCanvas(r, n, a, null, null, !0),
                    r.currentContext.clip()
                },
                postRenderCanvas: function(r) {
                    r.currentContext.restore()
                },
                destroy: function() {
                    this.geometryMask = null
                }
            });
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                scrollFactorX: 1,
                scrollFactorY: 1,
                setScrollFactor: function(e, f) {
                    return f === void 0 && (f = e),
                    this.scrollFactorX = e,
                    this.scrollFactorY = f,
                    this
                }
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(14)
              , f = t(25)
              , r = t(177)
              , o = t(269)
              , a = t(270)
              , n = t(3)
              , s = 4
              , l = {
                _scaleX: 1,
                _scaleY: 1,
                _rotation: 0,
                x: 0,
                y: 0,
                z: 0,
                w: 0,
                scale: {
                    get: function() {
                        return (this._scaleX + this._scaleY) / 2
                    },
                    set: function(i) {
                        this._scaleX = i,
                        this._scaleY = i,
                        i === 0 ? this.renderFlags &= ~s : this.renderFlags |= s
                    }
                },
                scaleX: {
                    get: function() {
                        return this._scaleX
                    },
                    set: function(i) {
                        this._scaleX = i,
                        i === 0 ? this.renderFlags &= ~s : this.renderFlags |= s
                    }
                },
                scaleY: {
                    get: function() {
                        return this._scaleY
                    },
                    set: function(i) {
                        this._scaleY = i,
                        i === 0 ? this.renderFlags &= ~s : this.renderFlags |= s
                    }
                },
                angle: {
                    get: function() {
                        return a(this._rotation * e.RAD_TO_DEG)
                    },
                    set: function(i) {
                        this.rotation = a(i) * e.DEG_TO_RAD
                    }
                },
                rotation: {
                    get: function() {
                        return this._rotation
                    },
                    set: function(i) {
                        this._rotation = o(i)
                    }
                },
                setPosition: function(i, h, u, d) {
                    return i === void 0 && (i = 0),
                    h === void 0 && (h = i),
                    u === void 0 && (u = 0),
                    d === void 0 && (d = 0),
                    this.x = i,
                    this.y = h,
                    this.z = u,
                    this.w = d,
                    this
                },
                copyPosition: function(i) {
                    return i.x !== void 0 && (this.x = i.x),
                    i.y !== void 0 && (this.y = i.y),
                    i.z !== void 0 && (this.z = i.z),
                    i.w !== void 0 && (this.w = i.w),
                    this
                },
                setRandomPosition: function(i, h, u, d) {
                    return i === void 0 && (i = 0),
                    h === void 0 && (h = 0),
                    u === void 0 && (u = this.scene.sys.scale.width),
                    d === void 0 && (d = this.scene.sys.scale.height),
                    this.x = i + Math.random() * u,
                    this.y = h + Math.random() * d,
                    this
                },
                setRotation: function(i) {
                    return i === void 0 && (i = 0),
                    this.rotation = i,
                    this
                },
                setAngle: function(i) {
                    return i === void 0 && (i = 0),
                    this.angle = i,
                    this
                },
                setScale: function(i, h) {
                    return i === void 0 && (i = 1),
                    h === void 0 && (h = i),
                    this.scaleX = i,
                    this.scaleY = h,
                    this
                },
                setX: function(i) {
                    return i === void 0 && (i = 0),
                    this.x = i,
                    this
                },
                setY: function(i) {
                    return i === void 0 && (i = 0),
                    this.y = i,
                    this
                },
                setZ: function(i) {
                    return i === void 0 && (i = 0),
                    this.z = i,
                    this
                },
                setW: function(i) {
                    return i === void 0 && (i = 0),
                    this.w = i,
                    this
                },
                getLocalTransformMatrix: function(i) {
                    return i === void 0 && (i = new f),
                    i.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY)
                },
                getWorldTransformMatrix: function(i, h) {
                    i === void 0 && (i = new f),
                    h === void 0 && (h = new f);
                    var u = this.parentContainer;
                    if (!u)
                        return this.getLocalTransformMatrix(i);
                    for (i.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY); u; )
                        h.applyITRS(u.x, u.y, u._rotation, u._scaleX, u._scaleY),
                        h.multiply(i, i),
                        u = u.parentContainer;
                    return i
                },
                getLocalPoint: function(i, h, u, d) {
                    u || (u = new n),
                    d || (d = this.scene.sys.cameras.main);
                    var v = d.scrollX
                      , p = d.scrollY
                      , g = i + v * this.scrollFactorX - v
                      , m = h + p * this.scrollFactorY - p;
                    return this.parentContainer ? this.getWorldTransformMatrix().applyInverse(g, m, u) : r(g, m, this.x, this.y, this.rotation, this.scaleX, this.scaleY, u),
                    this._originComponent && (u.x += this._displayOriginX,
                    u.y += this._displayOriginY),
                    u
                },
                getParentRotation: function() {
                    for (var i = 0, h = this.parentContainer; h; )
                        i += h.rotation,
                        h = h.parentContainer;
                    return i
                }
            };
            c.exports = l
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = 1
              , e = {
                _visible: !0,
                visible: {
                    get: function() {
                        return this._visible
                    },
                    set: function(f) {
                        f ? (this._visible = !0,
                        this.renderFlags |= t) : (this._visible = !1,
                        this.renderFlags &= ~t)
                    }
                },
                setVisible: function(f) {
                    return this.visible = f,
                    this
                }
            };
            c.exports = e
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                CHANGE_DATA: t(638),
                CHANGE_DATA_KEY: t(639),
                DESTROY: t(640),
                REMOVE_DATA: t(641),
                SET_DATA: t(642)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(130)
              , f = t(4)
              , r = function(o, a, n, s) {
                if (s === void 0 && (s = []),
                !a && !n)
                    return s;
                a ? n = Math.round(e(o) / a) : a = e(o) / n;
                for (var l = o.x, i = o.y, h = 0, u = 0; u < n; u++)
                    switch (s.push(new f(l,i)),
                    h) {
                    case 0:
                        l += a,
                        l >= o.right && (h = 1,
                        i += l - o.right,
                        l = o.right);
                        break;
                    case 1:
                        i += a,
                        i >= o.bottom && (h = 2,
                        l -= i - o.bottom,
                        i = o.bottom);
                        break;
                    case 2:
                        l -= a,
                        l <= o.left && (h = 3,
                        i -= o.left - l,
                        l = o.left);
                        break;
                    case 3:
                        i -= a,
                        i <= o.top && (h = 0,
                        i = o.top);
                        break
                    }
                return s
            };
            c.exports = r
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                f === void 0 && (f = 1),
                r === void 0 && (r = []);
                var o = Math.round(e.x1)
                  , a = Math.round(e.y1)
                  , n = Math.round(e.x2)
                  , s = Math.round(e.y2)
                  , l = Math.abs(n - o)
                  , i = Math.abs(s - a)
                  , h = o < n ? 1 : -1
                  , u = a < s ? 1 : -1
                  , d = l - i;
                r.push({
                    x: o,
                    y: a
                });
                for (var v = 1; !(o === n && a === s); ) {
                    var p = d << 1;
                    p > -i && (d -= i,
                    o += h),
                    p < l && (d += l,
                    a += u),
                    v % f === 0 && r.push({
                        x: o,
                        y: a
                    }),
                    v++
                }
                return r
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                if (f.length) {
                    if (f.length === 1)
                        return f[0]
                } else
                    return NaN;
                var o = 1, a, n;
                if (r) {
                    if (e < f[0][r])
                        return f[0];
                    for (; f[o][r] < e; )
                        o++
                } else
                    for (; f[o] < e; )
                        o++;
                return o > f.length && (o = f.length),
                r ? (a = f[o - 1][r],
                n = f[o][r],
                n - e <= e - a ? f[o] : f[o - 1]) : (a = f[o - 1],
                n = f[o],
                n - e <= e - a ? n : a)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = new e({
                initialize: function(o, a, n, s, l) {
                    l === void 0 && (l = !1),
                    this.textureKey = o,
                    this.textureFrame = a,
                    this.index = n,
                    this.frame = s,
                    this.isFirst = !1,
                    this.isLast = !1,
                    this.prevFrame = null,
                    this.nextFrame = null,
                    this.duration = 0,
                    this.progress = 0,
                    this.isKeyFrame = l
                },
                toJSON: function() {
                    return {
                        key: this.textureKey,
                        frame: this.textureFrame,
                        duration: this.duration,
                        keyframe: this.isKeyFrame
                    }
                },
                destroy: function() {
                    this.frame = void 0
                }
            });
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                var f = /\D/g;
                return e.sort(function(r, o) {
                    return parseInt(r.replace(f, ""), 10) - parseInt(o.replace(f, ""), 10)
                }),
                e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(185)
              , f = t(0)
              , r = t(102)
              , o = t(9)
              , a = t(132)
              , n = t(22)
              , s = t(2)
              , l = t(6)
              , i = t(186)
              , h = t(322)
              , u = new f({
                Extends: o,
                initialize: function(v) {
                    o.call(this),
                    this.game = v,
                    this.textureManager = null,
                    this.globalTimeScale = 1,
                    this.anims = new r,
                    this.mixes = new r,
                    this.paused = !1,
                    this.name = "AnimationManager",
                    v.events.once(n.BOOT, this.boot, this)
                },
                boot: function() {
                    this.textureManager = this.game.textures,
                    this.game.events.once(n.DESTROY, this.destroy, this)
                },
                addMix: function(d, v, p) {
                    var g = this.anims
                      , m = this.mixes
                      , x = typeof d == "string" ? d : d.key
                      , T = typeof v == "string" ? v : v.key;
                    if (g.has(x) && g.has(T)) {
                        var E = m.get(x);
                        E || (E = {}),
                        E[T] = p,
                        m.set(x, E)
                    }
                    return this
                },
                removeMix: function(d, v) {
                    var p = this.mixes
                      , g = typeof d == "string" ? d : d.key
                      , m = p.get(g);
                    if (m)
                        if (v) {
                            var x = typeof v == "string" ? v : v.key;
                            m.hasOwnProperty(x) && delete m[x]
                        } else
                            v || p.delete(g);
                    return this
                },
                getMix: function(d, v) {
                    var p = this.mixes
                      , g = typeof d == "string" ? d : d.key
                      , m = typeof v == "string" ? v : v.key
                      , x = p.get(g);
                    return x && x.hasOwnProperty(m) ? x[m] : 0
                },
                add: function(d, v) {
                    return this.anims.has(d) ? (console.warn("Animation key exists: " + d),
                    this) : (v.key = d,
                    this.anims.set(d, v),
                    this.emit(a.ADD_ANIMATION, d, v),
                    this)
                },
                exists: function(d) {
                    return this.anims.has(d)
                },
                createFromAseprite: function(d, v) {
                    var p = []
                      , g = this.game.cache.json.get(d);
                    if (!g)
                        return p;
                    var m = this
                      , x = l(g, "meta", null)
                      , T = l(g, "frames", null);
                    if (x && T) {
                        var E = l(x, "frameTags", []);
                        E.forEach(function(P) {
                            var M = []
                              , L = s(P, "name", null)
                              , R = s(P, "from", 0)
                              , O = s(P, "to", 0)
                              , F = s(P, "direction", "forward");
                            if (L && (!v || v && v.indexOf(L) > -1)) {
                                for (var B = [], N = Number.MAX_SAFE_INTEGER, Y = R; Y <= O; Y++) {
                                    var z = Y.toString()
                                      , W = T[z];
                                    if (W) {
                                        var b = s(W, "duration", Number.MAX_SAFE_INTEGER);
                                        b < N && (N = b),
                                        B.push({
                                            frame: z,
                                            duration: b
                                        })
                                    }
                                }
                                B.forEach(function(w) {
                                    M.push({
                                        key: d,
                                        frame: w.frame,
                                        duration: N - w.duration
                                    })
                                });
                                var D = N * M.length;
                                F === "reverse" && (M = M.reverse());
                                var I = {
                                    key: L,
                                    frames: M,
                                    duration: D,
                                    yoyo: F === "pingpong"
                                }
                                  , G = m.create(I);
                                G && p.push(G)
                            }
                        })
                    }
                    return p
                },
                create: function(d) {
                    var v = d.key
                      , p = !1;
                    return v && (p = this.get(v),
                    p || (p = new e(this,v,d),
                    this.anims.set(v, p),
                    this.emit(a.ADD_ANIMATION, v, p))),
                    p
                },
                fromJSON: function(d, v) {
                    v === void 0 && (v = !1),
                    v && this.anims.clear(),
                    typeof d == "string" && (d = JSON.parse(d));
                    var p = [];
                    if (d.hasOwnProperty("anims") && Array.isArray(d.anims)) {
                        for (var g = 0; g < d.anims.length; g++)
                            p.push(this.create(d.anims[g]));
                        d.hasOwnProperty("globalTimeScale") && (this.globalTimeScale = d.globalTimeScale)
                    } else
                        d.hasOwnProperty("key") && d.type === "frame" && p.push(this.create(d));
                    return p
                },
                generateFrameNames: function(d, v) {
                    var p = l(v, "prefix", "")
                      , g = l(v, "start", 0)
                      , m = l(v, "end", 0)
                      , x = l(v, "suffix", "")
                      , T = l(v, "zeroPad", 0)
                      , E = l(v, "outputArray", [])
                      , P = l(v, "frames", !1)
                      , M = this.textureManager.get(d);
                    if (!M)
                        return E;
                    var L;
                    if (v)
                        for (P || (P = h(g, m)),
                        L = 0; L < P.length; L++) {
                            var R = p + i(P[L], T, "0", 1) + x;
                            M.has(R) ? E.push({
                                key: d,
                                frame: R
                            }) : console.warn("generateFrameNames: Frame missing: " + R + " from texture: " + d)
                        }
                    else
                        for (P = M.getFrameNames(),
                        L = 0; L < P.length; L++)
                            E.push({
                                key: d,
                                frame: P[L]
                            });
                    return E
                },
                generateFrameNumbers: function(d, v) {
                    var p = l(v, "start", 0)
                      , g = l(v, "end", -1)
                      , m = l(v, "first", !1)
                      , x = l(v, "outputArray", [])
                      , T = l(v, "frames", !1)
                      , E = this.textureManager.get(d);
                    if (!E)
                        return x;
                    m && E.has(m) && x.push({
                        key: d,
                        frame: m
                    }),
                    T || (g === -1 && (g = E.frameTotal - 2),
                    T = h(p, g));
                    for (var P = 0; P < T.length; P++)
                        E.has(T[P]) ? x.push({
                            key: d,
                            frame: T[P]
                        }) : console.warn("generateFrameNumbers: Frame " + P + " missing from texture: " + d);
                    return x
                },
                get: function(d) {
                    return this.anims.get(d)
                },
                pauseAll: function() {
                    return this.paused || (this.paused = !0,
                    this.emit(a.PAUSE_ALL)),
                    this
                },
                play: function(d, v) {
                    Array.isArray(v) || (v = [v]);
                    for (var p = 0; p < v.length; p++)
                        v[p].anims.play(d);
                    return this
                },
                staggerPlay: function(d, v, p, g) {
                    p === void 0 && (p = 0),
                    g === void 0 && (g = !0),
                    Array.isArray(v) || (v = [v]);
                    var m = v.length;
                    g || m--;
                    for (var x = 0; x < v.length; x++) {
                        var T = p < 0 ? Math.abs(p) * (m - x) : p * x;
                        v[x].anims.playAfterDelay(d, T)
                    }
                    return this
                },
                remove: function(d) {
                    var v = this.get(d);
                    return v && (this.emit(a.REMOVE_ANIMATION, d, v),
                    this.anims.delete(d),
                    this.removeMix(d)),
                    v
                },
                resumeAll: function() {
                    return this.paused && (this.paused = !1,
                    this.emit(a.RESUME_ALL)),
                    this
                },
                toJSON: function(d) {
                    var v = {
                        anims: [],
                        globalTimeScale: this.globalTimeScale
                    };
                    return d !== void 0 && d !== "" ? v.anims.push(this.anims.get(d).toJSON()) : this.anims.each(function(p, g) {
                        v.anims.push(g.toJSON())
                    }),
                    v
                },
                destroy: function() {
                    this.anims.clear(),
                    this.mixes.clear(),
                    this.textureManager = null,
                    this.game = null
                }
            });
            c.exports = u
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                var a = [], n, s = !1;
                if ((r || o) && (s = !0,
                r || (r = ""),
                o || (o = "")),
                f < e)
                    for (n = e; n >= f; n--)
                        s ? a.push(r + n.toString() + o) : a.push(n);
                else
                    for (n = e; n <= f; n++)
                        s ? a.push(r + n.toString() + o) : a.push(n);
                return a
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(102)
              , r = t(9)
              , o = t(324)
              , a = new e({
                initialize: function() {
                    this.entries = new f,
                    this.events = new r
                },
                add: function(n, s) {
                    return this.entries.set(n, s),
                    this.events.emit(o.ADD, this, n, s),
                    this
                },
                has: function(n) {
                    return this.entries.has(n)
                },
                exists: function(n) {
                    return this.entries.has(n)
                },
                get: function(n) {
                    return this.entries.get(n)
                },
                remove: function(n) {
                    var s = this.get(n);
                    return s && (this.entries.delete(n),
                    this.events.emit(o.REMOVE, this, n, s.data)),
                    this
                },
                getKeys: function() {
                    return this.entries.keys()
                },
                destroy: function() {
                    this.entries.clear(),
                    this.events.removeAllListeners(),
                    this.entries = null,
                    this.events = null
                }
            });
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                ADD: t(736),
                REMOVE: t(737)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(323)
              , f = t(0)
              , r = t(22)
              , o = new f({
                initialize: function(n) {
                    this.game = n,
                    this.binary = new e,
                    this.bitmapFont = new e,
                    this.json = new e,
                    this.physics = new e,
                    this.shader = new e,
                    this.audio = new e,
                    this.video = new e,
                    this.text = new e,
                    this.html = new e,
                    this.obj = new e,
                    this.tilemap = new e,
                    this.xml = new e,
                    this.custom = {},
                    this.game.events.once(r.DESTROY, this.destroy, this)
                },
                addCustom: function(a) {
                    return this.custom.hasOwnProperty(a) || (this.custom[a] = new e),
                    this.custom[a]
                },
                destroy: function() {
                    for (var a = ["binary", "bitmapFont", "json", "physics", "shader", "audio", "video", "text", "html", "obj", "tilemap", "xml"], n = 0; n < a.length; n++)
                        this[a[n]].destroy(),
                        this[a[n]] = null;
                    for (var s in this.custom)
                        this.custom[s].destroy();
                    this.custom = null,
                    this.game = null
                }
            });
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(133)
              , f = t(190)
              , r = t(18)
              , o = t(0)
              , a = t(11)
              , n = t(333)
              , s = t(37)
              , l = t(135)
              , i = t(10)
              , h = t(3)
              , u = new o({
                Extends: e,
                Mixins: [a.Flip, a.Tint, a.Pipeline],
                initialize: function(v, p, g, m) {
                    e.call(this, v, p, g, m),
                    this.postPipelines = [],
                    this.pipelineData = {},
                    this.inputEnabled = !0,
                    this.fadeEffect = new n.Fade(this),
                    this.flashEffect = new n.Flash(this),
                    this.shakeEffect = new n.Shake(this),
                    this.panEffect = new n.Pan(this),
                    this.rotateToEffect = new n.RotateTo(this),
                    this.zoomEffect = new n.Zoom(this),
                    this.lerp = new h(1,1),
                    this.followOffset = new h,
                    this.deadzone = null,
                    this._follow = null
                },
                setDeadzone: function(d, v) {
                    if (d === void 0)
                        this.deadzone = null;
                    else {
                        if (this.deadzone ? (this.deadzone.width = d,
                        this.deadzone.height = v) : this.deadzone = new i(0,0,d,v),
                        this._follow) {
                            var p = this.width / 2
                              , g = this.height / 2
                              , m = this._follow.x - this.followOffset.x
                              , x = this._follow.y - this.followOffset.y;
                            this.midPoint.set(m, x),
                            this.scrollX = m - p,
                            this.scrollY = x - g
                        }
                        f(this.deadzone, this.midPoint.x, this.midPoint.y)
                    }
                    return this
                },
                fadeIn: function(d, v, p, g, m, x) {
                    return this.fadeEffect.start(!1, d, v, p, g, !0, m, x)
                },
                fadeOut: function(d, v, p, g, m, x) {
                    return this.fadeEffect.start(!0, d, v, p, g, !0, m, x)
                },
                fadeFrom: function(d, v, p, g, m, x, T) {
                    return this.fadeEffect.start(!1, d, v, p, g, m, x, T)
                },
                fade: function(d, v, p, g, m, x, T) {
                    return this.fadeEffect.start(!0, d, v, p, g, m, x, T)
                },
                flash: function(d, v, p, g, m, x, T) {
                    return this.flashEffect.start(d, v, p, g, m, x, T)
                },
                shake: function(d, v, p, g, m) {
                    return this.shakeEffect.start(d, v, p, g, m)
                },
                pan: function(d, v, p, g, m, x, T) {
                    return this.panEffect.start(d, v, p, g, m, x, T)
                },
                rotateTo: function(d, v, p, g, m, x, T) {
                    return this.rotateToEffect.start(d, v, p, g, m, x, T)
                },
                zoomTo: function(d, v, p, g, m, x) {
                    return this.zoomEffect.start(d, v, p, g, m, x)
                },
                preRender: function() {
                    this.renderList.length = 0;
                    var d = this.width
                      , v = this.height
                      , p = d * .5
                      , g = v * .5
                      , m = this.zoom
                      , x = this.matrix
                      , T = d * this.originX
                      , E = v * this.originY
                      , P = this._follow
                      , M = this.deadzone
                      , L = this.scrollX
                      , R = this.scrollY;
                    M && f(M, this.midPoint.x, this.midPoint.y);
                    var O = !1;
                    if (P && !this.panEffect.isRunning) {
                        var F = P.x - this.followOffset.x
                          , B = P.y - this.followOffset.y;
                        M ? (F < M.x ? L = l(L, L - (M.x - F), this.lerp.x) : F > M.right && (L = l(L, L + (F - M.right), this.lerp.x)),
                        B < M.y ? R = l(R, R - (M.y - B), this.lerp.y) : B > M.bottom && (R = l(R, R + (B - M.bottom), this.lerp.y))) : (L = l(L, F - T, this.lerp.x),
                        R = l(R, B - E, this.lerp.y)),
                        O = !0
                    }
                    this.useBounds && (L = this.clampX(L),
                    R = this.clampY(R)),
                    this.roundPixels && (T = Math.round(T),
                    E = Math.round(E),
                    L = Math.round(L),
                    R = Math.round(R)),
                    this.scrollX = L,
                    this.scrollY = R;
                    var N = L + p
                      , Y = R + g;
                    this.midPoint.set(N, Y);
                    var z = d / m
                      , W = v / m
                      , b = N - z / 2
                      , D = Y - W / 2;
                    this.roundPixels && (b = Math.round(b),
                    D = Math.round(D)),
                    this.worldView.setTo(b, D, z, W),
                    x.applyITRS(this.x + T, this.y + E, this.rotation, m, m),
                    x.translate(-T, -E),
                    this.shakeEffect.preRender(),
                    O && this.emit(s.FOLLOW_UPDATE, this, P)
                },
                setLerp: function(d, v) {
                    return d === void 0 && (d = 1),
                    v === void 0 && (v = d),
                    this.lerp.set(d, v),
                    this
                },
                setFollowOffset: function(d, v) {
                    return d === void 0 && (d = 0),
                    v === void 0 && (v = 0),
                    this.followOffset.set(d, v),
                    this
                },
                startFollow: function(d, v, p, g, m, x) {
                    v === void 0 && (v = !1),
                    p === void 0 && (p = 1),
                    g === void 0 && (g = p),
                    m === void 0 && (m = 0),
                    x === void 0 && (x = m),
                    this._follow = d,
                    this.roundPixels = v,
                    p = r(p, 0, 1),
                    g = r(g, 0, 1),
                    this.lerp.set(p, g),
                    this.followOffset.set(m, x);
                    var T = this.width / 2
                      , E = this.height / 2
                      , P = d.x - m
                      , M = d.y - x;
                    return this.midPoint.set(P, M),
                    this.scrollX = P - T,
                    this.scrollY = M - E,
                    this.useBounds && (this.scrollX = this.clampX(this.scrollX),
                    this.scrollY = this.clampY(this.scrollY)),
                    this
                },
                stopFollow: function() {
                    return this._follow = null,
                    this
                },
                resetFX: function() {
                    return this.rotateToEffect.reset(),
                    this.panEffect.reset(),
                    this.shakeEffect.reset(),
                    this.flashEffect.reset(),
                    this.fadeEffect.reset(),
                    this
                },
                update: function(d, v) {
                    this.visible && (this.rotateToEffect.update(d, v),
                    this.panEffect.update(d, v),
                    this.zoomEffect.update(d, v),
                    this.shakeEffect.update(d, v),
                    this.flashEffect.update(d, v),
                    this.fadeEffect.update(d, v))
                },
                destroy: function() {
                    this.resetFX(),
                    e.prototype.destroy.call(this),
                    this._follow = null,
                    this.deadzone = null
                }
            });
            c.exports = u
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(38)
              , f = function(r) {
                var o = new e;
                r = r.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(i, h, u, d) {
                    return h + h + u + u + d + d
                });
                var a = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(r);
                if (a) {
                    var n = parseInt(a[1], 16)
                      , s = parseInt(a[2], 16)
                      , l = parseInt(a[3], 16);
                    o.setTo(n, s, l)
                }
                return o
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                return o << 24 | e << 16 | f << 8 | r
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                o === void 0 && (o = {
                    h: 0,
                    s: 0,
                    v: 0
                }),
                e /= 255,
                f /= 255,
                r /= 255;
                var a = Math.min(e, f, r)
                  , n = Math.max(e, f, r)
                  , s = n - a
                  , l = 0
                  , i = n === 0 ? 0 : s / n
                  , h = n;
                return n !== a && (n === e ? l = (f - r) / s + (f < r ? 6 : 0) : n === f ? l = (r - e) / s + 2 : n === r && (l = (e - f) / s + 4),
                l /= 6),
                o.hasOwnProperty("_h") ? (o._h = l,
                o._s = i,
                o._v = h) : (o.h = l,
                o.s = i,
                o.v = h),
                o
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e > 16777215 ? {
                    a: e >>> 24,
                    r: e >> 16 & 255,
                    g: e >> 8 & 255,
                    b: e & 255
                } : {
                    a: 255,
                    r: e >> 16 & 255,
                    g: e >> 8 & 255,
                    b: e & 255
                }
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(38)
              , f = function(r) {
                return new e(r.r,r.g,r.b,r.a)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(38)
              , f = function(r) {
                var o = new e
                  , a = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(r.toLowerCase());
                if (a) {
                    var n = parseInt(a[1], 10)
                      , s = parseInt(a[2], 10)
                      , l = parseInt(a[3], 10)
                      , i = a[4] !== void 0 ? parseFloat(a[4]) : 1;
                    o.setTo(n, s, l, i * 255)
                }
                return o
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Fade: t(761),
                Flash: t(762),
                Pan: t(763),
                Shake: t(796),
                RotateTo: t(797),
                Zoom: t(798)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                In: t(764),
                Out: t(765),
                InOut: t(766)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                In: t(767),
                Out: t(768),
                InOut: t(769)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                In: t(770),
                Out: t(771),
                InOut: t(772)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                In: t(773),
                Out: t(774),
                InOut: t(775)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                In: t(776),
                Out: t(777),
                InOut: t(778)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                In: t(779),
                Out: t(780),
                InOut: t(781)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = t(782)
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                In: t(783),
                Out: t(784),
                InOut: t(785)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                In: t(786),
                Out: t(787),
                InOut: t(788)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                In: t(789),
                Out: t(790),
                InOut: t(791)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                In: t(792),
                Out: t(793),
                InOut: t(794)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = t(795)
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(33)
              , r = t(347)
              , o = t(2)
              , a = t(6)
              , n = t(7)
              , s = t(193)
              , l = t(1)
              , i = t(197)
              , h = t(187)
              , u = new e({
                initialize: function(v) {
                    v === void 0 && (v = {});
                    var p = ["#ff0000", "#ffff00", "#00ff00", "#00ffff", "#000000"]
                      , g = "#ffffff";
                    this.width = a(v, "width", 1024),
                    this.height = a(v, "height", 768),
                    this.zoom = a(v, "zoom", 1),
                    this.parent = a(v, "parent", void 0),
                    this.scaleMode = a(v, "scaleMode", 0),
                    this.expandParent = a(v, "expandParent", !0),
                    this.autoRound = a(v, "autoRound", !1),
                    this.autoCenter = a(v, "autoCenter", 0),
                    this.resizeInterval = a(v, "resizeInterval", 500),
                    this.fullscreenTarget = a(v, "fullscreenTarget", null),
                    this.minWidth = a(v, "minWidth", 0),
                    this.maxWidth = a(v, "maxWidth", 0),
                    this.minHeight = a(v, "minHeight", 0),
                    this.maxHeight = a(v, "maxHeight", 0);
                    var m = a(v, "scale", null);
                    m && (this.width = a(m, "width", this.width),
                    this.height = a(m, "height", this.height),
                    this.zoom = a(m, "zoom", this.zoom),
                    this.parent = a(m, "parent", this.parent),
                    this.scaleMode = a(m, "mode", this.scaleMode),
                    this.expandParent = a(m, "expandParent", this.expandParent),
                    this.autoRound = a(m, "autoRound", this.autoRound),
                    this.autoCenter = a(m, "autoCenter", this.autoCenter),
                    this.resizeInterval = a(m, "resizeInterval", this.resizeInterval),
                    this.fullscreenTarget = a(m, "fullscreenTarget", this.fullscreenTarget),
                    this.minWidth = a(m, "min.width", this.minWidth),
                    this.maxWidth = a(m, "max.width", this.maxWidth),
                    this.minHeight = a(m, "min.height", this.minHeight),
                    this.maxHeight = a(m, "max.height", this.maxHeight)),
                    this.renderType = a(v, "type", f.AUTO),
                    this.canvas = a(v, "canvas", null),
                    this.context = a(v, "context", null),
                    this.canvasStyle = a(v, "canvasStyle", null),
                    this.customEnvironment = a(v, "customEnvironment", !1),
                    this.sceneConfig = a(v, "scene", null),
                    this.seed = a(v, "seed", [(Date.now() * Math.random()).toString()]),
                    s.RND = new s.RandomDataGenerator(this.seed),
                    this.gameTitle = a(v, "title", ""),
                    this.gameURL = a(v, "url", "https://phaser.io"),
                    this.gameVersion = a(v, "version", ""),
                    this.autoFocus = a(v, "autoFocus", !0),
                    this.domCreateContainer = a(v, "dom.createContainer", !1),
                    this.domBehindCanvas = a(v, "dom.behindCanvas", !1),
                    this.domPointerEvents = a(v, "dom.pointerEvents", "none"),
                    this.inputKeyboard = a(v, "input.keyboard", !0),
                    this.inputKeyboardEventTarget = a(v, "input.keyboard.target", window),
                    this.inputKeyboardCapture = a(v, "input.keyboard.capture", []),
                    this.inputMouse = a(v, "input.mouse", !0),
                    this.inputMouseEventTarget = a(v, "input.mouse.target", null),
                    this.inputMousePreventDefaultDown = a(v, "input.mouse.preventDefaultDown", !0),
                    this.inputMousePreventDefaultUp = a(v, "input.mouse.preventDefaultUp", !0),
                    this.inputMousePreventDefaultMove = a(v, "input.mouse.preventDefaultMove", !0),
                    this.inputMousePreventDefaultWheel = a(v, "input.mouse.preventDefaultWheel", !0),
                    this.inputTouch = a(v, "input.touch", r.input.touch),
                    this.inputTouchEventTarget = a(v, "input.touch.target", null),
                    this.inputTouchCapture = a(v, "input.touch.capture", !0),
                    this.inputActivePointers = a(v, "input.activePointers", 1),
                    this.inputSmoothFactor = a(v, "input.smoothFactor", 0),
                    this.inputWindowEvents = a(v, "input.windowEvents", !0),
                    this.inputGamepad = a(v, "input.gamepad", !1),
                    this.inputGamepadEventTarget = a(v, "input.gamepad.target", window),
                    this.disableContextMenu = a(v, "disableContextMenu", !1),
                    this.audio = a(v, "audio", {}),
                    this.hideBanner = a(v, "banner", null) === !1,
                    this.hidePhaser = a(v, "banner.hidePhaser", !1),
                    this.bannerTextColor = a(v, "banner.text", g),
                    this.bannerBackgroundColor = a(v, "banner.background", p),
                    this.gameTitle === "" && this.hidePhaser && (this.hideBanner = !0),
                    this.fps = a(v, "fps", null);
                    var x = a(v, "render", v);
                    this.pipeline = a(x, "pipeline", null),
                    this.antialias = a(x, "antialias", !0),
                    this.antialiasGL = a(x, "antialiasGL", !0),
                    this.mipmapFilter = a(x, "mipmapFilter", "LINEAR"),
                    this.desynchronized = a(x, "desynchronized", !1),
                    this.roundPixels = a(x, "roundPixels", !1),
                    this.pixelArt = a(x, "pixelArt", this.zoom !== 1),
                    this.pixelArt && (this.antialias = !1,
                    this.antialiasGL = !1,
                    this.roundPixels = !0),
                    this.transparent = a(x, "transparent", !1),
                    this.clearBeforeRender = a(x, "clearBeforeRender", !0),
                    this.preserveDrawingBuffer = a(x, "preserveDrawingBuffer", !1),
                    this.premultipliedAlpha = a(x, "premultipliedAlpha", !0),
                    this.failIfMajorPerformanceCaveat = a(x, "failIfMajorPerformanceCaveat", !1),
                    this.powerPreference = a(x, "powerPreference", "default"),
                    this.batchSize = a(x, "batchSize", 4096),
                    this.maxTextures = a(x, "maxTextures", -1),
                    this.maxLights = a(x, "maxLights", 10);
                    var T = a(v, "backgroundColor", 0);
                    this.backgroundColor = h(T),
                    this.transparent && (this.backgroundColor = h(0),
                    this.backgroundColor.alpha = 0),
                    this.preBoot = a(v, "callbacks.preBoot", l),
                    this.postBoot = a(v, "callbacks.postBoot", l),
                    this.physics = a(v, "physics", {}),
                    this.defaultPhysicsSystem = a(this.physics, "default", !1),
                    this.loaderBaseURL = a(v, "loader.baseURL", ""),
                    this.loaderPath = a(v, "loader.path", "");
                    var E = r.os.android ? 6 : 32;
                    this.loaderMaxParallelDownloads = a(v, "loader.maxParallelDownloads", E),
                    this.loaderCrossOrigin = a(v, "loader.crossOrigin", void 0),
                    this.loaderResponseType = a(v, "loader.responseType", ""),
                    this.loaderAsync = a(v, "loader.async", !0),
                    this.loaderUser = a(v, "loader.user", ""),
                    this.loaderPassword = a(v, "loader.password", ""),
                    this.loaderTimeout = a(v, "loader.timeout", 0),
                    this.loaderWithCredentials = a(v, "loader.withCredentials", !1),
                    this.installGlobalPlugins = [],
                    this.installScenePlugins = [];
                    var P = a(v, "plugins", null)
                      , M = i.DefaultScene;
                    P && (Array.isArray(P) ? this.defaultPlugins = P : n(P) && (this.installGlobalPlugins = o(P, "global", []),
                    this.installScenePlugins = o(P, "scene", []),
                    Array.isArray(P.default) ? M = P.default : Array.isArray(P.defaultMerge) && (M = M.concat(P.defaultMerge)))),
                    this.defaultPlugins = M;
                    var L = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAg";
                    this.defaultImage = a(v, "images.default", L + "AQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg=="),
                    this.missingImage = a(v, "images.missing", L + "CAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg=="),
                    this.whiteImage = a(v, "images.white", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABdJREFUeNpi/P//PwMMMDEgAdwcgAADAJZuAwXJYZOzAAAAAElFTkSuQmCC"),
                    window && (window.FORCE_WEBGL ? this.renderType = f.WEBGL : window.FORCE_CANVAS && (this.renderType = f.CANVAS))
                }
            });
            c.exports = u
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                os: t(105),
                browser: t(136),
                features: t(191),
                input: t(808),
                audio: t(809),
                video: t(810),
                fullscreen: t(811),
                canvasFeatures: t(348)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(31)
              , f = {
                supportInverseAlpha: !1,
                supportNewBlendModes: !1
            };
            function r() {
                var n = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/"
                  , s = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg=="
                  , l = new Image;
                return l.onload = function() {
                    var i = new Image;
                    i.onload = function() {
                        var h = e.create(i, 6, 1)
                          , u = h.getContext("2d");
                        if (u.globalCompositeOperation = "multiply",
                        u.drawImage(l, 0, 0),
                        u.drawImage(i, 2, 0),
                        !u.getImageData(2, 0, 1, 1))
                            return !1;
                        var d = u.getImageData(2, 0, 1, 1).data;
                        e.remove(i),
                        f.supportNewBlendModes = d[0] === 255 && d[1] === 0 && d[2] === 0
                    }
                    ,
                    i.src = n + "/wCKxvRF" + s
                }
                ,
                l.src = n + "AP804Oa6" + s,
                !1
            }
            function o() {
                var n = e.create(this, 2, 1)
                  , s = n.getContext("2d");
                s.fillStyle = "rgba(10, 20, 30, 0.5)",
                s.fillRect(0, 0, 1, 1);
                var l = s.getImageData(0, 0, 1, 1);
                if (l === null)
                    return !1;
                s.putImageData(l, 1, 0);
                var i = s.getImageData(1, 0, 1, 1);
                return i.data[0] === l.data[0] && i.data[1] === l.data[1] && i.data[2] === l.data[2] && i.data[3] === l.data[3]
            }
            function a() {
                return typeof importScripts != "function" && document !== void 0 && (f.supportNewBlendModes = r(),
                f.supportInverseAlpha = o()),
                f
            }
            c.exports = a()
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                return Math.atan2(o - f, r - e)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return Math.atan2(f.y - e.y, f.x - e.x)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e = e % (2 * Math.PI),
                e >= 0 ? e : e + 2 * Math.PI
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       samme
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                var r = e.x - f.x
                  , o = e.y - f.y;
                return Math.sqrt(r * r + o * o)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                var a = e - r
                  , n = f - o;
                return a * a + n * n
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                return r === void 0 && (r = 1e-4),
                e > f - r
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                return r === void 0 && (r = 1e-4),
                e < f + r
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(357)
              , f = function(r, o) {
                return e(r) / e(o) / e(r - o)
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                if (e === 0)
                    return 1;
                for (var f = e; --e; )
                    f *= e;
                return f
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            function t(a, n) {
                var s = 1 - a;
                return s * s * s * n
            }
            function e(a, n) {
                var s = 1 - a;
                return 3 * s * s * a * n
            }
            function f(a, n) {
                return 3 * (1 - a) * a * a * n
            }
            function r(a, n) {
                return a * a * a * n
            }
            var o = function(a, n, s, l, i) {
                return t(a, n) + e(a, s) + f(a, l) + r(a, i)
            };
            c.exports = o
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            function t(o, a) {
                var n = 1 - o;
                return n * n * a
            }
            function e(o, a) {
                return 2 * (1 - o) * o * a
            }
            function f(o, a) {
                return o * o * a
            }
            var r = function(o, a, n, s) {
                return t(o, a) + e(o, n) + f(o, s)
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(184)
              , f = function(r, o, a) {
                return o + (a - o) * e(r, 0, 1)
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                var f = Math.log(e) / .6931471805599453;
                return 1 << Math.ceil(f)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                var r = e.x
                  , o = e.y;
                return e.x = r * Math.cos(f) - o * Math.sin(f),
                e.y = r * Math.sin(f) + o * Math.cos(f),
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e > 0 ? Math.ceil(e) : Math.floor(e)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = new e({
                initialize: function(o) {
                    this.val = new Float32Array(9),
                    o ? this.copy(o) : this.identity()
                },
                clone: function() {
                    return new f(this)
                },
                set: function(r) {
                    return this.copy(r)
                },
                copy: function(r) {
                    var o = this.val
                      , a = r.val;
                    return o[0] = a[0],
                    o[1] = a[1],
                    o[2] = a[2],
                    o[3] = a[3],
                    o[4] = a[4],
                    o[5] = a[5],
                    o[6] = a[6],
                    o[7] = a[7],
                    o[8] = a[8],
                    this
                },
                fromMat4: function(r) {
                    var o = r.val
                      , a = this.val;
                    return a[0] = o[0],
                    a[1] = o[1],
                    a[2] = o[2],
                    a[3] = o[4],
                    a[4] = o[5],
                    a[5] = o[6],
                    a[6] = o[8],
                    a[7] = o[9],
                    a[8] = o[10],
                    this
                },
                fromArray: function(r) {
                    var o = this.val;
                    return o[0] = r[0],
                    o[1] = r[1],
                    o[2] = r[2],
                    o[3] = r[3],
                    o[4] = r[4],
                    o[5] = r[5],
                    o[6] = r[6],
                    o[7] = r[7],
                    o[8] = r[8],
                    this
                },
                identity: function() {
                    var r = this.val;
                    return r[0] = 1,
                    r[1] = 0,
                    r[2] = 0,
                    r[3] = 0,
                    r[4] = 1,
                    r[5] = 0,
                    r[6] = 0,
                    r[7] = 0,
                    r[8] = 1,
                    this
                },
                transpose: function() {
                    var r = this.val
                      , o = r[1]
                      , a = r[2]
                      , n = r[5];
                    return r[1] = r[3],
                    r[2] = r[6],
                    r[3] = o,
                    r[5] = r[7],
                    r[6] = a,
                    r[7] = n,
                    this
                },
                invert: function() {
                    var r = this.val
                      , o = r[0]
                      , a = r[1]
                      , n = r[2]
                      , s = r[3]
                      , l = r[4]
                      , i = r[5]
                      , h = r[6]
                      , u = r[7]
                      , d = r[8]
                      , v = d * l - i * u
                      , p = -d * s + i * h
                      , g = u * s - l * h
                      , m = o * v + a * p + n * g;
                    return m ? (m = 1 / m,
                    r[0] = v * m,
                    r[1] = (-d * a + n * u) * m,
                    r[2] = (i * a - n * l) * m,
                    r[3] = p * m,
                    r[4] = (d * o - n * h) * m,
                    r[5] = (-i * o + n * s) * m,
                    r[6] = g * m,
                    r[7] = (-u * o + a * h) * m,
                    r[8] = (l * o - a * s) * m,
                    this) : null
                },
                adjoint: function() {
                    var r = this.val
                      , o = r[0]
                      , a = r[1]
                      , n = r[2]
                      , s = r[3]
                      , l = r[4]
                      , i = r[5]
                      , h = r[6]
                      , u = r[7]
                      , d = r[8];
                    return r[0] = l * d - i * u,
                    r[1] = n * u - a * d,
                    r[2] = a * i - n * l,
                    r[3] = i * h - s * d,
                    r[4] = o * d - n * h,
                    r[5] = n * s - o * i,
                    r[6] = s * u - l * h,
                    r[7] = a * h - o * u,
                    r[8] = o * l - a * s,
                    this
                },
                determinant: function() {
                    var r = this.val
                      , o = r[0]
                      , a = r[1]
                      , n = r[2]
                      , s = r[3]
                      , l = r[4]
                      , i = r[5]
                      , h = r[6]
                      , u = r[7]
                      , d = r[8];
                    return o * (d * l - i * u) + a * (-d * s + i * h) + n * (u * s - l * h)
                },
                multiply: function(r) {
                    var o = this.val
                      , a = o[0]
                      , n = o[1]
                      , s = o[2]
                      , l = o[3]
                      , i = o[4]
                      , h = o[5]
                      , u = o[6]
                      , d = o[7]
                      , v = o[8]
                      , p = r.val
                      , g = p[0]
                      , m = p[1]
                      , x = p[2]
                      , T = p[3]
                      , E = p[4]
                      , P = p[5]
                      , M = p[6]
                      , L = p[7]
                      , R = p[8];
                    return o[0] = g * a + m * l + x * u,
                    o[1] = g * n + m * i + x * d,
                    o[2] = g * s + m * h + x * v,
                    o[3] = T * a + E * l + P * u,
                    o[4] = T * n + E * i + P * d,
                    o[5] = T * s + E * h + P * v,
                    o[6] = M * a + L * l + R * u,
                    o[7] = M * n + L * i + R * d,
                    o[8] = M * s + L * h + R * v,
                    this
                },
                translate: function(r) {
                    var o = this.val
                      , a = r.x
                      , n = r.y;
                    return o[6] = a * o[0] + n * o[3] + o[6],
                    o[7] = a * o[1] + n * o[4] + o[7],
                    o[8] = a * o[2] + n * o[5] + o[8],
                    this
                },
                rotate: function(r) {
                    var o = this.val
                      , a = o[0]
                      , n = o[1]
                      , s = o[2]
                      , l = o[3]
                      , i = o[4]
                      , h = o[5]
                      , u = Math.sin(r)
                      , d = Math.cos(r);
                    return o[0] = d * a + u * l,
                    o[1] = d * n + u * i,
                    o[2] = d * s + u * h,
                    o[3] = d * l - u * a,
                    o[4] = d * i - u * n,
                    o[5] = d * h - u * s,
                    this
                },
                scale: function(r) {
                    var o = this.val
                      , a = r.x
                      , n = r.y;
                    return o[0] = a * o[0],
                    o[1] = a * o[1],
                    o[2] = a * o[2],
                    o[3] = n * o[3],
                    o[4] = n * o[4],
                    o[5] = n * o[5],
                    this
                },
                fromQuat: function(r) {
                    var o = r.x
                      , a = r.y
                      , n = r.z
                      , s = r.w
                      , l = o + o
                      , i = a + a
                      , h = n + n
                      , u = o * l
                      , d = o * i
                      , v = o * h
                      , p = a * i
                      , g = a * h
                      , m = n * h
                      , x = s * l
                      , T = s * i
                      , E = s * h
                      , P = this.val;
                    return P[0] = 1 - (p + m),
                    P[3] = d + E,
                    P[6] = v - T,
                    P[1] = d - E,
                    P[4] = 1 - (u + m),
                    P[7] = g + x,
                    P[2] = v + T,
                    P[5] = g - x,
                    P[8] = 1 - (u + p),
                    this
                },
                normalFromMat4: function(r) {
                    var o = r.val
                      , a = this.val
                      , n = o[0]
                      , s = o[1]
                      , l = o[2]
                      , i = o[3]
                      , h = o[4]
                      , u = o[5]
                      , d = o[6]
                      , v = o[7]
                      , p = o[8]
                      , g = o[9]
                      , m = o[10]
                      , x = o[11]
                      , T = o[12]
                      , E = o[13]
                      , P = o[14]
                      , M = o[15]
                      , L = n * u - s * h
                      , R = n * d - l * h
                      , O = n * v - i * h
                      , F = s * d - l * u
                      , B = s * v - i * u
                      , N = l * v - i * d
                      , Y = p * E - g * T
                      , z = p * P - m * T
                      , W = p * M - x * T
                      , b = g * P - m * E
                      , D = g * M - x * E
                      , I = m * M - x * P
                      , G = L * I - R * D + O * b + F * W - B * z + N * Y;
                    return G ? (G = 1 / G,
                    a[0] = (u * I - d * D + v * b) * G,
                    a[1] = (d * W - h * I - v * z) * G,
                    a[2] = (h * D - u * W + v * Y) * G,
                    a[3] = (l * D - s * I - i * b) * G,
                    a[4] = (n * I - l * W + i * z) * G,
                    a[5] = (s * W - n * D - i * Y) * G,
                    a[6] = (E * N - P * B + M * F) * G,
                    a[7] = (P * O - T * N - M * R) * G,
                    a[8] = (T * B - E * O + M * L) * G,
                    this) : null
                }
            });
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(364)
              , r = t(1)
              , o = t(39)
              , a = 1e-6
              , n = new Int8Array([1, 2, 0])
              , s = new Float32Array([0, 0, 0])
              , l = new o(1,0,0)
              , i = new o(0,1,0)
              , h = new o
              , u = new f
              , d = new e({
                initialize: function(p, g, m, x) {
                    this.onChangeCallback = r,
                    this.set(p, g, m, x)
                },
                x: {
                    get: function() {
                        return this._x
                    },
                    set: function(v) {
                        this._x = v,
                        this.onChangeCallback(this)
                    }
                },
                y: {
                    get: function() {
                        return this._y
                    },
                    set: function(v) {
                        this._y = v,
                        this.onChangeCallback(this)
                    }
                },
                z: {
                    get: function() {
                        return this._z
                    },
                    set: function(v) {
                        this._z = v,
                        this.onChangeCallback(this)
                    }
                },
                w: {
                    get: function() {
                        return this._w
                    },
                    set: function(v) {
                        this._w = v,
                        this.onChangeCallback(this)
                    }
                },
                copy: function(v) {
                    return this.set(v)
                },
                set: function(v, p, g, m, x) {
                    return x === void 0 && (x = !0),
                    typeof v == "object" ? (this._x = v.x || 0,
                    this._y = v.y || 0,
                    this._z = v.z || 0,
                    this._w = v.w || 0) : (this._x = v || 0,
                    this._y = p || 0,
                    this._z = g || 0,
                    this._w = m || 0),
                    x && this.onChangeCallback(this),
                    this
                },
                add: function(v) {
                    return this._x += v.x,
                    this._y += v.y,
                    this._z += v.z,
                    this._w += v.w,
                    this.onChangeCallback(this),
                    this
                },
                subtract: function(v) {
                    return this._x -= v.x,
                    this._y -= v.y,
                    this._z -= v.z,
                    this._w -= v.w,
                    this.onChangeCallback(this),
                    this
                },
                scale: function(v) {
                    return this._x *= v,
                    this._y *= v,
                    this._z *= v,
                    this._w *= v,
                    this.onChangeCallback(this),
                    this
                },
                length: function() {
                    var v = this.x
                      , p = this.y
                      , g = this.z
                      , m = this.w;
                    return Math.sqrt(v * v + p * p + g * g + m * m)
                },
                lengthSq: function() {
                    var v = this.x
                      , p = this.y
                      , g = this.z
                      , m = this.w;
                    return v * v + p * p + g * g + m * m
                },
                normalize: function() {
                    var v = this.x
                      , p = this.y
                      , g = this.z
                      , m = this.w
                      , x = v * v + p * p + g * g + m * m;
                    return x > 0 && (x = 1 / Math.sqrt(x),
                    this._x = v * x,
                    this._y = p * x,
                    this._z = g * x,
                    this._w = m * x),
                    this.onChangeCallback(this),
                    this
                },
                dot: function(v) {
                    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w
                },
                lerp: function(v, p) {
                    p === void 0 && (p = 0);
                    var g = this.x
                      , m = this.y
                      , x = this.z
                      , T = this.w;
                    return this.set(g + p * (v.x - g), m + p * (v.y - m), x + p * (v.z - x), T + p * (v.w - T))
                },
                rotationTo: function(v, p) {
                    var g = v.x * p.x + v.y * p.y + v.z * p.z;
                    return g < -.999999 ? (h.copy(l).cross(v).length() < a && h.copy(i).cross(v),
                    h.normalize(),
                    this.setAxisAngle(h, Math.PI)) : g > .999999 ? this.set(0, 0, 0, 1) : (h.copy(v).cross(p),
                    this._x = h.x,
                    this._y = h.y,
                    this._z = h.z,
                    this._w = 1 + g,
                    this.normalize())
                },
                setAxes: function(v, p, g) {
                    var m = u.val;
                    return m[0] = p.x,
                    m[3] = p.y,
                    m[6] = p.z,
                    m[1] = g.x,
                    m[4] = g.y,
                    m[7] = g.z,
                    m[2] = -v.x,
                    m[5] = -v.y,
                    m[8] = -v.z,
                    this.fromMat3(u).normalize()
                },
                identity: function() {
                    return this.set(0, 0, 0, 1)
                },
                setAxisAngle: function(v, p) {
                    p = p * .5;
                    var g = Math.sin(p);
                    return this.set(g * v.x, g * v.y, g * v.z, Math.cos(p))
                },
                multiply: function(v) {
                    var p = this.x
                      , g = this.y
                      , m = this.z
                      , x = this.w
                      , T = v.x
                      , E = v.y
                      , P = v.z
                      , M = v.w;
                    return this.set(p * M + x * T + g * P - m * E, g * M + x * E + m * T - p * P, m * M + x * P + p * E - g * T, x * M - p * T - g * E - m * P)
                },
                slerp: function(v, p) {
                    var g = this.x
                      , m = this.y
                      , x = this.z
                      , T = this.w
                      , E = v.x
                      , P = v.y
                      , M = v.z
                      , L = v.w
                      , R = g * E + m * P + x * M + T * L;
                    R < 0 && (R = -R,
                    E = -E,
                    P = -P,
                    M = -M,
                    L = -L);
                    var O = 1 - p
                      , F = p;
                    if (1 - R > a) {
                        var B = Math.acos(R)
                          , N = Math.sin(B);
                        O = Math.sin((1 - p) * B) / N,
                        F = Math.sin(p * B) / N
                    }
                    return this.set(O * g + F * E, O * m + F * P, O * x + F * M, O * T + F * L)
                },
                invert: function() {
                    var v = this.x
                      , p = this.y
                      , g = this.z
                      , m = this.w
                      , x = v * v + p * p + g * g + m * m
                      , T = x ? 1 / x : 0;
                    return this.set(-v * T, -p * T, -g * T, m * T)
                },
                conjugate: function() {
                    return this._x = -this.x,
                    this._y = -this.y,
                    this._z = -this.z,
                    this.onChangeCallback(this),
                    this
                },
                rotateX: function(v) {
                    v *= .5;
                    var p = this.x
                      , g = this.y
                      , m = this.z
                      , x = this.w
                      , T = Math.sin(v)
                      , E = Math.cos(v);
                    return this.set(p * E + x * T, g * E + m * T, m * E - g * T, x * E - p * T)
                },
                rotateY: function(v) {
                    v *= .5;
                    var p = this.x
                      , g = this.y
                      , m = this.z
                      , x = this.w
                      , T = Math.sin(v)
                      , E = Math.cos(v);
                    return this.set(p * E - m * T, g * E + x * T, m * E + p * T, x * E - g * T)
                },
                rotateZ: function(v) {
                    v *= .5;
                    var p = this.x
                      , g = this.y
                      , m = this.z
                      , x = this.w
                      , T = Math.sin(v)
                      , E = Math.cos(v);
                    return this.set(p * E + g * T, g * E - p * T, m * E + x * T, x * E - m * T)
                },
                calculateW: function() {
                    var v = this.x
                      , p = this.y
                      , g = this.z;
                    return this.w = -Math.sqrt(1 - v * v - p * p - g * g),
                    this
                },
                setFromEuler: function(v, p) {
                    var g = v.x / 2
                      , m = v.y / 2
                      , x = v.z / 2
                      , T = Math.cos(g)
                      , E = Math.cos(m)
                      , P = Math.cos(x)
                      , M = Math.sin(g)
                      , L = Math.sin(m)
                      , R = Math.sin(x);
                    switch (v.order) {
                    case "XYZ":
                        {
                            this.set(M * E * P + T * L * R, T * L * P - M * E * R, T * E * R + M * L * P, T * E * P - M * L * R, p);
                            break
                        }
                    case "YXZ":
                        {
                            this.set(M * E * P + T * L * R, T * L * P - M * E * R, T * E * R - M * L * P, T * E * P + M * L * R, p);
                            break
                        }
                    case "ZXY":
                        {
                            this.set(M * E * P - T * L * R, T * L * P + M * E * R, T * E * R + M * L * P, T * E * P - M * L * R, p);
                            break
                        }
                    case "ZYX":
                        {
                            this.set(M * E * P - T * L * R, T * L * P + M * E * R, T * E * R - M * L * P, T * E * P + M * L * R, p);
                            break
                        }
                    case "YZX":
                        {
                            this.set(M * E * P + T * L * R, T * L * P + M * E * R, T * E * R - M * L * P, T * E * P - M * L * R, p);
                            break
                        }
                    case "XZY":
                        {
                            this.set(M * E * P - T * L * R, T * L * P - M * E * R, T * E * R + M * L * P, T * E * P + M * L * R, p);
                            break
                        }
                    }
                    return this
                },
                setFromRotationMatrix: function(v) {
                    var p = v.val, g = p[0], m = p[4], x = p[8], T = p[1], E = p[5], P = p[9], M = p[2], L = p[6], R = p[10], O = g + E + R, F;
                    return O > 0 ? (F = .5 / Math.sqrt(O + 1),
                    this.set((L - P) * F, (x - M) * F, (T - m) * F, .25 / F)) : g > E && g > R ? (F = 2 * Math.sqrt(1 + g - E - R),
                    this.set(.25 * F, (m + T) / F, (x + M) / F, (L - P) / F)) : E > R ? (F = 2 * Math.sqrt(1 + E - g - R),
                    this.set((m + T) / F, .25 * F, (P + L) / F, (x - M) / F)) : (F = 2 * Math.sqrt(1 + R - g - E),
                    this.set((x + M) / F, (P + L) / F, .25 * F, (T - m) / F)),
                    this
                },
                fromMat3: function(v) {
                    var p = v.val, g = p[0] + p[4] + p[8], m;
                    if (g > 0)
                        m = Math.sqrt(g + 1),
                        this.w = .5 * m,
                        m = .5 / m,
                        this._x = (p[7] - p[5]) * m,
                        this._y = (p[2] - p[6]) * m,
                        this._z = (p[3] - p[1]) * m;
                    else {
                        var x = 0;
                        p[4] > p[0] && (x = 1),
                        p[8] > p[x * 3 + x] && (x = 2);
                        var T = n[x]
                          , E = n[T];
                        m = Math.sqrt(p[x * 3 + x] - p[T * 3 + T] - p[E * 3 + E] + 1),
                        s[x] = .5 * m,
                        m = .5 / m,
                        s[T] = (p[T * 3 + x] + p[x * 3 + T]) * m,
                        s[E] = (p[E * 3 + x] + p[x * 3 + E]) * m,
                        this._x = s[0],
                        this._y = s[1],
                        this._z = s[2],
                        this._w = (p[E * 3 + T] - p[T * 3 + E]) * m
                    }
                    return this.onChangeCallback(this),
                    this
                }
            });
            c.exports = d
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(367)
              , f = t(31)
              , r = t(33)
              , o = t(191)
              , a = function(n) {
                var s = n.config;
                if ((s.customEnvironment || s.canvas) && s.renderType === r.AUTO)
                    throw new Error("Must set explicit renderType in custom environment");
                if (!s.customEnvironment && !s.canvas && s.renderType !== r.HEADLESS)
                    if (s.renderType === r.CANVAS || s.renderType !== r.CANVAS && !o.webGL)
                        if (o.canvas)
                            s.renderType = r.CANVAS;
                        else
                            throw new Error("Cannot create Canvas or WebGL context, aborting.");
                    else
                        s.renderType = r.WEBGL;
                s.antialias || f.disableSmoothing();
                var l = n.scale.baseSize
                  , i = l.width
                  , h = l.height;
                if (s.canvas ? (n.canvas = s.canvas,
                n.canvas.width = i,
                n.canvas.height = h) : n.canvas = f.create(n, i, h, s.renderType),
                s.canvasStyle && (n.canvas.style = s.canvasStyle),
                s.antialias || e.setCrisp(n.canvas),
                s.renderType !== r.HEADLESS) {
                    var u, d;
                    u = t(368),
                    d = t(371),
                    s.renderType === r.WEBGL ? n.renderer = new d(n) : (n.renderer = new u(n),
                    n.context = n.renderer.gameContext)
                }
            };
            c.exports = a
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                setCrisp: function(e) {
                    var f = ["optimizeSpeed", "-moz-crisp-edges", "-o-crisp-edges", "-webkit-optimize-contrast", "optimize-contrast", "crisp-edges", "pixelated"];
                    return f.forEach(function(r) {
                        e.style["image-rendering"] = r
                    }),
                    e.style.msInterpolationMode = "nearest-neighbor",
                    e
                },
                setBicubic: function(e) {
                    return e.style["image-rendering"] = "auto",
                    e.style.msInterpolationMode = "bicubic",
                    e
                }
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(37)
              , f = t(369)
              , r = t(0)
              , o = t(33)
              , a = t(9)
              , n = t(91)
              , s = t(370)
              , l = t(104)
              , i = t(106)
              , h = t(25)
              , u = new r({
                Extends: a,
                initialize: function(v) {
                    a.call(this);
                    var p = v.config;
                    this.config = {
                        clearBeforeRender: p.clearBeforeRender,
                        backgroundColor: p.backgroundColor,
                        antialias: p.antialias,
                        roundPixels: p.roundPixels
                    },
                    this.game = v,
                    this.type = o.CANVAS,
                    this.drawCount = 0,
                    this.width = 0,
                    this.height = 0,
                    this.gameCanvas = v.canvas;
                    var g = {
                        alpha: v.config.transparent,
                        desynchronized: v.config.desynchronized
                    };
                    this.gameContext = p.context ? p.context : this.gameCanvas.getContext("2d", g),
                    this.currentContext = this.gameContext,
                    this.antialias = v.config.antialias,
                    this.blendModes = s(),
                    this.snapshotState = {
                        x: 0,
                        y: 0,
                        width: 1,
                        height: 1,
                        getPixel: !1,
                        callback: null,
                        type: "image/png",
                        encoder: .92
                    },
                    this._tempMatrix1 = new h,
                    this._tempMatrix2 = new h,
                    this._tempMatrix3 = new h,
                    this.isBooted = !1,
                    this.init()
                },
                init: function() {
                    this.game.textures.once(i.READY, this.boot, this)
                },
                boot: function() {
                    var d = this.game
                      , v = d.scale.baseSize;
                    this.width = v.width,
                    this.height = v.height,
                    this.isBooted = !0,
                    d.scale.on(l.RESIZE, this.onResize, this),
                    this.resize(v.width, v.height)
                },
                onResize: function(d, v) {
                    (v.width !== this.width || v.height !== this.height) && this.resize(v.width, v.height)
                },
                resize: function(d, v) {
                    this.width = d,
                    this.height = v,
                    this.emit(n.RESIZE, d, v)
                },
                resetTransform: function() {
                    this.currentContext.setTransform(1, 0, 0, 1, 0, 0)
                },
                setBlendMode: function(d) {
                    return this.currentContext.globalCompositeOperation = d,
                    this
                },
                setContext: function(d) {
                    return this.currentContext = d || this.gameContext,
                    this
                },
                setAlpha: function(d) {
                    return this.currentContext.globalAlpha = d,
                    this
                },
                preRender: function() {
                    var d = this.gameContext
                      , v = this.config
                      , p = this.width
                      , g = this.height;
                    d.globalAlpha = 1,
                    d.globalCompositeOperation = "source-over",
                    d.setTransform(1, 0, 0, 1, 0, 0),
                    v.clearBeforeRender && (d.clearRect(0, 0, p, g),
                    v.transparent || (d.fillStyle = v.backgroundColor.rgba,
                    d.fillRect(0, 0, p, g))),
                    d.save(),
                    this.drawCount = 0,
                    this.emit(n.PRE_RENDER)
                },
                render: function(d, v, p) {
                    var g = v.length;
                    this.emit(n.RENDER, d, p);
                    var m = p.x
                      , x = p.y
                      , T = p.width
                      , E = p.height
                      , P = p.renderToTexture ? p.context : d.sys.context;
                    P.save(),
                    this.game.scene.customViewports && (P.beginPath(),
                    P.rect(m, x, T, E),
                    P.clip()),
                    this.currentContext = P;
                    var M = p.mask;
                    M && M.preRenderCanvas(this, null, p._maskCamera),
                    p.transparent || (P.fillStyle = p.backgroundColor.rgba,
                    P.fillRect(m, x, T, E)),
                    P.globalAlpha = p.alpha,
                    P.globalCompositeOperation = "source-over",
                    this.drawCount += g,
                    p.renderToTexture && p.emit(e.PRE_RENDER, p),
                    p.matrix.copyToContext(P);
                    for (var L = 0; L < g; L++) {
                        var R = v[L];
                        R.mask && R.mask.preRenderCanvas(this, R, p),
                        R.renderCanvas(this, R, p),
                        R.mask && R.mask.postRenderCanvas(this, R, p)
                    }
                    P.setTransform(1, 0, 0, 1, 0, 0),
                    P.globalCompositeOperation = "source-over",
                    P.globalAlpha = 1,
                    p.flashEffect.postRenderCanvas(P),
                    p.fadeEffect.postRenderCanvas(P),
                    p.dirty = !1,
                    M && M.postRenderCanvas(this),
                    P.restore(),
                    p.renderToTexture && (p.emit(e.POST_RENDER, p),
                    p.renderToGame && d.sys.context.drawImage(p.canvas, m, x))
                },
                postRender: function() {
                    var d = this.gameContext;
                    d.restore(),
                    this.emit(n.POST_RENDER);
                    var v = this.snapshotState;
                    v.callback && (f(this.gameCanvas, v),
                    v.callback = null)
                },
                snapshotCanvas: function(d, v, p, g, m, x, T, E, P) {
                    p === void 0 && (p = !1),
                    this.snapshotArea(g, m, x, T, v, E, P);
                    var M = this.snapshotState;
                    return M.getPixel = p,
                    f(this.canvas, M),
                    M.callback = null,
                    this
                },
                snapshot: function(d, v, p) {
                    return this.snapshotArea(0, 0, this.gameCanvas.width, this.gameCanvas.height, d, v, p)
                },
                snapshotArea: function(d, v, p, g, m, x, T) {
                    var E = this.snapshotState;
                    return E.callback = m,
                    E.type = x,
                    E.encoder = T,
                    E.getPixel = !1,
                    E.x = d,
                    E.y = v,
                    E.width = Math.min(p, this.gameCanvas.width),
                    E.height = Math.min(g, this.gameCanvas.height),
                    this
                },
                snapshotPixel: function(d, v, p) {
                    return this.snapshotArea(d, v, 1, 1, p),
                    this.snapshotState.getPixel = !0,
                    this
                },
                batchSprite: function(d, v, p, g) {
                    var m = p.alpha * d.alpha;
                    if (m !== 0) {
                        var x = this.currentContext
                          , T = this._tempMatrix1
                          , E = this._tempMatrix2
                          , P = v.canvasData
                          , M = P.x
                          , L = P.y
                          , R = v.cutWidth
                          , O = v.cutHeight
                          , F = v.customPivot
                          , B = v.source.resolution
                          , N = d.displayOriginX
                          , Y = d.displayOriginY
                          , z = -N + v.x
                          , W = -Y + v.y;
                        if (d.isCropped) {
                            var b = d._crop;
                            (b.flipX !== d.flipX || b.flipY !== d.flipY) && v.updateCropUVs(b, d.flipX, d.flipY),
                            R = b.cw,
                            O = b.ch,
                            M = b.cx,
                            L = b.cy,
                            z = -N + b.x,
                            W = -Y + b.y,
                            d.flipX && (z >= 0 ? z = -(z + R) : z < 0 && (z = Math.abs(z) - R)),
                            d.flipY && (W >= 0 ? W = -(W + O) : W < 0 && (W = Math.abs(W) - O))
                        }
                        var D = 1
                          , I = 1;
                        d.flipX && (F || (z += -v.realWidth + N * 2),
                        D = -1),
                        d.flipY && (F || (W += -v.realHeight + Y * 2),
                        I = -1),
                        E.applyITRS(d.x, d.y, d.rotation, d.scaleX * D, d.scaleY * I),
                        T.copyFrom(p.matrix),
                        g ? (T.multiplyWithOffset(g, -p.scrollX * d.scrollFactorX, -p.scrollY * d.scrollFactorY),
                        E.e = d.x,
                        E.f = d.y) : (E.e -= p.scrollX * d.scrollFactorX,
                        E.f -= p.scrollY * d.scrollFactorY),
                        T.multiply(E),
                        x.save(),
                        T.setToContext(x),
                        x.globalCompositeOperation = this.blendModes[d.blendMode],
                        x.globalAlpha = m,
                        x.imageSmoothingEnabled = !(!this.antialias || v.source.scaleMode),
                        d.mask && d.mask.preRenderCanvas(this, d, p),
                        x.drawImage(v.source.image, M, L, R, O, z, W, R / B, O / B),
                        d.mask && d.mask.postRenderCanvas(this, d, p),
                        x.restore()
                    }
                },
                destroy: function() {
                    this.removeAllListeners(),
                    this.game = null,
                    this.gameCanvas = null,
                    this.gameContext = null
                }
            });
            c.exports = u
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(31)
              , f = t(38)
              , r = t(2)
              , o = function(a, n) {
                var s = r(n, "callback")
                  , l = r(n, "type", "image/png")
                  , i = r(n, "encoder", .92)
                  , h = Math.abs(Math.round(r(n, "x", 0)))
                  , u = Math.abs(Math.round(r(n, "y", 0)))
                  , d = r(n, "width", a.width)
                  , v = r(n, "height", a.height)
                  , p = r(n, "getPixel", !1);
                if (p) {
                    var g = a.getContext("2d")
                      , m = g.getImageData(h, u, 1, 1)
                      , x = m.data;
                    s.call(null, new f(x[0],x[1],x[2],x[3] / 255))
                } else if (h !== 0 || u !== 0 || d !== a.width || v !== a.height) {
                    var T = e.createWebGL(this, d, v)
                      , E = T.getContext("2d");
                    E.drawImage(a, h, u, d, v, 0, 0, d, v);
                    var P = new Image;
                    P.onerror = function() {
                        s.call(null),
                        e.remove(T)
                    }
                    ,
                    P.onload = function() {
                        s.call(null, P),
                        e.remove(T)
                    }
                    ,
                    P.src = T.toDataURL(l, i)
                } else {
                    var M = new Image;
                    M.onerror = function() {
                        s.call(null)
                    }
                    ,
                    M.onload = function() {
                        s.call(null, M)
                    }
                    ,
                    M.src = a.toDataURL(l, i)
                }
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(35)
              , f = t(348)
              , r = function() {
                var o = []
                  , a = f.supportNewBlendModes
                  , n = "source-over";
                return o[e.NORMAL] = n,
                o[e.ADD] = "lighter",
                o[e.MULTIPLY] = a ? "multiply" : n,
                o[e.SCREEN] = a ? "screen" : n,
                o[e.OVERLAY] = a ? "overlay" : n,
                o[e.DARKEN] = a ? "darken" : n,
                o[e.LIGHTEN] = a ? "lighten" : n,
                o[e.COLOR_DODGE] = a ? "color-dodge" : n,
                o[e.COLOR_BURN] = a ? "color-burn" : n,
                o[e.HARD_LIGHT] = a ? "hard-light" : n,
                o[e.SOFT_LIGHT] = a ? "soft-light" : n,
                o[e.DIFFERENCE] = a ? "difference" : n,
                o[e.EXCLUSION] = a ? "exclusion" : n,
                o[e.HUE] = a ? "hue" : n,
                o[e.SATURATION] = a ? "saturation" : n,
                o[e.COLOR] = a ? "color" : n,
                o[e.LUMINOSITY] = a ? "luminosity" : n,
                o[e.ERASE] = "destination-out",
                o[e.SOURCE_IN] = "source-in",
                o[e.SOURCE_OUT] = "source-out",
                o[e.SOURCE_ATOP] = "source-atop",
                o[e.DESTINATION_OVER] = "destination-over",
                o[e.DESTINATION_IN] = "destination-in",
                o[e.DESTINATION_OUT] = "destination-out",
                o[e.DESTINATION_ATOP] = "destination-atop",
                o[e.LIGHTER] = "lighter",
                o[e.COPY] = "copy",
                o[e.XOR] = "xor",
                o
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(93)
              , f = t(37)
              , r = t(0)
              , o = t(33)
              , a = t(9)
              , n = t(91)
              , s = t(22)
              , l = t(138)
              , i = t(69)
              , h = t(1)
              , u = t(372)
              , d = t(141)
              , v = t(104)
              , p = t(106)
              , g = t(12)
              , m = t(383)
              , x = new r({
                Extends: a,
                initialize: function(E) {
                    a.call(this);
                    var P = E.config
                      , M = {
                        alpha: P.transparent,
                        desynchronized: P.desynchronized,
                        depth: !1,
                        antialias: P.antialiasGL,
                        premultipliedAlpha: P.premultipliedAlpha,
                        stencil: !0,
                        failIfMajorPerformanceCaveat: P.failIfMajorPerformanceCaveat,
                        powerPreference: P.powerPreference,
                        preserveDrawingBuffer: P.preserveDrawingBuffer
                    };
                    this.config = {
                        clearBeforeRender: P.clearBeforeRender,
                        antialias: P.antialias,
                        backgroundColor: P.backgroundColor,
                        contextCreation: M,
                        roundPixels: P.roundPixels,
                        maxTextures: P.maxTextures,
                        maxTextureSize: P.maxTextureSize,
                        batchSize: P.batchSize,
                        maxLights: P.maxLights,
                        mipmapFilter: P.mipmapFilter
                    },
                    this.game = E,
                    this.type = o.WEBGL,
                    this.pipelines = null,
                    this.width = 0,
                    this.height = 0,
                    this.canvas = E.canvas,
                    this.blendModes = [],
                    this.contextLost = !1,
                    this.snapshotState = {
                        x: 0,
                        y: 0,
                        width: 1,
                        height: 1,
                        getPixel: !1,
                        callback: null,
                        type: "image/png",
                        encoder: .92,
                        isFramebuffer: !1,
                        bufferWidth: 0,
                        bufferHeight: 0
                    },
                    this.currentActiveTexture = 0,
                    this.startActiveTexture = 0,
                    this.maxTextures = 0,
                    this.textureIndexes,
                    this.tempTextures,
                    this.textureZero,
                    this.normalTexture,
                    this.currentFramebuffer = null,
                    this.fboStack = [],
                    this.currentProgram = null,
                    this.currentBlendMode = 1 / 0,
                    this.currentScissorEnabled = !1,
                    this.currentScissor = null,
                    this.scissorStack = [],
                    this.contextLostHandler = h,
                    this.contextRestoredHandler = h,
                    this.gl = null,
                    this.supportedExtensions = null,
                    this.instancedArraysExtension = null,
                    this.vaoExtension = null,
                    this.extensions = {},
                    this.glFormats = [],
                    this.compression = {
                        ETC1: !1,
                        PVRTC: !1,
                        S3TC: !1
                    },
                    this.drawingBufferHeight = 0,
                    this.blankTexture = null,
                    this.whiteTexture = null,
                    this.maskCount = 0,
                    this.maskStack = [],
                    this.currentMask = {
                        mask: null,
                        camera: null
                    },
                    this.currentCameraMask = {
                        mask: null,
                        camera: null
                    },
                    this.glFuncMap = null,
                    this.currentType = "",
                    this.newType = !1,
                    this.nextTypeMatch = !1,
                    this.finalType = !1,
                    this.mipmapFilter = null,
                    this.textureFlush = 0,
                    this.isTextureClean = !1,
                    this.defaultScissor = [0, 0, 0, 0],
                    this.isBooted = !1,
                    this.renderTarget = null,
                    this.projectionMatrix,
                    this.projectionWidth = 0,
                    this.projectionHeight = 0,
                    this.init(this.config)
                },
                init: function(T) {
                    var E, P = this.game, M = this.canvas, L = T.backgroundColor;
                    if (P.config.context ? E = P.config.context : E = M.getContext("webgl", T.contextCreation) || M.getContext("experimental-webgl", T.contextCreation),
                    !E || E.isContextLost())
                        throw this.contextLost = !0,
                        new Error("WebGL unsupported");
                    this.gl = E;
                    var R = this;
                    this.contextLostHandler = function(G) {
                        R.contextLost = !0,
                        R.game.events.emit(s.CONTEXT_LOST, R),
                        G.preventDefault()
                    }
                    ,
                    this.contextRestoredHandler = function() {
                        R.contextLost = !1,
                        R.init(R.config),
                        R.game.events.emit(s.CONTEXT_RESTORED, R)
                    }
                    ,
                    M.addEventListener("webglcontextlost", this.contextLostHandler, !1),
                    M.addEventListener("webglcontextrestored", this.contextRestoredHandler, !1),
                    P.context = E;
                    for (var O = 0; O <= 27; O++)
                        this.blendModes.push({
                            func: [E.ONE, E.ONE_MINUS_SRC_ALPHA],
                            equation: E.FUNC_ADD
                        });
                    this.blendModes[1].func = [E.ONE, E.DST_ALPHA],
                    this.blendModes[2].func = [E.DST_COLOR, E.ONE_MINUS_SRC_ALPHA],
                    this.blendModes[3].func = [E.ONE, E.ONE_MINUS_SRC_COLOR],
                    this.blendModes[17] = {
                        func: [E.ZERO, E.ONE_MINUS_SRC_ALPHA],
                        equation: E.FUNC_REVERSE_SUBTRACT
                    },
                    this.glFormats[0] = E.BYTE,
                    this.glFormats[1] = E.SHORT,
                    this.glFormats[2] = E.UNSIGNED_BYTE,
                    this.glFormats[3] = E.UNSIGNED_SHORT,
                    this.glFormats[4] = E.FLOAT,
                    this.glFuncMap = {
                        mat2: {
                            func: E.uniformMatrix2fv,
                            length: 1,
                            matrix: !0
                        },
                        mat3: {
                            func: E.uniformMatrix3fv,
                            length: 1,
                            matrix: !0
                        },
                        mat4: {
                            func: E.uniformMatrix4fv,
                            length: 1,
                            matrix: !0
                        },
                        "1f": {
                            func: E.uniform1f,
                            length: 1
                        },
                        "1fv": {
                            func: E.uniform1fv,
                            length: 1
                        },
                        "1i": {
                            func: E.uniform1i,
                            length: 1
                        },
                        "1iv": {
                            func: E.uniform1iv,
                            length: 1
                        },
                        "2f": {
                            func: E.uniform2f,
                            length: 2
                        },
                        "2fv": {
                            func: E.uniform2fv,
                            length: 1
                        },
                        "2i": {
                            func: E.uniform2i,
                            length: 2
                        },
                        "2iv": {
                            func: E.uniform2iv,
                            length: 1
                        },
                        "3f": {
                            func: E.uniform3f,
                            length: 3
                        },
                        "3fv": {
                            func: E.uniform3fv,
                            length: 1
                        },
                        "3i": {
                            func: E.uniform3i,
                            length: 3
                        },
                        "3iv": {
                            func: E.uniform3iv,
                            length: 1
                        },
                        "4f": {
                            func: E.uniform4f,
                            length: 4
                        },
                        "4fv": {
                            func: E.uniform4fv,
                            length: 1
                        },
                        "4i": {
                            func: E.uniform4i,
                            length: 4
                        },
                        "4iv": {
                            func: E.uniform4iv,
                            length: 1
                        }
                    };
                    var F = E.getSupportedExtensions();
                    (!T.maxTextures || T.maxTextures === -1) && (T.maxTextures = E.getParameter(E.MAX_TEXTURE_IMAGE_UNITS)),
                    T.maxTextureSize || (T.maxTextureSize = E.getParameter(E.MAX_TEXTURE_SIZE));
                    var B = "WEBGL_compressed_texture_"
                      , N = "WEBKIT_" + B;
                    this.compression.ETC1 = E.getExtension(B + "etc1") || E.getExtension(N + "etc1"),
                    this.compression.PVRTC = E.getExtension(B + "pvrtc") || E.getExtension(N + "pvrtc"),
                    this.compression.S3TC = E.getExtension(B + "s3tc") || E.getExtension(N + "s3tc"),
                    this.supportedExtensions = F;
                    var Y = "ANGLE_instanced_arrays";
                    this.instancedArraysExtension = F.indexOf(Y) > -1 ? E.getExtension(Y) : null;
                    var z = "OES_vertex_array_object";
                    this.vaoExtension = F.indexOf(z) > -1 ? E.getExtension(z) : null,
                    E.disable(E.DEPTH_TEST),
                    E.disable(E.CULL_FACE),
                    E.enable(E.BLEND),
                    E.clearColor(L.redGL, L.greenGL, L.blueGL, L.alphaGL),
                    this.mipmapFilter = E[T.mipmapFilter],
                    this.maxTextures = g.checkShaderMax(E, T.maxTextures),
                    this.textureIndexes = [];
                    var W = this.tempTextures;
                    if (Array.isArray(W))
                        for (var b = 0; O < this.maxTextures; b++)
                            E.deleteTexture(W[b]);
                    else
                        W = new Array(this.maxTextures);
                    for (var D = 0; D < this.maxTextures; D++) {
                        var I = E.createTexture();
                        E.activeTexture(E.TEXTURE0 + D),
                        E.bindTexture(E.TEXTURE_2D, I),
                        E.texImage2D(E.TEXTURE_2D, 0, E.RGBA, 1, 1, 0, E.RGBA, E.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255])),
                        W[D] = I,
                        this.textureIndexes.push(D)
                    }
                    return this.tempTextures = W,
                    this.currentActiveTexture = 1,
                    this.startActiveTexture++,
                    E.activeTexture(E.TEXTURE1),
                    this.pipelines = new u(this),
                    this.setBlendMode(o.BlendModes.NORMAL),
                    this.projectionMatrix = new i().identity(),
                    P.textures.once(p.READY, this.boot, this),
                    this
                },
                boot: function() {
                    var T = this.game
                      , E = this.pipelines
                      , P = T.scale.baseSize;
                    this.width = P.width,
                    this.height = P.height,
                    this.isBooted = !0,
                    this.renderTarget = new d(this,this.width,this.height,1,0,!0,!0),
                    E.boot(T.config.pipeline),
                    this.blankTexture = T.textures.getFrame("__DEFAULT"),
                    this.whiteTexture = T.textures.getFrame("__WHITE");
                    var M = this.gl;
                    M.bindFramebuffer(M.FRAMEBUFFER, null),
                    M.enable(M.SCISSOR_TEST),
                    T.scale.on(v.RESIZE, this.onResize, this),
                    this.resize(P.width, P.height)
                },
                onResize: function(T, E) {
                    (E.width !== this.width || E.height !== this.height) && this.resize(E.width, E.height)
                },
                beginCapture: function(T, E) {
                    T === void 0 && (T = this.width),
                    E === void 0 && (E = this.height),
                    this.renderTarget.bind(!0, T, E),
                    this.setProjectionMatrix(T, E),
                    this.resetTextures()
                },
                endCapture: function() {
                    return this.renderTarget.unbind(!0),
                    this.resetProjectionMatrix(),
                    this.renderTarget
                },
                resize: function(T, E) {
                    var P = this.gl;
                    return this.width = T,
                    this.height = E,
                    this.setProjectionMatrix(T, E),
                    P.viewport(0, 0, T, E),
                    this.drawingBufferHeight = P.drawingBufferHeight,
                    P.scissor(0, P.drawingBufferHeight - E, T, E),
                    this.defaultScissor[2] = T,
                    this.defaultScissor[3] = E,
                    this.emit(n.RESIZE, T, E),
                    this
                },
                getAspectRatio: function() {
                    return this.width / this.height
                },
                setProjectionMatrix: function(T, E) {
                    return (T !== this.projectionWidth || E !== this.projectionHeight) && (this.projectionWidth = T,
                    this.projectionHeight = E,
                    this.projectionMatrix.ortho(0, T, E, 0, -1e3, 1e3)),
                    this
                },
                resetProjectionMatrix: function() {
                    this.projectionWidth = this.width,
                    this.projectionHeight = this.height,
                    this.projectionMatrix.ortho(0, this.width, this.height, 0, -1e3, 1e3)
                },
                hasExtension: function(T) {
                    return this.supportedExtensions ? this.supportedExtensions.indexOf(T) : !1
                },
                getExtension: function(T) {
                    return this.hasExtension(T) ? (T in this.extensions || (this.extensions[T] = this.gl.getExtension(T)),
                    this.extensions[T]) : null
                },
                flush: function() {
                    this.pipelines.flush()
                },
                pushScissor: function(T, E, P, M, L) {
                    L === void 0 && (L = this.drawingBufferHeight);
                    var R = this.scissorStack
                      , O = [T, E, P, M];
                    return R.push(O),
                    this.setScissor(T, E, P, M, L),
                    this.currentScissor = O,
                    O
                },
                setScissor: function(T, E, P, M, L) {
                    L === void 0 && (L = this.drawingBufferHeight);
                    var R = this.gl
                      , O = this.currentScissor
                      , F = P > 0 && M > 0;
                    if (O && F) {
                        var B = O[0]
                          , N = O[1]
                          , Y = O[2]
                          , z = O[3];
                        F = B !== T || N !== E || Y !== P || z !== M
                    }
                    F && (this.flush(),
                    R.scissor(T, L - E - M, P, M))
                },
                resetScissor: function() {
                    var T = this.gl;
                    T.enable(T.SCISSOR_TEST);
                    var E = this.currentScissor;
                    if (E) {
                        var P = E[0]
                          , M = E[1]
                          , L = E[2]
                          , R = E[3];
                        L > 0 && R > 0 && T.scissor(P, this.drawingBufferHeight - M - R, L, R)
                    }
                },
                popScissor: function() {
                    var T = this.scissorStack;
                    T.pop();
                    var E = T[T.length - 1];
                    E && this.setScissor(E[0], E[1], E[2], E[3]),
                    this.currentScissor = E
                },
                hasActiveStencilMask: function() {
                    var T = this.currentMask.mask
                      , E = this.currentCameraMask.mask;
                    return T && T.isStencil || E && E.isStencil
                },
                resetViewport: function() {
                    var T = this.gl;
                    T.viewport(0, 0, this.width, this.height),
                    this.drawingBufferHeight = T.drawingBufferHeight
                },
                setBlendMode: function(T, E) {
                    E === void 0 && (E = !1);
                    var P = this.gl
                      , M = this.blendModes[T];
                    return E || T !== o.BlendModes.SKIP_CHECK && this.currentBlendMode !== T ? (this.flush(),
                    P.enable(P.BLEND),
                    P.blendEquation(M.equation),
                    M.func.length > 2 ? P.blendFuncSeparate(M.func[0], M.func[1], M.func[2], M.func[3]) : P.blendFunc(M.func[0], M.func[1]),
                    this.currentBlendMode = T,
                    !0) : !1
                },
                addBlendMode: function(T, E) {
                    var P = this.blendModes.push({
                        func: T,
                        equation: E
                    });
                    return P - 1
                },
                updateBlendMode: function(T, E, P) {
                    return this.blendModes[T] && (this.blendModes[T].func = E,
                    P && (this.blendModes[T].equation = P)),
                    this
                },
                removeBlendMode: function(T) {
                    return T > 17 && this.blendModes[T] && this.blendModes.splice(T, 1),
                    this
                },
                setBlankTexture: function() {
                    this.setTexture2D(this.blankTexture.glTexture)
                },
                setTextureSource: function(T) {
                    if (this.pipelines.forceZero())
                        return this.setTextureZero(T.glTexture, !0),
                        0;
                    var E = this.gl
                      , P = this.currentActiveTexture;
                    return T.glIndexCounter < this.startActiveTexture && (T.glIndexCounter = this.startActiveTexture,
                    P < this.maxTextures ? (T.glIndex = P,
                    E.activeTexture(E.TEXTURE0 + P),
                    E.bindTexture(E.TEXTURE_2D, T.glTexture),
                    this.currentActiveTexture++) : (this.flush(),
                    this.startActiveTexture++,
                    this.textureFlush++,
                    T.glIndexCounter = this.startActiveTexture,
                    T.glIndex = 1,
                    E.activeTexture(E.TEXTURE1),
                    E.bindTexture(E.TEXTURE_2D, T.glTexture),
                    this.currentActiveTexture = 2)),
                    this.isTextureClean = !1,
                    T.glIndex
                },
                isNewNormalMap: function(T, E) {
                    return this.textureZero !== T || this.normalTexture !== E
                },
                setTextureZero: function(T, E) {
                    if (this.textureZero !== T) {
                        E && this.flush();
                        var P = this.gl;
                        P.activeTexture(P.TEXTURE0),
                        P.bindTexture(P.TEXTURE_2D, T),
                        this.textureZero = T
                    }
                },
                clearTextureZero: function() {
                    this.textureZero = null
                },
                setNormalMap: function(T) {
                    if (this.normalTexture !== T) {
                        var E = this.gl;
                        E.activeTexture(E.TEXTURE1),
                        E.bindTexture(E.TEXTURE_2D, T),
                        this.normalTexture = T,
                        this.currentActiveTexture === 1 && (this.currentActiveTexture = 2)
                    }
                },
                clearNormalMap: function() {
                    this.normalTexture = null,
                    this.startActiveTexture++,
                    this.currentActiveTexture = 1,
                    this.textureFlush++
                },
                unbindTextures: function() {
                    for (var T = this.gl, E = this.tempTextures, P = 0; P < E.length; P++)
                        T.activeTexture(T.TEXTURE0 + P),
                        T.bindTexture(T.TEXTURE_2D, null);
                    this.normalTexture = null,
                    this.textureZero = null,
                    this.currentActiveTexture = 1,
                    this.startActiveTexture++,
                    this.textureFlush++
                },
                resetTextures: function(T) {
                    if (T === void 0 && (T = !1),
                    !this.isTextureClean) {
                        this.flush();
                        var E = this.gl
                          , P = this.tempTextures;
                        if (T) {
                            for (var M = 0; M < P.length; M++)
                                E.activeTexture(E.TEXTURE0 + M),
                                E.bindTexture(E.TEXTURE_2D, P[M]);
                            E.activeTexture(E.TEXTURE1),
                            E.bindTexture(E.TEXTURE_2D, P[1]),
                            this.isTextureClean = !0
                        } else
                            E.activeTexture(E.TEXTURE0),
                            E.bindTexture(E.TEXTURE_2D, P[0]),
                            E.activeTexture(E.TEXTURE1),
                            E.bindTexture(E.TEXTURE_2D, P[1]);
                        this.normalTexture = null,
                        this.textureZero = null,
                        this.currentActiveTexture = 1,
                        this.startActiveTexture++,
                        this.textureFlush++
                    }
                },
                setTexture2D: function(T) {
                    if (this.pipelines.forceZero())
                        return this.setTextureZero(T, !0),
                        0;
                    var E = this.gl
                      , P = this.currentActiveTexture;
                    return T.glIndexCounter < this.startActiveTexture && (T.glIndexCounter = this.startActiveTexture,
                    P < this.maxTextures ? (T.glIndex = P,
                    E.activeTexture(E.TEXTURE0 + P),
                    E.bindTexture(E.TEXTURE_2D, T),
                    this.currentActiveTexture++) : (this.flush(),
                    this.startActiveTexture++,
                    this.textureFlush++,
                    T.glIndexCounter = this.startActiveTexture,
                    T.glIndex = 1,
                    E.activeTexture(E.TEXTURE1),
                    E.bindTexture(E.TEXTURE_2D, T),
                    this.currentActiveTexture = 2)),
                    this.isTextureClean = !1,
                    T.glIndex
                },
                pushFramebuffer: function(T, E, P, M) {
                    return T === this.currentFramebuffer ? this : (this.fboStack.push(T),
                    this.setFramebuffer(T, E, P, M))
                },
                setFramebuffer: function(T, E, P, M) {
                    if (E === void 0 && (E = !1),
                    P === void 0 && (P = !1),
                    M === void 0 && (M = !0),
                    T === this.currentFramebuffer)
                        return this;
                    var L = this.gl
                      , R = this.width
                      , O = this.height;
                    return T && T.renderTexture && M ? (R = T.renderTexture.width,
                    O = T.renderTexture.height) : this.flush(),
                    L.bindFramebuffer(L.FRAMEBUFFER, T),
                    M && L.viewport(0, 0, R, O),
                    E && (T ? (this.drawingBufferHeight = O,
                    this.pushScissor(0, 0, R, O)) : (this.drawingBufferHeight = this.height,
                    this.popScissor())),
                    this.currentFramebuffer = T,
                    P && this.resetTextures(),
                    this
                },
                popFramebuffer: function(T, E, P) {
                    T === void 0 && (T = !1),
                    E === void 0 && (E = !1),
                    P === void 0 && (P = !0);
                    var M = this.fboStack;
                    M.pop();
                    var L = M[M.length - 1];
                    return L || (L = null),
                    this.setFramebuffer(L, T, E, P),
                    L
                },
                setProgram: function(T) {
                    return T !== this.currentProgram ? (this.flush(),
                    this.gl.useProgram(T),
                    this.currentProgram = T,
                    !0) : !1
                },
                resetProgram: function() {
                    return this.gl.useProgram(this.currentProgram),
                    this
                },
                createTextureFromSource: function(T, E, P, M) {
                    var L = this.gl
                      , R = L.NEAREST
                      , O = L.NEAREST
                      , F = L.CLAMP_TO_EDGE
                      , B = null;
                    E = T ? T.width : E,
                    P = T ? T.height : P;
                    var N = l(E, P);
                    return N && (F = L.REPEAT),
                    M === o.ScaleModes.LINEAR && this.config.antialias && (R = N ? this.mipmapFilter : L.LINEAR,
                    O = L.LINEAR),
                    !T && typeof E == "number" && typeof P == "number" ? B = this.createTexture2D(0, R, O, F, F, L.RGBA, null, E, P) : B = this.createTexture2D(0, R, O, F, F, L.RGBA, T),
                    B
                },
                createTexture2D: function(T, E, P, M, L, R, O, F, B, N, Y, z) {
                    N = N ?? !0,
                    Y === void 0 && (Y = !1),
                    z === void 0 && (z = !1);
                    var W = this.gl
                      , b = W.createTexture();
                    W.activeTexture(W.TEXTURE0);
                    var D = W.getParameter(W.TEXTURE_BINDING_2D);
                    return W.bindTexture(W.TEXTURE_2D, b),
                    W.texParameteri(W.TEXTURE_2D, W.TEXTURE_MIN_FILTER, E),
                    W.texParameteri(W.TEXTURE_2D, W.TEXTURE_MAG_FILTER, P),
                    W.texParameteri(W.TEXTURE_2D, W.TEXTURE_WRAP_S, L),
                    W.texParameteri(W.TEXTURE_2D, W.TEXTURE_WRAP_T, M),
                    W.pixelStorei(W.UNPACK_PREMULTIPLY_ALPHA_WEBGL, N),
                    W.pixelStorei(W.UNPACK_FLIP_Y_WEBGL, z),
                    O == null ? W.texImage2D(W.TEXTURE_2D, T, R, F, B, 0, R, W.UNSIGNED_BYTE, null) : (Y || (F = O.width,
                    B = O.height),
                    W.texImage2D(W.TEXTURE_2D, T, R, R, W.UNSIGNED_BYTE, O)),
                    l(F, B) && W.generateMipmap(W.TEXTURE_2D),
                    D && W.bindTexture(W.TEXTURE_2D, D),
                    b.isAlphaPremultiplied = N,
                    b.isRenderTexture = !1,
                    b.width = F,
                    b.height = B,
                    b.glIndex = 0,
                    b.glIndexCounter = -1,
                    b
                },
                createFramebuffer: function(T, E, P, M) {
                    var L = this.gl
                      , R = L.createFramebuffer()
                      , O = 0;
                    if (this.setFramebuffer(R),
                    M) {
                        var F = L.createRenderbuffer();
                        L.bindRenderbuffer(L.RENDERBUFFER, F),
                        L.renderbufferStorage(L.RENDERBUFFER, L.DEPTH_STENCIL, T, E),
                        L.framebufferRenderbuffer(L.FRAMEBUFFER, L.DEPTH_STENCIL_ATTACHMENT, L.RENDERBUFFER, F)
                    }
                    if (P.isRenderTexture = !0,
                    P.isAlphaPremultiplied = !1,
                    L.framebufferTexture2D(L.FRAMEBUFFER, L.COLOR_ATTACHMENT0, L.TEXTURE_2D, P, 0),
                    O = L.checkFramebufferStatus(L.FRAMEBUFFER),
                    O !== L.FRAMEBUFFER_COMPLETE) {
                        var B = {
                            36054: "Incomplete Attachment",
                            36055: "Missing Attachment",
                            36057: "Incomplete Dimensions",
                            36061: "Framebuffer Unsupported"
                        };
                        throw new Error("Framebuffer status: " + B[O])
                    }
                    return R.renderTexture = P,
                    this.setFramebuffer(null),
                    this.resetTextures(),
                    R
                },
                createProgram: function(T, E) {
                    var P = this.gl
                      , M = P.createProgram()
                      , L = P.createShader(P.VERTEX_SHADER)
                      , R = P.createShader(P.FRAGMENT_SHADER);
                    if (P.shaderSource(L, T),
                    P.shaderSource(R, E),
                    P.compileShader(L),
                    P.compileShader(R),
                    !P.getShaderParameter(L, P.COMPILE_STATUS))
                        throw new Error(`Vertex Shader failed:
` + P.getShaderInfoLog(L));
                    if (!P.getShaderParameter(R, P.COMPILE_STATUS))
                        throw new Error(`Fragment Shader failed:
` + P.getShaderInfoLog(R));
                    if (P.attachShader(M, L),
                    P.attachShader(M, R),
                    P.linkProgram(M),
                    !P.getProgramParameter(M, P.LINK_STATUS))
                        throw new Error(`Link Program failed:
` + P.getProgramInfoLog(M));
                    return P.useProgram(M),
                    M
                },
                createVertexBuffer: function(T, E) {
                    var P = this.gl
                      , M = P.createBuffer();
                    return P.bindBuffer(P.ARRAY_BUFFER, M),
                    P.bufferData(P.ARRAY_BUFFER, T, E),
                    P.bindBuffer(P.ARRAY_BUFFER, null),
                    M
                },
                createIndexBuffer: function(T, E) {
                    var P = this.gl
                      , M = P.createBuffer();
                    return P.bindBuffer(P.ELEMENT_ARRAY_BUFFER, M),
                    P.bufferData(P.ELEMENT_ARRAY_BUFFER, T, E),
                    P.bindBuffer(P.ELEMENT_ARRAY_BUFFER, null),
                    M
                },
                deleteTexture: function(T, E) {
                    return E && this.resetTextures(!0),
                    T && this.gl.deleteTexture(T),
                    this
                },
                deleteFramebuffer: function(T) {
                    return T && (this.gl.deleteFramebuffer(T),
                    e(this.fboStack, T),
                    this.currentFramebuffer === T && (this.currentFramebuffer = null)),
                    this
                },
                deleteProgram: function(T) {
                    return T && this.gl.deleteProgram(T),
                    this
                },
                deleteBuffer: function(T) {
                    return this.gl.deleteBuffer(T),
                    this
                },
                preRenderCamera: function(T) {
                    var E = T.x
                      , P = T.y
                      , M = T.width
                      , L = T.height
                      , R = T.backgroundColor;
                    if (T.emit(f.PRE_RENDER, T),
                    this.pipelines.preBatchCamera(T),
                    this.pushScissor(E, P, M, L),
                    T.mask && (this.currentCameraMask.mask = T.mask,
                    this.currentCameraMask.camera = T._maskCamera,
                    T.mask.preRenderWebGL(this, T, T._maskCamera)),
                    R.alphaGL > 0) {
                        var O = this.pipelines.setMulti();
                        O.drawFillRect(E, P, M, L, g.getTintFromFloats(R.blueGL, R.greenGL, R.redGL, 1), R.alphaGL)
                    }
                },
                getCurrentStencilMask: function() {
                    var T = null
                      , E = this.maskStack
                      , P = this.currentCameraMask;
                    return E.length > 0 ? T = E[E.length - 1] : P.mask && P.mask.isStencil && (T = P),
                    T
                },
                postRenderCamera: function(T) {
                    var E = T.flashEffect
                      , P = T.fadeEffect;
                    if (E.isRunning || P.isRunning || P.isComplete) {
                        var M = this.pipelines.setMulti();
                        E.postRenderWebGL(M, g.getTintFromFloats),
                        P.postRenderWebGL(M, g.getTintFromFloats)
                    }
                    T.dirty = !1,
                    this.popScissor(),
                    T.mask && (this.currentCameraMask.mask = null,
                    T.mask.postRenderWebGL(this, T._maskCamera)),
                    this.pipelines.postBatchCamera(T),
                    T.emit(f.POST_RENDER, T)
                },
                preRender: function() {
                    if (!this.contextLost) {
                        var T = this.gl;
                        if (T.bindFramebuffer(T.FRAMEBUFFER, null),
                        this.config.clearBeforeRender) {
                            var E = this.config.backgroundColor;
                            T.clearColor(E.redGL, E.greenGL, E.blueGL, E.alphaGL),
                            T.clear(T.COLOR_BUFFER_BIT | T.DEPTH_BUFFER_BIT | T.STENCIL_BUFFER_BIT)
                        }
                        T.enable(T.SCISSOR_TEST),
                        this.currentScissor = this.defaultScissor,
                        this.scissorStack.length = 0,
                        this.scissorStack.push(this.currentScissor),
                        this.game.scene.customViewports && T.scissor(0, this.drawingBufferHeight - this.height, this.width, this.height),
                        this.currentMask.mask = null,
                        this.currentCameraMask.mask = null,
                        this.maskStack.length = 0,
                        this.textureFlush = 0,
                        this.emit(n.PRE_RENDER)
                    }
                },
                render: function(T, E, P) {
                    if (!this.contextLost) {
                        var M = E.length;
                        if (this.emit(n.RENDER, T, P),
                        this.preRenderCamera(P),
                        M === 0) {
                            this.setBlendMode(o.BlendModes.NORMAL),
                            this.postRenderCamera(P);
                            return
                        }
                        this.currentType = "";
                        for (var L = this.currentMask, R = 0; R < M; R++) {
                            this.finalType = R === M - 1;
                            var O = E[R]
                              , F = O.mask;
                            L = this.currentMask,
                            L.mask && L.mask !== F && L.mask.postRenderWebGL(this, L.camera),
                            F && L.mask !== F && F.preRenderWebGL(this, O, P),
                            O.blendMode !== this.currentBlendMode && this.setBlendMode(O.blendMode);
                            var B = O.type;
                            B !== this.currentType && (this.newType = !0,
                            this.currentType = B),
                            this.finalType ? this.nextTypeMatch = !1 : this.nextTypeMatch = E[R + 1].type === this.currentType,
                            O.renderWebGL(this, O, P),
                            this.newType = !1
                        }
                        L = this.currentMask,
                        L.mask && L.mask.postRenderWebGL(this, L.camera),
                        this.setBlendMode(o.BlendModes.NORMAL),
                        this.postRenderCamera(P)
                    }
                },
                postRender: function() {
                    if (!this.contextLost) {
                        this.flush(),
                        this.emit(n.POST_RENDER);
                        var T = this.snapshotState;
                        T.callback && (m(this.canvas, T),
                        T.callback = null),
                        this.textureFlush > 0 && (this.startActiveTexture++,
                        this.currentActiveTexture = 1)
                    }
                },
                snapshot: function(T, E, P) {
                    return this.snapshotArea(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight, T, E, P)
                },
                snapshotArea: function(T, E, P, M, L, R, O) {
                    var F = this.snapshotState;
                    return F.callback = L,
                    F.type = R,
                    F.encoder = O,
                    F.getPixel = !1,
                    F.x = T,
                    F.y = E,
                    F.width = Math.min(P, this.gl.drawingBufferWidth),
                    F.height = Math.min(M, this.gl.drawingBufferHeight),
                    this
                },
                snapshotPixel: function(T, E, P) {
                    return this.snapshotArea(T, E, 1, 1, P),
                    this.snapshotState.getPixel = !0,
                    this
                },
                snapshotFramebuffer: function(T, E, P, M, L, R, O, F, B, N, Y) {
                    L === void 0 && (L = !1),
                    R === void 0 && (R = 0),
                    O === void 0 && (O = 0),
                    F === void 0 && (F = E),
                    B === void 0 && (B = P);
                    var z = this.currentFramebuffer;
                    this.snapshotArea(R, O, F, B, M, N, Y);
                    var W = this.snapshotState;
                    return W.getPixel = L,
                    W.isFramebuffer = !0,
                    W.bufferWidth = E,
                    W.bufferHeight = P,
                    this.setFramebuffer(T),
                    m(this.canvas, W),
                    this.setFramebuffer(z),
                    W.callback = null,
                    W.isFramebuffer = !1,
                    this
                },
                canvasToTexture: function(T, E, P, M) {
                    return P === void 0 && (P = !1),
                    M === void 0 && (M = !1),
                    E ? this.updateCanvasTexture(T, E, M) : this.createCanvasTexture(T, P, M)
                },
                createCanvasTexture: function(T, E, P) {
                    E === void 0 && (E = !1),
                    P === void 0 && (P = !1);
                    var M = this.gl
                      , L = M.NEAREST
                      , R = M.NEAREST
                      , O = T.width
                      , F = T.height
                      , B = M.CLAMP_TO_EDGE
                      , N = l(O, F);
                    return !E && N && (B = M.REPEAT),
                    this.config.antialias && (L = N ? this.mipmapFilter : M.LINEAR,
                    R = M.LINEAR),
                    this.createTexture2D(0, L, R, B, B, M.RGBA, T, O, F, !0, !1, P)
                },
                updateCanvasTexture: function(T, E, P) {
                    P === void 0 && (P = !1);
                    var M = this.gl
                      , L = T.width
                      , R = T.height;
                    if (L > 0 && R > 0) {
                        M.activeTexture(M.TEXTURE0);
                        var O = M.getParameter(M.TEXTURE_BINDING_2D);
                        M.bindTexture(M.TEXTURE_2D, E),
                        M.pixelStorei(M.UNPACK_FLIP_Y_WEBGL, P),
                        M.pixelStorei(M.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0),
                        M.texImage2D(M.TEXTURE_2D, 0, M.RGBA, M.RGBA, M.UNSIGNED_BYTE, T),
                        E.width = L,
                        E.height = R,
                        O && M.bindTexture(M.TEXTURE_2D, O)
                    }
                    return E
                },
                createVideoTexture: function(T, E, P) {
                    E === void 0 && (E = !1),
                    P === void 0 && (P = !1);
                    var M = this.gl
                      , L = M.NEAREST
                      , R = M.NEAREST
                      , O = T.videoWidth
                      , F = T.videoHeight
                      , B = M.CLAMP_TO_EDGE
                      , N = l(O, F);
                    return !E && N && (B = M.REPEAT),
                    this.config.antialias && (L = N ? this.mipmapFilter : M.LINEAR,
                    R = M.LINEAR),
                    this.createTexture2D(0, L, R, B, B, M.RGBA, T, O, F, !0, !0, P)
                },
                updateVideoTexture: function(T, E, P) {
                    P === void 0 && (P = !1);
                    var M = this.gl
                      , L = T.videoWidth
                      , R = T.videoHeight;
                    if (L > 0 && R > 0) {
                        M.activeTexture(M.TEXTURE0);
                        var O = M.getParameter(M.TEXTURE_BINDING_2D);
                        M.bindTexture(M.TEXTURE_2D, E),
                        M.pixelStorei(M.UNPACK_FLIP_Y_WEBGL, P),
                        M.texImage2D(M.TEXTURE_2D, 0, M.RGBA, M.RGBA, M.UNSIGNED_BYTE, T),
                        E.width = L,
                        E.height = R,
                        O && M.bindTexture(M.TEXTURE_2D, O)
                    }
                    return E
                },
                setTextureFilter: function(T, E) {
                    var P = this.gl
                      , M = [P.LINEAR, P.NEAREST][E];
                    P.activeTexture(P.TEXTURE0);
                    var L = P.getParameter(P.TEXTURE_BINDING_2D);
                    return P.bindTexture(P.TEXTURE_2D, T),
                    P.texParameteri(P.TEXTURE_2D, P.TEXTURE_MIN_FILTER, M),
                    P.texParameteri(P.TEXTURE_2D, P.TEXTURE_MAG_FILTER, M),
                    L && P.bindTexture(P.TEXTURE_2D, L),
                    this
                },
                getMaxTextureSize: function() {
                    return this.config.maxTextureSize
                },
                destroy: function() {
                    this.canvas.removeEventListener("webglcontextlost", this.contextLostHandler, !1),
                    this.canvas.removeEventListener("webglcontextrestored", this.contextRestoredHandler, !1);
                    for (var T = this.gl, E = this.tempTextures, P = 0; P < E.length; P++)
                        T.deleteTexture(E[P]);
                    this.pipelines.destroy(),
                    this.removeAllListeners(),
                    this.fboStack = [],
                    this.maskStack = [],
                    this.extensions = {},
                    this.textureIndexes = [],
                    this.gl = null,
                    this.game = null,
                    this.canvas = null,
                    this.contextLost = !0,
                    this.currentMask = null,
                    this.currentCameraMask = null
                }
            });
            c.exports = x
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(92)
              , r = t(102)
              , o = t(373)
              , a = t(376)
              , n = t(377)
              , s = t(108)
              , l = t(378)
              , i = t(379)
              , h = t(380)
              , u = t(381)
              , d = new e({
                initialize: function(p) {
                    this.game = p.game,
                    this.renderer = p,
                    this.classes = new r([[f.UTILITY_PIPELINE, u], [f.MULTI_PIPELINE, s], [f.BITMAPMASK_PIPELINE, o], [f.SINGLE_PIPELINE, h], [f.ROPE_PIPELINE, i], [f.LIGHT_PIPELINE, n], [f.POINTLIGHT_PIPELINE, l], [f.GRAPHICS_PIPELINE, a]]),
                    this.postPipelineClasses = new r,
                    this.pipelines = new r,
                    this.current = null,
                    this.previous = null,
                    this.MULTI_PIPELINE = null,
                    this.BITMAPMASK_PIPELINE = null,
                    this.UTILITY_PIPELINE = null,
                    this.fullFrame1,
                    this.fullFrame2,
                    this.halfFrame1,
                    this.halfFrame2
                },
                boot: function(v) {
                    var p, g, m = this, x = this.game;
                    if (this.classes.each(function(E, P) {
                        p = m.add(E, new P({
                            game: x
                        })),
                        E === f.UTILITY_PIPELINE && (m.UTILITY_PIPELINE = p,
                        m.fullFrame1 = p.fullFrame1,
                        m.fullFrame2 = p.fullFrame2,
                        m.halfFrame1 = p.halfFrame1,
                        m.halfFrame2 = p.halfFrame2)
                    }),
                    this.MULTI_PIPELINE = this.get(f.MULTI_PIPELINE),
                    this.BITMAPMASK_PIPELINE = this.get(f.BITMAPMASK_PIPELINE),
                    v)
                        for (g in v) {
                            var T = v[g];
                            p = new T(x),
                            p.isPostFX ? this.postPipelineClasses.set(g, T) : this.has(g) || (this.classes.set(g, T),
                            this.add(g, p))
                        }
                },
                add: function(v, p) {
                    if (p.isPostFX) {
                        console.warn(v + " is a Post Pipeline. Use `addPostPipeline` instead");
                        return
                    }
                    var g = this.pipelines
                      , m = this.renderer;
                    return g.has(v) ? console.warn("Pipeline exists: " + v) : (p.name = v,
                    p.manager = this,
                    g.set(v, p)),
                    p.hasBooted || p.boot(),
                    m.width !== 0 && m.height !== 0 && p.resize(m.width, m.height),
                    p
                },
                addPostPipeline: function(v, p) {
                    this.postPipelineClasses.has(v) || this.postPipelineClasses.set(v, p)
                },
                flush: function() {
                    this.current && this.current.flush()
                },
                has: function(v) {
                    var p = this.pipelines;
                    return typeof v == "string" ? p.has(v) : !!p.contains(v)
                },
                get: function(v) {
                    var p = this.pipelines;
                    if (typeof v == "string")
                        return p.get(v);
                    if (p.contains(v))
                        return v
                },
                getPostPipeline: function(v, p) {
                    var g = this.postPipelineClasses, m;
                    if (typeof v == "string" ? m = g.get(v) : typeof v == "function" ? g.contains(v) && (m = v) : typeof v == "object" && (m = g.get(v.name)),
                    m) {
                        var x = new m(this.game);
                        return p && (x.gameObject = p),
                        x
                    }
                },
                remove: function(v, p, g) {
                    p === void 0 && (p = !0),
                    g === void 0 && (g = !0),
                    this.pipelines.delete(v),
                    p && this.classes.delete(v),
                    g && this.postPipelineClasses.delete(v)
                },
                set: function(v, p, g) {
                    if (!v.isPostFX)
                        return this.isCurrent(v, g) || (this.flush(),
                        this.current && this.current.unbind(),
                        this.current = v,
                        v.bind(g)),
                        v.updateProjectionMatrix(),
                        v.onBind(p),
                        v
                },
                preBatch: function(v) {
                    if (v.hasPostPipeline) {
                        this.flush();
                        for (var p = v.postPipelines, g = p.length - 1; g >= 0; g--) {
                            var m = p[g];
                            m.active && m.preBatch(v)
                        }
                    }
                },
                postBatch: function(v) {
                    if (v.hasPostPipeline) {
                        this.flush();
                        for (var p = v.postPipelines, g = 0; g < p.length; g++) {
                            var m = p[g];
                            m.active && m.postBatch(v)
                        }
                    }
                },
                preBatchCamera: function(v) {
                    if (v.hasPostPipeline) {
                        this.flush();
                        for (var p = v.postPipelines, g = p.length - 1; g >= 0; g--) {
                            var m = p[g];
                            m.active && m.preBatch(v)
                        }
                    }
                },
                postBatchCamera: function(v) {
                    if (v.hasPostPipeline) {
                        this.flush();
                        for (var p = v.postPipelines, g = 0; g < p.length; g++) {
                            var m = p[g];
                            m.active && m.postBatch(v)
                        }
                    }
                },
                isCurrent: function(v, p) {
                    var g = this.renderer
                      , m = this.current;
                    return m && !p && (p = m.currentShader),
                    !(m !== v || p.program !== g.currentProgram)
                },
                copyFrame: function(v, p, g, m, x) {
                    return this.setUtility(this.UTILITY_PIPELINE.copyShader).copyFrame(v, p, g, m, x),
                    this
                },
                copyToGame: function(v) {
                    return this.setUtility(this.UTILITY_PIPELINE.copyShader).copyToGame(v),
                    this
                },
                drawFrame: function(v, p, g, m) {
                    return this.setUtility(this.UTILITY_PIPELINE.colorMatrixShader).drawFrame(v, p, g, m),
                    this
                },
                blendFrames: function(v, p, g, m, x) {
                    return this.setUtility(this.UTILITY_PIPELINE.linearShader).blendFrames(v, p, g, m, x),
                    this
                },
                blendFramesAdditive: function(v, p, g, m, x) {
                    return this.setUtility(this.UTILITY_PIPELINE.addShader).blendFramesAdditive(v, p, g, m, x),
                    this
                },
                clearFrame: function(v, p) {
                    return this.UTILITY_PIPELINE.clearFrame(v, p),
                    this
                },
                blitFrame: function(v, p, g, m, x, T) {
                    return this.setUtility(this.UTILITY_PIPELINE.copyShader).blitFrame(v, p, g, m, x, T),
                    this
                },
                copyFrameRect: function(v, p, g, m, x, T, E, P) {
                    return this.UTILITY_PIPELINE.copyFrameRect(v, p, g, m, x, T, E, P),
                    this
                },
                forceZero: function() {
                    return this.current && this.current.forceZero
                },
                setMulti: function() {
                    return this.set(this.MULTI_PIPELINE)
                },
                setUtility: function(v) {
                    return this.UTILITY_PIPELINE.bind(v)
                },
                rebind: function(v) {
                    v === void 0 && this.previous && (v = this.previous);
                    var p = this.renderer
                      , g = p.gl;
                    g.disable(g.DEPTH_TEST),
                    g.disable(g.CULL_FACE),
                    p.hasActiveStencilMask() ? g.clear(g.DEPTH_BUFFER_BIT) : (g.disable(g.STENCIL_TEST),
                    g.clear(g.DEPTH_BUFFER_BIT | g.STENCIL_BUFFER_BIT)),
                    g.viewport(0, 0, p.width, p.height),
                    p.currentProgram = null,
                    p.setBlendMode(0, !0);
                    var m = this.pipelines.entries;
                    for (var x in m)
                        m[x].glReset = !0;
                    v && (this.current = v,
                    v.rebind()),
                    p.resetTextures()
                },
                clear: function() {
                    var v = this.renderer;
                    this.flush(),
                    this.current ? (this.current.unbind(),
                    this.previous = this.current,
                    this.current = null) : this.previous = null,
                    v.currentProgram = null,
                    v.setBlendMode(0, !0)
                },
                destroy: function() {
                    this.flush(),
                    this.classes.clear(),
                    this.postPipelineClasses.clear(),
                    this.pipelines.clear(),
                    this.renderer = null,
                    this.game = null,
                    this.classes = null,
                    this.postPipelineClasses = null,
                    this.pipelines = null,
                    this.current = null,
                    this.previous = null
                }
            });
            c.exports = d
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(2)
              , r = t(866)
              , o = t(867)
              , a = t(107)
              , n = t(58)
              , s = new e({
                Extends: n,
                initialize: function(i) {
                    i.fragShader = f(i, "fragShader", r),
                    i.vertShader = f(i, "vertShader", o),
                    i.batchSize = f(i, "batchSize", 1),
                    i.vertices = f(i, "vertices", [-1, 1, -1, -7, 7, 1]),
                    i.attributes = f(i, "attributes", [{
                        name: "inPosition",
                        size: 2,
                        type: a.FLOAT
                    }]),
                    n.call(this, i)
                },
                boot: function() {
                    n.prototype.boot.call(this),
                    this.set1i("uMainSampler", 0),
                    this.set1i("uMaskSampler", 1)
                },
                resize: function(l, i) {
                    n.prototype.resize.call(this, l, i),
                    this.set2f("uResolution", l, i)
                },
                beginMask: function(l, i, h) {
                    var u = this.gl;
                    if (l.bitmapMask && u) {
                        var d = this.renderer;
                        d.flush(),
                        d.pushFramebuffer(l.mainFramebuffer),
                        u.disable(u.STENCIL_TEST),
                        u.clearColor(0, 0, 0, 0),
                        u.clear(u.COLOR_BUFFER_BIT),
                        d.currentCameraMask.mask !== l && (d.currentMask.mask = l,
                        d.currentMask.camera = h)
                    }
                },
                endMask: function(l, i) {
                    var h = this.gl
                      , u = this.renderer
                      , d = l.bitmapMask;
                    if (d && h) {
                        u.flush(),
                        u.pushFramebuffer(l.maskFramebuffer),
                        h.clearColor(0, 0, 0, 0),
                        h.clear(h.COLOR_BUFFER_BIT),
                        u.setBlendMode(0, !0),
                        d.renderWebGL(u, d, i),
                        u.flush(),
                        u.popFramebuffer(),
                        u.popFramebuffer();
                        var v = u.getCurrentStencilMask();
                        v ? (h.enable(h.STENCIL_TEST),
                        v.mask.applyStencil(u, v.camera, !0)) : u.currentMask.mask = null,
                        u.pipelines.set(this),
                        h.activeTexture(h.TEXTURE1),
                        h.bindTexture(h.TEXTURE_2D, l.maskTexture),
                        h.activeTexture(h.TEXTURE0),
                        h.bindTexture(h.TEXTURE_2D, l.mainTexture),
                        this.set1i("uInvertMaskAlpha", l.invertAlpha),
                        h.drawArrays(this.topology, 0, 3),
                        u.resetTextures()
                    }
                }
            });
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                AFTER_FLUSH: t(868),
                BEFORE_FLUSH: t(869),
                BIND: t(870),
                BOOT: t(871),
                DESTROY: t(872),
                REBIND: t(873),
                RESIZE: t(874)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(2)
              , r = t(107)
              , o = new e({
                initialize: function(n, s, l, i, h) {
                    this.pipeline = n,
                    this.name = s,
                    this.renderer = n.renderer,
                    this.gl = this.renderer.gl,
                    this.program = this.renderer.createProgram(l, i),
                    this.attributes,
                    this.vertexComponentCount = 0,
                    this.vertexSize = 0,
                    this.uniforms = {},
                    this.createAttributes(h),
                    this.createUniforms()
                },
                createAttributes: function(a) {
                    var n = 0
                      , s = 0
                      , l = [];
                    this.vertexComponentCount = 0;
                    for (var i = 0; i < a.length; i++) {
                        var h = a[i]
                          , u = h.name
                          , d = f(h, "size", 1)
                          , v = f(h, "type", r.FLOAT)
                          , p = v.enum
                          , g = v.size
                          , m = !!h.normalized;
                        l.push({
                            name: u,
                            size: d,
                            type: p,
                            normalized: m,
                            offset: s,
                            enabled: !1,
                            location: -1
                        }),
                        g === 4 ? n += d : n++,
                        s += d * g
                    }
                    this.vertexSize = s,
                    this.vertexComponentCount = n,
                    this.attributes = l
                },
                bind: function(a, n) {
                    return a === void 0 && (a = !1),
                    n === void 0 && (n = !1),
                    n && this.pipeline.flush(),
                    this.renderer.setProgram(this.program),
                    a && this.setAttribPointers(),
                    this
                },
                rebind: function() {
                    return this.renderer.setProgram(this.program),
                    this.setAttribPointers(!0),
                    this
                },
                setAttribPointers: function(a) {
                    a === void 0 && (a = !1);
                    for (var n = this.gl, s = this.vertexSize, l = this.attributes, i = this.program, h = 0; h < l.length; h++) {
                        var u = l[h]
                          , d = u.size
                          , v = u.type
                          , p = u.offset
                          , g = u.enabled
                          , m = u.location
                          , x = !!u.normalized;
                        if (a) {
                            var T = n.getAttribLocation(i, u.name);
                            T >= 0 ? (n.enableVertexAttribArray(T),
                            n.vertexAttribPointer(T, d, v, x, s, p),
                            u.enabled = !0,
                            u.location = T) : T !== -1 && n.disableVertexAttribArray(T)
                        } else
                            g ? n.vertexAttribPointer(m, d, v, x, s, p) : !g && m > -1 && (n.disableVertexAttribArray(m),
                            u.location = -1)
                    }
                    return this
                },
                createUniforms: function() {
                    var a = this.gl, n = this.program, s = this.uniforms, l, i, h, u = a.getProgramParameter(n, a.ACTIVE_UNIFORMS);
                    for (l = 0; l < u; l++) {
                        var d = a.getActiveUniform(n, l);
                        if (d) {
                            i = d.name,
                            h = a.getUniformLocation(n, i),
                            h !== null && (s[i] = {
                                name: i,
                                location: h,
                                value1: null,
                                value2: null,
                                value3: null,
                                value4: null
                            });
                            var v = i.indexOf("[");
                            v > 0 && (i = i.substr(0, v),
                            s.hasOwnProperty(i) || (h = a.getUniformLocation(n, i),
                            h !== null && (s[i] = {
                                name: i,
                                location: h,
                                value1: null,
                                value2: null,
                                value3: null,
                                value4: null
                            })))
                        }
                    }
                    return this
                },
                hasUniform: function(a) {
                    return this.uniforms.hasOwnProperty(a)
                },
                resetUniform: function(a) {
                    var n = this.uniforms[a];
                    return n && (n.value1 = null,
                    n.value2 = null,
                    n.value3 = null,
                    n.value4 = null),
                    this
                },
                setUniform1: function(a, n, s, l) {
                    var i = this.uniforms[n];
                    return i ? ((l || i.value1 !== s) && (i.value1 = s,
                    this.renderer.setProgram(this.program),
                    a.call(this.gl, i.location, s),
                    this.pipeline.currentShader = this),
                    this) : this
                },
                setUniform2: function(a, n, s, l, i) {
                    var h = this.uniforms[n];
                    return h ? ((i || h.value1 !== s || h.value2 !== l) && (h.value1 = s,
                    h.value2 = l,
                    this.renderer.setProgram(this.program),
                    a.call(this.gl, h.location, s, l),
                    this.pipeline.currentShader = this),
                    this) : this
                },
                setUniform3: function(a, n, s, l, i, h) {
                    var u = this.uniforms[n];
                    return u ? ((h || u.value1 !== s || u.value2 !== l || u.value3 !== i) && (u.value1 = s,
                    u.value2 = l,
                    u.value3 = i,
                    this.renderer.setProgram(this.program),
                    a.call(this.gl, u.location, s, l, i),
                    this.pipeline.currentShader = this),
                    this) : this
                },
                setUniform4: function(a, n, s, l, i, h, u) {
                    var d = this.uniforms[n];
                    return d ? ((u || d.value1 !== s || d.value2 !== l || d.value3 !== i || d.value4 !== h) && (d.value1 = s,
                    d.value2 = l,
                    d.value3 = i,
                    d.value4 = h,
                    this.renderer.setProgram(this.program),
                    a.call(this.gl, d.location, s, l, i, h),
                    this.pipeline.currentShader = this),
                    this) : this
                },
                set1f: function(a, n) {
                    return this.setUniform1(this.gl.uniform1f, a, n)
                },
                set2f: function(a, n, s) {
                    return this.setUniform2(this.gl.uniform2f, a, n, s)
                },
                set3f: function(a, n, s, l) {
                    return this.setUniform3(this.gl.uniform3f, a, n, s, l)
                },
                set4f: function(a, n, s, l, i) {
                    return this.setUniform4(this.gl.uniform4f, a, n, s, l, i)
                },
                set1fv: function(a, n) {
                    return this.setUniform1(this.gl.uniform1fv, a, n, !0)
                },
                set2fv: function(a, n) {
                    return this.setUniform1(this.gl.uniform2fv, a, n, !0)
                },
                set3fv: function(a, n) {
                    return this.setUniform1(this.gl.uniform3fv, a, n, !0)
                },
                set4fv: function(a, n) {
                    return this.setUniform1(this.gl.uniform4fv, a, n, !0)
                },
                set1iv: function(a, n) {
                    return this.setUniform1(this.gl.uniform1iv, a, n, !0)
                },
                set2iv: function(a, n) {
                    return this.setUniform1(this.gl.uniform2iv, a, n, !0)
                },
                set3iv: function(a, n) {
                    return this.setUniform1(this.gl.uniform3iv, a, n, !0)
                },
                set4iv: function(a, n) {
                    return this.setUniform1(this.gl.uniform4iv, a, n, !0)
                },
                set1i: function(a, n) {
                    return this.setUniform1(this.gl.uniform1i, a, n)
                },
                set2i: function(a, n, s) {
                    return this.setUniform2(this.gl.uniform2i, a, n, s)
                },
                set3i: function(a, n, s, l) {
                    return this.setUniform3(this.gl.uniform3i, a, n, s, l)
                },
                set4i: function(a, n, s, l, i) {
                    return this.setUniform4(this.gl.uniform4i, a, n, s, l, i)
                },
                setMatrix2fv: function(a, n, s) {
                    return this.setUniform2(this.gl.uniformMatrix2fv, a, n, s, !0)
                },
                setMatrix3fv: function(a, n, s) {
                    return this.setUniform2(this.gl.uniformMatrix3fv, a, n, s, !0)
                },
                setMatrix4fv: function(a, n, s) {
                    return this.setUniform2(this.gl.uniformMatrix4fv, a, n, s, !0)
                },
                destroy: function() {
                    this.gl.deleteProgram(this.program),
                    this.pipeline = null,
                    this.renderer = null,
                    this.gl = null,
                    this.program = null,
                    this.attributes = null,
                    this.uniforms = null
                }
            });
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(59)
              , r = t(2)
              , o = t(875)
              , a = t(876)
              , n = t(25)
              , s = t(107)
              , l = t(58)
              , i = new e({
                Extends: l,
                initialize: function(u) {
                    u.fragShader = r(u, "fragShader", o),
                    u.vertShader = r(u, "vertShader", a),
                    u.attributes = r(u, "attributes", [{
                        name: "inPosition",
                        size: 2
                    }, {
                        name: "inColor",
                        size: 4,
                        type: s.UNSIGNED_BYTE,
                        normalized: !0
                    }]),
                    l.call(this, u),
                    this.calcMatrix = new n,
                    this.tempTriangle = [{
                        x: 0,
                        y: 0,
                        width: 0
                    }, {
                        x: 0,
                        y: 0,
                        width: 0
                    }, {
                        x: 0,
                        y: 0,
                        width: 0
                    }, {
                        x: 0,
                        y: 0,
                        width: 0
                    }],
                    this.strokeTint = {
                        TL: 0,
                        TR: 0,
                        BL: 0,
                        BR: 0
                    },
                    this.fillTint = {
                        TL: 0,
                        TR: 0,
                        BL: 0,
                        BR: 0
                    },
                    this.currentFrame = {
                        u0: 0,
                        v0: 0,
                        u1: 1,
                        v1: 1
                    },
                    this.firstQuad = [0, 0, 0, 0, 0],
                    this.prevQuad = [0, 0, 0, 0, 0],
                    this.polygonCache = []
                },
                batchFillRect: function(h, u, d, v, p, g) {
                    this.renderer.pipelines.set(this);
                    var m = this.calcMatrix;
                    g && g.multiply(p, m);
                    var x = h + d
                      , T = u + v
                      , E = m.getX(h, u)
                      , P = m.getY(h, u)
                      , M = m.getX(h, T)
                      , L = m.getY(h, T)
                      , R = m.getX(x, T)
                      , O = m.getY(x, T)
                      , F = m.getX(x, u)
                      , B = m.getY(x, u)
                      , N = this.fillTint;
                    this.batchQuad(E, P, M, L, R, O, F, B, N.TL, N.TR, N.BL, N.BR)
                },
                batchFillTriangle: function(h, u, d, v, p, g, m, x) {
                    this.renderer.pipelines.set(this);
                    var T = this.calcMatrix;
                    x && x.multiply(m, T);
                    var E = T.getX(h, u)
                      , P = T.getY(h, u)
                      , M = T.getX(d, v)
                      , L = T.getY(d, v)
                      , R = T.getX(p, g)
                      , O = T.getY(p, g)
                      , F = this.fillTint;
                    this.batchTri(E, P, M, L, R, O, F.TL, F.TR, F.BL)
                },
                batchStrokeTriangle: function(h, u, d, v, p, g, m, x, T) {
                    var E = this.tempTriangle;
                    E[0].x = h,
                    E[0].y = u,
                    E[0].width = m,
                    E[1].x = d,
                    E[1].y = v,
                    E[1].width = m,
                    E[2].x = p,
                    E[2].y = g,
                    E[2].width = m,
                    E[3].x = h,
                    E[3].y = u,
                    E[3].width = m,
                    this.batchStrokePath(E, m, !1, x, T)
                },
                batchFillPath: function(h, u, d) {
                    this.renderer.pipelines.set(this);
                    var v = this.calcMatrix;
                    d && d.multiply(u, v);
                    for (var p = h.length, g = this.polygonCache, m, x, T = this.fillTint.TL, E = this.fillTint.TR, P = this.fillTint.BL, M = 0; M < p; ++M)
                        x = h[M],
                        g.push(x.x, x.y);
                    m = f(g),
                    p = m.length;
                    for (var L = 0; L < p; L += 3) {
                        var R = m[L + 0] * 2
                          , O = m[L + 1] * 2
                          , F = m[L + 2] * 2
                          , B = g[R + 0]
                          , N = g[R + 1]
                          , Y = g[O + 0]
                          , z = g[O + 1]
                          , W = g[F + 0]
                          , b = g[F + 1]
                          , D = v.getX(B, N)
                          , I = v.getY(B, N)
                          , G = v.getX(Y, z)
                          , w = v.getY(Y, z)
                          , U = v.getX(W, b)
                          , X = v.getY(W, b);
                        this.batchTri(D, I, G, w, U, X, T, E, P)
                    }
                    g.length = 0
                },
                batchStrokePath: function(h, u, d, v, p) {
                    this.renderer.pipelines.set(this),
                    this.prevQuad[4] = 0,
                    this.firstQuad[4] = 0;
                    for (var g = h.length - 1, m = 0; m < g; m++) {
                        var x = h[m]
                          , T = h[m + 1];
                        this.batchLine(x.x, x.y, T.x, T.y, x.width / 2, T.width / 2, u, m, !d && m === g - 1, v, p)
                    }
                },
                batchLine: function(h, u, d, v, p, g, m, x, T, E, P) {
                    this.renderer.pipelines.set(this);
                    var M = this.calcMatrix;
                    P && P.multiply(E, M);
                    var L = d - h
                      , R = v - u
                      , O = Math.sqrt(L * L + R * R)
                      , F = p * (v - u) / O
                      , B = p * (h - d) / O
                      , N = g * (v - u) / O
                      , Y = g * (h - d) / O
                      , z = d - N
                      , W = v - Y
                      , b = h - F
                      , D = u - B
                      , I = d + N
                      , G = v + Y
                      , w = h + F
                      , U = u + B
                      , X = M.getX(z, W)
                      , V = M.getY(z, W)
                      , H = M.getX(b, D)
                      , J = M.getY(b, D)
                      , $ = M.getX(I, G)
                      , _ = M.getY(I, G)
                      , nt = M.getX(w, U)
                      , K = M.getY(w, U)
                      , Z = this.strokeTint
                      , j = Z.TL
                      , Q = Z.TR
                      , tt = Z.BL
                      , et = Z.BR;
                    if (this.batchQuad(nt, K, H, J, X, V, $, _, j, Q, tt, et),
                    !(m <= 2)) {
                        var it = this.prevQuad
                          , k = this.firstQuad;
                        x > 0 && it[4] ? this.batchQuad(nt, K, H, J, it[0], it[1], it[2], it[3], j, Q, tt, et) : (k[0] = nt,
                        k[1] = K,
                        k[2] = H,
                        k[3] = J,
                        k[4] = 1),
                        T && k[4] ? this.batchQuad(X, V, $, _, k[0], k[1], k[2], k[3], j, Q, tt, et) : (it[0] = X,
                        it[1] = V,
                        it[2] = $,
                        it[3] = _,
                        it[4] = 1)
                    }
                },
                batchVert: function(h, u, d) {
                    var v = this.vertexViewF32
                      , p = this.vertexViewU32
                      , g = this.vertexCount * this.currentShader.vertexComponentCount - 1;
                    v[++g] = h,
                    v[++g] = u,
                    p[++g] = d,
                    this.vertexCount++
                },
                batchQuad: function(h, u, d, v, p, g, m, x, T, E, P, M) {
                    var L = !1;
                    return this.shouldFlush(6) && (this.flush(),
                    L = !0),
                    this.batchVert(h, u, T),
                    this.batchVert(d, v, P),
                    this.batchVert(p, g, M),
                    this.batchVert(h, u, T),
                    this.batchVert(p, g, M),
                    this.batchVert(m, x, E),
                    L
                },
                batchTri: function(h, u, d, v, p, g, m, x, T) {
                    var E = !1;
                    return this.shouldFlush(3) && (this.flush(),
                    E = !0),
                    this.batchVert(h, u, m),
                    this.batchVert(d, v, x),
                    this.batchVert(p, g, T),
                    E
                },
                destroy: function() {
                    return l.prototype.destroy.call(this),
                    this.polygonCache = null,
                    this
                }
            });
            c.exports = i
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(2)
              , r = t(877)
              , o = t(108)
              , a = t(3)
              , n = t(58)
              , s = 10
              , l = new a
              , i = new e({
                Extends: o,
                initialize: function(u) {
                    s = u.game.renderer.config.maxLights;
                    for (var d = f(u, "fragShader", r), v = [], p = 1; p <= s; p++)
                        v.push({
                            name: "lights" + p,
                            fragShader: d.replace("%LIGHT_COUNT%", p.toString())
                        });
                    u.shaders = v,
                    o.call(this, u),
                    this.inverseRotationMatrix = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]),
                    this.defaultNormalMap,
                    this.lightsActive = !0
                },
                boot: function() {
                    n.prototype.boot.call(this);
                    var h = this.gl
                      , u = h.createTexture();
                    h.activeTexture(h.TEXTURE0),
                    h.bindTexture(h.TEXTURE_2D, u),
                    h.texImage2D(h.TEXTURE_2D, 0, h.RGBA, 1, 1, 0, h.RGBA, h.UNSIGNED_BYTE, new Uint8Array([127, 127, 255, 255])),
                    this.defaultNormalMap = {
                        glTexture: u
                    };
                    for (var d = 0; d < this.shaders.length; d++)
                        this["lightShader" + (d + 1)] = this.shaders[d]
                },
                onRender: function(h, u) {
                    var d = h.sys.lights;
                    if (this.lightsActive = !1,
                    !(!d || !d.active)) {
                        var v = d.getLights(u)
                          , p = v.length;
                        if (p !== 0) {
                            this.lightsActive = !0,
                            this.setShader(this["lightShader" + p], !0);
                            var g, m = this.renderer, x = m.height, T = u.matrix;
                            for (this.set1i("uMainSampler", 0),
                            this.set1i("uNormSampler", 1),
                            this.set2f("uResolution", this.width / 2, this.height / 2),
                            this.set4f("uCamera", u.x, u.y, u.rotation, u.zoom),
                            this.set3f("uAmbientLightColor", d.ambientColor.r, d.ambientColor.g, d.ambientColor.b),
                            g = 0; g < p; g++) {
                                var E = v[g].light
                                  , P = E.color
                                  , M = "uLights[" + g + "].";
                                T.transformPoint(E.x, E.y, l),
                                this.set2f(M + "position", l.x - u.scrollX * E.scrollFactorX * u.zoom, x - (l.y - u.scrollY * E.scrollFactorY * u.zoom)),
                                this.set3f(M + "color", P.r, P.g, P.b),
                                this.set1f(M + "intensity", E.intensity),
                                this.set1f(M + "radius", E.radius)
                            }
                            this.currentNormalMapRotation = null
                        }
                    }
                },
                setNormalMapRotation: function(h) {
                    if (h !== this.currentNormalMapRotation || this.vertexCount === 0) {
                        this.vertexCount > 0 && this.flush();
                        var u = this.inverseRotationMatrix;
                        if (h) {
                            var d = -h
                              , v = Math.cos(d)
                              , p = Math.sin(d);
                            u[1] = p,
                            u[3] = -p,
                            u[0] = u[4] = v
                        } else
                            u[0] = u[4] = 1,
                            u[1] = u[3] = 0;
                        this.setMatrix3fv("uInverseRotationMatrix", !1, u),
                        this.currentNormalMapRotation = h
                    }
                },
                setTexture2D: function(h, u) {
                    var d = this.renderer;
                    h === void 0 && (h = d.tempTextures[0]);
                    var v = this.getNormalMap(u);
                    d.isNewNormalMap(h, v) && (this.flush(),
                    d.setTextureZero(h),
                    d.setNormalMap(v));
                    var p = u ? u.rotation : 0;
                    return this.setNormalMapRotation(p),
                    this.currentUnit = 0,
                    0
                },
                setGameObject: function(h, u) {
                    u === void 0 && (u = h.frame);
                    var d = this.renderer
                      , v = u.glTexture
                      , p = this.getNormalMap(h);
                    return d.isNewNormalMap() && (this.flush(),
                    d.setTextureZero(v),
                    d.setNormalMap(p)),
                    this.setNormalMapRotation(h.rotation),
                    this.currentUnit = 0,
                    0
                },
                getNormalMap: function(h) {
                    var u;
                    return h ? h.displayTexture ? u = h.displayTexture.dataSource[h.displayFrame.sourceIndex] : h.texture ? u = h.texture.dataSource[h.frame.sourceIndex] : h.tileset && (Array.isArray(h.tileset) ? u = h.tileset[0].image.dataSource[0] : u = h.tileset.image.dataSource[0]) : u = this.defaultNormalMap,
                    u || (u = this.defaultNormalMap),
                    u.glTexture
                },
                batchSprite: function(h, u, d) {
                    this.lightsActive && o.prototype.batchSprite.call(this, h, u, d)
                },
                batchTexture: function(h, u, d, v, p, g, m, x, T, E, P, M, L, R, O, F, B, N, Y, z, W, b, D, I, G, w, U, X, V, H, J, $) {
                    this.lightsActive && o.prototype.batchTexture.call(this, h, u, d, v, p, g, m, x, T, E, P, M, L, R, O, F, B, N, Y, z, W, b, D, I, G, w, U, X, V, H, J, $)
                },
                batchTextureFrame: function(h, u, d, v, p, g, m) {
                    this.lightsActive && o.prototype.batchTextureFrame.call(this, h, u, d, v, p, g, m)
                }
            });
            i.LIGHT_COUNT = s,
            c.exports = i
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(2)
              , r = t(880)
              , o = t(881)
              , a = t(58)
              , n = new e({
                Extends: a,
                initialize: function(l) {
                    l.vertShader = f(l, "vertShader", o),
                    l.fragShader = f(l, "fragShader", r),
                    l.attributes = f(l, "attributes", [{
                        name: "inPosition",
                        size: 2
                    }, {
                        name: "inLightPosition",
                        size: 2
                    }, {
                        name: "inLightRadius"
                    }, {
                        name: "inLightAttenuation"
                    }, {
                        name: "inLightColor",
                        size: 4
                    }]),
                    a.call(this, l)
                },
                onRender: function(s, l) {
                    this.set2f("uResolution", this.width, this.height),
                    this.set1f("uCameraZoom", l.zoom)
                },
                batchPointLight: function(s, l, i, h, u, d, v, p, g, m, x, T) {
                    var E = s.color
                      , P = s.intensity
                      , M = s.radius
                      , L = s.attenuation
                      , R = E.r * P
                      , O = E.g * P
                      , F = E.b * P
                      , B = l.alpha * s.alpha;
                    this.shouldFlush(6) && this.flush(),
                    this.batchLightVert(i, h, x, T, M, L, R, O, F, B),
                    this.batchLightVert(u, d, x, T, M, L, R, O, F, B),
                    this.batchLightVert(v, p, x, T, M, L, R, O, F, B),
                    this.batchLightVert(i, h, x, T, M, L, R, O, F, B),
                    this.batchLightVert(v, p, x, T, M, L, R, O, F, B),
                    this.batchLightVert(g, m, x, T, M, L, R, O, F, B)
                },
                batchLightVert: function(s, l, i, h, u, d, v, p, g, m) {
                    var x = this.vertexViewF32
                      , T = this.vertexCount * this.currentShader.vertexComponentCount - 1;
                    x[++T] = s,
                    x[++T] = l,
                    x[++T] = i,
                    x[++T] = h,
                    x[++T] = u,
                    x[++T] = d,
                    x[++T] = v,
                    x[++T] = p,
                    x[++T] = g,
                    x[++T] = m,
                    this.vertexCount++
                }
            });
            c.exports = n
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(2)
              , r = t(108)
              , o = new e({
                Extends: r,
                initialize: function(n) {
                    n.topology = 5,
                    n.batchSize = f(n, "batchSize", 256),
                    r.call(this, n)
                }
            });
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(2)
              , r = t(108)
              , o = t(882)
              , a = t(883)
              , n = t(58)
              , s = new e({
                Extends: r,
                initialize: function(i) {
                    i.fragShader = f(i, "fragShader", o),
                    i.vertShader = f(i, "vertShader", a),
                    i.forceZero = !0,
                    r.call(this, i)
                },
                boot: function() {
                    n.prototype.boot.call(this),
                    this.set1i("uMainSampler", 0)
                }
            });
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(884)
              , f = t(35)
              , r = t(0)
              , o = t(198)
              , a = t(885)
              , n = t(886)
              , s = t(2)
              , l = t(887)
              , i = t(382)
              , h = t(58)
              , u = new r({
                Extends: h,
                initialize: function(v) {
                    v.renderTarget = s(v, "renderTarget", [{
                        scale: 1
                    }, {
                        scale: 1
                    }, {
                        scale: .5
                    }, {
                        scale: .5
                    }]),
                    v.vertShader = s(v, "vertShader", i),
                    v.shaders = s(v, "shaders", [{
                        name: "Copy",
                        fragShader: n
                    }, {
                        name: "AddBlend",
                        fragShader: e
                    }, {
                        name: "LinearBlend",
                        fragShader: l
                    }, {
                        name: "ColorMatrix",
                        fragShader: a
                    }]),
                    v.attributes = s(v, "attributes", [{
                        name: "inPosition",
                        size: 2
                    }, {
                        name: "inTexCoord",
                        size: 2
                    }]),
                    v.vertices = [-1, -1, 0, 0, -1, 1, 0, 1, 1, 1, 1, 1, -1, -1, 0, 0, 1, 1, 1, 1, 1, -1, 1, 0],
                    v.batchSize = 1,
                    h.call(this, v),
                    this.colorMatrix = new o,
                    this.copyShader,
                    this.addShader,
                    this.linearShader,
                    this.colorMatrixShader,
                    this.fullFrame1,
                    this.fullFrame2,
                    this.halfFrame1,
                    this.halfFrame2
                },
                boot: function() {
                    h.prototype.boot.call(this);
                    var d = this.shaders
                      , v = this.renderTargets;
                    this.copyShader = d[0],
                    this.addShader = d[1],
                    this.linearShader = d[2],
                    this.colorMatrixShader = d[3],
                    this.fullFrame1 = v[0],
                    this.fullFrame2 = v[1],
                    this.halfFrame1 = v[2],
                    this.halfFrame2 = v[3]
                },
                copyFrame: function(d, v, p, g, m) {
                    p === void 0 && (p = 1),
                    g === void 0 && (g = !0),
                    m === void 0 && (m = !0);
                    var x = this.gl;
                    this.setShader(this.copyShader),
                    this.set1i("uMainSampler", 0),
                    this.set1f("uBrightness", p),
                    x.activeTexture(x.TEXTURE0),
                    x.bindTexture(x.TEXTURE_2D, d.texture),
                    v ? (x.viewport(0, 0, v.width, v.height),
                    x.bindFramebuffer(x.FRAMEBUFFER, v.framebuffer),
                    x.framebufferTexture2D(x.FRAMEBUFFER, x.COLOR_ATTACHMENT0, x.TEXTURE_2D, v.texture, 0)) : x.viewport(0, 0, d.width, d.height),
                    g && (m ? x.clearColor(0, 0, 0, 0) : x.clearColor(0, 0, 0, 1),
                    x.clear(x.COLOR_BUFFER_BIT)),
                    x.bufferData(x.ARRAY_BUFFER, this.vertexData, x.STATIC_DRAW),
                    x.drawArrays(x.TRIANGLES, 0, 6),
                    x.bindFramebuffer(x.FRAMEBUFFER, null),
                    x.bindTexture(x.TEXTURE_2D, null)
                },
                blitFrame: function(d, v, p, g, m, x) {
                    p === void 0 && (p = 1),
                    g === void 0 && (g = !0),
                    m === void 0 && (m = !0),
                    x === void 0 && (x = !1);
                    var T = this.gl;
                    if (this.setShader(this.copyShader),
                    this.set1i("uMainSampler", 0),
                    this.set1f("uBrightness", p),
                    T.activeTexture(T.TEXTURE0),
                    T.bindTexture(T.TEXTURE_2D, d.texture),
                    d.height > v.height)
                        T.viewport(0, 0, d.width, d.height),
                        this.setTargetUVs(d, v);
                    else {
                        var E = v.height - d.height;
                        T.viewport(0, E, d.width, d.height)
                    }
                    if (T.bindFramebuffer(T.FRAMEBUFFER, v.framebuffer),
                    T.framebufferTexture2D(T.FRAMEBUFFER, T.COLOR_ATTACHMENT0, T.TEXTURE_2D, v.texture, 0),
                    g && (m ? T.clearColor(0, 0, 0, 0) : T.clearColor(0, 0, 0, 1),
                    T.clear(T.COLOR_BUFFER_BIT)),
                    x) {
                        var P = this.renderer.currentBlendMode;
                        this.renderer.setBlendMode(f.ERASE)
                    }
                    T.bufferData(T.ARRAY_BUFFER, this.vertexData, T.STATIC_DRAW),
                    T.drawArrays(T.TRIANGLES, 0, 6),
                    x && this.renderer.setBlendMode(P),
                    T.bindFramebuffer(T.FRAMEBUFFER, null),
                    T.bindTexture(T.TEXTURE_2D, null),
                    this.resetUVs()
                },
                copyFrameRect: function(d, v, p, g, m, x, T, E) {
                    T === void 0 && (T = !0),
                    E === void 0 && (E = !0);
                    var P = this.gl;
                    P.bindFramebuffer(P.FRAMEBUFFER, d.framebuffer),
                    P.framebufferTexture2D(P.FRAMEBUFFER, P.COLOR_ATTACHMENT0, P.TEXTURE_2D, d.texture, 0),
                    T && (E ? P.clearColor(0, 0, 0, 0) : P.clearColor(0, 0, 0, 1),
                    P.clear(P.COLOR_BUFFER_BIT)),
                    P.activeTexture(P.TEXTURE0),
                    P.bindTexture(P.TEXTURE_2D, v.texture),
                    P.copyTexSubImage2D(P.TEXTURE_2D, 0, 0, 0, p, g, m, x),
                    P.bindFramebuffer(P.FRAMEBUFFER, null),
                    P.bindTexture(P.TEXTURE_2D, null)
                },
                copyToGame: function(d) {
                    var v = this.gl;
                    this.setShader(this.copyShader),
                    this.set1i("uMainSampler", 0),
                    this.set1f("uBrightness", 1),
                    this.renderer.popFramebuffer(),
                    v.activeTexture(v.TEXTURE0),
                    v.bindTexture(v.TEXTURE_2D, d.texture),
                    v.bufferData(v.ARRAY_BUFFER, this.vertexData, v.STATIC_DRAW),
                    v.drawArrays(v.TRIANGLES, 0, 6),
                    this.renderer.resetTextures()
                },
                drawFrame: function(d, v, p, g) {
                    p === void 0 && (p = !0),
                    g === void 0 && (g = this.colorMatrix);
                    var m = this.gl;
                    this.setShader(this.colorMatrixShader),
                    this.set1i("uMainSampler", 0),
                    this.set1fv("uColorMatrix", g.getData()),
                    this.set1f("uAlpha", g.alpha),
                    m.activeTexture(m.TEXTURE0),
                    m.bindTexture(m.TEXTURE_2D, d.texture),
                    v ? (m.viewport(0, 0, v.width, v.height),
                    m.bindFramebuffer(m.FRAMEBUFFER, v.framebuffer),
                    m.framebufferTexture2D(m.FRAMEBUFFER, m.COLOR_ATTACHMENT0, m.TEXTURE_2D, v.texture, 0)) : m.viewport(0, 0, d.width, d.height),
                    p ? m.clearColor(0, 0, 0, 0) : m.clearColor(0, 0, 0, 1),
                    m.clear(m.COLOR_BUFFER_BIT),
                    m.bufferData(m.ARRAY_BUFFER, this.vertexData, m.STATIC_DRAW),
                    m.drawArrays(m.TRIANGLES, 0, 6),
                    m.bindFramebuffer(m.FRAMEBUFFER, null),
                    m.bindTexture(m.TEXTURE_2D, null)
                },
                blendFrames: function(d, v, p, g, m, x) {
                    g === void 0 && (g = 1),
                    m === void 0 && (m = !0),
                    x === void 0 && (x = this.linearShader);
                    var T = this.gl;
                    this.setShader(x),
                    this.set1i("uMainSampler1", 0),
                    this.set1i("uMainSampler2", 1),
                    this.set1f("uStrength", g),
                    T.activeTexture(T.TEXTURE0),
                    T.bindTexture(T.TEXTURE_2D, d.texture),
                    T.activeTexture(T.TEXTURE1),
                    T.bindTexture(T.TEXTURE_2D, v.texture),
                    p ? (T.bindFramebuffer(T.FRAMEBUFFER, p.framebuffer),
                    T.framebufferTexture2D(T.FRAMEBUFFER, T.COLOR_ATTACHMENT0, T.TEXTURE_2D, p.texture, 0),
                    T.viewport(0, 0, p.width, p.height)) : T.viewport(0, 0, d.width, d.height),
                    m ? T.clearColor(0, 0, 0, 0) : T.clearColor(0, 0, 0, 1),
                    T.clear(T.COLOR_BUFFER_BIT),
                    T.bufferData(T.ARRAY_BUFFER, this.vertexData, T.STATIC_DRAW),
                    T.drawArrays(T.TRIANGLES, 0, 6),
                    T.bindFramebuffer(T.FRAMEBUFFER, null),
                    T.bindTexture(T.TEXTURE_2D, null)
                },
                blendFramesAdditive: function(d, v, p, g, m) {
                    this.blendFrames(d, v, p, g, m, this.addShader)
                },
                clearFrame: function(d, v) {
                    v === void 0 && (v = !0);
                    var p = this.gl;
                    p.viewport(0, 0, d.width, d.height),
                    p.bindFramebuffer(p.FRAMEBUFFER, d.framebuffer),
                    v ? p.clearColor(0, 0, 0, 0) : p.clearColor(0, 0, 0, 1),
                    p.clear(p.COLOR_BUFFER_BIT);
                    var g = this.renderer.currentFramebuffer;
                    p.bindFramebuffer(p.FRAMEBUFFER, g)
                },
                setUVs: function(d, v, p, g, m, x, T, E) {
                    var P = this.vertexViewF32;
                    P[2] = d,
                    P[3] = v,
                    P[6] = p,
                    P[7] = g,
                    P[10] = m,
                    P[11] = x,
                    P[14] = d,
                    P[15] = v,
                    P[18] = m,
                    P[19] = x,
                    P[22] = T,
                    P[23] = E
                },
                setTargetUVs: function(d, v) {
                    var p = v.height / d.height;
                    p > .5 ? p = .5 - (p - .5) : p = .5 + (.5 - p),
                    this.setUVs(0, p, 0, 1 + p, 1, 1 + p, 1, p)
                },
                flipX: function() {
                    this.setUVs(1, 0, 1, 1, 0, 1, 0, 0)
                },
                flipY: function() {
                    this.setUVs(0, 1, 0, 0, 1, 0, 1, 1)
                },
                resetUVs: function() {
                    this.setUVs(0, 0, 0, 1, 1, 1, 1, 0)
                }
            });
            c.exports = u
        }
        , function(c, S) {
            c.exports = ["#define SHADER_NAME PHASER_QUAD_VS", "", "precision mediump float;", "", "attribute vec2 inPosition;", "attribute vec2 inTexCoord;", "", "varying vec2 outFragCoord;", "varying vec2 outTexCoord;", "", "void main ()", "{", "    outFragCoord = inPosition.xy * 0.5 + 0.5;", "    outTexCoord = inTexCoord;", "", "    gl_Position = vec4(inPosition, 0, 1);", "}", ""].join(`
`)
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(31)
              , f = t(38)
              , r = t(2)
              , o = function(a, n) {
                var s = a.getContext("experimental-webgl")
                  , l = r(n, "callback")
                  , i = r(n, "type", "image/png")
                  , h = r(n, "encoder", .92)
                  , u = r(n, "x", 0)
                  , d = r(n, "y", 0)
                  , v = r(n, "getPixel", !1)
                  , p = r(n, "isFramebuffer", !1)
                  , g = p ? r(n, "bufferWidth", 1) : s.drawingBufferWidth
                  , m = p ? r(n, "bufferHeight", 1) : s.drawingBufferHeight;
                if (v) {
                    var x = new Uint8Array(4)
                      , T = p ? d : m - d;
                    s.readPixels(u, T, 1, 1, s.RGBA, s.UNSIGNED_BYTE, x),
                    l.call(null, new f(x[0],x[1],x[2],x[3] / 255))
                } else {
                    var E = r(n, "width", g)
                      , P = r(n, "height", m)
                      , M = E * P * 4
                      , L = new Uint8Array(M);
                    s.readPixels(u, m - d - P, E, P, s.RGBA, s.UNSIGNED_BYTE, L);
                    for (var R = e.createWebGL(this, E, P), O = R.getContext("2d"), F = O.getImageData(0, 0, E, P), B = F.data, N = 0; N < P; N++)
                        for (var Y = 0; Y < E; Y++) {
                            var z = ((P - N - 1) * E + Y) * 4
                              , W = (N * E + Y) * 4;
                            B[W + 0] = L[z + 0],
                            B[W + 1] = L[z + 1],
                            B[W + 2] = L[z + 2],
                            B[W + 3] = L[z + 3]
                        }
                    O.putImageData(F, 0, 0);
                    var b = new Image;
                    b.onerror = function() {
                        l.call(null),
                        e.remove(R)
                    }
                    ,
                    b.onload = function() {
                        l.call(null, b),
                        e.remove(R)
                    }
                    ,
                    b.src = R.toDataURL(i, h)
                }
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(33)
              , f = function(r) {
                var o = r.config;
                if (!o.hideBanner) {
                    var a = "WebGL";
                    o.renderType === e.CANVAS ? a = "Canvas" : o.renderType === e.HEADLESS && (a = "Headless");
                    var n = o.audio, s = r.device.audio, l;
                    if (s.webAudio && !n.disableWebAudio ? l = "Web Audio" : n.noAudio || !s.webAudio && !s.audioData ? l = "No Audio" : l = "HTML5 Audio",
                    r.device.browser.ie)
                        window.console && console.log("Phaser v" + e.VERSION + " / https://phaser.io");
                    else {
                        var i = ""
                          , h = [i];
                        if (Array.isArray(o.bannerBackgroundColor)) {
                            var u;
                            o.bannerBackgroundColor.forEach(function(v) {
                                i = i.concat("%c "),
                                h.push("background: " + v),
                                u = v
                            }),
                            h[h.length - 1] = "color: " + o.bannerTextColor + "; background: " + u
                        } else
                            i = i.concat("%c "),
                            h.push("color: " + o.bannerTextColor + "; background: " + o.bannerBackgroundColor);
                        h.push("background: transparent"),
                        o.gameTitle && (i = i.concat(o.gameTitle),
                        o.gameVersion && (i = i.concat(" v" + o.gameVersion)),
                        o.hidePhaser || (i = i.concat(" / ")));
                        var d = "";
                        o.hidePhaser || (i = i.concat("Phaser v" + e.VERSION + d + " (" + a + " | " + l + ")")),
                        i = i.concat(" %c " + o.gameURL),
                        h[0] = i,
                        console.log.apply(console, h)
                    }
                }
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(6)
              , r = t(1)
              , o = t(386)
              , a = new e({
                initialize: function(s, l) {
                    this.game = s,
                    this.raf = new o,
                    this.started = !1,
                    this.running = !1,
                    this.minFps = f(l, "min", 5),
                    this.targetFps = f(l, "target", 60),
                    this._min = 1e3 / this.minFps,
                    this._target = 1e3 / this.targetFps,
                    this.actualFps = this.targetFps,
                    this.nextFpsUpdate = 0,
                    this.framesThisSecond = 0,
                    this.callback = r,
                    this.forceSetTimeOut = f(l, "forceSetTimeOut", !1),
                    this.time = 0,
                    this.startTime = 0,
                    this.lastTime = 0,
                    this.frame = 0,
                    this.inFocus = !0,
                    this._pauseTime = 0,
                    this._coolDown = 0,
                    this.delta = 0,
                    this.deltaIndex = 0,
                    this.deltaHistory = [],
                    this.deltaSmoothingMax = f(l, "deltaHistory", 10),
                    this.panicMax = f(l, "panicMax", 120),
                    this.rawDelta = 0,
                    this.now = 0,
                    this.smoothStep = f(l, "smoothStep", !0)
                },
                blur: function() {
                    this.inFocus = !1
                },
                focus: function() {
                    this.inFocus = !0,
                    this.resetDelta()
                },
                pause: function() {
                    this._pauseTime = window.performance.now()
                },
                resume: function() {
                    this.resetDelta(),
                    this.startTime += this.time - this._pauseTime
                },
                resetDelta: function() {
                    var n = window.performance.now();
                    this.time = n,
                    this.lastTime = n,
                    this.nextFpsUpdate = n + 1e3,
                    this.framesThisSecond = 0;
                    for (var s = 0; s < this.deltaSmoothingMax; s++)
                        this.deltaHistory[s] = Math.min(this._target, this.deltaHistory[s]);
                    this.delta = 0,
                    this.deltaIndex = 0,
                    this._coolDown = this.panicMax
                },
                start: function(n) {
                    if (this.started)
                        return this;
                    this.started = !0,
                    this.running = !0;
                    for (var s = 0; s < this.deltaSmoothingMax; s++)
                        this.deltaHistory[s] = this._target;
                    this.resetDelta(),
                    this.startTime = window.performance.now(),
                    this.callback = n,
                    this.raf.start(this.step.bind(this), this.forceSetTimeOut, this._target)
                },
                step: function() {
                    var n = window.performance.now();
                    this.now = n;
                    var s = n - this.lastTime;
                    s < 0 && (s = 0),
                    this.rawDelta = s;
                    var l = this.deltaIndex
                      , i = this.deltaHistory
                      , h = this.deltaSmoothingMax
                      , u = s
                      , d = s;
                    if (this.smoothStep) {
                        (this._coolDown > 0 || !this.inFocus) && (this._coolDown--,
                        u = Math.min(u, this._target)),
                        u > this._min && (u = i[l],
                        u = Math.min(u, this._min)),
                        i[l] = u,
                        this.deltaIndex++,
                        this.deltaIndex > h && (this.deltaIndex = 0),
                        d = 0;
                        for (var v = 0; v < h; v++)
                            d += i[v];
                        d /= h
                    }
                    this.delta = d,
                    this.time += this.rawDelta,
                    n > this.nextFpsUpdate && (this.actualFps = .25 * this.framesThisSecond + .75 * this.actualFps,
                    this.nextFpsUpdate = n + 1e3,
                    this.framesThisSecond = 0),
                    this.framesThisSecond++;
                    var p = d / this._target;
                    this.callback(n, d, p),
                    this.lastTime = n,
                    this.frame++
                },
                tick: function() {
                    this.step()
                },
                sleep: function() {
                    this.running && (this.raf.stop(),
                    this.running = !1)
                },
                wake: function(n) {
                    this.running || (n && (this.startTime += -this.lastTime + (this.lastTime + window.performance.now())),
                    this.raf.start(this.step.bind(this), this.useRAF),
                    this.running = !0,
                    this.step())
                },
                getDuration: function() {
                    return Math.round(this.lastTime - this.startTime) / 1e3
                },
                getDurationMS: function() {
                    return Math.round(this.lastTime - this.startTime)
                },
                stop: function() {
                    return this.running = !1,
                    this.started = !1,
                    this.raf.stop(),
                    this
                },
                destroy: function() {
                    this.stop(),
                    this.callback = r,
                    this.raf = null,
                    this.game = null
                }
            });
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(1)
              , r = new e({
                initialize: function() {
                    this.isRunning = !1,
                    this.callback = f,
                    this.tick = 0,
                    this.isSetTimeOut = !1,
                    this.timeOutID = null,
                    this.lastTime = 0,
                    this.target = 0;
                    var a = this;
                    this.step = function n() {
                        var s = window.performance.now();
                        a.lastTime = a.tick,
                        a.tick = s,
                        a.callback(s),
                        a.timeOutID = window.requestAnimationFrame(n)
                    }
                    ,
                    this.stepTimeout = function n() {
                        var s = Date.now()
                          , l = Math.min(Math.max(a.target * 2 + a.tick - s, 0), a.target);
                        a.lastTime = a.tick,
                        a.tick = s,
                        a.callback(s),
                        a.timeOutID = window.setTimeout(n, l)
                    }
                },
                start: function(o, a, n) {
                    this.isRunning || (this.callback = o,
                    this.isSetTimeOut = a,
                    this.target = n,
                    this.isRunning = !0,
                    this.timeOutID = a ? window.setTimeout(this.stepTimeout, 0) : window.requestAnimationFrame(this.step))
                },
                stop: function() {
                    this.isRunning = !1,
                    this.isSetTimeOut ? clearTimeout(this.timeOutID) : window.cancelAnimationFrame(this.timeOutID)
                },
                destroy: function() {
                    this.stop(),
                    this.callback = f
                }
            });
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(22)
              , f = function(r) {
                var o, a = r.events;
                if (document.hidden !== void 0)
                    o = "visibilitychange";
                else {
                    var n = ["webkit", "moz", "ms"];
                    n.forEach(function(l) {
                        document[l + "Hidden"] !== void 0 && (document.hidden = function() {
                            return document[l + "Hidden"]
                        }
                        ,
                        o = l + "visibilitychange")
                    })
                }
                var s = function(l) {
                    document.hidden || l.type === "pause" ? a.emit(e.HIDDEN) : a.emit(e.VISIBLE)
                };
                o && document.addEventListener(o, s, !1),
                window.onblur = function() {
                    a.emit(e.BLUR)
                }
                ,
                window.onfocus = function() {
                    a.emit(e.FOCUS)
                }
                ,
                window.focus && r.config.autoFocus && window.focus()
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(389)
              , f = t(31)
              , r = t(6)
              , o = function(a) {
                var n = r(a, "data", [])
                  , s = r(a, "canvas", null)
                  , l = r(a, "palette", e)
                  , i = r(a, "pixelWidth", 1)
                  , h = r(a, "pixelHeight", i)
                  , u = r(a, "resizeCanvas", !0)
                  , d = r(a, "clearCanvas", !0)
                  , v = r(a, "preRender", null)
                  , p = r(a, "postRender", null)
                  , g = Math.floor(Math.abs(n[0].length * i))
                  , m = Math.floor(Math.abs(n.length * h));
                s || (s = f.create2D(this, g, m),
                u = !1,
                d = !1),
                u && (s.width = g,
                s.height = m);
                var x = s.getContext("2d");
                d && x.clearRect(0, 0, g, m),
                v && v(s, x);
                for (var T = 0; T < n.length; T++)
                    for (var E = n[T], P = 0; P < E.length; P++) {
                        var M = E[P];
                        M !== "." && M !== " " && (x.fillStyle = l[M],
                        x.fillRect(P * i, T * h, i, h))
                    }
                return p && p(s, x),
                s
            };
            c.exports = o
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                0: "#000",
                1: "#9D9D9D",
                2: "#FFF",
                3: "#BE2633",
                4: "#E06F8B",
                5: "#493C2B",
                6: "#A46422",
                7: "#EB8931",
                8: "#F7E26B",
                9: "#2F484E",
                A: "#44891A",
                B: "#A3CE27",
                C: "#1B2632",
                D: "#005784",
                E: "#31A2F2",
                F: "#B2DCEF"
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(358)
              , r = t(94)
              , o = t(3)
              , a = new e({
                Extends: r,
                initialize: function(s, l, i, h) {
                    r.call(this, "CubicBezierCurve"),
                    Array.isArray(s) && (h = new o(s[6],s[7]),
                    i = new o(s[4],s[5]),
                    l = new o(s[2],s[3]),
                    s = new o(s[0],s[1])),
                    this.p0 = s,
                    this.p1 = l,
                    this.p2 = i,
                    this.p3 = h
                },
                getStartPoint: function(n) {
                    return n === void 0 && (n = new o),
                    n.copy(this.p0)
                },
                getResolution: function(n) {
                    return n
                },
                getPoint: function(n, s) {
                    s === void 0 && (s = new o);
                    var l = this.p0
                      , i = this.p1
                      , h = this.p2
                      , u = this.p3;
                    return s.set(f(n, l.x, i.x, h.x, u.x), f(n, l.y, i.y, h.y, u.y))
                },
                draw: function(n, s) {
                    s === void 0 && (s = 32);
                    var l = this.getPoints(s);
                    n.beginPath(),
                    n.moveTo(this.p0.x, this.p0.y);
                    for (var i = 1; i < l.length; i++)
                        n.lineTo(l[i].x, l[i].y);
                    return n.strokePath(),
                    n
                },
                toJSON: function() {
                    return {
                        type: this.type,
                        points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y, this.p2.x, this.p2.y, this.p3.x, this.p3.y]
                    }
                }
            });
            a.fromJSON = function(n) {
                var s = n.points
                  , l = new o(s[0],s[1])
                  , i = new o(s[2],s[3])
                  , h = new o(s[4],s[5])
                  , u = new o(s[6],s[7]);
                return new a(l,i,h,u)
            }
            ,
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(94)
              , r = t(36)
              , o = t(6)
              , a = t(196)
              , n = t(3)
              , s = new e({
                Extends: f,
                initialize: function(i, h, u, d, v, p, g, m) {
                    if (typeof i == "object") {
                        var x = i;
                        i = o(x, "x", 0),
                        h = o(x, "y", 0),
                        u = o(x, "xRadius", 0),
                        d = o(x, "yRadius", u),
                        v = o(x, "startAngle", 0),
                        p = o(x, "endAngle", 360),
                        g = o(x, "clockwise", !1),
                        m = o(x, "rotation", 0)
                    } else
                        d === void 0 && (d = u),
                        v === void 0 && (v = 0),
                        p === void 0 && (p = 360),
                        g === void 0 && (g = !1),
                        m === void 0 && (m = 0);
                    f.call(this, "EllipseCurve"),
                    this.p0 = new n(i,h),
                    this._xRadius = u,
                    this._yRadius = d,
                    this._startAngle = r(v),
                    this._endAngle = r(p),
                    this._clockwise = g,
                    this._rotation = r(m)
                },
                getStartPoint: function(l) {
                    return l === void 0 && (l = new n),
                    this.getPoint(0, l)
                },
                getResolution: function(l) {
                    return l * 2
                },
                getPoint: function(l, i) {
                    i === void 0 && (i = new n);
                    for (var h = Math.PI * 2, u = this._endAngle - this._startAngle, d = Math.abs(u) < Number.EPSILON; u < 0; )
                        u += h;
                    for (; u > h; )
                        u -= h;
                    u < Number.EPSILON && (d ? u = 0 : u = h),
                    this._clockwise && !d && (u === h ? u = -h : u = u - h);
                    var v = this._startAngle + l * u
                      , p = this.p0.x + this._xRadius * Math.cos(v)
                      , g = this.p0.y + this._yRadius * Math.sin(v);
                    if (this._rotation !== 0) {
                        var m = Math.cos(this._rotation)
                          , x = Math.sin(this._rotation)
                          , T = p - this.p0.x
                          , E = g - this.p0.y;
                        p = T * m - E * x + this.p0.x,
                        g = T * x + E * m + this.p0.y
                    }
                    return i.set(p, g)
                },
                setXRadius: function(l) {
                    return this.xRadius = l,
                    this
                },
                setYRadius: function(l) {
                    return this.yRadius = l,
                    this
                },
                setWidth: function(l) {
                    return this.xRadius = l / 2,
                    this
                },
                setHeight: function(l) {
                    return this.yRadius = l / 2,
                    this
                },
                setStartAngle: function(l) {
                    return this.startAngle = l,
                    this
                },
                setEndAngle: function(l) {
                    return this.endAngle = l,
                    this
                },
                setClockwise: function(l) {
                    return this.clockwise = l,
                    this
                },
                setRotation: function(l) {
                    return this.rotation = l,
                    this
                },
                x: {
                    get: function() {
                        return this.p0.x
                    },
                    set: function(l) {
                        this.p0.x = l
                    }
                },
                y: {
                    get: function() {
                        return this.p0.y
                    },
                    set: function(l) {
                        this.p0.y = l
                    }
                },
                xRadius: {
                    get: function() {
                        return this._xRadius
                    },
                    set: function(l) {
                        this._xRadius = l
                    }
                },
                yRadius: {
                    get: function() {
                        return this._yRadius
                    },
                    set: function(l) {
                        this._yRadius = l
                    }
                },
                startAngle: {
                    get: function() {
                        return a(this._startAngle)
                    },
                    set: function(l) {
                        this._startAngle = r(l)
                    }
                },
                endAngle: {
                    get: function() {
                        return a(this._endAngle)
                    },
                    set: function(l) {
                        this._endAngle = r(l)
                    }
                },
                clockwise: {
                    get: function() {
                        return this._clockwise
                    },
                    set: function(l) {
                        this._clockwise = l
                    }
                },
                angle: {
                    get: function() {
                        return a(this._rotation)
                    },
                    set: function(l) {
                        this._rotation = r(l)
                    }
                },
                rotation: {
                    get: function() {
                        return this._rotation
                    },
                    set: function(l) {
                        this._rotation = l
                    }
                },
                toJSON: function() {
                    return {
                        type: this.type,
                        x: this.p0.x,
                        y: this.p0.y,
                        xRadius: this._xRadius,
                        yRadius: this._yRadius,
                        startAngle: a(this._startAngle),
                        endAngle: a(this._endAngle),
                        clockwise: this._clockwise,
                        rotation: a(this._rotation)
                    }
                }
            });
            s.fromJSON = function(l) {
                return new s(l)
            }
            ,
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(94)
              , r = t(199)
              , o = t(10)
              , a = t(3)
              , n = new e({
                Extends: f,
                initialize: function(l, i) {
                    f.call(this, "LineCurve"),
                    Array.isArray(l) && (i = new a(l[2],l[3]),
                    l = new a(l[0],l[1])),
                    this.p0 = l,
                    this.p1 = i,
                    this.arcLengthDivisions = 1
                },
                getBounds: function(s) {
                    return s === void 0 && (s = new o),
                    r([this.p0, this.p1], s)
                },
                getStartPoint: function(s) {
                    return s === void 0 && (s = new a),
                    s.copy(this.p0)
                },
                getResolution: function(s) {
                    return s === void 0 && (s = 1),
                    s
                },
                getPoint: function(s, l) {
                    return l === void 0 && (l = new a),
                    s === 1 ? l.copy(this.p1) : (l.copy(this.p1).subtract(this.p0).scale(s).add(this.p0),
                    l)
                },
                getPointAt: function(s, l) {
                    return this.getPoint(s, l)
                },
                getTangent: function(s, l) {
                    return l === void 0 && (l = new a),
                    l.copy(this.p1).subtract(this.p0).normalize(),
                    l
                },
                getUtoTmapping: function(s, l, i) {
                    var h;
                    if (l) {
                        var u = this.getLengths(i)
                          , d = u[u.length - 1]
                          , v = Math.min(l, d);
                        h = v / d
                    } else
                        h = s;
                    return h
                },
                draw: function(s) {
                    return s.lineBetween(this.p0.x, this.p0.y, this.p1.x, this.p1.y),
                    s
                },
                toJSON: function() {
                    return {
                        type: this.type,
                        points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y]
                    }
                }
            });
            n.fromJSON = function(s) {
                var l = s.points
                  , i = new a(l[0],l[1])
                  , h = new a(l[2],l[3]);
                return new n(i,h)
            }
            ,
            c.exports = n
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(3)
              , r = new e({
                initialize: function(a, n) {
                    this.active = !1,
                    this.p0 = new f(a,n)
                },
                getPoint: function(o, a) {
                    return a === void 0 && (a = new f),
                    a.copy(this.p0)
                },
                getPointAt: function(o, a) {
                    return this.getPoint(o, a)
                },
                getResolution: function() {
                    return 1
                },
                getLength: function() {
                    return 0
                },
                toJSON: function() {
                    return {
                        type: "MoveTo",
                        points: [this.p0.x, this.p0.y]
                    }
                }
            });
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(94)
              , r = t(359)
              , o = t(3)
              , a = new e({
                Extends: f,
                initialize: function(s, l, i) {
                    f.call(this, "QuadraticBezier"),
                    Array.isArray(s) && (i = new o(s[4],s[5]),
                    l = new o(s[2],s[3]),
                    s = new o(s[0],s[1])),
                    this.p0 = s,
                    this.p1 = l,
                    this.p2 = i
                },
                getStartPoint: function(n) {
                    return n === void 0 && (n = new o),
                    n.copy(this.p0)
                },
                getResolution: function(n) {
                    return n
                },
                getPoint: function(n, s) {
                    s === void 0 && (s = new o);
                    var l = this.p0
                      , i = this.p1
                      , h = this.p2;
                    return s.set(r(n, l.x, i.x, h.x), r(n, l.y, i.y, h.y))
                },
                draw: function(n, s) {
                    s === void 0 && (s = 32);
                    var l = this.getPoints(s);
                    n.beginPath(),
                    n.moveTo(this.p0.x, this.p0.y);
                    for (var i = 1; i < l.length; i++)
                        n.lineTo(l[i].x, l[i].y);
                    return n.strokePath(),
                    n
                },
                toJSON: function() {
                    return {
                        type: this.type,
                        points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y, this.p2.x, this.p2.y]
                    }
                }
            });
            a.fromJSON = function(n) {
                var s = n.points
                  , l = new o(s[0],s[1])
                  , i = new o(s[2],s[3])
                  , h = new o(s[4],s[5]);
                return new a(l,i,h)
            }
            ,
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(194)
              , f = t(0)
              , r = t(94)
              , o = t(3)
              , a = new f({
                Extends: r,
                initialize: function(s) {
                    s === void 0 && (s = []),
                    r.call(this, "SplineCurve"),
                    this.points = [],
                    this.addPoints(s)
                },
                addPoints: function(n) {
                    for (var s = 0; s < n.length; s++) {
                        var l = new o;
                        typeof n[s] == "number" ? (l.x = n[s],
                        l.y = n[s + 1],
                        s++) : Array.isArray(n[s]) ? (l.x = n[s][0],
                        l.y = n[s][1]) : (l.x = n[s].x,
                        l.y = n[s].y),
                        this.points.push(l)
                    }
                    return this
                },
                addPoint: function(n, s) {
                    var l = new o(n,s);
                    return this.points.push(l),
                    l
                },
                getStartPoint: function(n) {
                    return n === void 0 && (n = new o),
                    n.copy(this.points[0])
                },
                getResolution: function(n) {
                    return n * this.points.length
                },
                getPoint: function(n, s) {
                    s === void 0 && (s = new o);
                    var l = this.points
                      , i = (l.length - 1) * n
                      , h = Math.floor(i)
                      , u = i - h
                      , d = l[h === 0 ? h : h - 1]
                      , v = l[h]
                      , p = l[h > l.length - 2 ? l.length - 1 : h + 1]
                      , g = l[h > l.length - 3 ? l.length - 1 : h + 2];
                    return s.set(e(u, d.x, v.x, p.x, g.x), e(u, d.y, v.y, p.y, g.y))
                },
                toJSON: function() {
                    for (var n = [], s = 0; s < this.points.length; s++)
                        n.push(this.points[s].x),
                        n.push(this.points[s].y);
                    return {
                        type: this.type,
                        points: n
                    }
                }
            });
            a.fromJSON = function(n) {
                return new a(n.points)
            }
            ,
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = new e({
                initialize: function(o, a, n, s) {
                    (!a || a === "") && (a = ["precision mediump float;", "uniform vec2 resolution;", "varying vec2 fragCoord;", "void main () {", "    vec2 uv = fragCoord / resolution.xy;", "    gl_FragColor = vec4(uv.xyx, 1.0);", "}"].join(`
`)),
                    (!n || n === "") && (n = ["precision mediump float;", "uniform mat4 uProjectionMatrix;", "uniform mat4 uViewMatrix;", "uniform vec2 uResolution;", "attribute vec2 inPosition;", "varying vec2 fragCoord;", "varying vec2 outTexCoord;", "void main () {", "   gl_Position = uProjectionMatrix * uViewMatrix * vec4(inPosition, 1.0, 1.0);", "   fragCoord = vec2(inPosition.x, uResolution.y - inPosition.y);", "   outTexCoord = vec2(inPosition.x / uResolution.x, fragCoord.y / uResolution.y);", "}"].join(`
`)),
                    s === void 0 && (s = null),
                    this.key = o,
                    this.fragmentSrc = a,
                    this.vertexSrc = n,
                    this.uniforms = s
                }
            });
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(38);
            e.ColorSpectrum = t(909),
            e.ColorToRGBA = t(910),
            e.ComponentToHex = t(398),
            e.GetColor = t(103),
            e.GetColor32 = t(328),
            e.HexStringToColor = t(327),
            e.HSLToColor = t(911),
            e.HSVColorWheel = t(912),
            e.HSVToRGB = t(188),
            e.HueToComponent = t(399),
            e.IntegerToColor = t(189),
            e.IntegerToRGB = t(330),
            e.Interpolate = t(913),
            e.ObjectToColor = t(331),
            e.RandomRGB = t(914),
            e.RGBStringToColor = t(332),
            e.RGBToHSV = t(329),
            e.RGBToString = t(915),
            e.ValueToColor = t(187),
            c.exports = e
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                var f = e.toString(16);
                return f.length === 1 ? "0" + f : f
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                return r < 0 && (r += 1),
                r > 1 && (r -= 1),
                r < .16666666666666666 ? e + (f - e) * 6 * r : r < .5 ? f : r < .6666666666666666 ? e + (f - e) * (.6666666666666666 - r) * 6 : e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(105)
              , f = function(r) {
                if (document.readyState === "complete" || document.readyState === "interactive") {
                    r();
                    return
                }
                var o = function() {
                    document.removeEventListener("deviceready", o, !0),
                    document.removeEventListener("DOMContentLoaded", o, !0),
                    window.removeEventListener("load", o, !0),
                    r()
                };
                document.body ? e.cordova ? document.addEventListener("deviceready", o, !1) : (document.addEventListener("DOMContentLoaded", o, !0),
                window.addEventListener("load", o, !0)) : window.setTimeout(o, 20)
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                if (!e)
                    return window.innerHeight;
                var f = Math.abs(window.orientation)
                  , r = {
                    w: 0,
                    h: 0
                }
                  , o = document.createElement("div");
                return o.setAttribute("style", "position: fixed; height: 100vh; width: 0; top: 0"),
                document.documentElement.appendChild(o),
                r.w = f === 90 ? o.offsetHeight : window.innerWidth,
                r.h = f === 90 ? window.innerWidth : o.offsetHeight,
                document.documentElement.removeChild(o),
                o = null,
                Math.abs(window.orientation) !== 90 ? r.h : r.w
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(201)
              , f = function(r, o) {
                var a = window.screen
                  , n = a ? a.orientation || a.mozOrientation || a.msOrientation : !1;
                if (n && typeof n.type == "string")
                    return n.type;
                if (typeof n == "string")
                    return n;
                if (typeof window.orientation == "number")
                    return window.orientation === 0 || window.orientation === 180 ? e.ORIENTATION.PORTRAIT : e.ORIENTATION.LANDSCAPE;
                if (window.matchMedia) {
                    if (window.matchMedia("(orientation: portrait)").matches)
                        return e.ORIENTATION.PORTRAIT;
                    if (window.matchMedia("(orientation: landscape)").matches)
                        return e.ORIENTATION.LANDSCAPE
                } else
                    return o > r ? e.ORIENTATION.PORTRAIT : e.ORIENTATION.LANDSCAPE
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                NO_CENTER: 0,
                CENTER_BOTH: 1,
                CENTER_HORIZONTALLY: 2,
                CENTER_VERTICALLY: 3
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                LANDSCAPE: "landscape-primary",
                PORTRAIT: "portrait-primary"
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                NONE: 0,
                WIDTH_CONTROLS_HEIGHT: 1,
                HEIGHT_CONTROLS_WIDTH: 2,
                FIT: 3,
                ENVELOP: 4,
                RESIZE: 5
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                NO_ZOOM: 1,
                ZOOM_2X: 2,
                ZOOM_4X: 4,
                MAX_ZOOM: -1
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                var f;
                return e !== "" && (typeof e == "string" ? f = document.getElementById(e) : e && e.nodeType === 1 && (f = e)),
                f || (f = document.body),
                f
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                var f = "";
                try {
                    if (window.DOMParser) {
                        var r = new DOMParser;
                        f = r.parseFromString(e, "text/xml")
                    } else
                        f = new ActiveXObject("Microsoft.XMLDOM"),
                        f.loadXML(e)
                } catch {
                    f = null
                }
                return !f || !f.documentElement || f.getElementsByTagName("parsererror").length ? null : f
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(203)
              , r = t(9)
              , o = t(51)
              , a = t(22)
              , n = t(410)
              , s = t(411)
              , l = t(412)
              , i = t(413)
              , h = t(25)
              , u = t(177)
              , d = new e({
                initialize: function(p, g) {
                    this.game = p,
                    this.scaleManager,
                    this.canvas,
                    this.config = g,
                    this.enabled = !0,
                    this.events = new r,
                    this.isOver = !0,
                    this.defaultCursor = "",
                    this.keyboard = g.inputKeyboard ? new n(this) : null,
                    this.mouse = g.inputMouse ? new s(this) : null,
                    this.touch = g.inputTouch ? new i(this) : null,
                    this.pointers = [],
                    this.pointersTotal = g.inputActivePointers,
                    g.inputTouch && this.pointersTotal === 1 && (this.pointersTotal = 2);
                    for (var m = 0; m <= this.pointersTotal; m++) {
                        var x = new l(this,m);
                        x.smoothFactor = g.inputSmoothFactor,
                        this.pointers.push(x)
                    }
                    this.mousePointer = g.inputMouse ? this.pointers[0] : null,
                    this.activePointer = this.pointers[0],
                    this.globalTopOnly = !0,
                    this.time = 0,
                    this._tempPoint = {
                        x: 0,
                        y: 0
                    },
                    this._tempHitTest = [],
                    this._tempMatrix = new h,
                    this._tempMatrix2 = new h,
                    this._tempSkip = !1,
                    this.mousePointerContainer = [this.mousePointer],
                    p.events.once(a.BOOT, this.boot, this)
                },
                boot: function() {
                    this.canvas = this.game.canvas,
                    this.scaleManager = this.game.scale,
                    this.events.emit(o.MANAGER_BOOT),
                    this.game.events.on(a.PRE_RENDER, this.preRender, this),
                    this.game.events.once(a.DESTROY, this.destroy, this)
                },
                setCanvasOver: function(v) {
                    this.isOver = !0,
                    this.events.emit(o.GAME_OVER, v)
                },
                setCanvasOut: function(v) {
                    this.isOver = !1,
                    this.events.emit(o.GAME_OUT, v)
                },
                preRender: function() {
                    var v = this.game.loop.now
                      , p = this.game.loop.delta
                      , g = this.game.scene.getScenes(!0, !0);
                    this.time = v,
                    this.events.emit(o.MANAGER_UPDATE);
                    for (var m = 0; m < g.length; m++) {
                        var x = g[m];
                        if (x.sys.input && x.sys.input.updatePoll(v, p) && this.globalTopOnly)
                            return
                    }
                },
                setDefaultCursor: function(v) {
                    this.defaultCursor = v,
                    this.canvas.style.cursor !== v && (this.canvas.style.cursor = v)
                },
                setCursor: function(v) {
                    v.cursor && (this.canvas.style.cursor = v.cursor)
                },
                resetCursor: function(v) {
                    v.cursor && this.canvas && (this.canvas.style.cursor = this.defaultCursor)
                },
                addPointer: function(v) {
                    v === void 0 && (v = 1);
                    var p = [];
                    this.pointersTotal + v > 10 && (v = 10 - this.pointersTotal);
                    for (var g = 0; g < v; g++) {
                        var m = this.pointers.length
                          , x = new l(this,m);
                        x.smoothFactor = this.config.inputSmoothFactor,
                        this.pointers.push(x),
                        this.pointersTotal++,
                        p.push(x)
                    }
                    return p
                },
                updateInputPlugins: function(v, p) {
                    var g = this.game.scene.getScenes(!0, !0);
                    this._tempSkip = !1;
                    for (var m = 0; m < g.length; m++) {
                        var x = g[m];
                        if (x.sys.input) {
                            var T = x.sys.input.update(v, p);
                            if (T && this.globalTopOnly || this._tempSkip)
                                return
                        }
                    }
                },
                onTouchStart: function(v) {
                    for (var p = this.pointers, g = [], m = 0; m < v.changedTouches.length; m++)
                        for (var x = v.changedTouches[m], T = 1; T < this.pointersTotal; T++) {
                            var E = p[T];
                            if (!E.active) {
                                E.touchstart(x, v),
                                this.activePointer = E,
                                g.push(E);
                                break
                            }
                        }
                    this.updateInputPlugins(f.TOUCH_START, g)
                },
                onTouchMove: function(v) {
                    for (var p = this.pointers, g = [], m = 0; m < v.changedTouches.length; m++)
                        for (var x = v.changedTouches[m], T = 1; T < this.pointersTotal; T++) {
                            var E = p[T];
                            if (E.active && E.identifier === x.identifier) {
                                E.touchmove(x, v),
                                this.activePointer = E,
                                g.push(E);
                                break
                            }
                        }
                    this.updateInputPlugins(f.TOUCH_MOVE, g)
                },
                onTouchEnd: function(v) {
                    for (var p = this.pointers, g = [], m = 0; m < v.changedTouches.length; m++)
                        for (var x = v.changedTouches[m], T = 1; T < this.pointersTotal; T++) {
                            var E = p[T];
                            if (E.active && E.identifier === x.identifier) {
                                E.touchend(x, v),
                                g.push(E);
                                break
                            }
                        }
                    this.updateInputPlugins(f.TOUCH_END, g)
                },
                onTouchCancel: function(v) {
                    for (var p = this.pointers, g = [], m = 0; m < v.changedTouches.length; m++)
                        for (var x = v.changedTouches[m], T = 1; T < this.pointersTotal; T++) {
                            var E = p[T];
                            if (E.active && E.identifier === x.identifier) {
                                E.touchcancel(x, v),
                                g.push(E);
                                break
                            }
                        }
                    this.updateInputPlugins(f.TOUCH_CANCEL, g)
                },
                onMouseDown: function(v) {
                    var p = this.mousePointer;
                    p.down(v),
                    p.updateMotion(),
                    this.activePointer = p,
                    this.updateInputPlugins(f.MOUSE_DOWN, this.mousePointerContainer)
                },
                onMouseMove: function(v) {
                    var p = this.mousePointer;
                    p.move(v),
                    p.updateMotion(),
                    this.activePointer = p,
                    this.updateInputPlugins(f.MOUSE_MOVE, this.mousePointerContainer)
                },
                onMouseUp: function(v) {
                    var p = this.mousePointer;
                    p.up(v),
                    p.updateMotion(),
                    this.activePointer = p,
                    this.updateInputPlugins(f.MOUSE_UP, this.mousePointerContainer)
                },
                onMouseWheel: function(v) {
                    var p = this.mousePointer;
                    p.wheel(v),
                    this.activePointer = p,
                    this.updateInputPlugins(f.MOUSE_WHEEL, this.mousePointerContainer)
                },
                onPointerLockChange: function(v) {
                    var p = this.mouse.locked;
                    this.mousePointer.locked = p,
                    this.events.emit(o.POINTERLOCK_CHANGE, v, p)
                },
                inputCandidate: function(v, p) {
                    var g = v.input;
                    if (!g || !g.enabled || !g.alwaysEnabled && !v.willRender(p))
                        return !1;
                    var m = !0
                      , x = v.parentContainer;
                    if (x)
                        do {
                            if (!x.willRender(p)) {
                                m = !1;
                                break
                            }
                            x = x.parentContainer
                        } while (x);
                    return m
                },
                hitTest: function(v, p, g, m) {
                    m === void 0 && (m = this._tempHitTest);
                    var x = this._tempPoint
                      , T = g.scrollX
                      , E = g.scrollY;
                    m.length = 0;
                    var P = v.x
                      , M = v.y;
                    g.getWorldPoint(P, M, x),
                    v.worldX = x.x,
                    v.worldY = x.y;
                    for (var L = {
                        x: 0,
                        y: 0
                    }, R = this._tempMatrix, O = this._tempMatrix2, F = 0; F < p.length; F++) {
                        var B = p[F];
                        if (this.inputCandidate(B, g)) {
                            var N = x.x + T * B.scrollFactorX - T
                              , Y = x.y + E * B.scrollFactorY - E;
                            B.parentContainer ? (B.getWorldTransformMatrix(R, O),
                            R.applyInverse(N, Y, L)) : u(N, Y, B.x, B.y, B.rotation, B.scaleX, B.scaleY, L),
                            this.pointWithinHitArea(B, L.x, L.y) && m.push(B)
                        }
                    }
                    return m
                },
                pointWithinHitArea: function(v, p, g) {
                    p += v.displayOriginX,
                    g += v.displayOriginY;
                    var m = v.input;
                    return m && m.hitAreaCallback(m.hitArea, p, g, v) ? (m.localX = p,
                    m.localY = g,
                    !0) : !1
                },
                pointWithinInteractiveObject: function(v, p, g) {
                    return v.hitArea ? (p += v.gameObject.displayOriginX,
                    g += v.gameObject.displayOriginY,
                    v.localX = p,
                    v.localY = g,
                    v.hitAreaCallback(v.hitArea, p, g, v)) : !1
                },
                transformPointer: function(v, p, g, m) {
                    var x = v.position
                      , T = v.prevPosition;
                    T.x = x.x,
                    T.y = x.y;
                    var E = this.scaleManager.transformX(p)
                      , P = this.scaleManager.transformY(g)
                      , M = v.smoothFactor;
                    !m || M === 0 ? (x.x = E,
                    x.y = P) : (x.x = E * M + T.x * (1 - M),
                    x.y = P * M + T.y * (1 - M))
                },
                destroy: function() {
                    this.events.removeAllListeners(),
                    this.game.events.off(a.PRE_RENDER),
                    this.keyboard && this.keyboard.destroy(),
                    this.mouse && this.mouse.destroy(),
                    this.touch && this.touch.destroy();
                    for (var v = 0; v < this.pointers.length; v++)
                        this.pointers[v].destroy();
                    this.pointers = [],
                    this._tempHitTest = [],
                    this._tempMatrix.destroy(),
                    this.canvas = null,
                    this.game = null
                }
            });
            c.exports = d
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(93)
              , f = t(0)
              , r = t(22)
              , o = t(51)
              , a = t(143)
              , n = t(1)
              , s = new f({
                initialize: function(i) {
                    this.manager = i,
                    this.queue = [],
                    this.preventDefault = !0,
                    this.captures = [],
                    this.enabled = !1,
                    this.target,
                    this.onKeyDown = n,
                    this.onKeyUp = n,
                    i.events.once(o.MANAGER_BOOT, this.boot, this)
                },
                boot: function() {
                    var l = this.manager.config;
                    this.enabled = l.inputKeyboard,
                    this.target = l.inputKeyboardEventTarget,
                    this.addCapture(l.inputKeyboardCapture),
                    !this.target && window && (this.target = window),
                    this.enabled && this.target && this.startListeners(),
                    this.manager.game.events.on(r.POST_STEP, this.postUpdate, this)
                },
                startListeners: function() {
                    var l = this;
                    this.onKeyDown = function(h) {
                        if (!(h.defaultPrevented || !l.enabled || !l.manager)) {
                            l.queue.push(h),
                            l.manager.events.emit(o.MANAGER_PROCESS);
                            var u = h.altKey || h.ctrlKey || h.shiftKey || h.metaKey;
                            l.preventDefault && !u && l.captures.indexOf(h.keyCode) > -1 && h.preventDefault()
                        }
                    }
                    ,
                    this.onKeyUp = function(h) {
                        if (!(h.defaultPrevented || !l.enabled || !l.manager)) {
                            l.queue.push(h),
                            l.manager.events.emit(o.MANAGER_PROCESS);
                            var u = h.altKey || h.ctrlKey || h.shiftKey || h.metaKey;
                            l.preventDefault && !u && l.captures.indexOf(h.keyCode) > -1 && h.preventDefault()
                        }
                    }
                    ;
                    var i = this.target;
                    i && (i.addEventListener("keydown", this.onKeyDown, !1),
                    i.addEventListener("keyup", this.onKeyUp, !1),
                    this.enabled = !0)
                },
                stopListeners: function() {
                    var l = this.target;
                    l.removeEventListener("keydown", this.onKeyDown, !1),
                    l.removeEventListener("keyup", this.onKeyUp, !1),
                    this.enabled = !1
                },
                postUpdate: function() {
                    this.queue = []
                },
                addCapture: function(l) {
                    typeof l == "string" && (l = l.split(",")),
                    Array.isArray(l) || (l = [l]);
                    for (var i = this.captures, h = 0; h < l.length; h++) {
                        var u = l[h];
                        typeof u == "string" && (u = a[u.trim().toUpperCase()]),
                        i.indexOf(u) === -1 && i.push(u)
                    }
                    this.preventDefault = i.length > 0
                },
                removeCapture: function(l) {
                    typeof l == "string" && (l = l.split(",")),
                    Array.isArray(l) || (l = [l]);
                    for (var i = this.captures, h = 0; h < l.length; h++) {
                        var u = l[h];
                        typeof u == "string" && (u = a[u.toUpperCase()]),
                        e(i, u)
                    }
                    this.preventDefault = i.length > 0
                },
                clearCaptures: function() {
                    this.captures = [],
                    this.preventDefault = !1
                },
                destroy: function() {
                    this.stopListeners(),
                    this.clearCaptures(),
                    this.queue = [],
                    this.manager.game.events.off(r.POST_RENDER, this.postUpdate, this),
                    this.target = null,
                    this.enabled = !1,
                    this.manager = null
                }
            });
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(191)
              , r = t(51)
              , o = t(1)
              , a = new e({
                initialize: function(s) {
                    this.manager = s,
                    this.preventDefaultDown = !0,
                    this.preventDefaultUp = !0,
                    this.preventDefaultMove = !0,
                    this.preventDefaultWheel = !1,
                    this.enabled = !1,
                    this.target,
                    this.locked = !1,
                    this.onMouseMove = o,
                    this.onMouseDown = o,
                    this.onMouseUp = o,
                    this.onMouseDownWindow = o,
                    this.onMouseUpWindow = o,
                    this.onMouseOver = o,
                    this.onMouseOut = o,
                    this.onMouseWheel = o,
                    this.pointerLockChange = o,
                    this.isTop = !0,
                    s.events.once(r.MANAGER_BOOT, this.boot, this)
                },
                boot: function() {
                    var n = this.manager.config;
                    this.enabled = n.inputMouse,
                    this.target = n.inputMouseEventTarget,
                    this.passive = n.inputMousePassive,
                    this.preventDefaultDown = n.inputMousePreventDefaultDown,
                    this.preventDefaultUp = n.inputMousePreventDefaultUp,
                    this.preventDefaultMove = n.inputMousePreventDefaultMove,
                    this.preventDefaultWheel = n.inputMousePreventDefaultWheel,
                    this.target ? typeof this.target == "string" && (this.target = document.getElementById(this.target)) : this.target = this.manager.game.canvas,
                    n.disableContextMenu && this.disableContextMenu(),
                    this.enabled && this.target && this.startListeners()
                },
                disableContextMenu: function() {
                    return document.body.addEventListener("contextmenu", function(n) {
                        return n.preventDefault(),
                        !1
                    }),
                    this
                },
                requestPointerLock: function() {
                    if (f.pointerLock) {
                        var n = this.target;
                        n.requestPointerLock = n.requestPointerLock || n.mozRequestPointerLock || n.webkitRequestPointerLock,
                        n.requestPointerLock()
                    }
                },
                releasePointerLock: function() {
                    f.pointerLock && (document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock,
                    document.exitPointerLock())
                },
                startListeners: function() {
                    var n = this.target;
                    if (n) {
                        var s = this
                          , l = this.manager
                          , i = l.canvas
                          , h = window && window.focus && l.game.config.autoFocus;
                        this.onMouseMove = function(d) {
                            !d.defaultPrevented && s.enabled && l && l.enabled && (l.onMouseMove(d),
                            s.preventDefaultMove && d.preventDefault())
                        }
                        ,
                        this.onMouseDown = function(d) {
                            h && window.focus(),
                            !d.defaultPrevented && s.enabled && l && l.enabled && (l.onMouseDown(d),
                            s.preventDefaultDown && d.target === i && d.preventDefault())
                        }
                        ,
                        this.onMouseDownWindow = function(d) {
                            !d.defaultPrevented && s.enabled && l && l.enabled && d.target !== i && l.onMouseDown(d)
                        }
                        ,
                        this.onMouseUp = function(d) {
                            !d.defaultPrevented && s.enabled && l && l.enabled && (l.onMouseUp(d),
                            s.preventDefaultUp && d.target === i && d.preventDefault())
                        }
                        ,
                        this.onMouseUpWindow = function(d) {
                            !d.defaultPrevented && s.enabled && l && l.enabled && d.target !== i && l.onMouseUp(d)
                        }
                        ,
                        this.onMouseOver = function(d) {
                            !d.defaultPrevented && s.enabled && l && l.enabled && l.setCanvasOver(d)
                        }
                        ,
                        this.onMouseOut = function(d) {
                            !d.defaultPrevented && s.enabled && l && l.enabled && l.setCanvasOut(d)
                        }
                        ,
                        this.onMouseWheel = function(d) {
                            !d.defaultPrevented && s.enabled && l && l.enabled && l.onMouseWheel(d),
                            s.preventDefaultWheel && d.target === i && d.preventDefault()
                        }
                        ;
                        var u = {
                            passive: !0
                        };
                        if (n.addEventListener("mousemove", this.onMouseMove),
                        n.addEventListener("mousedown", this.onMouseDown),
                        n.addEventListener("mouseup", this.onMouseUp),
                        n.addEventListener("mouseover", this.onMouseOver, u),
                        n.addEventListener("mouseout", this.onMouseOut, u),
                        this.preventDefaultWheel ? n.addEventListener("wheel", this.onMouseWheel, {
                            passive: !1
                        }) : n.addEventListener("wheel", this.onMouseWheel, u),
                        window && l.game.config.inputWindowEvents)
                            try {
                                window.top.addEventListener("mousedown", this.onMouseDownWindow, u),
                                window.top.addEventListener("mouseup", this.onMouseUpWindow, u)
                            } catch {
                                window.addEventListener("mousedown", this.onMouseDownWindow, u),
                                window.addEventListener("mouseup", this.onMouseUpWindow, u),
                                this.isTop = !1
                            }
                        f.pointerLock && (this.pointerLockChange = function(d) {
                            var v = s.target;
                            s.locked = document.pointerLockElement === v || document.mozPointerLockElement === v || document.webkitPointerLockElement === v,
                            l.onPointerLockChange(d)
                        }
                        ,
                        document.addEventListener("pointerlockchange", this.pointerLockChange, !0),
                        document.addEventListener("mozpointerlockchange", this.pointerLockChange, !0),
                        document.addEventListener("webkitpointerlockchange", this.pointerLockChange, !0)),
                        this.enabled = !0
                    }
                },
                stopListeners: function() {
                    var n = this.target;
                    n.removeEventListener("mousemove", this.onMouseMove),
                    n.removeEventListener("mousedown", this.onMouseDown),
                    n.removeEventListener("mouseup", this.onMouseUp),
                    n.removeEventListener("mouseover", this.onMouseOver),
                    n.removeEventListener("mouseout", this.onMouseOut),
                    window && (n = this.isTop ? window.top : window,
                    n.removeEventListener("mousedown", this.onMouseDownWindow),
                    n.removeEventListener("mouseup", this.onMouseUpWindow)),
                    f.pointerLock && (document.removeEventListener("pointerlockchange", this.pointerLockChange, !0),
                    document.removeEventListener("mozpointerlockchange", this.pointerLockChange, !0),
                    document.removeEventListener("webkitpointerlockchange", this.pointerLockChange, !0))
                },
                destroy: function() {
                    this.stopListeners(),
                    this.target = null,
                    this.enabled = !1,
                    this.manager = null
                }
            });
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(349)
              , f = t(0)
              , r = t(50)
              , o = t(124)
              , a = t(360)
              , n = t(3)
              , s = t(105)
              , l = new f({
                initialize: function(h, u) {
                    this.manager = h,
                    this.id = u,
                    this.event,
                    this.downElement,
                    this.upElement,
                    this.camera = null,
                    this.button = 0,
                    this.buttons = 0,
                    this.position = new n,
                    this.prevPosition = new n,
                    this.midPoint = new n(-1,-1),
                    this.velocity = new n,
                    this.angle = 0,
                    this.distance = 0,
                    this.smoothFactor = 0,
                    this.motionFactor = .2,
                    this.worldX = 0,
                    this.worldY = 0,
                    this.moveTime = 0,
                    this.downX = 0,
                    this.downY = 0,
                    this.downTime = 0,
                    this.upX = 0,
                    this.upY = 0,
                    this.upTime = 0,
                    this.primaryDown = !1,
                    this.isDown = !1,
                    this.wasTouch = !1,
                    this.wasCanceled = !1,
                    this.movementX = 0,
                    this.movementY = 0,
                    this.identifier = 0,
                    this.pointerId = null,
                    this.active = u === 0,
                    this.locked = !1,
                    this.deltaX = 0,
                    this.deltaY = 0,
                    this.deltaZ = 0
                },
                updateWorldPoint: function(i) {
                    var h = i.getWorldPoint(this.x, this.y);
                    return this.worldX = h.x,
                    this.worldY = h.y,
                    this
                },
                positionToCamera: function(i, h) {
                    return i.getWorldPoint(this.x, this.y, h)
                },
                updateMotion: function() {
                    var i = this.position.x
                      , h = this.position.y
                      , u = this.midPoint.x
                      , d = this.midPoint.y;
                    if (!(i === u && h === d)) {
                        var v = a(this.motionFactor, u, i)
                          , p = a(this.motionFactor, d, h);
                        o(v, i, .1) && (v = i),
                        o(p, h, .1) && (p = h),
                        this.midPoint.set(v, p);
                        var g = i - v
                          , m = h - p;
                        this.velocity.set(g, m),
                        this.angle = e(v, p, i, h),
                        this.distance = Math.sqrt(g * g + m * m)
                    }
                },
                up: function(i) {
                    "buttons"in i && (this.buttons = i.buttons),
                    this.event = i,
                    this.button = i.button,
                    this.upElement = i.target,
                    this.manager.transformPointer(this, i.pageX, i.pageY, !1),
                    i.button === 0 && (this.primaryDown = !1,
                    this.upX = this.x,
                    this.upY = this.y),
                    this.buttons === 0 && (this.isDown = !1,
                    this.upTime = i.timeStamp,
                    this.wasTouch = !1)
                },
                down: function(i) {
                    "buttons"in i && (this.buttons = i.buttons),
                    this.event = i,
                    this.button = i.button,
                    this.downElement = i.target,
                    this.manager.transformPointer(this, i.pageX, i.pageY, !1),
                    i.button === 0 && (this.primaryDown = !0,
                    this.downX = this.x,
                    this.downY = this.y),
                    s.macOS && i.ctrlKey && (this.buttons = 2,
                    this.primaryDown = !1),
                    this.isDown || (this.isDown = !0,
                    this.downTime = i.timeStamp),
                    this.wasTouch = !1
                },
                move: function(i) {
                    "buttons"in i && (this.buttons = i.buttons),
                    this.event = i,
                    this.manager.transformPointer(this, i.pageX, i.pageY, !0),
                    this.locked && (this.movementX = i.movementX || i.mozMovementX || i.webkitMovementX || 0,
                    this.movementY = i.movementY || i.mozMovementY || i.webkitMovementY || 0),
                    this.moveTime = i.timeStamp,
                    this.wasTouch = !1
                },
                wheel: function(i) {
                    "buttons"in i && (this.buttons = i.buttons),
                    this.event = i,
                    this.manager.transformPointer(this, i.pageX, i.pageY, !1),
                    this.deltaX = i.deltaX,
                    this.deltaY = i.deltaY,
                    this.deltaZ = i.deltaZ,
                    this.wasTouch = !1
                },
                touchstart: function(i, h) {
                    i.pointerId && (this.pointerId = i.pointerId),
                    this.identifier = i.identifier,
                    this.target = i.target,
                    this.active = !0,
                    this.buttons = 1,
                    this.event = h,
                    this.downElement = i.target,
                    this.manager.transformPointer(this, i.pageX, i.pageY, !1),
                    this.primaryDown = !0,
                    this.downX = this.x,
                    this.downY = this.y,
                    this.downTime = h.timeStamp,
                    this.isDown = !0,
                    this.wasTouch = !0,
                    this.wasCanceled = !1,
                    this.updateMotion()
                },
                touchmove: function(i, h) {
                    this.event = h,
                    this.manager.transformPointer(this, i.pageX, i.pageY, !0),
                    this.moveTime = h.timeStamp,
                    this.wasTouch = !0,
                    this.updateMotion()
                },
                touchend: function(i, h) {
                    this.buttons = 0,
                    this.event = h,
                    this.upElement = i.target,
                    this.manager.transformPointer(this, i.pageX, i.pageY, !1),
                    this.primaryDown = !1,
                    this.upX = this.x,
                    this.upY = this.y,
                    this.upTime = h.timeStamp,
                    this.isDown = !1,
                    this.wasTouch = !0,
                    this.wasCanceled = !1,
                    this.active = !1,
                    this.updateMotion()
                },
                touchcancel: function(i, h) {
                    this.buttons = 0,
                    this.event = h,
                    this.upElement = i.target,
                    this.manager.transformPointer(this, i.pageX, i.pageY, !1),
                    this.primaryDown = !1,
                    this.upX = this.x,
                    this.upY = this.y,
                    this.upTime = h.timeStamp,
                    this.isDown = !1,
                    this.wasTouch = !0,
                    this.wasCanceled = !0,
                    this.active = !1
                },
                noButtonDown: function() {
                    return this.buttons === 0
                },
                leftButtonDown: function() {
                    return !!(this.buttons & 1)
                },
                rightButtonDown: function() {
                    return !!(this.buttons & 2)
                },
                middleButtonDown: function() {
                    return !!(this.buttons & 4)
                },
                backButtonDown: function() {
                    return !!(this.buttons & 8)
                },
                forwardButtonDown: function() {
                    return !!(this.buttons & 16)
                },
                leftButtonReleased: function() {
                    return this.button === 0 && !this.isDown
                },
                rightButtonReleased: function() {
                    return this.button === 2 && !this.isDown
                },
                middleButtonReleased: function() {
                    return this.button === 1 && !this.isDown
                },
                backButtonReleased: function() {
                    return this.button === 3 && !this.isDown
                },
                forwardButtonReleased: function() {
                    return this.button === 4 && !this.isDown
                },
                getDistance: function() {
                    return this.isDown ? r(this.downX, this.downY, this.x, this.y) : r(this.downX, this.downY, this.upX, this.upY)
                },
                getDistanceX: function() {
                    return this.isDown ? Math.abs(this.downX - this.x) : Math.abs(this.downX - this.upX)
                },
                getDistanceY: function() {
                    return this.isDown ? Math.abs(this.downY - this.y) : Math.abs(this.downY - this.upY)
                },
                getDuration: function() {
                    return this.isDown ? this.manager.time - this.downTime : this.upTime - this.downTime
                },
                getAngle: function() {
                    return this.isDown ? e(this.downX, this.downY, this.x, this.y) : e(this.downX, this.downY, this.upX, this.upY)
                },
                getInterpolatedPosition: function(i, h) {
                    i === void 0 && (i = 10),
                    h === void 0 && (h = []);
                    for (var u = this.prevPosition.x, d = this.prevPosition.y, v = this.position.x, p = this.position.y, g = 0; g < i; g++) {
                        var m = 1 / i * g;
                        h[g] = {
                            x: a(m, u, v),
                            y: a(m, d, p)
                        }
                    }
                    return h
                },
                destroy: function() {
                    this.camera = null,
                    this.manager = null,
                    this.position = null
                },
                x: {
                    get: function() {
                        return this.position.x
                    },
                    set: function(i) {
                        this.position.x = i
                    }
                },
                y: {
                    get: function() {
                        return this.position.y
                    },
                    set: function(i) {
                        this.position.y = i
                    }
                },
                time: {
                    get: function() {
                        return this.event ? this.event.timeStamp : 0
                    }
                }
            });
            c.exports = l
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(51)
              , r = t(1)
              , o = new e({
                initialize: function(n) {
                    this.manager = n,
                    this.capture = !0,
                    this.enabled = !1,
                    this.target,
                    this.onTouchStart = r,
                    this.onTouchStartWindow = r,
                    this.onTouchMove = r,
                    this.onTouchEnd = r,
                    this.onTouchEndWindow = r,
                    this.onTouchCancel = r,
                    this.onTouchCancelWindow = r,
                    this.onTouchOver = r,
                    this.onTouchOut = r,
                    n.events.once(f.MANAGER_BOOT, this.boot, this)
                },
                boot: function() {
                    var a = this.manager.config;
                    this.enabled = a.inputTouch,
                    this.target = a.inputTouchEventTarget,
                    this.capture = a.inputTouchCapture,
                    this.target || (this.target = this.manager.game.canvas),
                    a.disableContextMenu && this.disableContextMenu(),
                    this.enabled && this.target && this.startListeners()
                },
                disableContextMenu: function() {
                    return document.body.addEventListener("contextmenu", function(a) {
                        return a.preventDefault(),
                        !1
                    }),
                    this
                },
                startListeners: function() {
                    var a = this
                      , n = this.manager.canvas
                      , s = window && window.focus && this.manager.game.config.autoFocus;
                    this.onTouchStart = function(u) {
                        s && window.focus(),
                        !u.defaultPrevented && a.enabled && a.manager && a.manager.enabled && (a.manager.onTouchStart(u),
                        a.capture && u.cancelable && u.target === n && u.preventDefault())
                    }
                    ,
                    this.onTouchStartWindow = function(u) {
                        !u.defaultPrevented && a.enabled && a.manager && a.manager.enabled && u.target !== n && a.manager.onTouchStart(u)
                    }
                    ,
                    this.onTouchMove = function(u) {
                        !u.defaultPrevented && a.enabled && a.manager && a.manager.enabled && (a.manager.onTouchMove(u),
                        a.capture && u.cancelable && u.preventDefault())
                    }
                    ,
                    this.onTouchEnd = function(u) {
                        !u.defaultPrevented && a.enabled && a.manager && a.manager.enabled && (a.manager.onTouchEnd(u),
                        a.capture && u.cancelable && u.target === n && u.preventDefault())
                    }
                    ,
                    this.onTouchEndWindow = function(u) {
                        !u.defaultPrevented && a.enabled && a.manager && a.manager.enabled && u.target !== n && a.manager.onTouchEnd(u)
                    }
                    ,
                    this.onTouchCancel = function(u) {
                        !u.defaultPrevented && a.enabled && a.manager && a.manager.enabled && (a.manager.onTouchCancel(u),
                        a.capture && u.preventDefault())
                    }
                    ,
                    this.onTouchCancelWindow = function(u) {
                        !u.defaultPrevented && a.enabled && a.manager && a.manager.enabled && a.manager.onTouchCancel(u)
                    }
                    ,
                    this.onTouchOver = function(u) {
                        !u.defaultPrevented && a.enabled && a.manager && a.manager.enabled && a.manager.setCanvasOver(u)
                    }
                    ,
                    this.onTouchOut = function(u) {
                        !u.defaultPrevented && a.enabled && a.manager && a.manager.enabled && a.manager.setCanvasOut(u)
                    }
                    ;
                    var l = this.target;
                    if (l) {
                        var i = {
                            passive: !0
                        }
                          , h = {
                            passive: !1
                        };
                        l.addEventListener("touchstart", this.onTouchStart, this.capture ? h : i),
                        l.addEventListener("touchmove", this.onTouchMove, this.capture ? h : i),
                        l.addEventListener("touchend", this.onTouchEnd, this.capture ? h : i),
                        l.addEventListener("touchcancel", this.onTouchCancel, this.capture ? h : i),
                        l.addEventListener("touchover", this.onTouchOver, this.capture ? h : i),
                        l.addEventListener("touchout", this.onTouchOut, this.capture ? h : i),
                        window && this.manager.game.config.inputWindowEvents && (window.addEventListener("touchstart", this.onTouchStartWindow, h),
                        window.addEventListener("touchend", this.onTouchEndWindow, h),
                        window.addEventListener("touchcancel", this.onTouchCancelWindow, h)),
                        this.enabled = !0
                    }
                },
                stopListeners: function() {
                    var a = this.target;
                    a.removeEventListener("touchstart", this.onTouchStart),
                    a.removeEventListener("touchmove", this.onTouchMove),
                    a.removeEventListener("touchend", this.onTouchEnd),
                    a.removeEventListener("touchcancel", this.onTouchCancel),
                    a.removeEventListener("touchover", this.onTouchOver),
                    a.removeEventListener("touchout", this.onTouchOut),
                    window && (window.removeEventListener("touchstart", this.onTouchStartWindow),
                    window.removeEventListener("touchend", this.onTouchEndWindow))
                },
                destroy: function() {
                    this.stopListeners(),
                    this.target = null,
                    this.enabled = !1,
                    this.manager = null
                }
            });
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(22)
              , r = t(9)
              , o = t(8)
              , a = t(16)
              , n = t(5)
              , s = t(2)
              , l = t(24)
              , i = t(93)
              , h = new e({
                Extends: r,
                initialize: function(d) {
                    r.call(this),
                    this.game = d,
                    this.plugins = [],
                    this.scenePlugins = [],
                    this._pendingGlobal = [],
                    this._pendingScene = [],
                    d.isBooted ? this.boot() : d.events.once(f.BOOT, this.boot, this)
                },
                boot: function() {
                    var u, d, v, p, g, m, x, T = this.game.config, E = T.installGlobalPlugins;
                    for (E = E.concat(this._pendingGlobal),
                    u = 0; u < E.length; u++)
                        d = E[u],
                        v = s(d, "key", null),
                        p = s(d, "plugin", null),
                        g = s(d, "start", !1),
                        m = s(d, "mapping", null),
                        x = s(d, "data", null),
                        v && (p ? this.install(v, p, g, m, x) : console.warn("Missing `plugin` for key: " + v));
                    for (E = T.installScenePlugins,
                    E = E.concat(this._pendingScene),
                    u = 0; u < E.length; u++)
                        d = E[u],
                        v = s(d, "key", null),
                        p = s(d, "plugin", null),
                        m = s(d, "mapping", null),
                        v && (p ? this.installScenePlugin(v, p, m) : console.warn("Missing `plugin` for key: " + v));
                    this._pendingGlobal = [],
                    this._pendingScene = [],
                    this.game.events.once(f.DESTROY, this.destroy, this)
                },
                addToScene: function(u, d, v) {
                    var p, g, m, x = this.game, T = u.scene, E = u.settings.map, P = u.settings.isBooted;
                    for (p = 0; p < d.length; p++)
                        g = d[p],
                        x[g] ? (u[g] = x[g],
                        E.hasOwnProperty(g) && (T[E[g]] = u[g])) : g === "game" && E.hasOwnProperty(g) && (T[E[g]] = x);
                    for (var M = 0; M < v.length; M++)
                        for (m = v[M],
                        p = 0; p < m.length; p++)
                            if (g = m[p],
                            !!l.hasCore(g)) {
                                var L = l.getCore(g)
                                  , R = L.mapping
                                  , O = new L.plugin(T,this,R);
                                u[R] = O,
                                L.custom ? T[R] = O : E.hasOwnProperty(R) && (T[E[R]] = O),
                                P && O.boot()
                            }
                    for (m = this.plugins,
                    p = 0; p < m.length; p++) {
                        var F = m[p];
                        F.mapping && (T[F.mapping] = F.plugin)
                    }
                },
                getDefaultScenePlugins: function() {
                    var u = this.game.config.defaultPlugins;
                    return u = u.concat(this.scenePlugins),
                    u
                },
                installScenePlugin: function(u, d, v, p, g) {
                    if (g === void 0 && (g = !1),
                    typeof d != "function") {
                        console.warn("Invalid Scene Plugin: " + u);
                        return
                    }
                    if (!l.hasCore(u))
                        l.register(u, d, v, !0),
                        this.scenePlugins.push(u);
                    else if (!g && l.hasCore(u)) {
                        console.warn("Scene Plugin key in use: " + u);
                        return
                    }
                    if (p) {
                        var m = new d(p,this,u);
                        p.sys[u] = m,
                        v && v !== "" && (p[v] = m),
                        m.boot()
                    }
                },
                install: function(u, d, v, p, g) {
                    if (v === void 0 && (v = !1),
                    p === void 0 && (p = null),
                    g === void 0 && (g = null),
                    typeof d != "function")
                        return console.warn("Invalid Plugin: " + u),
                        null;
                    if (l.hasCustom(u))
                        return console.warn("Plugin key in use: " + u),
                        null;
                    if (p !== null && (v = !0),
                    !this.game.isBooted)
                        this._pendingGlobal.push({
                            key: u,
                            plugin: d,
                            start: v,
                            mapping: p,
                            data: g
                        });
                    else if (l.registerCustom(u, d, p, g),
                    v)
                        return this.start(u);
                    return null
                },
                getIndex: function(u) {
                    for (var d = this.plugins, v = 0; v < d.length; v++) {
                        var p = d[v];
                        if (p.key === u)
                            return v
                    }
                    return -1
                },
                getEntry: function(u) {
                    var d = this.getIndex(u);
                    if (d !== -1)
                        return this.plugins[d]
                },
                isActive: function(u) {
                    var d = this.getEntry(u);
                    return d && d.active
                },
                start: function(u, d) {
                    d === void 0 && (d = u);
                    var v = this.getEntry(d);
                    return v && !v.active ? (v.active = !0,
                    v.plugin.start()) : v || (v = this.createEntry(u, d)),
                    v ? v.plugin : null
                },
                createEntry: function(u, d) {
                    var v = l.getCustom(u);
                    if (v) {
                        var p = new v.plugin(this);
                        v = {
                            key: d,
                            plugin: p,
                            active: !0,
                            mapping: v.mapping,
                            data: v.data
                        },
                        this.plugins.push(v),
                        p.init(v.data),
                        p.start()
                    }
                    return v
                },
                stop: function(u) {
                    var d = this.getEntry(u);
                    return d && d.active && (d.active = !1,
                    d.plugin.stop()),
                    this
                },
                get: function(u, d) {
                    d === void 0 && (d = !0);
                    var v = this.getEntry(u);
                    if (v)
                        return v.plugin;
                    var p = this.getClass(u);
                    return p && d ? (v = this.createEntry(u, u),
                    v ? v.plugin : null) : p || null
                },
                getClass: function(u) {
                    return l.getCustomClass(u)
                },
                removeGlobalPlugin: function(u) {
                    var d = this.getEntry(u);
                    d && i(this.plugins, d),
                    l.removeCustom(u)
                },
                removeScenePlugin: function(u) {
                    i(this.scenePlugins, u),
                    l.remove(u)
                },
                registerGameObject: function(u, d, v) {
                    return d && n.register(u, d),
                    v && a.register(u, v),
                    this
                },
                removeGameObject: function(u, d, v) {
                    return d === void 0 && (d = !0),
                    v === void 0 && (v = !0),
                    d && n.remove(u),
                    v && a.remove(u),
                    this
                },
                registerFileType: function(u, d, v) {
                    o.register(u, d),
                    v && v.sys.load && (v.sys.load[u] = d)
                },
                destroy: function() {
                    for (var u = 0; u < this.plugins.length; u++)
                        this.plugins[u].plugin.destroy();
                    l.destroyCustomPlugins(),
                    this.game.noReturn && l.destroyCorePlugins(),
                    this.game = null,
                    this.plugins = [],
                    this.scenePlugins = []
                }
            });
            c.exports = h
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(201)
              , f = t(0)
              , r = t(9)
              , o = t(104)
              , a = t(22)
              , n = t(401)
              , s = t(407)
              , l = t(402)
              , i = t(1)
              , h = t(10)
              , u = t(416)
              , d = t(76)
              , v = t(3)
              , p = new f({
                Extends: r,
                initialize: function(m) {
                    r.call(this),
                    this.game = m,
                    this.canvas,
                    this.canvasBounds = new h,
                    this.parent = null,
                    this.parentIsWindow = !1,
                    this.parentSize = new u,
                    this.gameSize = new u,
                    this.baseSize = new u,
                    this.displaySize = new u,
                    this.scaleMode = e.SCALE_MODE.NONE,
                    this.zoom = 1,
                    this._resetZoom = !1,
                    this.displayScale = new v(1,1),
                    this.autoRound = !1,
                    this.autoCenter = e.CENTER.NO_CENTER,
                    this.orientation = e.ORIENTATION.LANDSCAPE,
                    this.fullscreen,
                    this.fullscreenTarget = null,
                    this._createdFullscreenTarget = !1,
                    this.dirty = !1,
                    this.resizeInterval = 500,
                    this._lastCheck = 0,
                    this._checkOrientation = !1,
                    this.listeners = {
                        orientationChange: i,
                        windowResize: i,
                        fullScreenChange: i,
                        fullScreenError: i
                    }
                },
                preBoot: function() {
                    this.parseConfig(this.game.config),
                    this.game.events.once(a.BOOT, this.boot, this)
                },
                boot: function() {
                    var g = this.game;
                    this.canvas = g.canvas,
                    this.fullscreen = g.device.fullscreen,
                    this.scaleMode !== e.SCALE_MODE.RESIZE && this.displaySize.setAspectMode(this.scaleMode),
                    this.scaleMode === e.SCALE_MODE.NONE ? this.resize(this.width, this.height) : (this.getParentBounds(),
                    this.parentSize.width > 0 && this.parentSize.height > 0 && this.displaySize.setParent(this.parentSize),
                    this.refresh()),
                    g.events.on(a.PRE_STEP, this.step, this),
                    g.events.once(a.READY, this.refresh, this),
                    g.events.once(a.DESTROY, this.destroy, this),
                    this.startListeners()
                },
                parseConfig: function(g) {
                    this.getParent(g),
                    this.getParentBounds();
                    var m = g.width
                      , x = g.height
                      , T = g.scaleMode
                      , E = g.zoom
                      , P = g.autoRound;
                    if (typeof m == "string") {
                        var M = this.parentSize.width;
                        M === 0 && (M = window.innerWidth);
                        var L = parseInt(m, 10) / 100;
                        m = Math.floor(M * L)
                    }
                    if (typeof x == "string") {
                        var R = this.parentSize.height;
                        R === 0 && (R = window.innerHeight);
                        var O = parseInt(x, 10) / 100;
                        x = Math.floor(R * O)
                    }
                    this.scaleMode = T,
                    this.autoRound = P,
                    this.autoCenter = g.autoCenter,
                    this.resizeInterval = g.resizeInterval,
                    P && (m = Math.floor(m),
                    x = Math.floor(x)),
                    this.gameSize.setSize(m, x),
                    E === e.ZOOM.MAX_ZOOM && (E = this.getMaxZoom()),
                    this.zoom = E,
                    E !== 1 && (this._resetZoom = !0),
                    this.baseSize.setSize(m, x),
                    P && (this.baseSize.width = Math.floor(this.baseSize.width),
                    this.baseSize.height = Math.floor(this.baseSize.height)),
                    g.minWidth > 0 && this.displaySize.setMin(g.minWidth * E, g.minHeight * E),
                    g.maxWidth > 0 && this.displaySize.setMax(g.maxWidth * E, g.maxHeight * E),
                    this.displaySize.setSize(m, x),
                    this.orientation = l(m, x)
                },
                getParent: function(g) {
                    var m = g.parent;
                    if (m !== null) {
                        if (this.parent = s(m),
                        this.parentIsWindow = this.parent === document.body,
                        g.expandParent && g.scaleMode !== e.SCALE_MODE.NONE) {
                            var x = this.parent.getBoundingClientRect();
                            (this.parentIsWindow || x.height === 0) && (document.documentElement.style.height = "100%",
                            document.body.style.height = "100%",
                            x = this.parent.getBoundingClientRect(),
                            !this.parentIsWindow && x.height === 0 && (this.parent.style.overflow = "hidden",
                            this.parent.style.width = "100%",
                            this.parent.style.height = "100%"))
                        }
                        g.fullscreenTarget && !this.fullscreenTarget && (this.fullscreenTarget = s(g.fullscreenTarget))
                    }
                },
                getParentBounds: function() {
                    if (!this.parent)
                        return !1;
                    var g = this.parentSize
                      , m = this.parent.getBoundingClientRect();
                    this.parentIsWindow && this.game.device.os.iOS && (m.height = n(!0));
                    var x = m.width
                      , T = m.height;
                    return g.width !== x || g.height !== T ? (g.setSize(x, T),
                    !0) : !1
                },
                lockOrientation: function(g) {
                    var m = screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation;
                    return m ? m.call(screen, g) : !1
                },
                setParentSize: function(g, m) {
                    return this.parentSize.setSize(g, m),
                    this.refresh()
                },
                setGameSize: function(g, m) {
                    var x = this.autoRound;
                    x && (g = Math.floor(g),
                    m = Math.floor(m));
                    var T = this.width
                      , E = this.height;
                    return this.gameSize.resize(g, m),
                    this.baseSize.resize(g, m),
                    x && (this.baseSize.width = Math.floor(this.baseSize.width),
                    this.baseSize.height = Math.floor(this.baseSize.height)),
                    this.displaySize.setAspectRatio(g / m),
                    this.canvas.width = this.baseSize.width,
                    this.canvas.height = this.baseSize.height,
                    this.refresh(T, E)
                },
                resize: function(g, m) {
                    var x = this.zoom
                      , T = this.autoRound;
                    T && (g = Math.floor(g),
                    m = Math.floor(m));
                    var E = this.width
                      , P = this.height;
                    this.gameSize.resize(g, m),
                    this.baseSize.resize(g, m),
                    T && (this.baseSize.width = Math.floor(this.baseSize.width),
                    this.baseSize.height = Math.floor(this.baseSize.height)),
                    this.displaySize.setSize(g * x, m * x),
                    this.canvas.width = this.baseSize.width,
                    this.canvas.height = this.baseSize.height;
                    var M = this.canvas.style
                      , L = g * x
                      , R = m * x;
                    return T && (L = Math.floor(L),
                    R = Math.floor(R)),
                    (L !== g || R !== m) && (M.width = L + "px",
                    M.height = R + "px"),
                    this.refresh(E, P)
                },
                setZoom: function(g) {
                    return this.zoom = g,
                    this._resetZoom = !0,
                    this.refresh()
                },
                setMaxZoom: function() {
                    return this.zoom = this.getMaxZoom(),
                    this._resetZoom = !0,
                    this.refresh()
                },
                refresh: function(g, m) {
                    g === void 0 && (g = this.width),
                    m === void 0 && (m = this.height),
                    this.updateScale(),
                    this.updateBounds(),
                    this.updateOrientation(),
                    this.displayScale.set(this.baseSize.width / this.canvasBounds.width, this.baseSize.height / this.canvasBounds.height);
                    var x = this.game.domContainer;
                    if (x) {
                        this.baseSize.setCSS(x);
                        var T = this.canvas.style
                          , E = x.style;
                        E.transform = "scale(" + this.displaySize.width / this.baseSize.width + "," + this.displaySize.height / this.baseSize.height + ")",
                        E.marginLeft = T.marginLeft,
                        E.marginTop = T.marginTop
                    }
                    return this.emit(o.RESIZE, this.gameSize, this.baseSize, this.displaySize, g, m),
                    this
                },
                updateOrientation: function() {
                    if (this._checkOrientation) {
                        this._checkOrientation = !1;
                        var g = l(this.width, this.height);
                        g !== this.orientation && (this.orientation = g,
                        this.emit(o.ORIENTATION_CHANGE, g))
                    }
                },
                updateScale: function() {
                    var g = this.canvas.style, m = this.gameSize.width, x = this.gameSize.height, T, E, P = this.zoom, M = this.autoRound;
                    this.scaleMode === e.SCALE_MODE.NONE ? (this.displaySize.setSize(m * P, x * P),
                    T = this.displaySize.width,
                    E = this.displaySize.height,
                    M && (T = Math.floor(T),
                    E = Math.floor(E)),
                    this._resetZoom && (g.width = T + "px",
                    g.height = E + "px",
                    this._resetZoom = !1)) : this.scaleMode === e.SCALE_MODE.RESIZE ? (this.displaySize.setSize(this.parentSize.width, this.parentSize.height),
                    this.gameSize.setSize(this.displaySize.width, this.displaySize.height),
                    this.baseSize.setSize(this.displaySize.width, this.displaySize.height),
                    T = this.displaySize.width,
                    E = this.displaySize.height,
                    M && (T = Math.floor(T),
                    E = Math.floor(E)),
                    this.canvas.width = T,
                    this.canvas.height = E) : (this.displaySize.setSize(this.parentSize.width, this.parentSize.height),
                    T = this.displaySize.width,
                    E = this.displaySize.height,
                    M && (T = Math.floor(T),
                    E = Math.floor(E)),
                    g.width = T + "px",
                    g.height = E + "px"),
                    this.getParentBounds(),
                    this.updateCenter()
                },
                getMaxZoom: function() {
                    var g = d(this.parentSize.width, this.gameSize.width, 0, !0)
                      , m = d(this.parentSize.height, this.gameSize.height, 0, !0);
                    return Math.max(Math.min(g, m), 1)
                },
                updateCenter: function() {
                    var g = this.autoCenter;
                    if (g !== e.CENTER.NO_CENTER) {
                        var m = this.canvas
                          , x = m.style
                          , T = m.getBoundingClientRect()
                          , E = T.width
                          , P = T.height
                          , M = Math.floor((this.parentSize.width - E) / 2)
                          , L = Math.floor((this.parentSize.height - P) / 2);
                        g === e.CENTER.CENTER_HORIZONTALLY ? L = 0 : g === e.CENTER.CENTER_VERTICALLY && (M = 0),
                        x.marginLeft = M + "px",
                        x.marginTop = L + "px"
                    }
                },
                updateBounds: function() {
                    var g = this.canvasBounds
                      , m = this.canvas.getBoundingClientRect();
                    g.x = m.left + (window.pageXOffset || 0) - (document.documentElement.clientLeft || 0),
                    g.y = m.top + (window.pageYOffset || 0) - (document.documentElement.clientTop || 0),
                    g.width = m.width,
                    g.height = m.height
                },
                transformX: function(g) {
                    return (g - this.canvasBounds.left) * this.displayScale.x
                },
                transformY: function(g) {
                    return (g - this.canvasBounds.top) * this.displayScale.y
                },
                startFullscreen: function(g) {
                    g === void 0 && (g = {
                        navigationUI: "hide"
                    });
                    var m = this.fullscreen;
                    if (!m.available) {
                        this.emit(o.FULLSCREEN_UNSUPPORTED);
                        return
                    }
                    if (!m.active) {
                        var x = this.getFullscreenTarget();
                        m.keyboard ? x[m.request](Element.ALLOW_KEYBOARD_INPUT) : x[m.request](g)
                    }
                },
                fullscreenSuccessHandler: function() {
                    this.getParentBounds(),
                    this.refresh(),
                    this.emit(o.ENTER_FULLSCREEN)
                },
                fullscreenErrorHandler: function(g) {
                    this.removeFullscreenTarget(),
                    this.emit(o.FULLSCREEN_FAILED, g)
                },
                getFullscreenTarget: function() {
                    if (!this.fullscreenTarget) {
                        var g = document.createElement("div");
                        g.style.margin = "0",
                        g.style.padding = "0",
                        g.style.width = "100%",
                        g.style.height = "100%",
                        this.fullscreenTarget = g,
                        this._createdFullscreenTarget = !0
                    }
                    if (this._createdFullscreenTarget) {
                        var m = this.canvas.parentNode;
                        m.insertBefore(this.fullscreenTarget, this.canvas),
                        this.fullscreenTarget.appendChild(this.canvas)
                    }
                    return this.fullscreenTarget
                },
                removeFullscreenTarget: function() {
                    if (this._createdFullscreenTarget) {
                        var g = this.fullscreenTarget;
                        if (g && g.parentNode) {
                            var m = g.parentNode;
                            m.insertBefore(this.canvas, g),
                            m.removeChild(g)
                        }
                    }
                },
                stopFullscreen: function() {
                    var g = this.fullscreen;
                    if (!g.available)
                        return this.emit(o.FULLSCREEN_UNSUPPORTED),
                        !1;
                    g.active && document[g.cancel](),
                    this.removeFullscreenTarget(),
                    this.getParentBounds(),
                    this.emit(o.LEAVE_FULLSCREEN),
                    this.refresh()
                },
                toggleFullscreen: function(g) {
                    this.fullscreen.active ? this.stopFullscreen() : this.startFullscreen(g)
                },
                startListeners: function() {
                    var g = this
                      , m = this.listeners;
                    if (m.orientationChange = function() {
                        g.updateBounds(),
                        g._checkOrientation = !0,
                        g.dirty = !0
                    }
                    ,
                    m.windowResize = function() {
                        g.updateBounds(),
                        g.dirty = !0
                    }
                    ,
                    window.addEventListener("orientationchange", m.orientationChange, !1),
                    window.addEventListener("resize", m.windowResize, !1),
                    this.fullscreen.available) {
                        m.fullScreenChange = function(T) {
                            return g.onFullScreenChange(T)
                        }
                        ,
                        m.fullScreenError = function(T) {
                            return g.onFullScreenError(T)
                        }
                        ;
                        var x = ["webkit", "moz", ""];
                        x.forEach(function(T) {
                            document.addEventListener(T + "fullscreenchange", m.fullScreenChange, !1),
                            document.addEventListener(T + "fullscreenerror", m.fullScreenError, !1)
                        }),
                        document.addEventListener("MSFullscreenChange", m.fullScreenChange, !1),
                        document.addEventListener("MSFullscreenError", m.fullScreenError, !1)
                    }
                },
                onFullScreenChange: function() {
                    document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement || document.mozFullScreenElement ? this.fullscreenSuccessHandler() : this.stopFullscreen()
                },
                onFullScreenError: function() {
                    this.removeFullscreenTarget()
                },
                step: function(g, m) {
                    this.parent && (this._lastCheck += m,
                    (this.dirty || this._lastCheck > this.resizeInterval) && (this.getParentBounds() && this.refresh(),
                    this.dirty = !1,
                    this._lastCheck = 0))
                },
                stopListeners: function() {
                    var g = this.listeners;
                    window.removeEventListener("orientationchange", g.orientationChange, !1),
                    window.removeEventListener("resize", g.windowResize, !1);
                    var m = ["webkit", "moz", ""];
                    m.forEach(function(x) {
                        document.removeEventListener(x + "fullscreenchange", g.fullScreenChange, !1),
                        document.removeEventListener(x + "fullscreenerror", g.fullScreenError, !1)
                    }),
                    document.removeEventListener("MSFullscreenChange", g.fullScreenChange, !1),
                    document.removeEventListener("MSFullscreenError", g.fullScreenError, !1)
                },
                destroy: function() {
                    this.removeAllListeners(),
                    this.stopListeners(),
                    this.game = null,
                    this.canvas = null,
                    this.canvasBounds = null,
                    this.parent = null,
                    this.fullscreenTarget = null,
                    this.parentSize.destroy(),
                    this.gameSize.destroy(),
                    this.baseSize.destroy(),
                    this.displaySize.destroy()
                },
                isFullscreen: {
                    get: function() {
                        return this.fullscreen.active
                    }
                },
                width: {
                    get: function() {
                        return this.gameSize.width
                    }
                },
                height: {
                    get: function() {
                        return this.gameSize.height
                    }
                },
                isPortrait: {
                    get: function() {
                        return this.orientation === e.ORIENTATION.PORTRAIT
                    }
                },
                isLandscape: {
                    get: function() {
                        return this.orientation === e.ORIENTATION.LANDSCAPE
                    }
                },
                isGamePortrait: {
                    get: function() {
                        return this.height > this.width
                    }
                },
                isGameLandscape: {
                    get: function() {
                        return this.width > this.height
                    }
                }
            });
            c.exports = p
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(18)
              , f = t(0)
              , r = t(76)
              , o = t(3)
              , a = new f({
                initialize: function(s, l, i, h) {
                    s === void 0 && (s = 0),
                    l === void 0 && (l = s),
                    i === void 0 && (i = 0),
                    h === void 0 && (h = null),
                    this._width = s,
                    this._height = l,
                    this._parent = h,
                    this.aspectMode = i,
                    this.aspectRatio = l === 0 ? 1 : s / l,
                    this.minWidth = 0,
                    this.minHeight = 0,
                    this.maxWidth = Number.MAX_VALUE,
                    this.maxHeight = Number.MAX_VALUE,
                    this.snapTo = new o
                },
                setAspectMode: function(n) {
                    return n === void 0 && (n = 0),
                    this.aspectMode = n,
                    this.setSize(this._width, this._height)
                },
                setSnap: function(n, s) {
                    return n === void 0 && (n = 0),
                    s === void 0 && (s = n),
                    this.snapTo.set(n, s),
                    this.setSize(this._width, this._height)
                },
                setParent: function(n) {
                    return this._parent = n,
                    this.setSize(this._width, this._height)
                },
                setMin: function(n, s) {
                    return n === void 0 && (n = 0),
                    s === void 0 && (s = n),
                    this.minWidth = e(n, 0, this.maxWidth),
                    this.minHeight = e(s, 0, this.maxHeight),
                    this.setSize(this._width, this._height)
                },
                setMax: function(n, s) {
                    return n === void 0 && (n = Number.MAX_VALUE),
                    s === void 0 && (s = n),
                    this.maxWidth = e(n, this.minWidth, Number.MAX_VALUE),
                    this.maxHeight = e(s, this.minHeight, Number.MAX_VALUE),
                    this.setSize(this._width, this._height)
                },
                setSize: function(n, s) {
                    switch (n === void 0 && (n = 0),
                    s === void 0 && (s = n),
                    this.aspectMode) {
                    case a.NONE:
                        this._width = this.getNewWidth(r(n, this.snapTo.x)),
                        this._height = this.getNewHeight(r(s, this.snapTo.y)),
                        this.aspectRatio = this._height === 0 ? 1 : this._width / this._height;
                        break;
                    case a.WIDTH_CONTROLS_HEIGHT:
                        this._width = this.getNewWidth(r(n, this.snapTo.x)),
                        this._height = this.getNewHeight(this._width * (1 / this.aspectRatio), !1);
                        break;
                    case a.HEIGHT_CONTROLS_WIDTH:
                        this._height = this.getNewHeight(r(s, this.snapTo.y)),
                        this._width = this.getNewWidth(this._height * this.aspectRatio, !1);
                        break;
                    case a.FIT:
                        this.constrain(n, s, !0);
                        break;
                    case a.ENVELOP:
                        this.constrain(n, s, !1);
                        break
                    }
                    return this
                },
                setAspectRatio: function(n) {
                    return this.aspectRatio = n,
                    this.setSize(this._width, this._height)
                },
                resize: function(n, s) {
                    return this._width = this.getNewWidth(r(n, this.snapTo.x)),
                    this._height = this.getNewHeight(r(s, this.snapTo.y)),
                    this.aspectRatio = this._height === 0 ? 1 : this._width / this._height,
                    this
                },
                getNewWidth: function(n, s) {
                    return s === void 0 && (s = !0),
                    n = e(n, this.minWidth, this.maxWidth),
                    s && this._parent && n > this._parent.width && (n = Math.max(this.minWidth, this._parent.width)),
                    n
                },
                getNewHeight: function(n, s) {
                    return s === void 0 && (s = !0),
                    n = e(n, this.minHeight, this.maxHeight),
                    s && this._parent && n > this._parent.height && (n = Math.max(this.minHeight, this._parent.height)),
                    n
                },
                constrain: function(n, s, l) {
                    n === void 0 && (n = 0),
                    s === void 0 && (s = n),
                    l === void 0 && (l = !0),
                    n = this.getNewWidth(n),
                    s = this.getNewHeight(s);
                    var i = this.snapTo
                      , h = s === 0 ? 1 : n / s;
                    return l && this.aspectRatio > h || !l && this.aspectRatio < h ? (n = r(n, i.x),
                    s = n / this.aspectRatio,
                    i.y > 0 && (s = r(s, i.y),
                    n = s * this.aspectRatio)) : (l && this.aspectRatio < h || !l && this.aspectRatio > h) && (s = r(s, i.y),
                    n = s * this.aspectRatio,
                    i.x > 0 && (n = r(n, i.x),
                    s = n * (1 / this.aspectRatio))),
                    this._width = n,
                    this._height = s,
                    this
                },
                fitTo: function(n, s) {
                    return this.constrain(n, s, !0)
                },
                envelop: function(n, s) {
                    return this.constrain(n, s, !1)
                },
                setWidth: function(n) {
                    return this.setSize(n, this._height)
                },
                setHeight: function(n) {
                    return this.setSize(this._width, n)
                },
                toString: function() {
                    return "[{ Size (width=" + this._width + " height=" + this._height + " aspectRatio=" + this.aspectRatio + " aspectMode=" + this.aspectMode + ") }]"
                },
                setCSS: function(n) {
                    n && n.style && (n.style.width = this._width + "px",
                    n.style.height = this._height + "px")
                },
                copy: function(n) {
                    return n.setAspectMode(this.aspectMode),
                    n.aspectRatio = this.aspectRatio,
                    n.setSize(this.width, this.height)
                },
                destroy: function() {
                    this._parent = null,
                    this.snapTo = null
                },
                width: {
                    get: function() {
                        return this._width
                    },
                    set: function(n) {
                        this.setSize(n, this._height)
                    }
                },
                height: {
                    get: function() {
                        return this._height
                    },
                    set: function(n) {
                        this.setSize(this._width, n)
                    }
                }
            });
            a.NONE = 0,
            a.WIDTH_CONTROLS_HEIGHT = 1,
            a.HEIGHT_CONTROLS_WIDTH = 2,
            a.FIT = 3,
            a.ENVELOP = 4,
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(144)
              , r = t(20)
              , o = t(22)
              , a = t(6)
              , n = t(95)
              , s = t(1)
              , l = t(418)
              , i = t(204)
              , h = new e({
                initialize: function(d, v) {
                    if (this.game = d,
                    this.keys = {},
                    this.scenes = [],
                    this._pending = [],
                    this._start = [],
                    this._queue = [],
                    this._data = {},
                    this.isProcessing = !1,
                    this.isBooted = !1,
                    this.customViewports = 0,
                    v) {
                        Array.isArray(v) || (v = [v]);
                        for (var p = 0; p < v.length; p++)
                            this._pending.push({
                                key: "default",
                                scene: v[p],
                                autoStart: p === 0,
                                data: {}
                            })
                    }
                    d.events.once(o.READY, this.bootQueue, this)
                },
                bootQueue: function() {
                    if (!this.isBooted) {
                        var u, d, v, p;
                        for (u = 0; u < this._pending.length; u++) {
                            d = this._pending[u],
                            v = d.key,
                            p = d.scene;
                            var g;
                            p instanceof l ? g = this.createSceneFromInstance(v, p) : typeof p == "object" ? g = this.createSceneFromObject(v, p) : typeof p == "function" && (g = this.createSceneFromFunction(v, p)),
                            v = g.sys.settings.key,
                            this.keys[v] = g,
                            this.scenes.push(g),
                            this._data[v] && (g.sys.settings.data = this._data[v].data,
                            this._data[v].autoStart && (d.autoStart = !0)),
                            (d.autoStart || g.sys.settings.active) && this._start.push(v)
                        }
                        for (this._pending.length = 0,
                        this._data = {},
                        this.isBooted = !0,
                        u = 0; u < this._start.length; u++)
                            d = this._start[u],
                            this.start(d);
                        this._start.length = 0
                    }
                },
                processQueue: function() {
                    var u = this._pending.length
                      , d = this._queue.length;
                    if (!(u === 0 && d === 0)) {
                        var v, p;
                        if (u) {
                            for (v = 0; v < u; v++)
                                p = this._pending[v],
                                this.add(p.key, p.scene, p.autoStart, p.data);
                            for (v = 0; v < this._start.length; v++)
                                p = this._start[v],
                                this.start(p);
                            this._start.length = 0,
                            this._pending.length = 0;
                            return
                        }
                        for (v = 0; v < this._queue.length; v++)
                            p = this._queue[v],
                            this[p.op](p.keyA, p.keyB);
                        this._queue.length = 0
                    }
                },
                add: function(u, d, v, p) {
                    if (v === void 0 && (v = !1),
                    p === void 0 && (p = {}),
                    this.isProcessing || !this.isBooted)
                        return this._pending.push({
                            key: u,
                            scene: d,
                            autoStart: v,
                            data: p
                        }),
                        this.isBooted || (this._data[u] = {
                            data: p
                        }),
                        null;
                    u = this.getKey(u, d);
                    var g;
                    return d instanceof l ? g = this.createSceneFromInstance(u, d) : typeof d == "object" ? (d.key = u,
                    g = this.createSceneFromObject(u, d)) : typeof d == "function" && (g = this.createSceneFromFunction(u, d)),
                    g.sys.settings.data = p,
                    u = g.sys.settings.key,
                    this.keys[u] = g,
                    this.scenes.push(g),
                    (v || g.sys.settings.active) && (this._pending.length ? this._start.push(u) : this.start(u)),
                    g
                },
                remove: function(u) {
                    if (this.isProcessing)
                        this._queue.push({
                            op: "remove",
                            keyA: u,
                            keyB: null
                        });
                    else {
                        var d = this.getScene(u);
                        if (!d || d.sys.isTransitioning())
                            return this;
                        var v = this.scenes.indexOf(d)
                          , p = d.sys.settings.key;
                        v > -1 && (delete this.keys[p],
                        this.scenes.splice(v, 1),
                        this._start.indexOf(p) > -1 && (v = this._start.indexOf(p),
                        this._start.splice(v, 1)),
                        d.sys.destroy())
                    }
                    return this
                },
                bootScene: function(u) {
                    var d = u.sys
                      , v = d.settings;
                    d.sceneUpdate = s,
                    u.init && (u.init.call(u, v.data),
                    v.status = f.INIT,
                    v.isTransition && d.events.emit(r.TRANSITION_INIT, v.transitionFrom, v.transitionDuration));
                    var p;
                    d.load && (p = d.load,
                    p.reset()),
                    p && u.preload ? (u.preload.call(u),
                    p.list.size === 0 ? this.create(u) : (v.status = f.LOADING,
                    p.once(n.COMPLETE, this.loadComplete, this),
                    p.start())) : this.create(u)
                },
                loadComplete: function(u) {
                    this.create(u.scene)
                },
                payloadComplete: function(u) {
                    this.bootScene(u.scene)
                },
                update: function(u, d) {
                    this.processQueue(),
                    this.isProcessing = !0;
                    for (var v = this.scenes.length - 1; v >= 0; v--) {
                        var p = this.scenes[v].sys;
                        p.settings.status > f.START && p.settings.status <= f.RUNNING && p.step(u, d)
                    }
                },
                render: function(u) {
                    for (var d = 0; d < this.scenes.length; d++) {
                        var v = this.scenes[d].sys;
                        v.settings.visible && v.settings.status >= f.LOADING && v.settings.status < f.SLEEPING && v.render(u)
                    }
                    this.isProcessing = !1
                },
                create: function(u) {
                    var d = u.sys
                      , v = d.settings;
                    u.create && (v.status = f.CREATING,
                    u.create.call(u, v.data),
                    v.status === f.DESTROYED) || (v.isTransition && d.events.emit(r.TRANSITION_START, v.transitionFrom, v.transitionDuration),
                    u.update && (d.sceneUpdate = u.update),
                    v.status = f.RUNNING,
                    d.events.emit(r.CREATE, u))
                },
                createSceneFromFunction: function(u, d) {
                    var v = new d;
                    if (v instanceof l) {
                        var p = v.sys.settings.key;
                        if (p !== "" && (u = p),
                        this.keys.hasOwnProperty(u))
                            throw new Error("Cannot add a Scene with duplicate key: " + u);
                        return this.createSceneFromInstance(u, v)
                    } else
                        return v.sys = new i(v),
                        v.sys.settings.key = u,
                        v.sys.init(this.game),
                        v
                },
                createSceneFromInstance: function(u, d) {
                    var v = d.sys.settings.key;
                    return v === "" && (d.sys.settings.key = u),
                    d.sys.init(this.game),
                    d
                },
                createSceneFromObject: function(u, d) {
                    var v = new l(d)
                      , p = v.sys.settings.key;
                    p !== "" ? u = p : v.sys.settings.key = u,
                    v.sys.init(this.game);
                    for (var g = ["init", "preload", "create", "update", "render"], m = 0; m < g.length; m++) {
                        var x = a(d, g[m], null);
                        x && (v[g[m]] = x)
                    }
                    if (d.hasOwnProperty("extend")) {
                        for (var T in d.extend)
                            if (d.extend.hasOwnProperty(T)) {
                                var E = d.extend[T];
                                T === "data" && v.hasOwnProperty("data") && typeof E == "object" ? v.data.merge(E) : T !== "sys" && (v[T] = E)
                            }
                    }
                    return v
                },
                getKey: function(u, d) {
                    if (u || (u = "default"),
                    typeof d == "function")
                        return u;
                    if (d instanceof l ? u = d.sys.settings.key : typeof d == "object" && d.hasOwnProperty("key") && (u = d.key),
                    this.keys.hasOwnProperty(u))
                        throw new Error("Cannot add a Scene with duplicate key: " + u);
                    return u
                },
                getScenes: function(u, d) {
                    u === void 0 && (u = !0),
                    d === void 0 && (d = !1);
                    for (var v = [], p = this.scenes, g = 0; g < p.length; g++) {
                        var m = p[g];
                        m && (!u || u && m.sys.isActive()) && v.push(m)
                    }
                    return d ? v.reverse() : v
                },
                getScene: function(u) {
                    if (typeof u == "string") {
                        if (this.keys[u])
                            return this.keys[u]
                    } else
                        for (var d = 0; d < this.scenes.length; d++)
                            if (u === this.scenes[d])
                                return u;
                    return null
                },
                isActive: function(u) {
                    var d = this.getScene(u);
                    return d ? d.sys.isActive() : null
                },
                isPaused: function(u) {
                    var d = this.getScene(u);
                    return d ? d.sys.isPaused() : null
                },
                isVisible: function(u) {
                    var d = this.getScene(u);
                    return d ? d.sys.isVisible() : null
                },
                isSleeping: function(u) {
                    var d = this.getScene(u);
                    return d ? d.sys.isSleeping() : null
                },
                pause: function(u, d) {
                    var v = this.getScene(u);
                    return v && v.sys.pause(d),
                    this
                },
                resume: function(u, d) {
                    var v = this.getScene(u);
                    return v && v.sys.resume(d),
                    this
                },
                sleep: function(u, d) {
                    var v = this.getScene(u);
                    return v && !v.sys.isTransitioning() && v.sys.sleep(d),
                    this
                },
                wake: function(u, d) {
                    var v = this.getScene(u);
                    return v && v.sys.wake(d),
                    this
                },
                run: function(u, d) {
                    var v = this.getScene(u);
                    if (!v) {
                        for (var p = 0; p < this._pending.length; p++)
                            if (this._pending[p].key === u) {
                                this.queueOp("start", u, d);
                                break
                            }
                        return this
                    }
                    v.sys.isSleeping() ? v.sys.wake(d) : v.sys.isPaused() ? v.sys.resume(d) : this.start(u, d)
                },
                start: function(u, d) {
                    if (!this.isBooted)
                        return this._data[u] = {
                            autoStart: !0,
                            data: d
                        },
                        this;
                    var v = this.getScene(u);
                    if (v) {
                        var p = v.sys;
                        if (p.isActive() || p.isPaused())
                            p.shutdown(),
                            p.sceneUpdate = s,
                            p.start(d);
                        else {
                            p.sceneUpdate = s,
                            p.start(d);
                            var g;
                            if (p.load && (g = p.load),
                            g && p.settings.hasOwnProperty("pack") && (g.reset(),
                            g.addPack({
                                payload: p.settings.pack
                            })))
                                return p.settings.status = f.LOADING,
                                g.once(n.COMPLETE, this.payloadComplete, this),
                                g.start(),
                                this
                        }
                        this.bootScene(v)
                    }
                    return this
                },
                stop: function(u, d) {
                    var v = this.getScene(u);
                    return v && !v.sys.isTransitioning() && v.sys.shutdown(d),
                    this
                },
                switch: function(u, d) {
                    var v = this.getScene(u)
                      , p = this.getScene(d);
                    return v && p && v !== p && (this.sleep(u),
                    this.isSleeping(d) ? this.wake(d) : this.start(d)),
                    this
                },
                getAt: function(u) {
                    return this.scenes[u]
                },
                getIndex: function(u) {
                    var d = this.getScene(u);
                    return this.scenes.indexOf(d)
                },
                bringToTop: function(u) {
                    if (this.isProcessing)
                        this._queue.push({
                            op: "bringToTop",
                            keyA: u,
                            keyB: null
                        });
                    else {
                        var d = this.getIndex(u);
                        if (d !== -1 && d < this.scenes.length) {
                            var v = this.getScene(u);
                            this.scenes.splice(d, 1),
                            this.scenes.push(v)
                        }
                    }
                    return this
                },
                sendToBack: function(u) {
                    if (this.isProcessing)
                        this._queue.push({
                            op: "sendToBack",
                            keyA: u,
                            keyB: null
                        });
                    else {
                        var d = this.getIndex(u);
                        if (d !== -1 && d > 0) {
                            var v = this.getScene(u);
                            this.scenes.splice(d, 1),
                            this.scenes.unshift(v)
                        }
                    }
                    return this
                },
                moveDown: function(u) {
                    if (this.isProcessing)
                        this._queue.push({
                            op: "moveDown",
                            keyA: u,
                            keyB: null
                        });
                    else {
                        var d = this.getIndex(u);
                        if (d > 0) {
                            var v = d - 1
                              , p = this.getScene(u)
                              , g = this.getAt(v);
                            this.scenes[d] = g,
                            this.scenes[v] = p
                        }
                    }
                    return this
                },
                moveUp: function(u) {
                    if (this.isProcessing)
                        this._queue.push({
                            op: "moveUp",
                            keyA: u,
                            keyB: null
                        });
                    else {
                        var d = this.getIndex(u);
                        if (d < this.scenes.length - 1) {
                            var v = d + 1
                              , p = this.getScene(u)
                              , g = this.getAt(v);
                            this.scenes[d] = g,
                            this.scenes[v] = p
                        }
                    }
                    return this
                },
                moveAbove: function(u, d) {
                    if (u === d)
                        return this;
                    if (this.isProcessing)
                        this._queue.push({
                            op: "moveAbove",
                            keyA: u,
                            keyB: d
                        });
                    else {
                        var v = this.getIndex(u)
                          , p = this.getIndex(d);
                        if (v !== -1 && p !== -1) {
                            var g = this.getAt(p);
                            this.scenes.splice(p, 1),
                            this.scenes.splice(v + 1, 0, g)
                        }
                    }
                    return this
                },
                moveBelow: function(u, d) {
                    if (u === d)
                        return this;
                    if (this.isProcessing)
                        this._queue.push({
                            op: "moveBelow",
                            keyA: u,
                            keyB: d
                        });
                    else {
                        var v = this.getIndex(u)
                          , p = this.getIndex(d);
                        if (v !== -1 && p !== -1) {
                            var g = this.getAt(p);
                            this.scenes.splice(p, 1),
                            v === 0 ? this.scenes.unshift(g) : this.scenes.splice(v, 0, g)
                        }
                    }
                    return this
                },
                queueOp: function(u, d, v) {
                    return this._queue.push({
                        op: u,
                        keyA: d,
                        keyB: v
                    }),
                    this
                },
                swapPosition: function(u, d) {
                    if (u === d)
                        return this;
                    if (this.isProcessing)
                        this._queue.push({
                            op: "swapPosition",
                            keyA: u,
                            keyB: d
                        });
                    else {
                        var v = this.getIndex(u)
                          , p = this.getIndex(d);
                        if (v !== p && v !== -1 && p !== -1) {
                            var g = this.getAt(v);
                            this.scenes[v] = this.scenes[p],
                            this.scenes[p] = g
                        }
                    }
                    return this
                },
                dump: function() {
                    for (var u = [], d = ["pending", "init", "start", "loading", "creating", "running", "paused", "sleeping", "shutdown", "destroyed"], v = 0; v < this.scenes.length; v++) {
                        var p = this.scenes[v].sys
                          , g = p.settings.visible && (p.settings.status === f.RUNNING || p.settings.status === f.PAUSED) ? "[*] " : "[-] ";
                        g += p.settings.key + " (" + d[p.settings.status] + ")",
                        u.push(g)
                    }
                    console.log(u.join(`
`))
                },
                destroy: function() {
                    for (var u = 0; u < this.scenes.length; u++) {
                        var d = this.scenes[u].sys;
                        d.destroy()
                    }
                    this.update = s,
                    this.scenes = [],
                    this._pending = [],
                    this._start = [],
                    this._queue = [],
                    this.game = null
                }
            });
            c.exports = h
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(204)
              , r = new e({
                initialize: function(a) {
                    this.sys = new f(this,a),
                    this.game,
                    this.anims,
                    this.cache,
                    this.registry,
                    this.sound,
                    this.textures,
                    this.events,
                    this.cameras,
                    this.add,
                    this.make,
                    this.scene,
                    this.children,
                    this.lights,
                    this.data,
                    this.input,
                    this.load,
                    this.time,
                    this.tweens,
                    this.physics,
                    this.matter,
                    this.scale,
                    this.plugins,
                    this.renderer
                },
                update: function() {}
            });
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(2)
              , f = t(205)
              , r = function(o) {
                var a = o.game.config.defaultPhysicsSystem
                  , n = e(o.settings, "physics", !1);
                if (!(!a && !n)) {
                    var s = [];
                    if (a && s.push(f(a + "Physics")),
                    n)
                        for (var l in n)
                            l = f(l.concat("Physics")),
                            s.indexOf(l) === -1 && s.push(l);
                    return s
                }
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(2)
              , f = function(r) {
                var o = r.plugins.getDefaultScenePlugins()
                  , a = e(r.settings, "plugins", !1);
                return Array.isArray(a) ? a : o || []
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(144)
              , f = t(6)
              , r = t(127)
              , o = t(978)
              , a = {
                create: function(n) {
                    return typeof n == "string" ? n = {
                        key: n
                    } : n === void 0 && (n = {}),
                    {
                        status: e.PENDING,
                        key: f(n, "key", ""),
                        active: f(n, "active", !1),
                        visible: f(n, "visible", !0),
                        isBooted: !1,
                        isTransition: !1,
                        transitionFrom: null,
                        transitionDuration: 0,
                        transitionAllowInput: !0,
                        data: {},
                        pack: f(n, "pack", !1),
                        cameras: f(n, "cameras", null),
                        map: f(n, "map", r(o, f(n, "mapAdd", {}))),
                        physics: f(n, "physics", {}),
                        loader: f(n, "loader", {}),
                        plugins: f(n, "plugins", !1),
                        input: f(n, "input", {})
                    }
                }
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(31)
              , f = t(423)
              , r = t(0)
              , o = t(38)
              , a = t(33)
              , n = t(9)
              , s = t(106)
              , l = t(22)
              , i = t(388)
              , h = t(6)
              , u = t(425)
              , d = t(206)
              , v = new r({
                Extends: n,
                initialize: function(g) {
                    n.call(this),
                    this.game = g,
                    this.name = "TextureManager",
                    this.list = {},
                    this._tempCanvas = e.create2D(this, 1, 1),
                    this._tempContext = this._tempCanvas.getContext("2d"),
                    this._pending = 0,
                    g.events.once(l.BOOT, this.boot, this)
                },
                boot: function() {
                    this._pending = 3,
                    this.on(s.LOAD, this.updatePending, this),
                    this.on(s.ERROR, this.updatePending, this);
                    var p = this.game.config;
                    this.addBase64("__DEFAULT", p.defaultImage),
                    this.addBase64("__MISSING", p.missingImage),
                    this.addBase64("__WHITE", p.whiteImage),
                    this.game.events.once(l.DESTROY, this.destroy, this)
                },
                updatePending: function() {
                    this._pending--,
                    this._pending === 0 && (this.off(s.LOAD),
                    this.off(s.ERROR),
                    this.emit(s.READY))
                },
                checkKey: function(p) {
                    return this.exists(p) ? (console.error("Texture key already in use: " + p),
                    !1) : !0
                },
                remove: function(p) {
                    if (typeof p == "string")
                        if (this.exists(p))
                            p = this.get(p);
                        else
                            return console.warn("No texture found matching key: " + p),
                            this;
                    return this.list.hasOwnProperty(p.key) && (p.destroy(),
                    this.emit(s.REMOVE, p.key)),
                    this
                },
                removeKey: function(p) {
                    return this.list.hasOwnProperty(p) && delete this.list[p],
                    this
                },
                addBase64: function(p, g) {
                    if (this.checkKey(p)) {
                        var m = this
                          , x = new Image;
                        x.onerror = function() {
                            m.emit(s.ERROR, p)
                        }
                        ,
                        x.onload = function() {
                            var T = m.create(p, x);
                            u.Image(T, 0),
                            m.emit(s.ADD, p, T),
                            m.emit(s.LOAD, p, T)
                        }
                        ,
                        x.src = g
                    }
                    return this
                },
                getBase64: function(p, g, m, x) {
                    m === void 0 && (m = "image/png"),
                    x === void 0 && (x = .92);
                    var T = ""
                      , E = this.getFrame(p, g);
                    if (E && (E.source.isRenderTexture || E.source.isGLTexture))
                        console.warn("Cannot getBase64 from WebGL Texture");
                    else if (E) {
                        var P = E.canvasData
                          , M = e.create2D(this, P.width, P.height)
                          , L = M.getContext("2d");
                        L.drawImage(E.source.image, P.x, P.y, P.width, P.height, 0, 0, P.width, P.height),
                        T = M.toDataURL(m, x),
                        e.remove(M)
                    }
                    return T
                },
                addImage: function(p, g, m) {
                    var x = null;
                    return this.checkKey(p) && (x = this.create(p, g),
                    u.Image(x, 0),
                    m && x.setDataSource(m),
                    this.emit(s.ADD, p, x)),
                    x
                },
                addGLTexture: function(p, g, m, x) {
                    var T = null;
                    return this.checkKey(p) && (m === void 0 && (m = g.width),
                    x === void 0 && (x = g.height),
                    T = this.create(p, g, m, x),
                    T.add("__BASE", 0, 0, 0, m, x),
                    this.emit(s.ADD, p, T)),
                    T
                },
                addRenderTexture: function(p, g) {
                    var m = null;
                    return this.checkKey(p) && (m = this.create(p, g),
                    m.add("__BASE", 0, 0, 0, g.width, g.height),
                    this.emit(s.ADD, p, m)),
                    m
                },
                generate: function(p, g) {
                    if (this.checkKey(p)) {
                        var m = e.create(this, 1, 1);
                        return g.canvas = m,
                        i(g),
                        this.addCanvas(p, m)
                    } else
                        return null
                },
                createCanvas: function(p, g, m) {
                    if (g === void 0 && (g = 256),
                    m === void 0 && (m = 256),
                    this.checkKey(p)) {
                        var x = e.create(this, g, m, a.CANVAS, !0);
                        return this.addCanvas(p, x)
                    }
                    return null
                },
                addCanvas: function(p, g, m) {
                    m === void 0 && (m = !1);
                    var x = null;
                    return m ? x = new f(this,p,g,g.width,g.height) : this.checkKey(p) && (x = new f(this,p,g,g.width,g.height),
                    this.list[p] = x,
                    this.emit(s.ADD, p, x)),
                    x
                },
                addAtlas: function(p, g, m, x) {
                    return Array.isArray(m.textures) || Array.isArray(m.frames) ? this.addAtlasJSONArray(p, g, m, x) : this.addAtlasJSONHash(p, g, m, x)
                },
                addAtlasJSONArray: function(p, g, m, x) {
                    var T = null;
                    if (this.checkKey(p)) {
                        if (T = this.create(p, g),
                        Array.isArray(m))
                            for (var E = m.length === 1, P = 0; P < T.source.length; P++) {
                                var M = E ? m[0] : m[P];
                                u.JSONArray(T, P, M)
                            }
                        else
                            u.JSONArray(T, 0, m);
                        x && T.setDataSource(x),
                        this.emit(s.ADD, p, T)
                    }
                    return T
                },
                addAtlasJSONHash: function(p, g, m, x) {
                    var T = null;
                    if (this.checkKey(p)) {
                        if (T = this.create(p, g),
                        Array.isArray(m))
                            for (var E = 0; E < m.length; E++)
                                u.JSONHash(T, E, m[E]);
                        else
                            u.JSONHash(T, 0, m);
                        x && T.setDataSource(x),
                        this.emit(s.ADD, p, T)
                    }
                    return T
                },
                addAtlasXML: function(p, g, m, x) {
                    var T = null;
                    return this.checkKey(p) && (T = this.create(p, g),
                    u.AtlasXML(T, 0, m),
                    x && T.setDataSource(x),
                    this.emit(s.ADD, p, T)),
                    T
                },
                addUnityAtlas: function(p, g, m, x) {
                    var T = null;
                    return this.checkKey(p) && (T = this.create(p, g),
                    u.UnityYAML(T, 0, m),
                    x && T.setDataSource(x),
                    this.emit(s.ADD, p, T)),
                    T
                },
                addSpriteSheet: function(p, g, m) {
                    var x = null;
                    if (this.checkKey(p)) {
                        x = this.create(p, g);
                        var T = x.source[0].width
                          , E = x.source[0].height;
                        u.SpriteSheet(x, 0, 0, 0, T, E, m),
                        this.emit(s.ADD, p, x)
                    }
                    return x
                },
                addSpriteSheetFromAtlas: function(p, g) {
                    if (!this.checkKey(p))
                        return null;
                    var m = h(g, "atlas", null)
                      , x = h(g, "frame", null);
                    if (!(!m || !x)) {
                        var T = this.get(m)
                          , E = T.get(x);
                        if (E) {
                            var P = this.create(p, E.source.image);
                            return E.trimmed ? u.SpriteSheetFromAtlas(P, E, g) : u.SpriteSheet(P, 0, E.cutX, E.cutY, E.cutWidth, E.cutHeight, g),
                            this.emit(s.ADD, p, P),
                            P
                        }
                    }
                },
                create: function(p, g, m, x) {
                    var T = null;
                    return this.checkKey(p) && (T = new d(this,p,g,m,x),
                    this.list[p] = T),
                    T
                },
                exists: function(p) {
                    return this.list.hasOwnProperty(p)
                },
                get: function(p) {
                    return p === void 0 && (p = "__DEFAULT"),
                    this.list[p] ? this.list[p] : p instanceof d ? p : this.list.__MISSING
                },
                cloneFrame: function(p, g) {
                    if (this.list[p])
                        return this.list[p].get(g).clone()
                },
                getFrame: function(p, g) {
                    if (this.list[p])
                        return this.list[p].get(g)
                },
                getTextureKeys: function() {
                    var p = [];
                    for (var g in this.list)
                        g !== "__DEFAULT" && g !== "__MISSING" && p.push(g);
                    return p
                },
                getPixel: function(p, g, m, x) {
                    var T = this.getFrame(m, x);
                    if (T) {
                        p -= T.x,
                        g -= T.y;
                        var E = T.data.cut;
                        if (p += E.x,
                        g += E.y,
                        p >= E.x && p < E.r && g >= E.y && g < E.b) {
                            var P = this._tempContext;
                            P.clearRect(0, 0, 1, 1),
                            P.drawImage(T.source.image, p, g, 1, 1, 0, 0, 1, 1);
                            var M = P.getImageData(0, 0, 1, 1);
                            return new o(M.data[0],M.data[1],M.data[2],M.data[3])
                        }
                    }
                    return null
                },
                getPixelAlpha: function(p, g, m, x) {
                    var T = this.getFrame(m, x);
                    if (T) {
                        p -= T.x,
                        g -= T.y;
                        var E = T.data.cut;
                        if (p += E.x,
                        g += E.y,
                        p >= E.x && p < E.r && g >= E.y && g < E.b) {
                            var P = this._tempContext;
                            P.clearRect(0, 0, 1, 1),
                            P.drawImage(T.source.image, p, g, 1, 1, 0, 0, 1, 1);
                            var M = P.getImageData(0, 0, 1, 1);
                            return M.data[3]
                        }
                    }
                    return null
                },
                setTexture: function(p, g, m) {
                    return this.list[g] && (p.texture = this.list[g],
                    p.frame = p.texture.get(m)),
                    p
                },
                renameTexture: function(p, g) {
                    var m = this.get(p);
                    return m && p !== g ? (m.key = g,
                    this.list[g] = m,
                    delete this.list[p],
                    !0) : !1
                },
                each: function(p, g) {
                    for (var m = [null], x = 1; x < arguments.length; x++)
                        m.push(arguments[x]);
                    for (var T in this.list)
                        m[0] = this.list[T],
                        p.apply(g, m)
                },
                destroy: function() {
                    for (var p in this.list)
                        this.list[p].destroy();
                    this.list = {},
                    this.game = null,
                    e.remove(this._tempCanvas)
                }
            });
            c.exports = v
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(18)
              , r = t(38)
              , o = t(33)
              , a = t(138)
              , n = t(206)
              , s = new e({
                Extends: n,
                initialize: function(i, h, u, d, v) {
                    n.call(this, i, h, u, d, v),
                    this.add("__BASE", 0, 0, 0, d, v),
                    this._source = this.frames.__BASE.source,
                    this.canvas = this._source.image,
                    this.context = this.canvas.getContext("2d"),
                    this.width = d,
                    this.height = v,
                    this.imageData = this.context.getImageData(0, 0, d, v),
                    this.data = null,
                    this.imageData && (this.data = this.imageData.data),
                    this.pixels = null,
                    this.buffer,
                    this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer,
                    this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length),
                    this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data)
                },
                update: function() {
                    return this.imageData = this.context.getImageData(0, 0, this.width, this.height),
                    this.data = this.imageData.data,
                    this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer,
                    this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length),
                    this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data,
                    this.manager.game.config.renderType === o.WEBGL && this.refresh(),
                    this
                },
                draw: function(l, i, h) {
                    return this.context.drawImage(h, l, i),
                    this.update()
                },
                drawFrame: function(l, i, h, u) {
                    h === void 0 && (h = 0),
                    u === void 0 && (u = 0);
                    var d = this.manager.getFrame(l, i);
                    if (d) {
                        var v = d.canvasData
                          , p = d.cutWidth
                          , g = d.cutHeight
                          , m = d.source.resolution;
                        return this.context.drawImage(d.source.image, v.x, v.y, p, g, h, u, p / m, g / m),
                        this.update()
                    } else
                        return this
                },
                setPixel: function(l, i, h, u, d, v) {
                    v === void 0 && (v = 255),
                    l = Math.abs(Math.floor(l)),
                    i = Math.abs(Math.floor(i));
                    var p = this.getIndex(l, i);
                    if (p > -1) {
                        var g = this.context.getImageData(l, i, 1, 1);
                        g.data[0] = h,
                        g.data[1] = u,
                        g.data[2] = d,
                        g.data[3] = v,
                        this.context.putImageData(g, l, i)
                    }
                    return this
                },
                putData: function(l, i, h, u, d, v, p) {
                    return u === void 0 && (u = 0),
                    d === void 0 && (d = 0),
                    v === void 0 && (v = l.width),
                    p === void 0 && (p = l.height),
                    this.context.putImageData(l, i, h, u, d, v, p),
                    this
                },
                getData: function(l, i, h, u) {
                    l = f(Math.floor(l), 0, this.width - 1),
                    i = f(Math.floor(i), 0, this.height - 1),
                    h = f(h, 1, this.width - l),
                    u = f(u, 1, this.height - i);
                    var d = this.context.getImageData(l, i, h, u);
                    return d
                },
                getPixel: function(l, i, h) {
                    h || (h = new r);
                    var u = this.getIndex(l, i);
                    if (u > -1) {
                        var d = this.data
                          , v = d[u + 0]
                          , p = d[u + 1]
                          , g = d[u + 2]
                          , m = d[u + 3];
                        h.setTo(v, p, g, m)
                    }
                    return h
                },
                getPixels: function(l, i, h, u) {
                    l === void 0 && (l = 0),
                    i === void 0 && (i = 0),
                    h === void 0 && (h = this.width),
                    u === void 0 && (u = h),
                    l = Math.abs(Math.round(l)),
                    i = Math.abs(Math.round(i));
                    for (var d = f(l, 0, this.width), v = f(l + h, 0, this.width), p = f(i, 0, this.height), g = f(i + u, 0, this.height), m = new r, x = [], T = p; T < g; T++) {
                        for (var E = [], P = d; P < v; P++)
                            m = this.getPixel(P, T, m),
                            E.push({
                                x: P,
                                y: T,
                                color: m.color,
                                alpha: m.alphaGL
                            });
                        x.push(E)
                    }
                    return x
                },
                getIndex: function(l, i) {
                    return l = Math.abs(Math.round(l)),
                    i = Math.abs(Math.round(i)),
                    l < this.width && i < this.height ? (l + i * this.width) * 4 : -1
                },
                refresh: function() {
                    return this._source.update(),
                    this
                },
                getCanvas: function() {
                    return this.canvas
                },
                getContext: function() {
                    return this.context
                },
                clear: function(l, i, h, u) {
                    return l === void 0 && (l = 0),
                    i === void 0 && (i = 0),
                    h === void 0 && (h = this.width),
                    u === void 0 && (u = this.height),
                    this.context.clearRect(l, i, h, u),
                    this.update()
                },
                setSize: function(l, i) {
                    return i === void 0 && (i = l),
                    (l !== this.width || i !== this.height) && (this.canvas.width = l,
                    this.canvas.height = i,
                    this._source.width = l,
                    this._source.height = i,
                    this._source.isPowerOf2 = a(l, i),
                    this.frames.__BASE.setSize(l, i, 0, 0),
                    this.width = l,
                    this.height = i,
                    this.refresh()),
                    this
                },
                destroy: function() {
                    n.prototype.destroy.call(this),
                    this._source = null,
                    this.canvas = null,
                    this.context = null,
                    this.imageData = null,
                    this.data = null,
                    this.pixels = null,
                    this.buffer = null
                }
            });
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(31)
              , f = t(0)
              , r = t(138)
              , o = t(168)
              , a = new f({
                initialize: function(s, l, i, h, u) {
                    u === void 0 && (u = !1);
                    var d = s.manager.game;
                    this.renderer = d.renderer,
                    this.texture = s,
                    this.source = l,
                    this.image = l,
                    this.compressionAlgorithm = null,
                    this.resolution = 1,
                    this.width = i || l.naturalWidth || l.videoWidth || l.width || 0,
                    this.height = h || l.naturalHeight || l.videoHeight || l.height || 0,
                    this.scaleMode = o.DEFAULT,
                    this.isCanvas = l instanceof HTMLCanvasElement,
                    this.isVideo = window.hasOwnProperty("HTMLVideoElement") && l instanceof HTMLVideoElement,
                    this.isRenderTexture = l.type === "RenderTexture",
                    this.isGLTexture = window.hasOwnProperty("WebGLTexture") && l instanceof WebGLTexture,
                    this.isPowerOf2 = r(this.width, this.height),
                    this.glTexture = null,
                    this.glIndex = 0,
                    this.glIndexCounter = -1,
                    this.flipY = u,
                    this.init(d)
                },
                init: function(n) {
                    var s = this.renderer;
                    s && (s.gl ? this.isCanvas ? this.glTexture = s.createCanvasTexture(this.image, !1, this.flipY) : this.isVideo ? this.glTexture = s.createVideoTexture(this.image, !1, this.flipY) : this.isRenderTexture ? (this.image = this.source.canvas,
                    this.glTexture = s.createTextureFromSource(null, this.width, this.height, this.scaleMode)) : this.isGLTexture ? this.glTexture = this.source : this.glTexture = s.createTextureFromSource(this.image, this.width, this.height, this.scaleMode) : this.isRenderTexture && (this.image = this.source.canvas)),
                    n.config.antialias || this.setFilter(1)
                },
                setFilter: function(n) {
                    this.renderer.gl && this.renderer.setTextureFilter(this.glTexture, n),
                    this.scaleMode = n
                },
                setFlipY: function(n) {
                    return n === void 0 && (n = !0),
                    this.flipY = n,
                    this
                },
                update: function() {
                    var n = this.renderer.gl;
                    n && this.isCanvas ? this.glTexture = this.renderer.updateCanvasTexture(this.image, this.glTexture, this.flipY) : n && this.isVideo && (this.glTexture = this.renderer.updateVideoTexture(this.image, this.glTexture, this.flipY))
                },
                destroy: function() {
                    this.glTexture && this.renderer.deleteTexture(this.glTexture, !0),
                    this.isCanvas && e.remove(this.image),
                    this.renderer = null,
                    this.texture = null,
                    this.source = null,
                    this.image = null,
                    this.glTexture = null
                }
            });
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                AtlasXML: t(979),
                Canvas: t(980),
                Image: t(981),
                JSONArray: t(982),
                JSONHash: t(983),
                SpriteSheet: t(984),
                SpriteSheetFromAtlas: t(985),
                UnityYAML: t(986)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(427)
              , f = t(430)
              , r = t(432)
              , o = {
                create: function(a) {
                    var n = a.config.audio
                      , s = a.device.audio;
                    return n.noAudio || !s.webAudio && !s.audioData ? new f(a) : s.webAudio && !n.disableWebAudio ? new r(a) : new e(a)
                }
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(145)
              , f = t(0)
              , r = t(70)
              , o = t(429)
              , a = new f({
                Extends: e,
                initialize: function(s) {
                    this.override = !0,
                    this.audioPlayDelay = .1,
                    this.loopEndOffset = .05,
                    this.onBlurPausedSounds = [],
                    this.locked = "ontouchstart"in window,
                    this.lockedActionsQueue = this.locked ? [] : null,
                    this._mute = !1,
                    this._volume = 1,
                    e.call(this, s)
                },
                add: function(n, s) {
                    var l = new o(this,n,s);
                    return this.sounds.push(l),
                    l
                },
                unlock: function() {
                    this.locked = !1;
                    var n = this;
                    if (this.game.cache.audio.entries.each(function(h, u) {
                        for (var d = 0; d < u.length; d++)
                            if (u[d].dataset.locked === "true")
                                return n.locked = !0,
                                !1;
                        return !0
                    }),
                    !!this.locked) {
                        var s = !1
                          , l = function() {
                            s = !0
                        }
                          , i = function() {
                            if (s) {
                                s = !1;
                                return
                            }
                            document.body.removeEventListener("touchmove", l),
                            document.body.removeEventListener("touchend", i);
                            var h = [];
                            if (n.game.cache.audio.entries.each(function(d, v) {
                                for (var p = 0; p < v.length; p++) {
                                    var g = v[p];
                                    g.dataset.locked === "true" && h.push(g)
                                }
                                return !0
                            }),
                            h.length !== 0) {
                                var u = h[h.length - 1];
                                u.oncanplaythrough = function() {
                                    u.oncanplaythrough = null,
                                    h.forEach(function(d) {
                                        d.dataset.locked = "false"
                                    }),
                                    n.unlocked = !0
                                }
                                ,
                                h.forEach(function(d) {
                                    d.load()
                                })
                            }
                        };
                        this.once(r.UNLOCKED, function() {
                            for (this.forEachActiveSound(function(u) {
                                u.currentMarker === null && u.duration === 0 && (u.duration = u.tags[0].duration),
                                u.totalDuration = u.tags[0].duration
                            }); this.lockedActionsQueue.length; ) {
                                var h = this.lockedActionsQueue.shift();
                                h.sound[h.prop].apply ? h.sound[h.prop].apply(h.sound, h.value || []) : h.sound[h.prop] = h.value
                            }
                        }, this),
                        document.body.addEventListener("touchmove", l, !1),
                        document.body.addEventListener("touchend", i, !1)
                    }
                },
                onBlur: function() {
                    this.forEachActiveSound(function(n) {
                        n.isPlaying && (this.onBlurPausedSounds.push(n),
                        n.onBlur())
                    })
                },
                onFocus: function() {
                    this.onBlurPausedSounds.forEach(function(n) {
                        n.onFocus()
                    }),
                    this.onBlurPausedSounds.length = 0
                },
                destroy: function() {
                    e.prototype.destroy.call(this),
                    this.onBlurPausedSounds.length = 0,
                    this.onBlurPausedSounds = null
                },
                isLocked: function(n, s, l) {
                    return n.tags[0].dataset.locked === "true" ? (this.lockedActionsQueue.push({
                        sound: n,
                        prop: s,
                        value: l
                    }),
                    !0) : !1
                },
                setMute: function(n) {
                    return this.mute = n,
                    this
                },
                mute: {
                    get: function() {
                        return this._mute
                    },
                    set: function(n) {
                        this._mute = n,
                        this.forEachActiveSound(function(s) {
                            s.updateMute()
                        }),
                        this.emit(r.GLOBAL_MUTE, this, n)
                    }
                },
                setVolume: function(n) {
                    return this.volume = n,
                    this
                },
                volume: {
                    get: function() {
                        return this._volume
                    },
                    set: function(n) {
                        this._volume = n,
                        this.forEachActiveSound(function(s) {
                            s.updateVolume()
                        }),
                        this.emit(r.GLOBAL_VOLUME, this, n)
                    }
                }
            });
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(78)
              , f = function(r, o, a, n, s) {
                if (n === void 0 && (n = 0),
                s === void 0 && (s = r.length),
                e(r, n, s))
                    for (var l = n; l < s; l++) {
                        var i = r[l];
                        if (!o || o && a === void 0 && i.hasOwnProperty(o) || o && a !== void 0 && i[o] === a)
                            return i
                    }
                return null
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(146)
              , f = t(0)
              , r = t(70)
              , o = t(18)
              , a = new f({
                Extends: e,
                initialize: function(s, l, i) {
                    if (i === void 0 && (i = {}),
                    this.tags = s.game.cache.audio.get(l),
                    !this.tags)
                        throw new Error('There is no audio asset with key "' + l + '" in the audio cache');
                    this.audio = null,
                    this.startTime = 0,
                    this.previousTime = 0,
                    this.duration = this.tags[0].duration,
                    this.totalDuration = this.tags[0].duration,
                    e.call(this, s, l, i)
                },
                play: function(n, s) {
                    return this.manager.isLocked(this, "play", [n, s]) || !e.prototype.play.call(this, n, s) || !this.pickAndPlayAudioTag() ? !1 : (this.emit(r.PLAY, this),
                    !0)
                },
                pause: function() {
                    return this.manager.isLocked(this, "pause") || this.startTime > 0 || !e.prototype.pause.call(this) ? !1 : (this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0),
                    this.stopAndReleaseAudioTag(),
                    this.emit(r.PAUSE, this),
                    !0)
                },
                resume: function() {
                    return this.manager.isLocked(this, "resume") || this.startTime > 0 || !e.prototype.resume.call(this) || !this.pickAndPlayAudioTag() ? !1 : (this.emit(r.RESUME, this),
                    !0)
                },
                stop: function() {
                    return this.manager.isLocked(this, "stop") || !e.prototype.stop.call(this) ? !1 : (this.stopAndReleaseAudioTag(),
                    this.emit(r.STOP, this),
                    !0)
                },
                pickAndPlayAudioTag: function() {
                    if (!this.pickAudioTag())
                        return this.reset(),
                        !1;
                    var n = this.currentConfig.seek
                      , s = this.currentConfig.delay
                      , l = (this.currentMarker ? this.currentMarker.start : 0) + n;
                    return this.previousTime = l,
                    this.audio.currentTime = l,
                    this.applyConfig(),
                    s === 0 ? (this.startTime = 0,
                    this.audio.paused && this.playCatchPromise()) : (this.startTime = window.performance.now() + s * 1e3,
                    this.audio.paused || this.audio.pause()),
                    this.resetConfig(),
                    !0
                },
                pickAudioTag: function() {
                    if (this.audio)
                        return !0;
                    for (var n = 0; n < this.tags.length; n++) {
                        var s = this.tags[n];
                        if (s.dataset.used === "false")
                            return s.dataset.used = "true",
                            this.audio = s,
                            !0
                    }
                    if (!this.manager.override)
                        return !1;
                    var l = [];
                    this.manager.forEachActiveSound(function(h) {
                        h.key === this.key && h.audio && l.push(h)
                    }, this),
                    l.sort(function(h, u) {
                        return h.loop === u.loop ? u.seek / u.duration - h.seek / h.duration : h.loop ? 1 : -1
                    });
                    var i = l[0];
                    return this.audio = i.audio,
                    i.reset(),
                    i.audio = null,
                    i.startTime = 0,
                    i.previousTime = 0,
                    !0
                },
                playCatchPromise: function() {
                    var n = this.audio.play();
                    n && n.catch(function(s) {
                        console.warn(s)
                    })
                },
                stopAndReleaseAudioTag: function() {
                    this.startTime = 0,
                    this.previousTime = 0,
                    this.audio && (this.audio.pause(),
                    this.audio.dataset.used = "false",
                    this.audio = null)
                },
                reset: function() {
                    e.prototype.stop.call(this)
                },
                onBlur: function() {
                    this.isPlaying = !1,
                    this.isPaused = !0,
                    this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0),
                    this.currentConfig.delay = Math.max(0, (this.startTime - window.performance.now()) / 1e3),
                    this.stopAndReleaseAudioTag()
                },
                onFocus: function() {
                    this.isPlaying = !0,
                    this.isPaused = !1,
                    this.pickAndPlayAudioTag()
                },
                update: function(n) {
                    if (this.isPlaying) {
                        if (this.startTime > 0) {
                            this.startTime < n - this.manager.audioPlayDelay && (this.audio.currentTime += Math.max(0, n - this.startTime) / 1e3,
                            this.startTime = 0,
                            this.previousTime = this.audio.currentTime,
                            this.playCatchPromise());
                            return
                        }
                        var s = this.currentMarker ? this.currentMarker.start : 0
                          , l = s + this.duration
                          , i = this.audio.currentTime;
                        if (this.currentConfig.loop)
                            i >= l - this.manager.loopEndOffset ? (this.audio.currentTime = s + Math.max(0, i - l),
                            i = this.audio.currentTime) : i < s && (this.audio.currentTime += s,
                            i = this.audio.currentTime),
                            i < this.previousTime && this.emit(r.LOOPED, this);
                        else if (i >= l) {
                            this.reset(),
                            this.stopAndReleaseAudioTag(),
                            this.emit(r.COMPLETE, this);
                            return
                        }
                        this.previousTime = i
                    }
                },
                destroy: function() {
                    e.prototype.destroy.call(this),
                    this.tags = null,
                    this.audio && this.stopAndReleaseAudioTag()
                },
                updateMute: function() {
                    this.audio && (this.audio.muted = this.currentConfig.mute || this.manager.mute)
                },
                updateVolume: function() {
                    this.audio && (this.audio.volume = o(this.currentConfig.volume * this.manager.volume, 0, 1))
                },
                calculateRate: function() {
                    e.prototype.calculateRate.call(this),
                    this.audio && (this.audio.playbackRate = this.totalRate)
                },
                mute: {
                    get: function() {
                        return this.currentConfig.mute
                    },
                    set: function(n) {
                        this.currentConfig.mute = n,
                        !this.manager.isLocked(this, "mute", n) && (this.updateMute(),
                        this.emit(r.MUTE, this, n))
                    }
                },
                setMute: function(n) {
                    return this.mute = n,
                    this
                },
                volume: {
                    get: function() {
                        return this.currentConfig.volume
                    },
                    set: function(n) {
                        this.currentConfig.volume = n,
                        !this.manager.isLocked(this, "volume", n) && (this.updateVolume(),
                        this.emit(r.VOLUME, this, n))
                    }
                },
                setVolume: function(n) {
                    return this.volume = n,
                    this
                },
                rate: {
                    get: function() {
                        return this.currentConfig.rate
                    },
                    set: function(n) {
                        this.currentConfig.rate = n,
                        !this.manager.isLocked(this, r.RATE, n) && (this.calculateRate(),
                        this.emit(r.RATE, this, n))
                    }
                },
                setRate: function(n) {
                    return this.rate = n,
                    this
                },
                detune: {
                    get: function() {
                        return this.currentConfig.detune
                    },
                    set: function(n) {
                        this.currentConfig.detune = n,
                        !this.manager.isLocked(this, r.DETUNE, n) && (this.calculateRate(),
                        this.emit(r.DETUNE, this, n))
                    }
                },
                setDetune: function(n) {
                    return this.detune = n,
                    this
                },
                seek: {
                    get: function() {
                        return this.isPlaying ? this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0) : this.isPaused ? this.currentConfig.seek : 0
                    },
                    set: function(n) {
                        this.manager.isLocked(this, "seek", n) || this.startTime > 0 || (this.isPlaying || this.isPaused) && (n = Math.min(Math.max(0, n), this.duration),
                        this.isPlaying ? (this.previousTime = n,
                        this.audio.currentTime = n) : this.isPaused && (this.currentConfig.seek = n),
                        this.emit(r.SEEK, this, n))
                    }
                },
                setSeek: function(n) {
                    return this.seek = n,
                    this
                },
                loop: {
                    get: function() {
                        return this.currentConfig.loop
                    },
                    set: function(n) {
                        this.currentConfig.loop = n,
                        !this.manager.isLocked(this, "loop", n) && (this.audio && (this.audio.loop = n),
                        this.emit(r.LOOP, this, n))
                    }
                },
                setLoop: function(n) {
                    return this.loop = n,
                    this
                },
                pan: {
                    get: function() {
                        return this.currentConfig.pan
                    },
                    set: function(n) {
                        this.currentConfig.pan = n,
                        this.emit(r.PAN, this, n)
                    }
                },
                setPan: function(n) {
                    return this.pan = n,
                    this
                }
            });
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(145)
              , f = t(0)
              , r = t(9)
              , o = t(431)
              , a = t(1)
              , n = new f({
                Extends: r,
                initialize: function(l) {
                    r.call(this),
                    this.game = l,
                    this.sounds = [],
                    this.mute = !1,
                    this.volume = 1,
                    this.rate = 1,
                    this.detune = 0,
                    this.pauseOnBlur = !0,
                    this.locked = !1
                },
                add: function(s, l) {
                    var i = new o(this,s,l);
                    return this.sounds.push(i),
                    i
                },
                addAudioSprite: function(s, l) {
                    var i = this.add(s, l);
                    return i.spritemap = {},
                    i
                },
                play: function(s, l) {
                    return !1
                },
                playAudioSprite: function(s, l, i) {
                    return !1
                },
                remove: function(s) {
                    return e.prototype.remove.call(this, s)
                },
                removeByKey: function(s) {
                    return e.prototype.removeByKey.call(this, s)
                },
                pauseAll: a,
                resumeAll: a,
                stopAll: a,
                update: a,
                setRate: a,
                setDetune: a,
                setMute: a,
                setVolume: a,
                forEachActiveSound: function(s, l) {
                    e.prototype.forEachActiveSound.call(this, s, l)
                },
                destroy: function() {
                    e.prototype.destroy.call(this)
                }
            });
            c.exports = n
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(146)
              , f = t(0)
              , r = t(9)
              , o = t(17)
              , a = function() {
                return !1
            }
              , n = function() {
                return null
            }
              , s = function() {
                return this
            }
              , l = new f({
                Extends: r,
                initialize: function(h, u, d) {
                    d === void 0 && (d = {}),
                    r.call(this),
                    this.manager = h,
                    this.key = u,
                    this.isPlaying = !1,
                    this.isPaused = !1,
                    this.totalRate = 1,
                    this.duration = 0,
                    this.totalDuration = 0,
                    this.config = o({
                        mute: !1,
                        volume: 1,
                        rate: 1,
                        detune: 0,
                        seek: 0,
                        loop: !1,
                        delay: 0,
                        pan: 0
                    }, d),
                    this.currentConfig = this.config,
                    this.mute = !1,
                    this.volume = 1,
                    this.rate = 1,
                    this.detune = 0,
                    this.seek = 0,
                    this.loop = !1,
                    this.pan = 0,
                    this.markers = {},
                    this.currentMarker = null,
                    this.pendingRemove = !1
                },
                addMarker: a,
                updateMarker: a,
                removeMarker: n,
                play: a,
                pause: a,
                resume: a,
                stop: a,
                destroy: function() {
                    e.prototype.destroy.call(this)
                },
                setMute: s,
                setVolume: s,
                setRate: s,
                setDetune: s,
                setSeek: s,
                setLoop: s,
                setPan: s
            });
            c.exports = l
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(433)
              , f = t(145)
              , r = t(0)
              , o = t(70)
              , a = t(22)
              , n = t(434)
              , s = new r({
                Extends: f,
                initialize: function(i) {
                    this.context = this.createAudioContext(i),
                    this.masterMuteNode = this.context.createGain(),
                    this.masterVolumeNode = this.context.createGain(),
                    this.masterMuteNode.connect(this.masterVolumeNode),
                    this.masterVolumeNode.connect(this.context.destination),
                    this.destination = this.masterMuteNode,
                    this.locked = this.context.state === "suspended" && ("ontouchstart"in window || "onclick"in window),
                    f.call(this, i),
                    this.locked && i.isBooted ? this.unlock() : i.events.once(a.BOOT, this.unlock, this)
                },
                createAudioContext: function(l) {
                    var i = l.config.audio;
                    if (i.context)
                        return i.context.resume(),
                        i.context;
                    if (window.hasOwnProperty("AudioContext"))
                        return new AudioContext;
                    if (window.hasOwnProperty("webkitAudioContext"))
                        return new window.webkitAudioContext
                },
                setAudioContext: function(l) {
                    return this.context && this.context.close(),
                    this.masterMuteNode && this.masterMuteNode.disconnect(),
                    this.masterVolumeNode && this.masterVolumeNode.disconnect(),
                    this.context = l,
                    this.masterMuteNode = l.createGain(),
                    this.masterVolumeNode = l.createGain(),
                    this.masterMuteNode.connect(this.masterVolumeNode),
                    this.masterVolumeNode.connect(l.destination),
                    this.destination = this.masterMuteNode,
                    this
                },
                add: function(l, i) {
                    var h = new n(this,l,i);
                    return this.sounds.push(h),
                    h
                },
                decodeAudio: function(l, i) {
                    var h;
                    Array.isArray(l) ? h = l : h = [{
                        key: l,
                        data: i
                    }];
                    for (var u = this.game.cache.audio, d = h.length, v = 0; v < h.length; v++) {
                        var p = h[v]
                          , g = p.key
                          , m = p.data;
                        typeof m == "string" && (m = e(m));
                        var x = function(E, P) {
                            u.add(E, P),
                            this.emit(o.DECODED, E),
                            d--,
                            d === 0 && this.emit(o.DECODED_ALL)
                        }
                        .bind(this, g)
                          , T = function(E, P) {
                            console.error("Error decoding audio: " + E + " - ", P ? P.message : ""),
                            d--,
                            d === 0 && this.emit(o.DECODED_ALL)
                        }
                        .bind(this, g);
                        this.context.decodeAudioData(m, x, T)
                    }
                },
                unlock: function() {
                    var l = this
                      , i = document.body
                      , h = function u() {
                        if (l.context && i) {
                            var d = i.removeEventListener;
                            l.context.resume().then(function() {
                                d("touchstart", u),
                                d("touchend", u),
                                d("click", u),
                                d("keydown", u),
                                l.unlocked = !0
                            }, function() {
                                d("touchstart", u),
                                d("touchend", u),
                                d("click", u),
                                d("keydown", u)
                            })
                        }
                    };
                    i && (i.addEventListener("touchstart", h, !1),
                    i.addEventListener("touchend", h, !1),
                    i.addEventListener("click", h, !1),
                    i.addEventListener("keydown", h, !1))
                },
                onBlur: function() {
                    this.locked || this.context.suspend()
                },
                onFocus: function() {
                    var l = this.context;
                    (l.state === "suspended" || l.state === "interrupted") && !this.locked && l.resume()
                },
                update: function(l, i) {
                    f.prototype.update.call(this, l, i);
                    var h = this.context;
                    h && h.state === "interrupted" && h.resume()
                },
                destroy: function() {
                    if (this.destination = null,
                    this.masterVolumeNode.disconnect(),
                    this.masterVolumeNode = null,
                    this.masterMuteNode.disconnect(),
                    this.masterMuteNode = null,
                    this.game.config.audio.context)
                        this.context.suspend();
                    else {
                        var l = this;
                        this.context.close().then(function() {
                            l.context = null
                        })
                    }
                    f.prototype.destroy.call(this)
                },
                setMute: function(l) {
                    return this.mute = l,
                    this
                },
                mute: {
                    get: function() {
                        return this.masterMuteNode.gain.value === 0
                    },
                    set: function(l) {
                        this.masterMuteNode.gain.setValueAtTime(l ? 0 : 1, 0),
                        this.emit(o.GLOBAL_MUTE, this, l)
                    }
                },
                setVolume: function(l) {
                    return this.volume = l,
                    this
                },
                volume: {
                    get: function() {
                        return this.masterVolumeNode.gain.value
                    },
                    set: function(l) {
                        this.masterVolumeNode.gain.setValueAtTime(l, 0),
                        this.emit(o.GLOBAL_VOLUME, this, l)
                    }
                }
            });
            c.exports = s
        }
        , function(c, S) {
            /**
 * @author       Niklas von Hertzen (https://github.com/niklasvh/base64-arraybuffer)
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            for (var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", e = new Uint8Array(256), f = 0; f < t.length; f++)
                e[t.charCodeAt(f)] = f;
            var r = function(o) {
                o = o.substr(o.indexOf(",") + 1);
                var a = o.length, n = a * .75, s = 0, l, i, h, u;
                o[a - 1] === "=" && (n--,
                o[a - 2] === "=" && n--);
                for (var d = new ArrayBuffer(n), v = new Uint8Array(d), p = 0; p < a; p += 4)
                    l = e[o.charCodeAt(p)],
                    i = e[o.charCodeAt(p + 1)],
                    h = e[o.charCodeAt(p + 2)],
                    u = e[o.charCodeAt(p + 3)],
                    v[s++] = l << 2 | i >> 4,
                    v[s++] = (i & 15) << 4 | h >> 2,
                    v[s++] = (h & 3) << 6 | u & 63;
                return d
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(146)
              , f = t(0)
              , r = t(70)
              , o = new f({
                Extends: e,
                initialize: function(n, s, l) {
                    if (l === void 0 && (l = {}),
                    this.audioBuffer = n.game.cache.audio.get(s),
                    !this.audioBuffer)
                        throw new Error('Audio key "' + s + '" missing from cache');
                    this.source = null,
                    this.loopSource = null,
                    this.muteNode = n.context.createGain(),
                    this.volumeNode = n.context.createGain(),
                    this.pannerNode = null,
                    this.playTime = 0,
                    this.startTime = 0,
                    this.loopTime = 0,
                    this.rateUpdates = [],
                    this.hasEnded = !1,
                    this.hasLooped = !1,
                    this.muteNode.connect(this.volumeNode),
                    n.context.createStereoPanner ? (this.pannerNode = n.context.createStereoPanner(),
                    this.volumeNode.connect(this.pannerNode),
                    this.pannerNode.connect(n.destination)) : this.volumeNode.connect(n.destination),
                    this.duration = this.audioBuffer.duration,
                    this.totalDuration = this.audioBuffer.duration,
                    e.call(this, n, s, l)
                },
                play: function(a, n) {
                    return e.prototype.play.call(this, a, n) ? (this.stopAndRemoveBufferSource(),
                    this.createAndStartBufferSource(),
                    this.emit(r.PLAY, this),
                    !0) : !1
                },
                pause: function() {
                    return this.manager.context.currentTime < this.startTime || !e.prototype.pause.call(this) ? !1 : (this.currentConfig.seek = this.getCurrentTime(),
                    this.stopAndRemoveBufferSource(),
                    this.emit(r.PAUSE, this),
                    !0)
                },
                resume: function() {
                    return this.manager.context.currentTime < this.startTime || !e.prototype.resume.call(this) ? !1 : (this.createAndStartBufferSource(),
                    this.emit(r.RESUME, this),
                    !0)
                },
                stop: function() {
                    return e.prototype.stop.call(this) ? (this.stopAndRemoveBufferSource(),
                    this.emit(r.STOP, this),
                    !0) : !1
                },
                createAndStartBufferSource: function() {
                    var a = this.currentConfig.seek
                      , n = this.currentConfig.delay
                      , s = this.manager.context.currentTime + n
                      , l = (this.currentMarker ? this.currentMarker.start : 0) + a
                      , i = this.duration - a;
                    this.playTime = s - a,
                    this.startTime = s,
                    this.source = this.createBufferSource(),
                    this.applyConfig(),
                    this.source.start(Math.max(0, s), Math.max(0, l), Math.max(0, i)),
                    this.resetConfig()
                },
                createAndStartLoopBufferSource: function() {
                    var a = this.getLoopTime()
                      , n = this.currentMarker ? this.currentMarker.start : 0
                      , s = this.duration;
                    this.loopTime = a,
                    this.loopSource = this.createBufferSource(),
                    this.loopSource.playbackRate.setValueAtTime(this.totalRate, 0),
                    this.loopSource.start(Math.max(0, a), Math.max(0, n), Math.max(0, s))
                },
                createBufferSource: function() {
                    var a = this
                      , n = this.manager.context.createBufferSource();
                    return n.buffer = this.audioBuffer,
                    n.connect(this.muteNode),
                    n.onended = function(s) {
                        s.target === a.source && (a.currentConfig.loop ? a.hasLooped = !0 : a.hasEnded = !0)
                    }
                    ,
                    n
                },
                stopAndRemoveBufferSource: function() {
                    this.source && (this.source.stop(),
                    this.source.disconnect(),
                    this.source = null),
                    this.playTime = 0,
                    this.startTime = 0,
                    this.stopAndRemoveLoopBufferSource()
                },
                stopAndRemoveLoopBufferSource: function() {
                    this.loopSource && (this.loopSource.stop(),
                    this.loopSource.disconnect(),
                    this.loopSource = null),
                    this.loopTime = 0
                },
                applyConfig: function() {
                    this.rateUpdates.length = 0,
                    this.rateUpdates.push({
                        time: 0,
                        rate: 1
                    }),
                    e.prototype.applyConfig.call(this)
                },
                update: function() {
                    this.hasEnded ? (this.hasEnded = !1,
                    e.prototype.stop.call(this),
                    this.stopAndRemoveBufferSource(),
                    this.emit(r.COMPLETE, this)) : this.hasLooped && (this.hasLooped = !1,
                    this.source = this.loopSource,
                    this.loopSource = null,
                    this.playTime = this.startTime = this.loopTime,
                    this.rateUpdates.length = 0,
                    this.rateUpdates.push({
                        time: 0,
                        rate: this.totalRate
                    }),
                    this.createAndStartLoopBufferSource(),
                    this.emit(r.LOOPED, this))
                },
                destroy: function() {
                    e.prototype.destroy.call(this),
                    this.audioBuffer = null,
                    this.stopAndRemoveBufferSource(),
                    this.muteNode.disconnect(),
                    this.muteNode = null,
                    this.volumeNode.disconnect(),
                    this.volumeNode = null,
                    this.pannerNode && (this.pannerNode.disconnect(),
                    this.pannerNode = null),
                    this.rateUpdates.length = 0,
                    this.rateUpdates = null
                },
                calculateRate: function() {
                    e.prototype.calculateRate.call(this);
                    var a = this.manager.context.currentTime;
                    this.source && typeof this.totalRate == "number" && this.source.playbackRate.setValueAtTime(this.totalRate, a),
                    this.isPlaying && (this.rateUpdates.push({
                        time: Math.max(this.startTime, a) - this.playTime,
                        rate: this.totalRate
                    }),
                    this.loopSource && (this.stopAndRemoveLoopBufferSource(),
                    this.createAndStartLoopBufferSource()))
                },
                getCurrentTime: function() {
                    for (var a = 0, n = 0; n < this.rateUpdates.length; n++) {
                        var s = 0;
                        n < this.rateUpdates.length - 1 ? s = this.rateUpdates[n + 1].time : s = this.manager.context.currentTime - this.playTime,
                        a += (s - this.rateUpdates[n].time) * this.rateUpdates[n].rate
                    }
                    return a
                },
                getLoopTime: function() {
                    for (var a = 0, n = 0; n < this.rateUpdates.length - 1; n++)
                        a += (this.rateUpdates[n + 1].time - this.rateUpdates[n].time) * this.rateUpdates[n].rate;
                    var s = this.rateUpdates[this.rateUpdates.length - 1];
                    return this.playTime + s.time + (this.duration - a) / s.rate
                },
                rate: {
                    get: function() {
                        return this.currentConfig.rate
                    },
                    set: function(a) {
                        this.currentConfig.rate = a,
                        this.calculateRate(),
                        this.emit(r.RATE, this, a)
                    }
                },
                setRate: function(a) {
                    return this.rate = a,
                    this
                },
                detune: {
                    get: function() {
                        return this.currentConfig.detune
                    },
                    set: function(a) {
                        this.currentConfig.detune = a,
                        this.calculateRate(),
                        this.emit(r.DETUNE, this, a)
                    }
                },
                setDetune: function(a) {
                    return this.detune = a,
                    this
                },
                mute: {
                    get: function() {
                        return this.muteNode.gain.value === 0
                    },
                    set: function(a) {
                        this.currentConfig.mute = a,
                        this.muteNode.gain.setValueAtTime(a ? 0 : 1, 0),
                        this.emit(r.MUTE, this, a)
                    }
                },
                setMute: function(a) {
                    return this.mute = a,
                    this
                },
                volume: {
                    get: function() {
                        return this.volumeNode.gain.value
                    },
                    set: function(a) {
                        this.currentConfig.volume = a,
                        this.volumeNode.gain.setValueAtTime(a, 0),
                        this.emit(r.VOLUME, this, a)
                    }
                },
                setVolume: function(a) {
                    return this.volume = a,
                    this
                },
                seek: {
                    get: function() {
                        return this.isPlaying ? this.manager.context.currentTime < this.startTime ? this.startTime - this.playTime : this.getCurrentTime() : this.isPaused ? this.currentConfig.seek : 0
                    },
                    set: function(a) {
                        this.manager.context.currentTime < this.startTime || (this.isPlaying || this.isPaused) && (a = Math.min(Math.max(0, a), this.duration),
                        this.currentConfig.seek = a,
                        this.isPlaying && (this.stopAndRemoveBufferSource(),
                        this.createAndStartBufferSource()),
                        this.emit(r.SEEK, this, a))
                    }
                },
                setSeek: function(a) {
                    return this.seek = a,
                    this
                },
                loop: {
                    get: function() {
                        return this.currentConfig.loop
                    },
                    set: function(a) {
                        this.currentConfig.loop = a,
                        this.isPlaying && (this.stopAndRemoveLoopBufferSource(),
                        a && this.createAndStartLoopBufferSource()),
                        this.emit(r.LOOP, this, a)
                    }
                },
                setLoop: function(a) {
                    return this.loop = a,
                    this
                },
                pan: {
                    get: function() {
                        return this.pannerNode ? this.pannerNode.pan.value : 0
                    },
                    set: function(a) {
                        this.currentConfig.pan = a,
                        this.pannerNode && this.pannerNode.pan.setValueAtTime(a, this.manager.context.currentTime),
                        this.emit(r.PAN, this, a)
                    }
                },
                setPan: function(a) {
                    return this.pan = a,
                    this
                }
            });
            c.exports = o
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                for (var f = e.length, r = e[0].length, o = new Array(r), a = 0; a < r; a++) {
                    o[a] = new Array(f);
                    for (var n = f - 1; n > -1; n--)
                        o[a][n] = e[n][a]
                }
                return o
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            function t(r, o, a) {
                var n = r[o];
                r[o] = r[a],
                r[a] = n
            }
            function e(r, o) {
                return r < o ? -1 : r > o ? 1 : 0
            }
            var f = function(r, o, a, n, s) {
                for (a === void 0 && (a = 0),
                n === void 0 && (n = r.length - 1),
                s === void 0 && (s = e); n > a; ) {
                    if (n - a > 600) {
                        var l = n - a + 1
                          , i = o - a + 1
                          , h = Math.log(l)
                          , u = .5 * Math.exp(2 * h / 3)
                          , d = .5 * Math.sqrt(h * u * (l - u) / l) * (i - l / 2 < 0 ? -1 : 1)
                          , v = Math.max(a, Math.floor(o - i * u / l + d))
                          , p = Math.min(n, Math.floor(o + (l - i) * u / l + d));
                        f(r, o, v, p, s)
                    }
                    var g = r[o]
                      , m = a
                      , x = n;
                    for (t(r, a, o),
                    s(r[n], g) > 0 && t(r, a, n); m < x; ) {
                        for (t(r, m, x),
                        m++,
                        x--; s(r[m], g) < 0; )
                            m++;
                        for (; s(r[x], g) > 0; )
                            x--
                    }
                    s(r[a], g) === 0 ? t(r, a, x) : (x++,
                    t(r, x, n)),
                    x <= o && (a = x + 1),
                    o <= x && (n = x - 1)
                }
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(6)
              , f = t(131)
              , r = function(a, n, s) {
                for (var l = [], i = 0; i < a.length; i++)
                    for (var h = 0; h < n.length; h++)
                        for (var u = 0; u < s; u++)
                            l.push({
                                a: a[i],
                                b: n[h]
                            });
                return l
            }
              , o = function(a, n, s) {
                var l = e(s, "max", 0)
                  , i = e(s, "qty", 1)
                  , h = e(s, "random", !1)
                  , u = e(s, "randomB", !1)
                  , d = e(s, "repeat", 0)
                  , v = e(s, "yoyo", !1)
                  , p = [];
                if (u && f(n),
                d === -1)
                    if (l === 0)
                        d = 0;
                    else {
                        var g = a.length * n.length * i;
                        v && (g *= 2),
                        d = Math.ceil(l / g)
                    }
                for (var m = 0; m <= d; m++) {
                    var x = r(a, n, i);
                    h && f(x),
                    p = p.concat(x),
                    v && (x.reverse(),
                    p = p.concat(x))
                }
                return l && p.splice(l),
                p
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                PROCESS_QUEUE_ADD: t(1041),
                PROCESS_QUEUE_REMOVE: t(1042)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(13)
              , f = function(r, o) {
                var a = e(o, "anims", null);
                if (a === null)
                    return r;
                if (typeof a == "string")
                    r.anims.play(a);
                else if (typeof a == "object") {
                    var n = r.anims
                      , s = e(a, "key", void 0);
                    if (s) {
                        var l = e(a, "startFrame", void 0)
                          , i = e(a, "delay", 0)
                          , h = e(a, "repeat", 0)
                          , u = e(a, "repeatDelay", 0)
                          , d = e(a, "yoyo", !1)
                          , v = e(a, "play", !1)
                          , p = e(a, "delayedPlay", 0)
                          , g = {
                            key: s,
                            delay: i,
                            repeat: h,
                            repeatDelay: u,
                            yoyo: d,
                            startFrame: l
                        };
                        v ? n.play(g) : p > 0 ? n.playAfterDelay(g, p) : n.load(g)
                    }
                }
                return r
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(109)
              , r = new e({
                initialize: function(a, n, s, l, i) {
                    this.parent = a,
                    this.x = n,
                    this.y = s,
                    this.frame = l,
                    this.data = {},
                    this.tint = 16777215,
                    this._visible = i,
                    this._alpha = 1,
                    this.flipX = !1,
                    this.flipY = !1
                },
                setFrame: function(o) {
                    return o === void 0 ? this.frame = this.parent.frame : o instanceof f && o.texture === this.parent.texture ? this.frame = o : this.frame = this.parent.texture.get(o),
                    this
                },
                resetFlip: function() {
                    return this.flipX = !1,
                    this.flipY = !1,
                    this
                },
                reset: function(o, a, n) {
                    return this.x = o,
                    this.y = a,
                    this.flipX = !1,
                    this.flipY = !1,
                    this._alpha = 1,
                    this._visible = !0,
                    this.parent.dirty = !0,
                    n && this.setFrame(n),
                    this
                },
                setPosition: function(o, a) {
                    return this.x = o,
                    this.y = a,
                    this
                },
                setFlipX: function(o) {
                    return this.flipX = o,
                    this
                },
                setFlipY: function(o) {
                    return this.flipY = o,
                    this
                },
                setFlip: function(o, a) {
                    return this.flipX = o,
                    this.flipY = a,
                    this
                },
                setVisible: function(o) {
                    return this.visible = o,
                    this
                },
                setAlpha: function(o) {
                    return this.alpha = o,
                    this
                },
                setTint: function(o) {
                    return this.tint = o,
                    this
                },
                destroy: function() {
                    this.parent.dirty = !0,
                    this.parent.children.remove(this),
                    this.parent = void 0,
                    this.frame = void 0,
                    this.data = void 0
                },
                visible: {
                    get: function() {
                        return this._visible
                    },
                    set: function(o) {
                        this.parent.dirty |= this._visible !== o,
                        this._visible = o
                    }
                },
                alpha: {
                    get: function() {
                        return this._alpha
                    },
                    set: function(o) {
                        this.parent.dirty |= this._alpha > 0 != o > 0,
                        this._alpha = o
                    }
                }
            });
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(10)
              , f = function(r, o, a) {
                a === void 0 && (a = new e);
                var n = Math.min(r.x, o.x)
                  , s = Math.min(r.y, o.y)
                  , l = Math.max(r.right, o.right) - n
                  , i = Math.max(r.bottom, o.bottom) - s;
                return a.setTo(n, s, l, i)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(11)
              , r = t(1055)
              , o = t(15)
              , a = t(7)
              , n = t(202)
              , s = t(20)
              , l = t(140)
              , i = new e({
                Extends: o,
                Mixins: [f.AlphaSingle, f.BlendMode, f.Depth, f.Origin, f.ScrollFactor, f.Transform, f.Visible, r],
                initialize: function(u, d, v, p, g, m) {
                    o.call(this, u, "DOMElement"),
                    this.parent = u.sys.game.domContainer,
                    this.cache = u.sys.cache.html,
                    this.node,
                    this.transformOnly = !1,
                    this.skewX = 0,
                    this.skewY = 0,
                    this.rotate3d = new l,
                    this.rotate3dAngle = "deg",
                    this.pointerEvents = "auto",
                    this.width = 0,
                    this.height = 0,
                    this.displayWidth = 0,
                    this.displayHeight = 0,
                    this.handler = this.dispatchNativeEvent.bind(this),
                    this.setPosition(d, v),
                    typeof p == "string" ? p[0] === "#" ? this.setElement(p.substr(1), g, m) : this.createElement(p, g, m) : p && this.setElement(p, g, m),
                    u.sys.events.on(s.SLEEP, this.handleSceneEvent, this),
                    u.sys.events.on(s.WAKE, this.handleSceneEvent, this)
                },
                addedToScene: function() {
                    this.scene.sys.updateList.add(this)
                },
                removedFromScene: function() {
                    this.scene.sys.updateList.remove(this)
                },
                handleSceneEvent: function(h) {
                    var u = this.node
                      , d = u.style;
                    u && (d.display = h.settings.visible ? "block" : "none")
                },
                setSkew: function(h, u) {
                    return h === void 0 && (h = 0),
                    u === void 0 && (u = h),
                    this.skewX = h,
                    this.skewY = u,
                    this
                },
                setPerspective: function(h) {
                    return this.parent.style.perspective = h + "px",
                    this
                },
                perspective: {
                    get: function() {
                        return parseFloat(this.parent.style.perspective)
                    },
                    set: function(h) {
                        this.parent.style.perspective = h + "px"
                    }
                },
                addListener: function(h) {
                    if (this.node) {
                        h = h.split(" ");
                        for (var u = 0; u < h.length; u++)
                            this.node.addEventListener(h[u], this.handler, !1)
                    }
                    return this
                },
                removeListener: function(h) {
                    if (this.node) {
                        h = h.split(" ");
                        for (var u = 0; u < h.length; u++)
                            this.node.removeEventListener(h[u], this.handler)
                    }
                    return this
                },
                dispatchNativeEvent: function(h) {
                    this.emit(h.type, h)
                },
                createElement: function(h, u, d) {
                    return this.setElement(document.createElement(h), u, d)
                },
                setElement: function(h, u, d) {
                    this.removeElement();
                    var v;
                    if (typeof h == "string" ? (h[0] === "#" && (h = h.substr(1)),
                    v = document.getElementById(h)) : typeof h == "object" && h.nodeType === 1 && (v = h),
                    !v)
                        return this;
                    if (this.node = v,
                    u && a(u))
                        for (var p in u)
                            v.style[p] = u[p];
                    else
                        typeof u == "string" && (v.style = u);
                    return v.style.zIndex = "0",
                    v.style.display = "inline",
                    v.style.position = "absolute",
                    v.phaser = this,
                    this.parent && this.parent.appendChild(v),
                    d && (v.innerText = d),
                    this.updateSize()
                },
                createFromCache: function(h, u) {
                    var d = this.cache.get(h);
                    return d && this.createFromHTML(d, u),
                    this
                },
                createFromHTML: function(h, u) {
                    u === void 0 && (u = "div"),
                    this.removeElement();
                    var d = document.createElement(u);
                    return this.node = d,
                    d.style.zIndex = "0",
                    d.style.display = "inline",
                    d.style.position = "absolute",
                    d.phaser = this,
                    this.parent && this.parent.appendChild(d),
                    d.innerHTML = h,
                    this.updateSize()
                },
                removeElement: function() {
                    return this.node && (n(this.node),
                    this.node = null),
                    this
                },
                updateSize: function() {
                    var h = this.node
                      , u = h.getBoundingClientRect();
                    return this.width = h.clientWidth,
                    this.height = h.clientHeight,
                    this.displayWidth = u.width || 0,
                    this.displayHeight = u.height || 0,
                    this
                },
                getChildByProperty: function(h, u) {
                    if (this.node) {
                        for (var d = this.node.querySelectorAll("*"), v = 0; v < d.length; v++)
                            if (d[v][h] === u)
                                return d[v]
                    }
                    return null
                },
                getChildByID: function(h) {
                    return this.getChildByProperty("id", h)
                },
                getChildByName: function(h) {
                    return this.getChildByProperty("name", h)
                },
                setClassName: function(h) {
                    return this.node && (this.node.className = h,
                    this.updateSize()),
                    this
                },
                setText: function(h) {
                    return this.node && (this.node.innerText = h,
                    this.updateSize()),
                    this
                },
                setHTML: function(h) {
                    return this.node && (this.node.innerHTML = h,
                    this.updateSize()),
                    this
                },
                preUpdate: function() {
                    var h = this.parentContainer
                      , u = this.node;
                    u && h && !h.willRender() && (u.style.display = "none")
                },
                willRender: function() {
                    return !0
                },
                preDestroy: function() {
                    this.removeElement(),
                    this.scene.sys.events.off(s.SLEEP, this.handleSceneEvent, this),
                    this.scene.sys.events.off(s.WAKE, this.handleSceneEvent, this)
                }
            });
            c.exports = i
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1056)
              , f = t(15)
              , r = t(25)
              , o = new r
              , a = new r
              , n = new r
              , s = function(l, i, h, u) {
                if (i.node) {
                    var d = i.node.style
                      , v = i.scene.sys.settings;
                    if (!d || !v.visible || f.RENDER_MASK !== i.renderFlags || i.cameraFilter !== 0 && i.cameraFilter & h.id || i.parentContainer && !i.parentContainer.willRender()) {
                        d.display = "none";
                        return
                    }
                    var p = i.parentContainer
                      , g = h.alpha * i.alpha;
                    p && (g *= p.alpha);
                    var m = o
                      , x = a
                      , T = n
                      , E = 0
                      , P = 0
                      , M = "0%"
                      , L = "0%";
                    u ? (E = i.width * i.scaleX * i.originX,
                    P = i.height * i.scaleY * i.originY,
                    x.applyITRS(i.x - E, i.y - P, i.rotation, i.scaleX, i.scaleY),
                    m.copyFrom(h.matrix),
                    m.multiplyWithOffset(u, -h.scrollX * i.scrollFactorX, -h.scrollY * i.scrollFactorY),
                    x.e = i.x - E,
                    x.f = i.y - P,
                    m.multiply(x, T)) : (E = i.width * i.originX,
                    P = i.height * i.originY,
                    x.applyITRS(i.x - E, i.y - P, i.rotation, i.scaleX, i.scaleY),
                    m.copyFrom(h.matrix),
                    M = 100 * i.originX + "%",
                    L = 100 * i.originY + "%",
                    x.e -= h.scrollX * i.scrollFactorX,
                    x.f -= h.scrollY * i.scrollFactorY,
                    m.multiply(x, T)),
                    i.transformOnly || (d.display = "block",
                    d.opacity = g,
                    d.zIndex = i._depth,
                    d.pointerEvents = i.pointerEvents,
                    d.mixBlendMode = e[i._blendMode]),
                    d.transform = T.getCSSMatrix() + " skew(" + i.skewX + "rad, " + i.skewY + "rad) rotate3d(" + i.rotate3d.x + "," + i.rotate3d.y + "," + i.rotate3d.z + "," + i.rotate3d.w + i.rotate3dAngle + ")",
                    d.transformOrigin = M + " " + L
                }
            };
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(11)
              , r = t(15)
              , o = t(1060)
              , a = new e({
                Extends: r,
                Mixins: [f.Alpha, f.BlendMode, f.Depth, f.Flip, f.Origin, f.ScrollFactor, f.Size, f.Texture, f.Tint, f.Transform, f.Visible, o],
                initialize: function(s) {
                    r.call(this, s, "Extern")
                },
                addedToScene: function() {
                    this.scene.sys.updateList.add(this)
                },
                removedFromScene: function() {
                    this.scene.sys.updateList.remove(this)
                },
                preUpdate: function() {},
                render: function() {}
            });
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(218)
              , f = t(98)
              , r = t(14)
              , o = t(4)
              , a = function(n, s, l) {
                l === void 0 && (l = new o);
                var i = f(s, 0, r.PI2);
                return e(n, i, l)
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(447)
              , f = t(218)
              , r = t(98)
              , o = t(14)
              , a = function(n, s, l, i) {
                i === void 0 && (i = []),
                !s && l > 0 && (s = e(n) / l);
                for (var h = 0; h < s; h++) {
                    var u = r(h / s, 0, o.PI2);
                    i.push(f(n, u))
                }
                return i
            };
            c.exports = a
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                var f = e.width / 2
                  , r = e.height / 2
                  , o = Math.pow(f - r, 2) / Math.pow(f + r, 2);
                return Math.PI * (f + r) * (1 + 3 * o / (10 + Math.sqrt(4 - 3 * o)))
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(217)
              , f = t(30)
              , r = function(o, a, n, s, l, i) {
                var h = a.commandBuffer
                  , u = h.length
                  , d = l || o.currentContext;
                if (!(u === 0 || !f(o, d, a, n, s))) {
                    n.addToRenderList(a);
                    var v = 1
                      , p = 1
                      , g = 0
                      , m = 0
                      , x = 1
                      , T = 0
                      , E = 0
                      , P = 0;
                    d.beginPath();
                    for (var M = 0; M < u; ++M) {
                        var L = h[M];
                        switch (L) {
                        case e.ARC:
                            d.arc(h[M + 1], h[M + 2], h[M + 3], h[M + 4], h[M + 5], h[M + 6]),
                            M += 7;
                            break;
                        case e.LINE_STYLE:
                            x = h[M + 1],
                            g = h[M + 2],
                            v = h[M + 3],
                            T = (g & 16711680) >>> 16,
                            E = (g & 65280) >>> 8,
                            P = g & 255,
                            d.strokeStyle = "rgba(" + T + "," + E + "," + P + "," + v + ")",
                            d.lineWidth = x,
                            M += 3;
                            break;
                        case e.FILL_STYLE:
                            m = h[M + 1],
                            p = h[M + 2],
                            T = (m & 16711680) >>> 16,
                            E = (m & 65280) >>> 8,
                            P = m & 255,
                            d.fillStyle = "rgba(" + T + "," + E + "," + P + "," + p + ")",
                            M += 2;
                            break;
                        case e.BEGIN_PATH:
                            d.beginPath();
                            break;
                        case e.CLOSE_PATH:
                            d.closePath();
                            break;
                        case e.FILL_PATH:
                            i || d.fill();
                            break;
                        case e.STROKE_PATH:
                            i || d.stroke();
                            break;
                        case e.FILL_RECT:
                            i ? d.rect(h[M + 1], h[M + 2], h[M + 3], h[M + 4]) : d.fillRect(h[M + 1], h[M + 2], h[M + 3], h[M + 4]),
                            M += 4;
                            break;
                        case e.FILL_TRIANGLE:
                            d.beginPath(),
                            d.moveTo(h[M + 1], h[M + 2]),
                            d.lineTo(h[M + 3], h[M + 4]),
                            d.lineTo(h[M + 5], h[M + 6]),
                            d.closePath(),
                            i || d.fill(),
                            M += 6;
                            break;
                        case e.STROKE_TRIANGLE:
                            d.beginPath(),
                            d.moveTo(h[M + 1], h[M + 2]),
                            d.lineTo(h[M + 3], h[M + 4]),
                            d.lineTo(h[M + 5], h[M + 6]),
                            d.closePath(),
                            i || d.stroke(),
                            M += 6;
                            break;
                        case e.LINE_TO:
                            d.lineTo(h[M + 1], h[M + 2]),
                            M += 2;
                            break;
                        case e.MOVE_TO:
                            d.moveTo(h[M + 1], h[M + 2]),
                            M += 2;
                            break;
                        case e.LINE_FX_TO:
                            d.lineTo(h[M + 1], h[M + 2]),
                            M += 5;
                            break;
                        case e.MOVE_FX_TO:
                            d.moveTo(h[M + 1], h[M + 2]),
                            M += 5;
                            break;
                        case e.SAVE:
                            d.save();
                            break;
                        case e.RESTORE:
                            d.restore();
                            break;
                        case e.TRANSLATE:
                            d.translate(h[M + 1], h[M + 2]),
                            M += 2;
                            break;
                        case e.SCALE:
                            d.scale(h[M + 1], h[M + 2]),
                            M += 2;
                            break;
                        case e.ROTATE:
                            d.rotate(h[M + 1]),
                            M += 1;
                            break;
                        case e.GRADIENT_FILL_STYLE:
                            M += 5;
                            break;
                        case e.GRADIENT_LINE_STYLE:
                            M += 6;
                            break
                        }
                    }
                    d.restore()
                }
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(137)
              , r = t(80)
              , o = t(2)
              , a = t(68)
              , n = new e({
                initialize: function(l, i, h, u) {
                    u === void 0 && (u = !1),
                    this.propertyKey = i,
                    this.propertyValue = h,
                    this.defaultValue = h,
                    this.steps = 0,
                    this.counter = 0,
                    this.start = 0,
                    this.end = 0,
                    this.ease,
                    this.emitOnly = u,
                    this.onEmit = this.defaultEmit,
                    this.onUpdate = this.defaultUpdate,
                    this.loadConfig(l)
                },
                loadConfig: function(s, l) {
                    s === void 0 && (s = {}),
                    l && (this.propertyKey = l),
                    this.propertyValue = o(s, this.propertyKey, this.defaultValue),
                    this.setMethods(),
                    this.emitOnly && (this.onUpdate = this.defaultUpdate)
                },
                toJSON: function() {
                    return this.propertyValue
                },
                onChange: function(s) {
                    return this.propertyValue = s,
                    this.setMethods()
                },
                setMethods: function() {
                    var s = this.propertyValue
                      , l = typeof s;
                    if (this.onEmit = this.defaultEmit,
                    this.onUpdate = this.defaultUpdate,
                    l === "number")
                        this.onEmit = this.staticValueEmit,
                        this.onUpdate = this.staticValueUpdate;
                    else if (Array.isArray(s))
                        this.onEmit = this.randomStaticValueEmit;
                    else if (l === "function")
                        this.emitOnly ? this.onEmit = s : this.onUpdate = s;
                    else if (l === "object" && this.hasBoth(s, "start", "end")) {
                        this.start = s.start,
                        this.end = s.end;
                        var i = this.has(s, "random");
                        if (i && (this.onEmit = this.randomRangedValueEmit),
                        this.has(s, "steps"))
                            this.steps = s.steps,
                            this.counter = this.start,
                            this.onEmit = this.steppedEmit;
                        else {
                            var h = this.has(s, "ease") ? s.ease : "Linear";
                            this.ease = r(h, s.easeParams),
                            i || (this.onEmit = this.easedValueEmit),
                            this.onUpdate = this.easeValueUpdate
                        }
                    } else if (l === "object" && this.hasBoth(s, "min", "max"))
                        this.start = s.min,
                        this.end = s.max,
                        this.onEmit = this.randomRangedValueEmit;
                    else if (l === "object" && this.has(s, "random")) {
                        var u = s.random;
                        Array.isArray(u) && (this.start = u[0],
                        this.end = u[1]),
                        this.onEmit = this.randomRangedValueEmit
                    } else
                        l === "object" && this.hasEither(s, "onEmit", "onUpdate") && (this.has(s, "onEmit") && (this.onEmit = s.onEmit),
                        this.has(s, "onUpdate") && (this.onUpdate = s.onUpdate));
                    return this
                },
                has: function(s, l) {
                    return s.hasOwnProperty(l)
                },
                hasBoth: function(s, l, i) {
                    return s.hasOwnProperty(l) && s.hasOwnProperty(i)
                },
                hasEither: function(s, l, i) {
                    return s.hasOwnProperty(l) || s.hasOwnProperty(i)
                },
                defaultEmit: function(s, l, i) {
                    return i
                },
                defaultUpdate: function(s, l, i, h) {
                    return h
                },
                staticValueEmit: function() {
                    return this.propertyValue
                },
                staticValueUpdate: function() {
                    return this.propertyValue
                },
                randomStaticValueEmit: function() {
                    var s = Math.floor(Math.random() * this.propertyValue.length);
                    return this.propertyValue[s]
                },
                randomRangedValueEmit: function(s, l) {
                    var i = f(this.start, this.end);
                    return s && s.data[l] && (s.data[l].min = i),
                    i
                },
                steppedEmit: function() {
                    var s = this.counter
                      , l = this.counter + (this.end - this.start) / this.steps;
                    return this.counter = a(l, this.start, this.end),
                    s
                },
                easedValueEmit: function(s, l) {
                    if (s && s.data[l]) {
                        var i = s.data[l];
                        i.min = this.start,
                        i.max = this.end
                    }
                    return this.start
                },
                easeValueUpdate: function(s, l, i) {
                    var h = s.data[l];
                    return (h.max - h.min) * this.ease(i) + h.min
                }
            });
            c.exports = n
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(2)
              , r = new e({
                initialize: function(a, n, s, l, i) {
                    if (typeof a == "object") {
                        var h = a;
                        a = f(h, "x", 0),
                        n = f(h, "y", 0),
                        s = f(h, "power", 0),
                        l = f(h, "epsilon", 100),
                        i = f(h, "gravity", 50)
                    } else
                        a === void 0 && (a = 0),
                        n === void 0 && (n = 0),
                        s === void 0 && (s = 0),
                        l === void 0 && (l = 100),
                        i === void 0 && (i = 50);
                    this.x = a,
                    this.y = n,
                    this.active = !0,
                    this._gravity = i,
                    this._power = 0,
                    this._epsilon = 0,
                    this.power = s,
                    this.epsilon = l
                },
                update: function(o, a) {
                    var n = this.x - o.x
                      , s = this.y - o.y
                      , l = n * n + s * s;
                    if (l !== 0) {
                        var i = Math.sqrt(l);
                        l < this._epsilon && (l = this._epsilon);
                        var h = this._power * a / (l * i) * 100;
                        o.velocityX += n * h,
                        o.velocityY += s * h
                    }
                },
                epsilon: {
                    get: function() {
                        return Math.sqrt(this._epsilon)
                    },
                    set: function(o) {
                        this._epsilon = o * o
                    }
                },
                power: {
                    get: function() {
                        return this._power / this._gravity
                    },
                    set: function(o) {
                        this._power = o * this._gravity
                    }
                },
                gravity: {
                    get: function() {
                        return this._gravity
                    },
                    set: function(o) {
                        var a = this.power;
                        this._gravity = o,
                        this.power = a
                    }
                }
            });
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(36)
              , r = t(50)
              , o = new e({
                initialize: function(n) {
                    this.emitter = n,
                    this.frame = null,
                    this.x = 0,
                    this.y = 0,
                    this.velocityX = 0,
                    this.velocityY = 0,
                    this.accelerationX = 0,
                    this.accelerationY = 0,
                    this.maxVelocityX = 1e4,
                    this.maxVelocityY = 1e4,
                    this.bounce = 0,
                    this.scaleX = 1,
                    this.scaleY = 1,
                    this.alpha = 1,
                    this.angle = 0,
                    this.rotation = 0,
                    this.tint = 16777215,
                    this.life = 1e3,
                    this.lifeCurrent = 1e3,
                    this.delayCurrent = 0,
                    this.lifeT = 0,
                    this.data = {
                        tint: {
                            min: 16777215,
                            max: 16777215,
                            current: 16777215
                        },
                        alpha: {
                            min: 1,
                            max: 1
                        },
                        rotate: {
                            min: 0,
                            max: 0
                        },
                        scaleX: {
                            min: 1,
                            max: 1
                        },
                        scaleY: {
                            min: 1,
                            max: 1
                        }
                    }
                },
                isAlive: function() {
                    return this.lifeCurrent > 0
                },
                resetPosition: function() {
                    this.x = 0,
                    this.y = 0
                },
                fire: function(a, n) {
                    var s = this.emitter;
                    this.frame = s.getFrame(),
                    s.emitZone && s.emitZone.getPoint(this),
                    a === void 0 ? this.x += s.x.onEmit(this, "x") : this.x += a,
                    n === void 0 ? this.y += s.y.onEmit(this, "y") : this.y += n,
                    this.life = s.lifespan.onEmit(this, "lifespan"),
                    this.lifeCurrent = this.life,
                    this.lifeT = 0;
                    var l = s.speedX.onEmit(this, "speedX")
                      , i = s.speedY ? s.speedY.onEmit(this, "speedY") : l;
                    if (s.radial) {
                        var h = f(s.angle.onEmit(this, "angle"));
                        this.velocityX = Math.cos(h) * Math.abs(l),
                        this.velocityY = Math.sin(h) * Math.abs(i)
                    } else if (s.moveTo) {
                        var u = s.moveToX.onEmit(this, "moveToX")
                          , d = s.moveToY ? s.moveToY.onEmit(this, "moveToY") : u
                          , v = Math.atan2(d - this.y, u - this.x)
                          , p = r(this.x, this.y, u, d) / (this.life / 1e3);
                        this.velocityX = Math.cos(v) * p,
                        this.velocityY = Math.sin(v) * p
                    } else
                        this.velocityX = l,
                        this.velocityY = i;
                    s.acceleration && (this.accelerationX = s.accelerationX.onEmit(this, "accelerationX"),
                    this.accelerationY = s.accelerationY.onEmit(this, "accelerationY")),
                    this.maxVelocityX = s.maxVelocityX.onEmit(this, "maxVelocityX"),
                    this.maxVelocityY = s.maxVelocityY.onEmit(this, "maxVelocityY"),
                    this.delayCurrent = s.delay.onEmit(this, "delay"),
                    this.scaleX = s.scaleX.onEmit(this, "scaleX"),
                    this.scaleY = s.scaleY ? s.scaleY.onEmit(this, "scaleY") : this.scaleX,
                    this.angle = s.rotate.onEmit(this, "rotate"),
                    this.rotation = f(this.angle),
                    this.bounce = s.bounce.onEmit(this, "bounce"),
                    this.alpha = s.alpha.onEmit(this, "alpha"),
                    this.tint = s.tint.onEmit(this, "tint")
                },
                computeVelocity: function(a, n, s, l) {
                    var i = this.velocityX
                      , h = this.velocityY
                      , u = this.accelerationX
                      , d = this.accelerationY
                      , v = this.maxVelocityX
                      , p = this.maxVelocityY;
                    i += a.gravityX * s,
                    h += a.gravityY * s,
                    u && (i += u * s),
                    d && (h += d * s),
                    i > v ? i = v : i < -v && (i = -v),
                    h > p ? h = p : h < -p && (h = -p),
                    this.velocityX = i,
                    this.velocityY = h;
                    for (var g = 0; g < l.length; g++)
                        l[g].update(this, n, s)
                },
                checkBounds: function(a) {
                    var n = a.bounds
                      , s = -this.bounce;
                    this.x < n.x && a.collideLeft ? (this.x = n.x,
                    this.velocityX *= s) : this.x > n.right && a.collideRight && (this.x = n.right,
                    this.velocityX *= s),
                    this.y < n.y && a.collideTop ? (this.y = n.y,
                    this.velocityY *= s) : this.y > n.bottom && a.collideBottom && (this.y = n.bottom,
                    this.velocityY *= s)
                },
                update: function(a, n, s) {
                    if (this.delayCurrent > 0)
                        return this.delayCurrent -= a,
                        !1;
                    var l = this.emitter
                      , i = 1 - this.lifeCurrent / this.life;
                    return this.lifeT = i,
                    this.computeVelocity(l, a, n, s),
                    this.x += this.velocityX * n,
                    this.y += this.velocityY * n,
                    l.bounds && this.checkBounds(l),
                    l.deathZone && l.deathZone.willKill(this) ? (this.lifeCurrent = 0,
                    !0) : (this.scaleX = l.scaleX.onUpdate(this, "scaleX", i, this.scaleX),
                    l.scaleY ? this.scaleY = l.scaleY.onUpdate(this, "scaleY", i, this.scaleY) : this.scaleY = this.scaleX,
                    this.angle = l.rotate.onUpdate(this, "rotate", i, this.angle),
                    this.rotation = f(this.angle),
                    this.alpha = l.alpha.onUpdate(this, "alpha", i, this.alpha),
                    this.tint = l.tint.onUpdate(this, "tint", i, this.tint),
                    this.lifeCurrent -= a,
                    this.lifeCurrent <= 0)
                }
            });
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(35)
              , f = t(0)
              , r = t(11)
              , o = t(453)
              , a = t(454)
              , n = t(449)
              , s = t(2)
              , l = t(210)
              , i = t(455)
              , h = t(126)
              , u = t(451)
              , d = t(456)
              , v = t(10)
              , p = t(79)
              , g = t(3)
              , m = t(68)
              , x = new f({
                Mixins: [r.BlendMode, r.Mask, r.ScrollFactor, r.Visible],
                initialize: function(E, P) {
                    this.manager = E,
                    this.texture = E.texture,
                    this.frames = [E.defaultFrame],
                    this.defaultFrame = E.defaultFrame,
                    this.configFastMap = ["active", "blendMode", "collideBottom", "collideLeft", "collideRight", "collideTop", "deathCallback", "deathCallbackScope", "emitCallback", "emitCallbackScope", "follow", "frequency", "gravityX", "gravityY", "maxParticles", "name", "on", "particleBringToTop", "particleClass", "radial", "timeScale", "trackVisible", "visible"],
                    this.configOpMap = ["accelerationX", "accelerationY", "angle", "alpha", "bounce", "delay", "lifespan", "maxVelocityX", "maxVelocityY", "moveToX", "moveToY", "quantity", "rotate", "scaleX", "scaleY", "speedX", "speedY", "tint", "x", "y"],
                    this.name = "",
                    this.particleClass = u,
                    this.x = new n(P,"x",0,!0),
                    this.y = new n(P,"y",0,!0),
                    this.radial = !0,
                    this.gravityX = 0,
                    this.gravityY = 0,
                    this.acceleration = !1,
                    this.accelerationX = new n(P,"accelerationX",0,!0),
                    this.accelerationY = new n(P,"accelerationY",0,!0),
                    this.maxVelocityX = new n(P,"maxVelocityX",1e4,!0),
                    this.maxVelocityY = new n(P,"maxVelocityY",1e4,!0),
                    this.speedX = new n(P,"speedX",0,!0),
                    this.speedY = new n(P,"speedY",0,!0),
                    this.moveTo = !1,
                    this.moveToX = new n(P,"moveToX",0,!0),
                    this.moveToY = new n(P,"moveToY",0,!0),
                    this.bounce = new n(P,"bounce",0,!0),
                    this.scaleX = new n(P,"scaleX",1),
                    this.scaleY = new n(P,"scaleY",1),
                    this.tint = new n(P,"tint",16777215),
                    this.alpha = new n(P,"alpha",1),
                    this.lifespan = new n(P,"lifespan",1e3,!0),
                    this.angle = new n(P,"angle",{
                        min: 0,
                        max: 360
                    },!0),
                    this.rotate = new n(P,"rotate",0),
                    this.emitCallback = null,
                    this.emitCallbackScope = null,
                    this.deathCallback = null,
                    this.deathCallbackScope = null,
                    this.maxParticles = 0,
                    this.quantity = new n(P,"quantity",1,!0),
                    this.delay = new n(P,"delay",0,!0),
                    this.frequency = 0,
                    this.on = !0,
                    this.particleBringToTop = !0,
                    this.timeScale = 1,
                    this.emitZone = null,
                    this.deathZone = null,
                    this.bounds = null,
                    this.collideLeft = !0,
                    this.collideRight = !0,
                    this.collideTop = !0,
                    this.collideBottom = !0,
                    this.active = !0,
                    this.visible = !0,
                    this.blendMode = e.NORMAL,
                    this.follow = null,
                    this.followOffset = new g,
                    this.trackVisible = !1,
                    this.currentFrame = 0,
                    this.randomFrame = !0,
                    this.frameQuantity = 1,
                    this.dead = [],
                    this.alive = [],
                    this._counter = 0,
                    this._frameCounter = 0,
                    P && this.fromJSON(P)
                },
                fromJSON: function(T) {
                    if (!T)
                        return this;
                    var E = 0
                      , P = "";
                    for (E = 0; E < this.configFastMap.length; E++)
                        P = this.configFastMap[E],
                        h(T, P) && (this[P] = s(T, P));
                    for (E = 0; E < this.configOpMap.length; E++)
                        P = this.configOpMap[E],
                        h(T, P) && this[P].loadConfig(T);
                    if (this.acceleration = this.accelerationX.propertyValue !== 0 || this.accelerationY.propertyValue !== 0,
                    this.moveTo = this.moveToX.propertyValue !== 0 || this.moveToY.propertyValue !== 0,
                    h(T, "speed") && (this.speedX.loadConfig(T, "speed"),
                    this.speedY = null),
                    (i(T, ["speedX", "speedY"]) || this.moveTo) && (this.radial = !1),
                    h(T, "scale") && (this.scaleX.loadConfig(T, "scale"),
                    this.scaleY = null),
                    h(T, "callbackScope")) {
                        var M = s(T, "callbackScope", null);
                        this.emitCallbackScope = M,
                        this.deathCallbackScope = M
                    }
                    return h(T, "emitZone") && this.setEmitZone(T.emitZone),
                    h(T, "deathZone") && this.setDeathZone(T.deathZone),
                    h(T, "bounds") && this.setBounds(T.bounds),
                    h(T, "followOffset") && this.followOffset.setFromObject(s(T, "followOffset", 0)),
                    h(T, "frame") && this.setFrame(T.frame),
                    h(T, "reserve") && this.reserve(T.reserve),
                    this
                },
                toJSON: function(T) {
                    T === void 0 && (T = {});
                    var E = 0
                      , P = "";
                    for (E = 0; E < this.configFastMap.length; E++)
                        P = this.configFastMap[E],
                        T[P] = this[P];
                    for (E = 0; E < this.configOpMap.length; E++)
                        P = this.configOpMap[E],
                        this[P] && (T[P] = this[P].toJSON());
                    return this.speedY || (delete T.speedX,
                    T.speed = this.speedX.toJSON()),
                    this.scaleY || (delete T.scaleX,
                    T.scale = this.scaleX.toJSON()),
                    T
                },
                startFollow: function(T, E, P, M) {
                    return E === void 0 && (E = 0),
                    P === void 0 && (P = 0),
                    M === void 0 && (M = !1),
                    this.follow = T,
                    this.followOffset.set(E, P),
                    this.trackVisible = M,
                    this
                },
                stopFollow: function() {
                    return this.follow = null,
                    this.followOffset.set(0, 0),
                    this.trackVisible = !1,
                    this
                },
                getFrame: function() {
                    if (this.frames.length === 1)
                        return this.defaultFrame;
                    if (this.randomFrame)
                        return l(this.frames);
                    var T = this.frames[this.currentFrame];
                    return this._frameCounter++,
                    this._frameCounter === this.frameQuantity && (this._frameCounter = 0,
                    this.currentFrame = m(this.currentFrame + 1, 0, this._frameLength)),
                    T
                },
                setFrame: function(T, E, P) {
                    E === void 0 && (E = !0),
                    P === void 0 && (P = 1),
                    this.randomFrame = E,
                    this.frameQuantity = P,
                    this.currentFrame = 0,
                    this._frameCounter = 0;
                    var M = typeof T;
                    if (Array.isArray(T) || M === "string" || M === "number")
                        this.manager.setEmitterFrames(T, this);
                    else if (M === "object") {
                        var L = T;
                        T = s(L, "frames", null),
                        T && this.manager.setEmitterFrames(T, this);
                        var R = s(L, "cycle", !1);
                        this.randomFrame = !R,
                        this.frameQuantity = s(L, "quantity", P)
                    }
                    return this._frameLength = this.frames.length,
                    this._frameLength === 1 && (this.frameQuantity = 1,
                    this.randomFrame = !1),
                    this
                },
                setRadial: function(T) {
                    return T === void 0 && (T = !0),
                    this.radial = T,
                    this
                },
                setPosition: function(T, E) {
                    return this.x.onChange(T),
                    this.y.onChange(E),
                    this
                },
                setBounds: function(T, E, P, M) {
                    if (typeof T == "object") {
                        var L = T;
                        T = L.x,
                        E = L.y,
                        P = h(L, "w") ? L.w : L.width,
                        M = h(L, "h") ? L.h : L.height
                    }
                    return this.bounds ? this.bounds.setTo(T, E, P, M) : this.bounds = new v(T,E,P,M),
                    this
                },
                setSpeedX: function(T) {
                    return this.speedX.onChange(T),
                    this.radial = !1,
                    this
                },
                setSpeedY: function(T) {
                    return this.speedY && (this.speedY.onChange(T),
                    this.radial = !1),
                    this
                },
                setSpeed: function(T) {
                    return this.speedX.onChange(T),
                    this.speedY = null,
                    this.radial = !0,
                    this
                },
                setScaleX: function(T) {
                    return this.scaleX.onChange(T),
                    this
                },
                setScaleY: function(T) {
                    return this.scaleY.onChange(T),
                    this
                },
                setScale: function(T) {
                    return this.scaleX.onChange(T),
                    this.scaleY = null,
                    this
                },
                setGravityX: function(T) {
                    return this.gravityX = T,
                    this
                },
                setGravityY: function(T) {
                    return this.gravityY = T,
                    this
                },
                setGravity: function(T, E) {
                    return this.gravityX = T,
                    this.gravityY = E,
                    this
                },
                setAlpha: function(T) {
                    return this.alpha.onChange(T),
                    this
                },
                setTint: function(T) {
                    return this.tint.onChange(T),
                    this
                },
                setEmitterAngle: function(T) {
                    return this.angle.onChange(T),
                    this
                },
                setAngle: function(T) {
                    return this.angle.onChange(T),
                    this
                },
                setLifespan: function(T) {
                    return this.lifespan.onChange(T),
                    this
                },
                setQuantity: function(T) {
                    return this.quantity.onChange(T),
                    this
                },
                setFrequency: function(T, E) {
                    return this.frequency = T,
                    this._counter = 0,
                    E && this.quantity.onChange(E),
                    this
                },
                setEmitZone: function(T) {
                    if (T === void 0)
                        this.emitZone = null;
                    else {
                        var E = s(T, "type", "random")
                          , P = s(T, "source", null);
                        switch (E) {
                        case "random":
                            this.emitZone = new d(P);
                            break;
                        case "edge":
                            var M = s(T, "quantity", 1)
                              , L = s(T, "stepRate", 0)
                              , R = s(T, "yoyo", !1)
                              , O = s(T, "seamless", !0);
                            this.emitZone = new a(P,M,L,R,O);
                            break
                        }
                    }
                    return this
                },
                setDeathZone: function(T) {
                    if (T === void 0)
                        this.deathZone = null;
                    else {
                        var E = s(T, "type", "onEnter")
                          , P = s(T, "source", null);
                        if (P && typeof P.contains == "function") {
                            var M = E === "onEnter";
                            this.deathZone = new o(P,M)
                        }
                    }
                    return this
                },
                reserve: function(T) {
                    for (var E = this.dead, P = 0; P < T; P++)
                        E.push(new this.particleClass(this));
                    return this
                },
                getAliveParticleCount: function() {
                    return this.alive.length
                },
                getDeadParticleCount: function() {
                    return this.dead.length
                },
                getParticleCount: function() {
                    return this.getAliveParticleCount() + this.getDeadParticleCount()
                },
                atLimit: function() {
                    return this.maxParticles > 0 && this.getParticleCount() === this.maxParticles
                },
                onParticleEmit: function(T, E) {
                    return T === void 0 ? (this.emitCallback = null,
                    this.emitCallbackScope = null) : typeof T == "function" && (this.emitCallback = T,
                    E && (this.emitCallbackScope = E)),
                    this
                },
                onParticleDeath: function(T, E) {
                    return T === void 0 ? (this.deathCallback = null,
                    this.deathCallbackScope = null) : typeof T == "function" && (this.deathCallback = T,
                    E && (this.deathCallbackScope = E)),
                    this
                },
                killAll: function() {
                    for (var T = this.dead, E = this.alive; E.length > 0; )
                        T.push(E.pop());
                    return this
                },
                forEachAlive: function(T, E) {
                    for (var P = this.alive, M = P.length, L = 0; L < M; ++L)
                        T.call(E, P[L], this);
                    return this
                },
                forEachDead: function(T, E) {
                    for (var P = this.dead, M = P.length, L = 0; L < M; ++L)
                        T.call(E, P[L], this);
                    return this
                },
                start: function() {
                    return this.on = !0,
                    this._counter = 0,
                    this
                },
                stop: function() {
                    return this.on = !1,
                    this
                },
                pause: function() {
                    return this.active = !1,
                    this
                },
                resume: function() {
                    return this.active = !0,
                    this
                },
                remove: function() {
                    return this.manager.removeEmitter(this),
                    this
                },
                depthSort: function() {
                    return p(this.alive, this.depthSortCallback),
                    this
                },
                flow: function(T, E) {
                    return E === void 0 && (E = 1),
                    this.frequency = T,
                    this.quantity.onChange(E),
                    this.start()
                },
                explode: function(T, E, P) {
                    return this.frequency = -1,
                    this.emitParticle(T, E, P)
                },
                emitParticleAt: function(T, E, P) {
                    return this.emitParticle(P, T, E)
                },
                emitParticle: function(T, E, P) {
                    if (!this.atLimit()) {
                        T === void 0 && (T = this.quantity.onEmit());
                        for (var M = this.dead, L = this.follow ? this.follow.x + this.followOffset.x : E, R = this.follow ? this.follow.y + this.followOffset.y : P, O = 0; O < T; O++) {
                            var F = M.pop();
                            if (F || (F = new this.particleClass(this)),
                            F.fire(L, R),
                            this.particleBringToTop ? this.alive.push(F) : this.alive.unshift(F),
                            this.emitCallback && this.emitCallback.call(this.emitCallbackScope, F, this),
                            this.atLimit())
                                break
                        }
                        return F
                    }
                },
                preUpdate: function(T, E) {
                    E *= this.timeScale;
                    var P = E / 1e3;
                    this.trackVisible && (this.visible = this.follow.visible);
                    var M = this.manager.getProcessors()
                      , L = this.alive
                      , R = this.dead
                      , O = 0
                      , F = []
                      , B = L.length;
                    for (O = 0; O < B; O++) {
                        var N = L[O];
                        N.update(E, P, M) && F.push({
                            index: O,
                            particle: N
                        })
                    }
                    if (B = F.length,
                    B > 0) {
                        var Y = this.deathCallback
                          , z = this.deathCallbackScope;
                        for (O = B - 1; O >= 0; O--) {
                            var W = F[O];
                            L.splice(W.index, 1),
                            R.push(W.particle),
                            Y && Y.call(z, W.particle),
                            W.particle.resetPosition()
                        }
                    }
                    this.on && (this.frequency === 0 ? this.emitParticle() : this.frequency > 0 && (this._counter -= E,
                    this._counter <= 0 && (this.emitParticle(),
                    this._counter = this.frequency - Math.abs(this._counter))))
                },
                depthSortCallback: function(T, E) {
                    return T.y - E.y
                }
            });
            c.exports = x
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = new e({
                initialize: function(o, a) {
                    this.source = o,
                    this.killOnEnter = a
                },
                willKill: function(r) {
                    var o = this.source.contains(r.x, r.y);
                    return o && this.killOnEnter || !o && !this.killOnEnter
                }
            });
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = new e({
                initialize: function(o, a, n, s, l) {
                    s === void 0 && (s = !1),
                    l === void 0 && (l = !0),
                    this.source = o,
                    this.points = [],
                    this.quantity = a,
                    this.stepRate = n,
                    this.yoyo = s,
                    this.counter = -1,
                    this.seamless = l,
                    this._length = 0,
                    this._direction = 0,
                    this.updateSource()
                },
                updateSource: function() {
                    if (this.points = this.source.getPoints(this.quantity, this.stepRate),
                    this.seamless) {
                        var r = this.points[0]
                          , o = this.points[this.points.length - 1];
                        r.x === o.x && r.y === o.y && this.points.pop()
                    }
                    var a = this._length;
                    return this._length = this.points.length,
                    this._length < a && this.counter > this._length && (this.counter = this._length - 1),
                    this
                },
                changeSource: function(r) {
                    return this.source = r,
                    this.updateSource()
                },
                getPoint: function(r) {
                    this._direction === 0 ? (this.counter++,
                    this.counter >= this._length && (this.yoyo ? (this._direction = 1,
                    this.counter = this._length - 1) : this.counter = 0)) : (this.counter--,
                    this.counter === -1 && (this.yoyo ? (this._direction = 0,
                    this.counter = 0) : this.counter = this._length - 1));
                    var o = this.points[this.counter];
                    o && (r.x = o.x,
                    r.y = o.y)
                }
            });
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                for (var r = 0; r < f.length; r++)
                    if (e.hasOwnProperty(f[r]))
                        return !0;
                return !1
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(3)
              , r = new e({
                initialize: function(a) {
                    this.source = a,
                    this._tempVec = new f
                },
                getPoint: function(o) {
                    var a = this._tempVec;
                    this.source.getRandomPoint(a),
                    o.x = a.x,
                    o.y = a.y
                }
            });
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(11)
              , r = t(73)
              , o = new e({
                Extends: r,
                Mixins: [f.PathFollower],
                initialize: function(n, s, l, i, h, u) {
                    r.call(this, n, l, i, h, u),
                    this.path = s
                },
                preUpdate: function(a, n) {
                    this.anims.update(a, n),
                    this.pathUpdate(a)
                }
            });
            c.exports = o
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                var o = e.canvas
                  , a = e.context
                  , n = e.style
                  , s = []
                  , l = 0
                  , i = r.length;
                n.maxLines > 0 && n.maxLines < r.length && (i = n.maxLines),
                n.syncFont(o, a);
                for (var h = 0; h < i; h++) {
                    var u = n.strokeThickness;
                    u += a.measureText(r[h]).width,
                    n.wordWrap && (u -= a.measureText(" ").width),
                    s[h] = Math.ceil(u),
                    l = Math.max(l, s[h])
                }
                var d = f.fontSize + n.strokeThickness
                  , v = d * i
                  , p = e.lineSpacing;
                return i > 1 && (v += p * (i - 1)),
                {
                    width: l,
                    height: v,
                    lines: i,
                    lineWidths: s,
                    lineSpacing: p,
                    lineHeight: d
                }
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(13)
              , r = t(6)
              , o = t(460)
              , a = {
                fontFamily: ["fontFamily", "Courier"],
                fontSize: ["fontSize", "16px"],
                fontStyle: ["fontStyle", ""],
                backgroundColor: ["backgroundColor", null],
                color: ["color", "#fff"],
                stroke: ["stroke", "#fff"],
                strokeThickness: ["strokeThickness", 0],
                shadowOffsetX: ["shadow.offsetX", 0],
                shadowOffsetY: ["shadow.offsetY", 0],
                shadowColor: ["shadow.color", "#000"],
                shadowBlur: ["shadow.blur", 0],
                shadowStroke: ["shadow.stroke", !1],
                shadowFill: ["shadow.fill", !1],
                align: ["align", "left"],
                maxLines: ["maxLines", 0],
                fixedWidth: ["fixedWidth", 0],
                fixedHeight: ["fixedHeight", 0],
                resolution: ["resolution", 0],
                rtl: ["rtl", !1],
                testString: ["testString", "|MÃ‰qgy"],
                baselineX: ["baselineX", 1.2],
                baselineY: ["baselineY", 1.4],
                wordWrapWidth: ["wordWrap.width", null],
                wordWrapCallback: ["wordWrap.callback", null],
                wordWrapCallbackScope: ["wordWrap.callbackScope", null],
                wordWrapUseAdvanced: ["wordWrap.useAdvancedWrap", !1]
            }
              , n = new e({
                initialize: function(l, i) {
                    this.parent = l,
                    this.fontFamily,
                    this.fontSize,
                    this.fontStyle,
                    this.backgroundColor,
                    this.color,
                    this.stroke,
                    this.strokeThickness,
                    this.shadowOffsetX,
                    this.shadowOffsetY,
                    this.shadowColor,
                    this.shadowBlur,
                    this.shadowStroke,
                    this.shadowFill,
                    this.align,
                    this.maxLines,
                    this.fixedWidth,
                    this.fixedHeight,
                    this.resolution,
                    this.rtl,
                    this.testString,
                    this.baselineX,
                    this.baselineY,
                    this.wordWrapWidth,
                    this.wordWrapCallback,
                    this.wordWrapCallbackScope,
                    this.wordWrapUseAdvanced,
                    this._font,
                    this.setStyle(i, !1, !0);
                    var h = r(i, "metrics", !1);
                    h ? this.metrics = {
                        ascent: r(h, "ascent", 0),
                        descent: r(h, "descent", 0),
                        fontSize: r(h, "fontSize", 0)
                    } : this.metrics = o(this)
                },
                setStyle: function(s, l, i) {
                    l === void 0 && (l = !0),
                    i === void 0 && (i = !1),
                    s && s.hasOwnProperty("fontSize") && typeof s.fontSize == "number" && (s.fontSize = s.fontSize.toString() + "px");
                    for (var h in a) {
                        var u = i ? a[h][1] : this[h];
                        h === "wordWrapCallback" || h === "wordWrapCallbackScope" ? this[h] = r(s, a[h][0], u) : this[h] = f(s, a[h][0], u)
                    }
                    var d = r(s, "font", null);
                    d !== null && this.setFont(d, !1),
                    this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(" ").trim();
                    var v = r(s, "fill", null);
                    return v !== null && (this.color = v),
                    l ? this.update(!0) : this.parent
                },
                syncFont: function(s, l) {
                    l.font = this._font
                },
                syncStyle: function(s, l) {
                    l.textBaseline = "alphabetic",
                    l.fillStyle = this.color,
                    l.strokeStyle = this.stroke,
                    l.lineWidth = this.strokeThickness,
                    l.lineCap = "round",
                    l.lineJoin = "round"
                },
                syncShadow: function(s, l) {
                    l ? (s.shadowOffsetX = this.shadowOffsetX,
                    s.shadowOffsetY = this.shadowOffsetY,
                    s.shadowColor = this.shadowColor,
                    s.shadowBlur = this.shadowBlur) : (s.shadowOffsetX = 0,
                    s.shadowOffsetY = 0,
                    s.shadowColor = 0,
                    s.shadowBlur = 0)
                },
                update: function(s) {
                    return s && (this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(" ").trim(),
                    this.metrics = o(this)),
                    this.parent.updateText()
                },
                setFont: function(s, l) {
                    l === void 0 && (l = !0);
                    var i = s
                      , h = ""
                      , u = "";
                    if (typeof s != "string")
                        i = r(s, "fontFamily", "Courier"),
                        h = r(s, "fontSize", "16px"),
                        u = r(s, "fontStyle", "");
                    else {
                        var d = s.split(" ")
                          , v = 0;
                        u = d.length > 2 ? d[v++] : "",
                        h = d[v++] || "16px",
                        i = d[v++] || "Courier"
                    }
                    return (i !== this.fontFamily || h !== this.fontSize || u !== this.fontStyle) && (this.fontFamily = i,
                    this.fontSize = h,
                    this.fontStyle = u,
                    l && this.update(!0)),
                    this.parent
                },
                setFontFamily: function(s) {
                    return this.fontFamily !== s && (this.fontFamily = s,
                    this.update(!0)),
                    this.parent
                },
                setFontStyle: function(s) {
                    return this.fontStyle !== s && (this.fontStyle = s,
                    this.update(!0)),
                    this.parent
                },
                setFontSize: function(s) {
                    return typeof s == "number" && (s = s.toString() + "px"),
                    this.fontSize !== s && (this.fontSize = s,
                    this.update(!0)),
                    this.parent
                },
                setTestString: function(s) {
                    return this.testString = s,
                    this.update(!0)
                },
                setFixedSize: function(s, l) {
                    return this.fixedWidth = s,
                    this.fixedHeight = l,
                    s && (this.parent.width = s),
                    l && (this.parent.height = l),
                    this.update(!1)
                },
                setBackgroundColor: function(s) {
                    return this.backgroundColor = s,
                    this.update(!1)
                },
                setFill: function(s) {
                    return this.color = s,
                    this.update(!1)
                },
                setColor: function(s) {
                    return this.color = s,
                    this.update(!1)
                },
                setResolution: function(s) {
                    return this.resolution = s,
                    this.update(!1)
                },
                setStroke: function(s, l) {
                    return l === void 0 && (l = this.strokeThickness),
                    s === void 0 && this.strokeThickness !== 0 ? (this.strokeThickness = 0,
                    this.update(!0)) : (this.stroke !== s || this.strokeThickness !== l) && (this.stroke = s,
                    this.strokeThickness = l,
                    this.update(!0)),
                    this.parent
                },
                setShadow: function(s, l, i, h, u, d) {
                    return s === void 0 && (s = 0),
                    l === void 0 && (l = 0),
                    i === void 0 && (i = "#000"),
                    h === void 0 && (h = 0),
                    u === void 0 && (u = !1),
                    d === void 0 && (d = !0),
                    this.shadowOffsetX = s,
                    this.shadowOffsetY = l,
                    this.shadowColor = i,
                    this.shadowBlur = h,
                    this.shadowStroke = u,
                    this.shadowFill = d,
                    this.update(!1)
                },
                setShadowOffset: function(s, l) {
                    return s === void 0 && (s = 0),
                    l === void 0 && (l = s),
                    this.shadowOffsetX = s,
                    this.shadowOffsetY = l,
                    this.update(!1)
                },
                setShadowColor: function(s) {
                    return s === void 0 && (s = "#000"),
                    this.shadowColor = s,
                    this.update(!1)
                },
                setShadowBlur: function(s) {
                    return s === void 0 && (s = 0),
                    this.shadowBlur = s,
                    this.update(!1)
                },
                setShadowStroke: function(s) {
                    return this.shadowStroke = s,
                    this.update(!1)
                },
                setShadowFill: function(s) {
                    return this.shadowFill = s,
                    this.update(!1)
                },
                setWordWrapWidth: function(s, l) {
                    return l === void 0 && (l = !1),
                    this.wordWrapWidth = s,
                    this.wordWrapUseAdvanced = l,
                    this.update(!1)
                },
                setWordWrapCallback: function(s, l) {
                    return l === void 0 && (l = null),
                    this.wordWrapCallback = s,
                    this.wordWrapCallbackScope = l,
                    this.update(!1)
                },
                setAlign: function(s) {
                    return s === void 0 && (s = "left"),
                    this.align = s,
                    this.update(!1)
                },
                setMaxLines: function(s) {
                    return s === void 0 && (s = 0),
                    this.maxLines = s,
                    this.update(!1)
                },
                getTextMetrics: function() {
                    var s = this.metrics;
                    return {
                        ascent: s.ascent,
                        descent: s.descent,
                        fontSize: s.fontSize
                    }
                },
                toJSON: function() {
                    var s = {};
                    for (var l in a)
                        s[l] = this[l];
                    return s.metrics = this.getTextMetrics(),
                    s
                },
                destroy: function() {
                    this.parent = void 0
                }
            });
            c.exports = n
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(31)
              , f = function(r) {
                var o = e.create(this)
                  , a = o.getContext("2d");
                r.syncFont(o, a);
                var n = a.measureText(r.testString);
                if ("actualBoundingBoxAscent"in n) {
                    var s = n.actualBoundingBoxAscent
                      , l = n.actualBoundingBoxDescent;
                    return e.remove(o),
                    {
                        ascent: s,
                        descent: l,
                        fontSize: s + l
                    }
                }
                var i = Math.ceil(n.width * r.baselineX)
                  , h = i
                  , u = 2 * h;
                h = h * r.baselineY | 0,
                o.width = i,
                o.height = u,
                a.fillStyle = "#f00",
                a.fillRect(0, 0, i, u),
                a.font = r._font,
                a.textBaseline = "alphabetic",
                a.fillStyle = "#000",
                a.fillText(r.testString, 0, h);
                var d = {
                    ascent: 0,
                    descent: 0,
                    fontSize: 0
                }
                  , v = a.getImageData(0, 0, i, u);
                if (!v)
                    return d.ascent = h,
                    d.descent = h + 6,
                    d.fontSize = d.ascent + d.descent,
                    e.remove(o),
                    d;
                var p = v.data, g = p.length, m = i * 4, x, T, E = 0, P = !1;
                for (x = 0; x < h; x++) {
                    for (T = 0; T < m; T += 4)
                        if (p[E + T] !== 255) {
                            P = !0;
                            break
                        }
                    if (!P)
                        E += m;
                    else
                        break
                }
                for (d.ascent = h - x,
                E = g - m,
                P = !1,
                x = u; x > h; x--) {
                    for (T = 0; T < m; T += 4)
                        if (p[E + T] !== 255) {
                            P = !0;
                            break
                        }
                    if (!P)
                        E -= m;
                    else
                        break
                }
                return d.descent = x - h,
                d.fontSize = d.ascent + d.descent,
                e.remove(o),
                d
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1097)
              , f = t(0)
              , r = t(36)
              , o = t(59)
              , a = t(65)
              , n = t(14)
              , s = t(34)
              , l = new f({
                Extends: s,
                Mixins: [e],
                initialize: function(h, u, d, v, p, g, m, x, T) {
                    u === void 0 && (u = 0),
                    d === void 0 && (d = 0),
                    v === void 0 && (v = 128),
                    p === void 0 && (p = 0),
                    g === void 0 && (g = 360),
                    m === void 0 && (m = !1),
                    s.call(this, h, "Arc", new a(0,0,v)),
                    this._startAngle = p,
                    this._endAngle = g,
                    this._anticlockwise = m,
                    this._iterations = .01,
                    this.setPosition(u, d);
                    var E = this.geom.radius * 2;
                    this.setSize(E, E),
                    x !== void 0 && this.setFillStyle(x, T),
                    this.updateDisplayOrigin(),
                    this.updateData()
                },
                iterations: {
                    get: function() {
                        return this._iterations
                    },
                    set: function(i) {
                        this._iterations = i,
                        this.updateData()
                    }
                },
                radius: {
                    get: function() {
                        return this.geom.radius
                    },
                    set: function(i) {
                        this.geom.radius = i;
                        var h = i * 2;
                        this.setSize(h, h),
                        this.updateDisplayOrigin(),
                        this.updateData()
                    }
                },
                startAngle: {
                    get: function() {
                        return this._startAngle
                    },
                    set: function(i) {
                        this._startAngle = i,
                        this.updateData()
                    }
                },
                endAngle: {
                    get: function() {
                        return this._endAngle
                    },
                    set: function(i) {
                        this._endAngle = i,
                        this.updateData()
                    }
                },
                anticlockwise: {
                    get: function() {
                        return this._anticlockwise
                    },
                    set: function(i) {
                        this._anticlockwise = i,
                        this.updateData()
                    }
                },
                setRadius: function(i) {
                    return this.radius = i,
                    this
                },
                setIterations: function(i) {
                    return i === void 0 && (i = .01),
                    this.iterations = i,
                    this
                },
                setStartAngle: function(i, h) {
                    return this._startAngle = i,
                    h !== void 0 && (this._anticlockwise = h),
                    this.updateData()
                },
                setEndAngle: function(i, h) {
                    return this._endAngle = i,
                    h !== void 0 && (this._anticlockwise = h),
                    this.updateData()
                },
                updateData: function() {
                    var i = this._iterations
                      , h = i
                      , u = this.geom.radius
                      , d = r(this._startAngle)
                      , v = r(this._endAngle)
                      , p = this._anticlockwise
                      , g = u
                      , m = u;
                    v -= d,
                    p ? v < -n.PI2 ? v = -n.PI2 : v > 0 && (v = -n.PI2 + v % n.PI2) : v > n.PI2 ? v = n.PI2 : v < 0 && (v = n.PI2 + v % n.PI2);
                    for (var x = [g + Math.cos(d) * u, m + Math.sin(d) * u], T; h < 1; )
                        T = v * h + d,
                        x.push(g + Math.cos(T) * u, m + Math.sin(T) * u),
                        h += i;
                    return T = v + d,
                    x.push(g + Math.cos(T) * u, m + Math.sin(T) * u),
                    x.push(g + Math.cos(d) * u, m + Math.sin(d) * u),
                    this.pathIndexes = o(x),
                    this.pathData = x,
                    this
                }
            });
            c.exports = l
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(1100)
              , r = t(59)
              , o = t(10)
              , a = t(34)
              , n = new e({
                Extends: a,
                Mixins: [f],
                initialize: function(l, i, h, u, d, v) {
                    i === void 0 && (i = 0),
                    h === void 0 && (h = 0),
                    a.call(this, l, "Curve", u),
                    this._smoothness = 32,
                    this._curveBounds = new o,
                    this.closePath = !1,
                    this.setPosition(i, h),
                    d !== void 0 && this.setFillStyle(d, v),
                    this.updateData()
                },
                smoothness: {
                    get: function() {
                        return this._smoothness
                    },
                    set: function(s) {
                        this._smoothness = s,
                        this.updateData()
                    }
                },
                setSmoothness: function(s) {
                    return this._smoothness = s,
                    this.updateData()
                },
                updateData: function() {
                    var s = this._curveBounds
                      , l = this._smoothness;
                    this.geom.getBounds(s, l),
                    this.setSize(s.width, s.height),
                    this.updateDisplayOrigin();
                    for (var i = [], h = this.geom.getPoints(l), u = 0; u < h.length; u++)
                        i.push(h[u].x, h[u].y);
                    return i.push(h[0].x, h[0].y),
                    this.pathIndexes = r(i),
                    this.pathData = i,
                    this
                }
            });
            c.exports = n
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(59)
              , r = t(1103)
              , o = t(111)
              , a = t(34)
              , n = new e({
                Extends: a,
                Mixins: [r],
                initialize: function(l, i, h, u, d, v, p) {
                    i === void 0 && (i = 0),
                    h === void 0 && (h = 0),
                    u === void 0 && (u = 128),
                    d === void 0 && (d = 128),
                    a.call(this, l, "Ellipse", new o(u / 2,d / 2,u,d)),
                    this._smoothness = 64,
                    this.setPosition(i, h),
                    this.width = u,
                    this.height = d,
                    v !== void 0 && this.setFillStyle(v, p),
                    this.updateDisplayOrigin(),
                    this.updateData()
                },
                smoothness: {
                    get: function() {
                        return this._smoothness
                    },
                    set: function(s) {
                        this._smoothness = s,
                        this.updateData()
                    }
                },
                setSize: function(s, l) {
                    return this.width = s,
                    this.height = l,
                    this.geom.setPosition(s / 2, l / 2),
                    this.geom.setSize(s, l),
                    this.updateData()
                },
                setSmoothness: function(s) {
                    return this._smoothness = s,
                    this.updateData()
                },
                updateData: function() {
                    for (var s = [], l = this.geom.getPoints(this._smoothness), i = 0; i < l.length; i++)
                        s.push(l[i].x, l[i].y);
                    return s.push(l[0].x, l[0].y),
                    this.pathIndexes = f(s),
                    this.pathData = s,
                    this
                }
            });
            c.exports = n
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(34)
              , r = t(1106)
              , o = new e({
                Extends: f,
                Mixins: [r],
                initialize: function(n, s, l, i, h, u, d, v, p, g, m) {
                    s === void 0 && (s = 0),
                    l === void 0 && (l = 0),
                    i === void 0 && (i = 128),
                    h === void 0 && (h = 128),
                    u === void 0 && (u = 32),
                    d === void 0 && (d = 32),
                    f.call(this, n, "Grid", null),
                    this.cellWidth = u,
                    this.cellHeight = d,
                    this.showCells = !0,
                    this.outlineFillColor = 0,
                    this.outlineFillAlpha = 0,
                    this.showOutline = !0,
                    this.showAltCells = !1,
                    this.altFillColor,
                    this.altFillAlpha,
                    this.setPosition(s, l),
                    this.setSize(i, h),
                    this.setFillStyle(v, p),
                    g !== void 0 && this.setOutlineStyle(g, m),
                    this.updateDisplayOrigin()
                },
                setFillStyle: function(a, n) {
                    return n === void 0 && (n = 1),
                    a === void 0 ? this.showCells = !1 : (this.fillColor = a,
                    this.fillAlpha = n,
                    this.showCells = !0),
                    this
                },
                setAltFillStyle: function(a, n) {
                    return n === void 0 && (n = 1),
                    a === void 0 ? this.showAltCells = !1 : (this.altFillColor = a,
                    this.altFillAlpha = n,
                    this.showAltCells = !0),
                    this
                },
                setOutlineStyle: function(a, n) {
                    return n === void 0 && (n = 1),
                    a === void 0 ? this.showOutline = !1 : (this.outlineFillColor = a,
                    this.outlineFillAlpha = n,
                    this.showOutline = !0),
                    this
                }
            });
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1109)
              , f = t(0)
              , r = t(34)
              , o = new f({
                Extends: r,
                Mixins: [e],
                initialize: function(n, s, l, i, h, u, d, v) {
                    s === void 0 && (s = 0),
                    l === void 0 && (l = 0),
                    i === void 0 && (i = 48),
                    h === void 0 && (h = 32),
                    u === void 0 && (u = 15658734),
                    d === void 0 && (d = 10066329),
                    v === void 0 && (v = 13421772),
                    r.call(this, n, "IsoBox", null),
                    this.projection = 4,
                    this.fillTop = u,
                    this.fillLeft = d,
                    this.fillRight = v,
                    this.showTop = !0,
                    this.showLeft = !0,
                    this.showRight = !0,
                    this.isFilled = !0,
                    this.setPosition(s, l),
                    this.setSize(i, h),
                    this.updateDisplayOrigin()
                },
                setProjection: function(a) {
                    return this.projection = a,
                    this
                },
                setFaces: function(a, n, s) {
                    return a === void 0 && (a = !0),
                    n === void 0 && (n = !0),
                    s === void 0 && (s = !0),
                    this.showTop = a,
                    this.showLeft = n,
                    this.showRight = s,
                    this
                },
                setFillStyle: function(a, n, s) {
                    return this.fillTop = a,
                    this.fillLeft = n,
                    this.fillRight = s,
                    this.isFilled = !0,
                    this
                }
            });
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(1112)
              , r = t(34)
              , o = new e({
                Extends: r,
                Mixins: [f],
                initialize: function(n, s, l, i, h, u, d, v, p) {
                    s === void 0 && (s = 0),
                    l === void 0 && (l = 0),
                    i === void 0 && (i = 48),
                    h === void 0 && (h = 32),
                    u === void 0 && (u = !1),
                    d === void 0 && (d = 15658734),
                    v === void 0 && (v = 10066329),
                    p === void 0 && (p = 13421772),
                    r.call(this, n, "IsoTriangle", null),
                    this.projection = 4,
                    this.fillTop = d,
                    this.fillLeft = v,
                    this.fillRight = p,
                    this.showTop = !0,
                    this.showLeft = !0,
                    this.showRight = !0,
                    this.isReversed = u,
                    this.isFilled = !0,
                    this.setPosition(s, l),
                    this.setSize(i, h),
                    this.updateDisplayOrigin()
                },
                setProjection: function(a) {
                    return this.projection = a,
                    this
                },
                setReversed: function(a) {
                    return this.isReversed = a,
                    this
                },
                setFaces: function(a, n, s) {
                    return a === void 0 && (a = !0),
                    n === void 0 && (n = !0),
                    s === void 0 && (s = !0),
                    this.showTop = a,
                    this.showLeft = n,
                    this.showRight = s,
                    this
                },
                setFillStyle: function(a, n, s) {
                    return this.fillTop = a,
                    this.fillLeft = n,
                    this.fillRight = s,
                    this.isFilled = !0,
                    this
                }
            });
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(34)
              , r = t(47)
              , o = t(1115)
              , a = new e({
                Extends: f,
                Mixins: [o],
                initialize: function(s, l, i, h, u, d, v, p, g) {
                    l === void 0 && (l = 0),
                    i === void 0 && (i = 0),
                    h === void 0 && (h = 0),
                    u === void 0 && (u = 0),
                    d === void 0 && (d = 128),
                    v === void 0 && (v = 0),
                    f.call(this, s, "Line", new r(h,u,d,v));
                    var m = Math.max(1, this.geom.right - this.geom.left)
                      , x = Math.max(1, this.geom.bottom - this.geom.top);
                    this.lineWidth = 1,
                    this._startWidth = 1,
                    this._endWidth = 1,
                    this.setPosition(l, i),
                    this.setSize(m, x),
                    p !== void 0 && this.setStrokeStyle(1, p, g),
                    this.updateDisplayOrigin()
                },
                setLineWidth: function(n, s) {
                    return s === void 0 && (s = n),
                    this._startWidth = n,
                    this._endWidth = s,
                    this.lineWidth = n,
                    this
                },
                setTo: function(n, s, l, i) {
                    return this.geom.setTo(n, s, l, i),
                    this
                }
            });
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1118)
              , f = t(0)
              , r = t(59)
              , o = t(469)
              , a = t(227)
              , n = t(34)
              , s = t(472)
              , l = new f({
                Extends: n,
                Mixins: [e],
                initialize: function(h, u, d, v, p, g) {
                    u === void 0 && (u = 0),
                    d === void 0 && (d = 0),
                    n.call(this, h, "Polygon", new a(v));
                    var m = o(this.geom);
                    this.setPosition(u, d),
                    this.setSize(m.width, m.height),
                    p !== void 0 && this.setFillStyle(p, g),
                    this.updateDisplayOrigin(),
                    this.updateData()
                },
                smooth: function(i) {
                    i === void 0 && (i = 1);
                    for (var h = 0; h < i; h++)
                        s(this.geom);
                    return this.updateData()
                },
                updateData: function() {
                    for (var i = [], h = this.geom.points, u = 0; u < h.length; u++)
                        i.push(h[u].x, h[u].y);
                    return i.push(h[0].x, h[0].y),
                    this.pathIndexes = r(i),
                    this.pathData = i,
                    this
                }
            });
            c.exports = l
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(10)
              , f = function(r, o) {
                o === void 0 && (o = new e);
                for (var a = 1 / 0, n = 1 / 0, s = -a, l = -n, i, h = 0; h < r.points.length; h++)
                    i = r.points[h],
                    a = Math.min(a, i.x),
                    n = Math.min(n, i.y),
                    s = Math.max(s, i.x),
                    l = Math.max(l, i.y);
                return o.x = a,
                o.y = n,
                o.width = s - a,
                o.height = l - n,
                o
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(67)
              , f = t(47)
              , r = t(471)
              , o = function(a, n, s, l) {
                l === void 0 && (l = []);
                var i = a.points
                  , h = r(a);
                !n && s > 0 && (n = h / s);
                for (var u = 0; u < n; u++)
                    for (var d = h * (u / n), v = 0, p = 0; p < i.length; p++) {
                        var g = i[p]
                          , m = i[(p + 1) % i.length]
                          , x = new f(g.x,g.y,m.x,m.y)
                          , T = e(x);
                        if (d < v || d > v + T) {
                            v += T;
                            continue
                        }
                        var E = x.getPoint((d - v) / T);
                        l.push(E);
                        break
                    }
                return l
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(67)
              , f = t(47)
              , r = function(o) {
                for (var a = o.points, n = 0, s = 0; s < a.length; s++) {
                    var l = a[s]
                      , i = a[(s + 1) % a.length]
                      , h = new f(l.x,l.y,i.x,i.y);
                    n += e(h)
                }
                return n
            };
            c.exports = r
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Igor Ognichenko <ognichenko.igor@gmail.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(f, r) {
                return f[0] = r[0],
                f[1] = r[1],
                f
            }
              , e = function(f) {
                var r, o = [], a = f.points;
                for (r = 0; r < a.length; r++)
                    o.push([a[r].x, a[r].y]);
                var n = [];
                for (o.length > 0 && n.push(t([0, 0], o[0])),
                r = 0; r < o.length - 1; r++) {
                    var s = o[r]
                      , l = o[r + 1]
                      , i = s[0]
                      , h = s[1]
                      , u = l[0]
                      , d = l[1];
                    n.push([.85 * i + .15 * u, .85 * h + .15 * d]),
                    n.push([.15 * i + .85 * u, .15 * h + .85 * d])
                }
                return o.length > 1 && n.push(t([0, 0], o[o.length - 1])),
                f.setTo(n)
            };
            c.exports = e
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(10)
              , r = t(34)
              , o = t(1121)
              , a = new e({
                Extends: r,
                Mixins: [o],
                initialize: function(s, l, i, h, u, d, v) {
                    l === void 0 && (l = 0),
                    i === void 0 && (i = 0),
                    h === void 0 && (h = 128),
                    u === void 0 && (u = 128),
                    r.call(this, s, "Rectangle", new f(0,0,h,u)),
                    this.setPosition(l, i),
                    this.setSize(h, u),
                    d !== void 0 && this.setFillStyle(d, v),
                    this.updateDisplayOrigin(),
                    this.updateData()
                },
                setSize: function(n, s) {
                    return this.width = n,
                    this.height = s,
                    this.geom.setSize(n, s),
                    this.updateData(),
                    this
                },
                updateData: function() {
                    var n = []
                      , s = this.geom
                      , l = this._tempLine;
                    return s.getLineA(l),
                    n.push(l.x1, l.y1, l.x2, l.y2),
                    s.getLineB(l),
                    n.push(l.x2, l.y2),
                    s.getLineC(l),
                    n.push(l.x2, l.y2),
                    s.getLineD(l),
                    n.push(l.x2, l.y2),
                    this.pathData = n,
                    this
                }
            });
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1124)
              , f = t(0)
              , r = t(59)
              , o = t(34)
              , a = new f({
                Extends: o,
                Mixins: [e],
                initialize: function(s, l, i, h, u, d, v, p) {
                    l === void 0 && (l = 0),
                    i === void 0 && (i = 0),
                    h === void 0 && (h = 5),
                    u === void 0 && (u = 32),
                    d === void 0 && (d = 64),
                    o.call(this, s, "Star", null),
                    this._points = h,
                    this._innerRadius = u,
                    this._outerRadius = d,
                    this.setPosition(l, i),
                    this.setSize(d * 2, d * 2),
                    v !== void 0 && this.setFillStyle(v, p),
                    this.updateDisplayOrigin(),
                    this.updateData()
                },
                setPoints: function(n) {
                    return this._points = n,
                    this.updateData()
                },
                setInnerRadius: function(n) {
                    return this._innerRadius = n,
                    this.updateData()
                },
                setOuterRadius: function(n) {
                    return this._outerRadius = n,
                    this.updateData()
                },
                points: {
                    get: function() {
                        return this._points
                    },
                    set: function(n) {
                        this._points = n,
                        this.updateData()
                    }
                },
                innerRadius: {
                    get: function() {
                        return this._innerRadius
                    },
                    set: function(n) {
                        this._innerRadius = n,
                        this.updateData()
                    }
                },
                outerRadius: {
                    get: function() {
                        return this._outerRadius
                    },
                    set: function(n) {
                        this._outerRadius = n,
                        this.updateData()
                    }
                },
                updateData: function() {
                    var n = []
                      , s = this._points
                      , l = this._innerRadius
                      , i = this._outerRadius
                      , h = Math.PI / 2 * 3
                      , u = Math.PI / s
                      , d = i
                      , v = i;
                    n.push(d, v + -i);
                    for (var p = 0; p < s; p++)
                        n.push(d + Math.cos(h) * i, v + Math.sin(h) * i),
                        h += u,
                        n.push(d + Math.cos(h) * l, v + Math.sin(h) * l),
                        h += u;
                    return n.push(d, v + -i),
                    this.pathIndexes = r(n),
                    this.pathData = n,
                    this
                }
            });
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(34)
              , r = t(82)
              , o = t(1127)
              , a = new e({
                Extends: f,
                Mixins: [o],
                initialize: function(s, l, i, h, u, d, v, p, g, m, x) {
                    l === void 0 && (l = 0),
                    i === void 0 && (i = 0),
                    h === void 0 && (h = 0),
                    u === void 0 && (u = 128),
                    d === void 0 && (d = 64),
                    v === void 0 && (v = 0),
                    p === void 0 && (p = 128),
                    g === void 0 && (g = 128),
                    f.call(this, s, "Triangle", new r(h,u,d,v,p,g));
                    var T = this.geom.right - this.geom.left
                      , E = this.geom.bottom - this.geom.top;
                    this.setPosition(l, i),
                    this.setSize(T, E),
                    m !== void 0 && this.setFillStyle(m, x),
                    this.updateDisplayOrigin(),
                    this.updateData()
                },
                setTo: function(n, s, l, i, h, u) {
                    return this.geom.setTo(n, s, l, i, h, u),
                    this.updateData()
                },
                updateData: function() {
                    var n = []
                      , s = this.geom
                      , l = this._tempLine;
                    return s.getLineA(l),
                    n.push(l.x1, l.y1, l.x2, l.y2),
                    s.getLineB(l),
                    n.push(l.x2, l.y2),
                    s.getLineC(l),
                    n.push(l.x2, l.y2),
                    this.pathData = n,
                    this
                }
            });
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4)
              , f = t(67)
              , r = function(o, a, n) {
                n === void 0 && (n = new e);
                var s = o.getLineA()
                  , l = o.getLineB()
                  , i = o.getLineC();
                if (a <= 0 || a >= 1)
                    return n.x = s.x1,
                    n.y = s.y1,
                    n;
                var h = f(s)
                  , u = f(l)
                  , d = f(i)
                  , v = h + u + d
                  , p = v * a
                  , g = 0;
                return p < h ? (g = p / h,
                n.x = s.x1 + (s.x2 - s.x1) * g,
                n.y = s.y1 + (s.y2 - s.y1) * g) : p > h + u ? (p -= h + u,
                g = p / d,
                n.x = i.x1 + (i.x2 - i.x1) * g,
                n.y = i.y1 + (i.y2 - i.y1) * g) : (p -= h,
                g = p / u,
                n.x = l.x1 + (l.x2 - l.x1) * g,
                n.y = l.y1 + (l.y2 - l.y1) * g),
                n
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(67)
              , f = t(4)
              , r = function(o, a, n, s) {
                s === void 0 && (s = []);
                var l = o.getLineA()
                  , i = o.getLineB()
                  , h = o.getLineC()
                  , u = e(l)
                  , d = e(i)
                  , v = e(h)
                  , p = u + d + v;
                !a && n > 0 && (a = p / n);
                for (var g = 0; g < a; g++) {
                    var m = p * (g / a)
                      , x = 0
                      , T = new f;
                    m < u ? (x = m / u,
                    T.x = l.x1 + (l.x2 - l.x1) * x,
                    T.y = l.y1 + (l.y2 - l.y1) * x) : m > u + d ? (m -= u + d,
                    x = m / v,
                    T.x = h.x1 + (h.x2 - h.x1) * x,
                    T.y = h.y1 + (h.y2 - h.y1) * x) : (m -= u,
                    x = m / d,
                    T.x = i.x1 + (i.x2 - i.x1) * x,
                    T.y = i.y1 + (i.y2 - i.y1) * x),
                    s.push(T)
                }
                return s
            };
            c.exports = r
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                if (!e || typeof e == "number")
                    return !1;
                if (e.hasOwnProperty(f))
                    return e[f] = r,
                    !0;
                if (f.indexOf(".") !== -1) {
                    for (var o = f.split("."), a = e, n = e, s = 0; s < o.length; s++)
                        if (a.hasOwnProperty(o[s]))
                            n = a,
                            a = a[o[s]];
                        else
                            return !1;
                    return n[o[o.length - 1]] = r,
                    !0
                }
                return !1
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(116)
              , f = t(117)
              , r = function(o, a, n, s, l, i, h) {
                if (s === void 0 && (s = !1),
                i === void 0 && (i = 16777215),
                h === void 0 && (h = 1),
                o.length !== a.length) {
                    console.warn("GenerateVerts: vertices and uvs count not equal");
                    return
                }
                var u = {
                    faces: [],
                    vertices: []
                }, d, v, p, g, m, x, T, E, P, M, L, R = s ? 3 : 2, O = Array.isArray(i), F = Array.isArray(h);
                if (Array.isArray(n) && n.length > 0)
                    for (d = 0; d < n.length; d++) {
                        var B = n[d]
                          , N = n[d] * 2
                          , Y = n[d] * R;
                        v = o[Y],
                        p = o[Y + 1],
                        g = s ? o[Y + 2] : 0,
                        m = a[N],
                        x = a[N + 1],
                        T = O ? i[B] : i,
                        E = F ? h[B] : h,
                        P = 0,
                        M = 0,
                        L = 0,
                        l && (P = l[Y],
                        M = l[Y + 1],
                        L = s ? l[Y + 2] : 0),
                        u.vertices.push(new f(v,p,g,m,x,T,E,P,M,L))
                    }
                else {
                    var z = 0
                      , W = 0;
                    for (d = 0; d < o.length; d += R)
                        v = o[d],
                        p = o[d + 1],
                        g = s ? o[d + 2] : 0,
                        m = a[z],
                        x = a[z + 1],
                        T = O ? i[W] : i,
                        E = F ? h[W] : h,
                        P = 0,
                        M = 0,
                        L = 0,
                        l && (P = l[d],
                        M = l[d + 1],
                        L = s ? l[d + 2] : 0),
                        u.vertices.push(new f(v,p,g,m,x,T,E,P,M,L)),
                        z += 2,
                        W++
                }
                for (d = 0; d < u.vertices.length; d += 3) {
                    var b = u.vertices[d]
                      , D = u.vertices[d + 1]
                      , I = u.vertices[d + 2];
                    u.faces.push(new e(b,D,I))
                }
                return u
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(116)
              , f = t(69)
              , r = t(39)
              , o = t(117)
              , a = new r
              , n = new r
              , s = new f
              , l = function(i, h, u, d, v, p, g, m, x, T) {
                u === void 0 && (u = 1),
                d === void 0 && (d = 0),
                v === void 0 && (v = 0),
                p === void 0 && (p = 0),
                g === void 0 && (g = 0),
                m === void 0 && (m = 0),
                x === void 0 && (x = 0),
                T === void 0 && (T = !0);
                var E = {
                    faces: [],
                    verts: []
                }
                  , P = i.materials;
                a.set(d, v, p),
                n.set(g, m, x),
                s.fromRotationXYTranslation(n, a, T);
                for (var M = 0; M < i.models.length; M++)
                    for (var L = i.models[M], R = L.vertices, O = L.textureCoords, F = L.faces, B = 0; B < F.length; B++) {
                        var N = F[B]
                          , Y = N.vertices[0]
                          , z = N.vertices[1]
                          , W = N.vertices[2]
                          , b = R[Y.vertexIndex]
                          , D = R[z.vertexIndex]
                          , I = R[W.vertexIndex]
                          , G = Y.textureCoordsIndex
                          , w = z.textureCoordsIndex
                          , U = W.textureCoordsIndex
                          , X = G === -1 ? {
                            u: 0,
                            v: 1
                        } : O[G]
                          , V = w === -1 ? {
                            u: 0,
                            v: 0
                        } : O[w]
                          , H = U === -1 ? {
                            u: 1,
                            v: 1
                        } : O[U]
                          , J = 16777215;
                        N.material !== "" && P[N.material] && (J = P[N.material]);
                        var $ = new o(b.x * u,b.y * u,b.z * u,X.u,X.v,J).transformMat4(s)
                          , _ = new o(D.x * u,D.y * u,D.z * u,V.u,V.v,J).transformMat4(s)
                          , nt = new o(I.x * u,I.y * u,I.z * u,H.u,H.v,J).transformMat4(s);
                        E.verts.push($, _, nt),
                        E.faces.push(new e($,_,nt))
                    }
                return h && (h.faces = h.faces.concat(E.faces),
                h.vertices = h.vertices.concat(E.verts)),
                E
            };
            c.exports = l
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(65)
              , f = t(0)
              , r = t(11)
              , o = t(200)
              , a = t(12)
              , n = new f({
                Extends: e,
                Mixins: [r.ScrollFactor, r.Visible],
                initialize: function(l, i, h, u, d, v, p) {
                    e.call(this, l, i, h),
                    this.color = new o(u,d,v),
                    this.intensity = p,
                    this.renderFlags = 15,
                    this.cameraFilter = 0,
                    this.setScrollFactor(1, 1)
                },
                willRender: function(s) {
                    return !(n.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & s.id)
                },
                setColor: function(s) {
                    var l = a.getFloatsFromUintRGB(s);
                    return this.color.set(l[0], l[1], l[2]),
                    this
                },
                setIntensity: function(s) {
                    return this.intensity = s,
                    this
                },
                setRadius: function(s) {
                    return this.radius = s,
                    this
                }
            });
            n.RENDER_MASK = 15,
            c.exports = n
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(151)
              , f = t(0)
              , r = t(50)
              , o = t(481)
              , a = t(150)
              , n = t(200)
              , s = t(74)
              , l = t(79)
              , i = t(12)
              , h = new f({
                initialize: function() {
                    this.lights = [],
                    this.ambientColor = new n(.1,.1,.1),
                    this.active = !1,
                    this.maxLights = -1,
                    this.visibleLights = 0
                },
                addPointLight: function(u, d, v, p, g, m) {
                    return this.systems.displayList.add(new a(this.scene,u,d,v,p,g,m))
                },
                enable: function() {
                    return this.maxLights === -1 && (this.maxLights = this.systems.renderer.config.maxLights),
                    this.active = !0,
                    this
                },
                disable: function() {
                    return this.active = !1,
                    this
                },
                getLights: function(u) {
                    for (var d = this.lights, v = u.worldView, p = [], g = 0; g < d.length; g++) {
                        var m = d[g];
                        m.willRender(u) && e(m, v) && p.push({
                            light: m,
                            distance: r(m.x, m.y, v.centerX, v.centerY)
                        })
                    }
                    return p.length > this.maxLights && (l(p, this.sortByDistance),
                    p = p.slice(0, this.maxLights)),
                    this.visibleLights = p.length,
                    p
                },
                sortByDistance: function(u, d) {
                    return u.distance >= d.distance
                },
                setAmbientColor: function(u) {
                    var d = i.getFloatsFromUintRGB(u);
                    return this.ambientColor.set(d[0], d[1], d[2]),
                    this
                },
                getMaxVisibleLights: function() {
                    return this.maxLights
                },
                getLightCount: function() {
                    return this.lights.length
                },
                addLight: function(u, d, v, p, g) {
                    u === void 0 && (u = 0),
                    d === void 0 && (d = 0),
                    v === void 0 && (v = 128),
                    p === void 0 && (p = 16777215),
                    g === void 0 && (g = 1);
                    var m = i.getFloatsFromUintRGB(p)
                      , x = new o(u,d,v,m[0],m[1],m[2],g);
                    return this.lights.push(x),
                    x
                },
                removeLight: function(u) {
                    var d = this.lights.indexOf(u);
                    return d >= 0 && s(this.lights, d),
                    this
                },
                shutdown: function() {
                    this.lights.length = 0
                },
                destroy: function() {
                    this.shutdown()
                }
            });
            c.exports = h
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(56)
              , f = t(17)
              , r = {
                Circle: t(1191),
                Ellipse: t(1201),
                Intersects: t(484),
                Line: t(1221),
                Mesh: t(1243),
                Point: t(1246),
                Polygon: t(1260),
                Rectangle: t(502),
                Triangle: t(1293)
            };
            r = f(!1, r, e),
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                CircleToCircle: t(231),
                CircleToRectangle: t(151),
                GetCircleToCircle: t(1211),
                GetCircleToRectangle: t(1212),
                GetLineToCircle: t(232),
                GetLineToLine: t(485),
                GetLineToPoints: t(486),
                GetLineToPolygon: t(487),
                GetLineToRectangle: t(234),
                GetRaysFromPointToPolygon: t(1213),
                GetRectangleIntersection: t(1214),
                GetRectangleToRectangle: t(1215),
                GetRectangleToTriangle: t(1216),
                GetTriangleToCircle: t(1217),
                GetTriangleToLine: t(492),
                GetTriangleToTriangle: t(1218),
                LineToCircle: t(233),
                LineToLine: t(96),
                LineToRectangle: t(488),
                PointToLine: t(496),
                PointToLineSegment: t(1219),
                RectangleToRectangle: t(152),
                RectangleToTriangle: t(489),
                RectangleToValues: t(1220),
                TriangleToCircle: t(491),
                TriangleToLine: t(493),
                TriangleToTriangle: t(494)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(39)
              , f = function(r, o, a) {
                var n = r.x1
                  , s = r.y1
                  , l = r.x2
                  , i = r.y2
                  , h = o.x1
                  , u = o.y1
                  , d = o.x2
                  , v = o.y2
                  , p = l - n
                  , g = i - s
                  , m = d - h
                  , x = v - u
                  , T = x * p - m * g;
                if (p === 0 || T === 0)
                    return !1;
                var E = (p * (u - s) + g * (n - h)) / (m * g - x * p)
                  , P = (h + m * E - n) / p;
                return P < 0 || E < 0 || E > 1 ? null : (a === void 0 && (a = new e),
                a.set(n + p * P, s + g * P, P))
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(39)
              , f = t(485)
              , r = t(47)
              , o = new r
              , a = new e
              , n = function(s, l, i) {
                i === void 0 && (i = new e);
                var h = !1;
                i.set(),
                a.set();
                for (var u = l[0], d = 1; d < l.length; d++) {
                    var v = l[d];
                    o.setTo(u.x, u.y, v.x, v.y),
                    u = v,
                    f(s, o, a) && (!h || a.z < i.z) && (i.copy(a),
                    h = !0)
                }
                return h ? i : null
            };
            c.exports = n
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(39)
              , f = t(140)
              , r = t(486)
              , o = new e
              , a = function(n, s, l) {
                l === void 0 && (l = new f),
                Array.isArray(s) || (s = [s]);
                var i = !1;
                l.set(),
                o.set();
                for (var h = 0; h < s.length; h++)
                    r(n, s[h].points, o) && (!i || o.z < l.z) && (l.set(o.x, o.y, o.z, h),
                    i = !0);
                return i ? l : null
            };
            c.exports = a
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                var r = e.x1
                  , o = e.y1
                  , a = e.x2
                  , n = e.y2
                  , s = f.x
                  , l = f.y
                  , i = f.right
                  , h = f.bottom
                  , u = 0;
                if (r >= s && r <= i && o >= l && o <= h || a >= s && a <= i && n >= l && n <= h)
                    return !0;
                if (r < s && a >= s) {
                    if (u = o + (n - o) * (s - r) / (a - r),
                    u > l && u <= h)
                        return !0
                } else if (r > i && a <= i && (u = o + (n - o) * (i - r) / (a - r),
                u >= l && u <= h))
                    return !0;
                if (o < l && n >= l) {
                    if (u = r + (a - r) * (l - o) / (n - o),
                    u >= s && u <= i)
                        return !0
                } else if (o > h && n <= h && (u = r + (a - r) * (h - o) / (n - o),
                u >= s && u <= i))
                    return !0;
                return !1
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(96)
              , f = t(57)
              , r = t(235)
              , o = t(490)
              , a = function(n, s) {
                if (s.left > n.right || s.right < n.left || s.top > n.bottom || s.bottom < n.top)
                    return !1;
                var l = s.getLineA()
                  , i = s.getLineB()
                  , h = s.getLineC();
                if (f(n, l.x1, l.y1) || f(n, l.x2, l.y2) || f(n, i.x1, i.y1) || f(n, i.x2, i.y2) || f(n, h.x1, h.y1) || f(n, h.x2, h.y2))
                    return !0;
                var u = n.getLineA()
                  , d = n.getLineB()
                  , v = n.getLineC()
                  , p = n.getLineD();
                if (e(l, u) || e(l, d) || e(l, v) || e(l, p) || e(i, u) || e(i, d) || e(i, v) || e(i, p) || e(h, u) || e(h, d) || e(h, v) || e(h, p))
                    return !0;
                var g = o(n)
                  , m = r(s, g, !0);
                return m.length > 0
            };
            c.exports = a
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return f === void 0 && (f = []),
                f.push({
                    x: e.x,
                    y: e.y
                }),
                f.push({
                    x: e.right,
                    y: e.y
                }),
                f.push({
                    x: e.right,
                    y: e.bottom
                }),
                f.push({
                    x: e.x,
                    y: e.bottom
                }),
                f
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(233)
              , f = t(115)
              , r = function(o, a) {
                return o.left > a.right || o.right < a.left || o.top > a.bottom || o.bottom < a.top ? !1 : !!(f(o, a.x, a.y) || e(o.getLineA(), a) || e(o.getLineB(), a) || e(o.getLineC(), a))
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4)
              , f = t(493)
              , r = t(96)
              , o = function(a, n, s) {
                if (s === void 0 && (s = []),
                f(a, n))
                    for (var l = a.getLineA(), i = a.getLineB(), h = a.getLineC(), u = [new e, new e, new e], d = [r(l, n, u[0]), r(i, n, u[1]), r(h, n, u[2])], v = 0; v < 3; v++)
                        d[v] && s.push(u[v]);
                return s
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(96)
              , f = function(r, o) {
                return !!(r.contains(o.x1, o.y1) || r.contains(o.x2, o.y2) || e(r.getLineA(), o) || e(r.getLineB(), o) || e(r.getLineC(), o))
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(235)
              , f = t(495)
              , r = t(96)
              , o = function(a, n) {
                if (a.left > n.right || a.right < n.left || a.top > n.bottom || a.bottom < n.top)
                    return !1;
                var s = a.getLineA()
                  , l = a.getLineB()
                  , i = a.getLineC()
                  , h = n.getLineA()
                  , u = n.getLineB()
                  , d = n.getLineC();
                if (r(s, h) || r(s, u) || r(s, d) || r(l, h) || r(l, u) || r(l, d) || r(i, h) || r(i, u) || r(i, d))
                    return !0;
                var v = f(a)
                  , p = e(n, v, !0);
                return p.length > 0 || (v = f(n),
                p = e(a, v, !0),
                p.length > 0)
            };
            c.exports = o
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return f === void 0 && (f = []),
                f.push({
                    x: e.x1,
                    y: e.y1
                }),
                f.push({
                    x: e.x2,
                    y: e.y2
                }),
                f.push({
                    x: e.x3,
                    y: e.y3
                }),
                f
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Florian Mertens
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                r === void 0 && (r = 1);
                var o = f.x1
                  , a = f.y1
                  , n = f.x2
                  , s = f.y2
                  , l = e.x
                  , i = e.y
                  , h = (n - o) * (n - o) + (s - a) * (s - a);
                if (h === 0)
                    return !1;
                var u = ((l - o) * (n - o) + (i - a) * (s - a)) / h;
                if (u < 0)
                    return Math.sqrt((o - l) * (o - l) + (a - i) * (a - i)) <= r;
                if (u >= 0 && u <= 1) {
                    var d = ((a - i) * (n - o) - (o - l) * (s - a)) / h;
                    return Math.abs(d) * Math.sqrt(h) <= r
                } else
                    return Math.sqrt((n - l) * (n - l) + (s - i) * (s - i)) <= r
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(14)
              , f = t(68)
              , r = t(97)
              , o = function(a) {
                var n = r(a) - e.TAU;
                return f(n, -Math.PI, Math.PI)
            };
            c.exports = o
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = !0
              , e = "untitled"
              , f = ""
              , r = "";
            function o(g) {
                var m = g.indexOf("#");
                return m > -1 ? g.substring(0, m) : g
            }
            function a(g) {
                return g.models.length === 0 && g.models.push({
                    faces: [],
                    name: e,
                    textureCoords: [],
                    vertexNormals: [],
                    vertices: []
                }),
                f = "",
                g.models[g.models.length - 1]
            }
            function n(g, m) {
                var x = g.length >= 2 ? g[1] : e;
                m.models.push({
                    faces: [],
                    name: x,
                    textureCoords: [],
                    vertexNormals: [],
                    vertices: []
                }),
                f = ""
            }
            function s(g) {
                g.length === 2 && (f = g[1])
            }
            function l(g, m) {
                var x = g.length
                  , T = x >= 2 ? parseFloat(g[1]) : 0
                  , E = x >= 3 ? parseFloat(g[2]) : 0
                  , P = x >= 4 ? parseFloat(g[3]) : 0;
                a(m).vertices.push({
                    x: T,
                    y: E,
                    z: P
                })
            }
            function i(g, m) {
                var x = g.length
                  , T = x >= 2 ? parseFloat(g[1]) : 0
                  , E = x >= 3 ? parseFloat(g[2]) : 0
                  , P = x >= 4 ? parseFloat(g[3]) : 0;
                isNaN(T) && (T = 0),
                isNaN(E) && (E = 0),
                isNaN(P) && (P = 0),
                t && (E = 1 - E),
                a(m).textureCoords.push({
                    u: T,
                    v: E,
                    w: P
                })
            }
            function h(g, m) {
                var x = g.length
                  , T = x >= 2 ? parseFloat(g[1]) : 0
                  , E = x >= 3 ? parseFloat(g[2]) : 0
                  , P = x >= 4 ? parseFloat(g[3]) : 0;
                a(m).vertexNormals.push({
                    x: T,
                    y: E,
                    z: P
                })
            }
            function u(g, m) {
                var x = g.length - 1;
                if (!(x < 3)) {
                    for (var T = {
                        group: f,
                        material: r,
                        vertices: []
                    }, E = 0; E < x; E++) {
                        var P = g[E + 1]
                          , M = P.split("/")
                          , L = M.length;
                        if (!(L < 1 || L > 3)) {
                            var R = 0
                              , O = 0
                              , F = 0;
                            R = parseInt(M[0], 10),
                            L > 1 && M[1] !== "" && (O = parseInt(M[1], 10)),
                            L > 2 && (F = parseInt(M[2], 10)),
                            R !== 0 && (R < 0 && (R = a(m).vertices.length + 1 + R),
                            O -= 1,
                            R -= 1,
                            F -= 1,
                            T.vertices.push({
                                textureCoordsIndex: O,
                                vertexIndex: R,
                                vertexNormalIndex: F
                            }))
                        }
                    }
                    a(m).faces.push(T)
                }
            }
            function d(g, m) {
                g.length >= 2 && m.materialLibraries.push(g[1])
            }
            function v(g) {
                g.length >= 2 && (r = g[1])
            }
            var p = function(g, m) {
                m === void 0 && (m = !0),
                t = m;
                var x = {
                    materials: {},
                    materialLibraries: [],
                    models: []
                };
                f = "",
                r = "";
                for (var T = g.split(`
`), E = 0; E < T.length; E++) {
                    var P = o(T[E])
                      , M = P.replace(/\s\s+/g, " ").trim().split(" ");
                    switch (M[0].toLowerCase()) {
                    case "o":
                        n(M, x);
                        break;
                    case "g":
                        s(M);
                        break;
                    case "v":
                        l(M, x);
                        break;
                    case "vt":
                        i(M, x);
                        break;
                    case "vn":
                        h(M, x);
                        break;
                    case "f":
                        u(M, x);
                        break;
                    case "mtllib":
                        d(M, x);
                        break;
                    case "usemtl":
                        v(M);
                        break
                    }
                }
                return x
            };
            c.exports = p
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(103)
              , f = function(r) {
                for (var o = {}, a = r.split(`
`), n = "", s = 0; s < a.length; s++) {
                    var l = a[s].trim();
                    if (!(l.indexOf("#") === 0 || l === "")) {
                        var i = l.replace(/\s\s+/g, " ").trim().split(" ");
                        switch (i[0].toLowerCase()) {
                        case "newmtl":
                            {
                                n = i[1];
                                break
                            }
                        case "kd":
                            {
                                var h = Math.floor(i[1] * 255)
                                  , u = i.length >= 2 ? Math.floor(i[2] * 255) : h
                                  , d = i.length >= 3 ? Math.floor(i[3] * 255) : h;
                                o[n] = e(h, u, d);
                                break
                            }
                        }
                    }
                }
                return o
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return Math.sqrt(e.x * e.x + e.y * e.y)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e.x * e.x + e.y * e.y
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(10);
            e.Area = t(1267),
            e.Ceil = t(1268),
            e.CeilAll = t(1269),
            e.CenterOn = t(190),
            e.Clone = t(1270),
            e.Contains = t(57),
            e.ContainsPoint = t(1271),
            e.ContainsRect = t(503),
            e.CopyFrom = t(1272),
            e.Decompose = t(490),
            e.Equals = t(1273),
            e.FitInside = t(1274),
            e.FitOutside = t(1275),
            e.Floor = t(1276),
            e.FloorAll = t(1277),
            e.FromPoints = t(199),
            e.FromXY = t(1278),
            e.GetAspectRatio = t(237),
            e.GetCenter = t(1279),
            e.GetPoint = t(171),
            e.GetPoints = t(306),
            e.GetSize = t(1280),
            e.Inflate = t(1281),
            e.Intersection = t(1282),
            e.MarchingAnts = t(316),
            e.MergePoints = t(1283),
            e.MergeRect = t(1284),
            e.MergeXY = t(1285),
            e.Offset = t(1286),
            e.OffsetPoint = t(1287),
            e.Overlaps = t(1288),
            e.Perimeter = t(130),
            e.PerimeterPoint = t(1289),
            e.Random = t(174),
            e.RandomOutside = t(1290),
            e.SameDimensions = t(1291),
            e.Scale = t(1292),
            e.Union = t(441),
            c.exports = e
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return f.width * f.height > e.width * e.height ? !1 : f.x > e.x && f.x < e.right && f.right > e.x && f.right < e.right && f.y > e.y && f.y < e.bottom && f.bottom > e.y && f.bottom < e.bottom
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4)
              , f = function(r, o) {
                return o === void 0 && (o = new e),
                o.x = (r.x1 + r.x2 + r.x3) / 3,
                o.y = (r.y1 + r.y2 + r.y3) / 3,
                o
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                return e.x1 += f,
                e.y1 += r,
                e.x2 += f,
                e.y2 += r,
                e.x3 += f,
                e.y3 += r,
                e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4);
            function f(o, a, n, s) {
                var l = o - n
                  , i = a - s
                  , h = l * l + i * i;
                return Math.sqrt(h)
            }
            var r = function(o, a) {
                a === void 0 && (a = new e);
                var n = o.x1
                  , s = o.y1
                  , l = o.x2
                  , i = o.y2
                  , h = o.x3
                  , u = o.y3
                  , d = f(h, u, l, i)
                  , v = f(n, s, h, u)
                  , p = f(l, i, n, s)
                  , g = d + v + p;
                return a.x = (n * d + l * v + h * p) / g,
                a.y = (s * d + i * v + u * p) / g,
                a
            };
            c.exports = r
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return function(r, o, a, n) {
                    var s = e.getPixelAlpha(o, a, n.texture.key, n.frame.name);
                    return s && s >= f
                }
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                return {
                    gameObject: e,
                    enabled: !0,
                    alwaysEnabled: !1,
                    draggable: !1,
                    dropZone: !1,
                    cursor: !1,
                    target: null,
                    camera: null,
                    hitArea: f,
                    hitAreaCallback: r,
                    hitAreaDebug: null,
                    customHitArea: !1,
                    localX: 0,
                    localY: 0,
                    dragState: 0,
                    dragStartX: 0,
                    dragStartY: 0,
                    dragStartXGlobal: 0,
                    dragStartYGlobal: 0,
                    dragX: 0,
                    dragY: 0
                }
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = new e({
                initialize: function(o, a) {
                    this.pad = o,
                    this.events = o.events,
                    this.index = a,
                    this.value = 0,
                    this.threshold = .1
                },
                update: function(r) {
                    this.value = r
                },
                getValue: function() {
                    return Math.abs(this.value) < this.threshold ? 0 : this.value
                },
                destroy: function() {
                    this.pad = null,
                    this.events = null
                }
            });
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(239)
              , r = new e({
                initialize: function(a, n) {
                    this.pad = a,
                    this.events = a.manager,
                    this.index = n,
                    this.value = 0,
                    this.threshold = 1,
                    this.pressed = !1
                },
                update: function(o) {
                    this.value = o;
                    var a = this.pad
                      , n = this.index;
                    o >= this.threshold ? this.pressed || (this.pressed = !0,
                    this.events.emit(f.BUTTON_DOWN, a, this, o),
                    this.pad.emit(f.GAMEPAD_BUTTON_DOWN, n, o, this)) : this.pressed && (this.pressed = !1,
                    this.events.emit(f.BUTTON_UP, a, this, o),
                    this.pad.emit(f.GAMEPAD_BUTTON_UP, n, o, this))
                },
                destroy: function() {
                    this.pad = null,
                    this.events = null
                }
            });
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(509)
              , f = t(510)
              , r = t(0)
              , o = t(9)
              , a = t(3)
              , n = new r({
                Extends: o,
                initialize: function(l, i) {
                    o.call(this),
                    this.manager = l,
                    this.pad = i,
                    this.id = i.id,
                    this.index = i.index;
                    for (var h = [], u = 0; u < i.buttons.length; u++)
                        h.push(new f(this,u));
                    this.buttons = h;
                    var d = [];
                    for (u = 0; u < i.axes.length; u++)
                        d.push(new e(this,u));
                    this.axes = d,
                    this.vibration = i.vibrationActuator;
                    var v = {
                        value: 0,
                        pressed: !1
                    };
                    this._LCLeft = h[14] ? h[14] : v,
                    this._LCRight = h[15] ? h[15] : v,
                    this._LCTop = h[12] ? h[12] : v,
                    this._LCBottom = h[13] ? h[13] : v,
                    this._RCLeft = h[2] ? h[2] : v,
                    this._RCRight = h[1] ? h[1] : v,
                    this._RCTop = h[3] ? h[3] : v,
                    this._RCBottom = h[0] ? h[0] : v,
                    this._FBLeftTop = h[4] ? h[4] : v,
                    this._FBLeftBottom = h[6] ? h[6] : v,
                    this._FBRightTop = h[5] ? h[5] : v,
                    this._FBRightBottom = h[7] ? h[7] : v;
                    var p = {
                        value: 0
                    };
                    this._HAxisLeft = d[0] ? d[0] : p,
                    this._VAxisLeft = d[1] ? d[1] : p,
                    this._HAxisRight = d[2] ? d[2] : p,
                    this._VAxisRight = d[3] ? d[3] : p,
                    this.leftStick = new a,
                    this.rightStick = new a,
                    this._created = performance.now()
                },
                getAxisTotal: function() {
                    return this.axes.length
                },
                getAxisValue: function(s) {
                    return this.axes[s].getValue()
                },
                setAxisThreshold: function(s) {
                    for (var l = 0; l < this.axes.length; l++)
                        this.axes[l].threshold = s
                },
                getButtonTotal: function() {
                    return this.buttons.length
                },
                getButtonValue: function(s) {
                    return this.buttons[s].value
                },
                isButtonDown: function(s) {
                    return this.buttons[s].pressed
                },
                update: function(s) {
                    if (!(s.timestamp < this._created)) {
                        var l, i = this.buttons, h = s.buttons, u = i.length;
                        for (l = 0; l < u; l++)
                            i[l].update(h[l].value);
                        var d = this.axes
                          , v = s.axes;
                        for (u = d.length,
                        l = 0; l < u; l++)
                            d[l].update(v[l]);
                        u >= 2 && (this.leftStick.set(d[0].getValue(), d[1].getValue()),
                        u >= 4 && this.rightStick.set(d[2].getValue(), d[3].getValue()))
                    }
                },
                destroy: function() {
                    this.removeAllListeners(),
                    this.manager = null,
                    this.pad = null;
                    var s;
                    for (s = 0; s < this.buttons.length; s++)
                        this.buttons[s].destroy();
                    for (s = 0; s < this.axes.length; s++)
                        this.axes[s].destroy();
                    this.buttons = [],
                    this.axes = []
                },
                connected: {
                    get: function() {
                        return this.pad.connected
                    }
                },
                timestamp: {
                    get: function() {
                        return this.pad.timestamp
                    }
                },
                left: {
                    get: function() {
                        return this._LCLeft.pressed
                    }
                },
                right: {
                    get: function() {
                        return this._LCRight.pressed
                    }
                },
                up: {
                    get: function() {
                        return this._LCTop.pressed
                    }
                },
                down: {
                    get: function() {
                        return this._LCBottom.pressed
                    }
                },
                A: {
                    get: function() {
                        return this._RCBottom.pressed
                    }
                },
                Y: {
                    get: function() {
                        return this._RCTop.pressed
                    }
                },
                X: {
                    get: function() {
                        return this._RCLeft.pressed
                    }
                },
                B: {
                    get: function() {
                        return this._RCRight.pressed
                    }
                },
                L1: {
                    get: function() {
                        return this._FBLeftTop.value
                    }
                },
                L2: {
                    get: function() {
                        return this._FBLeftBottom.value
                    }
                },
                R1: {
                    get: function() {
                        return this._FBRightTop.value
                    }
                },
                R2: {
                    get: function() {
                        return this._FBRightBottom.value
                    }
                }
            });
            c.exports = n
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(9)
              , r = t(154)
              , o = new e({
                Extends: f,
                initialize: function(n, s) {
                    f.call(this),
                    this.plugin = n,
                    this.keyCode = s,
                    this.originalEvent = void 0,
                    this.enabled = !0,
                    this.isDown = !1,
                    this.isUp = !0,
                    this.altKey = !1,
                    this.ctrlKey = !1,
                    this.shiftKey = !1,
                    this.metaKey = !1,
                    this.location = 0,
                    this.timeDown = 0,
                    this.duration = 0,
                    this.timeUp = 0,
                    this.emitOnRepeat = !1,
                    this.repeats = 0,
                    this._justDown = !1,
                    this._justUp = !1,
                    this._tick = -1
                },
                setEmitOnRepeat: function(a) {
                    return this.emitOnRepeat = a,
                    this
                },
                onDown: function(a) {
                    this.originalEvent = a,
                    this.enabled && (this.altKey = a.altKey,
                    this.ctrlKey = a.ctrlKey,
                    this.shiftKey = a.shiftKey,
                    this.metaKey = a.metaKey,
                    this.location = a.location,
                    this.repeats++,
                    this.isDown ? this.emitOnRepeat && this.emit(r.DOWN, this, a) : (this.isDown = !0,
                    this.isUp = !1,
                    this.timeDown = a.timeStamp,
                    this.duration = 0,
                    this._justDown = !0,
                    this._justUp = !1,
                    this.emit(r.DOWN, this, a)))
                },
                onUp: function(a) {
                    this.originalEvent = a,
                    this.enabled && (this.isDown = !1,
                    this.isUp = !0,
                    this.timeUp = a.timeStamp,
                    this.duration = this.timeUp - this.timeDown,
                    this.repeats = 0,
                    this._justDown = !1,
                    this._justUp = !0,
                    this._tick = -1,
                    this.emit(r.UP, this, a))
                },
                reset: function() {
                    return this.preventDefault = !0,
                    this.enabled = !0,
                    this.isDown = !1,
                    this.isUp = !0,
                    this.altKey = !1,
                    this.ctrlKey = !1,
                    this.shiftKey = !1,
                    this.metaKey = !1,
                    this.timeDown = 0,
                    this.duration = 0,
                    this.timeUp = 0,
                    this.repeats = 0,
                    this._justDown = !1,
                    this._justUp = !1,
                    this._tick = -1,
                    this
                },
                getDuration: function() {
                    return this.isDown ? this.plugin.game.loop.time - this.timeDown : 0
                },
                destroy: function() {
                    this.removeAllListeners(),
                    this.originalEvent = null,
                    this.plugin = null
                }
            });
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(154)
              , r = t(2)
              , o = t(514)
              , a = t(516)
              , n = new e({
                initialize: function(l, i, h) {
                    if (h === void 0 && (h = {}),
                    i.length < 2)
                        return !1;
                    this.manager = l,
                    this.enabled = !0,
                    this.keyCodes = [];
                    for (var u = 0; u < i.length; u++) {
                        var d = i[u];
                        typeof d == "string" ? this.keyCodes.push(d.toUpperCase().charCodeAt(0)) : typeof d == "number" ? this.keyCodes.push(d) : d.hasOwnProperty("keyCode") && this.keyCodes.push(d.keyCode)
                    }
                    this.current = this.keyCodes[0],
                    this.index = 0,
                    this.size = this.keyCodes.length,
                    this.timeLastMatched = 0,
                    this.matched = !1,
                    this.timeMatched = 0,
                    this.resetOnWrongKey = r(h, "resetOnWrongKey", !0),
                    this.maxKeyDelay = r(h, "maxKeyDelay", 0),
                    this.resetOnMatch = r(h, "resetOnMatch", !1),
                    this.deleteOnMatch = r(h, "deleteOnMatch", !1);
                    var v = this
                      , p = function(g) {
                        if (!(v.matched || !v.enabled)) {
                            var m = o(g, v);
                            m && (v.manager.emit(f.COMBO_MATCH, v, g),
                            v.resetOnMatch ? a(v) : v.deleteOnMatch && v.destroy())
                        }
                    };
                    this.onKeyDown = p,
                    this.manager.on(f.ANY_KEY_DOWN, this.onKeyDown)
                },
                progress: {
                    get: function() {
                        return this.index / this.size
                    }
                },
                destroy: function() {
                    this.enabled = !1,
                    this.keyCodes = [],
                    this.manager.off(f.ANY_KEY_DOWN, this.onKeyDown),
                    this.manager = null
                }
            });
            c.exports = n
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(515)
              , f = function(r, o) {
                if (o.matched)
                    return !0;
                var a = !1
                  , n = !1;
                if (r.keyCode === o.current)
                    if (o.index > 0 && o.maxKeyDelay > 0) {
                        var s = o.timeLastMatched + o.maxKeyDelay;
                        r.timeStamp <= s && (n = !0,
                        a = e(r, o))
                    } else
                        n = !0,
                        a = e(r, o);
                return !n && o.resetOnWrongKey && (o.index = 0,
                o.current = o.keyCodes[0]),
                a && (o.timeLastMatched = r.timeStamp,
                o.matched = !0,
                o.timeMatched = r.timeStamp),
                a
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return f.timeLastMatched = e.timeStamp,
                f.index++,
                f.index === f.size ? !0 : (f.current = f.keyCodes[f.index],
                !1)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e.current = e.keyCodes[0],
                e.index = 0,
                e.timeLastMatched = 0,
                e.matched = !1,
                e.timeMatched = 0,
                e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(240)
              , f = function(r, o) {
                var a = e(o, r.xhrSettings)
                  , n = new XMLHttpRequest;
                if (n.open("GET", r.src, a.async, a.user, a.password),
                n.responseType = r.xhrSettings.responseType,
                n.timeout = a.timeout,
                a.headers)
                    for (var s in a.headers)
                        n.setRequestHeader(s, a.headers[s]);
                return a.header && a.headerValue && n.setRequestHeader(a.header, a.headerValue),
                a.requestedWith && n.setRequestHeader("X-Requested-With", a.requestedWith),
                a.overrideMimeType && n.overrideMimeType(a.overrideMimeType),
                a.withCredentials && (n.withCredentials = !0),
                n.onload = r.onLoad.bind(r, n),
                n.onerror = r.onError.bind(r, n),
                n.onprogress = r.onProgress.bind(r),
                n.send(),
                n
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(21)
              , r = t(23)
              , o = t(8)
              , a = t(2)
              , n = t(519)
              , s = t(7)
              , l = new e({
                Extends: r,
                initialize: function(h, u, d, v, p) {
                    if (s(u)) {
                        var g = u;
                        u = a(g, "key"),
                        v = a(g, "xhrSettings"),
                        p = a(g, "context", p)
                    }
                    var m = {
                        type: "audio",
                        cache: h.cacheManager.audio,
                        extension: d.type,
                        responseType: "arraybuffer",
                        key: u,
                        url: d.url,
                        xhrSettings: v,
                        config: {
                            context: p
                        }
                    };
                    r.call(this, h, m)
                },
                onProcess: function() {
                    this.state = f.FILE_PROCESSING;
                    var i = this;
                    this.config.context.decodeAudioData(this.xhrLoader.response, function(h) {
                        i.data = h,
                        i.onProcessComplete()
                    }, function(h) {
                        console.error("Error decoding audio: " + i.key + " - ", h ? h.message : null),
                        i.onProcessError()
                    }),
                    this.config.context = null
                }
            });
            l.create = function(i, h, u, d, v) {
                var p = i.systems.game
                  , g = p.config.audio
                  , m = p.device.audio;
                s(h) && (u = a(h, "url", []),
                d = a(h, "config", {}));
                var x = l.getAudioURL(p, u);
                return x ? m.webAudio && !g.disableWebAudio ? new l(i,h,x,v,p.sound.context) : new n(i,h,x,d) : null
            }
            ,
            l.getAudioURL = function(i, h) {
                Array.isArray(h) || (h = [h]);
                for (var u = 0; u < h.length; u++) {
                    var d = a(h[u], "url", h[u]);
                    if (d.indexOf("blob:") === 0 || d.indexOf("data:") === 0)
                        return {
                            url: d,
                            type: ""
                        };
                    var v = d.match(/\.([a-zA-Z0-9]+)($|\?)/);
                    if (v = a(h[u], "type", v ? v[1] : "").toLowerCase(),
                    i.device.audio[v])
                        return {
                            url: d,
                            type: v
                        }
                }
                return null
            }
            ,
            o.register("audio", function(i, h, u, d) {
                var v = this.systems.game
                  , p = v.config.audio
                  , g = v.device.audio;
                if (p.noAudio || !g.webAudio && !g.audioData)
                    return this;
                var m;
                if (Array.isArray(i))
                    for (var x = 0; x < i.length; x++)
                        m = l.create(this, i[x]),
                        m && this.addFile(m);
                else
                    m = l.create(this, i, h, u, d),
                    m && this.addFile(m);
                return this
            }),
            c.exports = l
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(95)
              , r = t(23)
              , o = t(2)
              , a = t(155)
              , n = t(7)
              , s = new e({
                Extends: r,
                initialize: function(i, h, u, d) {
                    if (n(h)) {
                        var v = h;
                        h = o(v, "key"),
                        d = o(v, "config", d)
                    }
                    var p = {
                        type: "audio",
                        cache: i.cacheManager.audio,
                        extension: u.type,
                        key: h,
                        url: u.url,
                        config: d
                    };
                    r.call(this, i, p),
                    this.locked = "ontouchstart"in window,
                    this.loaded = !1,
                    this.filesLoaded = 0,
                    this.filesTotal = 0
                },
                onLoad: function() {
                    this.loaded || (this.loaded = !0,
                    this.loader.nextFile(this, !0))
                },
                onError: function() {
                    for (var l = 0; l < this.data.length; l++) {
                        var i = this.data[l];
                        i.oncanplaythrough = null,
                        i.onerror = null
                    }
                    this.loader.nextFile(this, !1)
                },
                onProgress: function(l) {
                    var i = l.target;
                    i.oncanplaythrough = null,
                    i.onerror = null,
                    this.filesLoaded++,
                    this.percentComplete = Math.min(this.filesLoaded / this.filesTotal, 1),
                    this.loader.emit(f.FILE_PROGRESS, this, this.percentComplete),
                    this.filesLoaded === this.filesTotal && this.onLoad()
                },
                load: function() {
                    this.data = [];
                    var l = this.config && this.config.instances || 1;
                    this.filesTotal = l,
                    this.filesLoaded = 0,
                    this.percentComplete = 0;
                    for (var i = 0; i < l; i++) {
                        var h = new Audio;
                        h.dataset || (h.dataset = {}),
                        h.dataset.name = this.key + ("0" + i).slice(-2),
                        h.dataset.used = "false",
                        this.locked ? h.dataset.locked = "true" : (h.dataset.locked = "false",
                        h.preload = "auto",
                        h.oncanplaythrough = this.onProgress.bind(this),
                        h.onerror = this.onError.bind(this)),
                        this.data.push(h)
                    }
                    for (i = 0; i < this.data.length; i++)
                        h = this.data[i],
                        h.src = a(this, this.loader.baseURL),
                        this.locked || h.load();
                    this.locked && setTimeout(this.onLoad.bind(this))
                }
            });
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(21)
              , r = t(23)
              , o = t(8)
              , a = t(2)
              , n = t(7)
              , s = new e({
                Extends: r,
                initialize: function(i, h, u, d) {
                    var v = "js";
                    if (n(h)) {
                        var p = h;
                        h = a(p, "key"),
                        u = a(p, "url"),
                        d = a(p, "xhrSettings"),
                        v = a(p, "extension", v)
                    }
                    var g = {
                        type: "script",
                        cache: !1,
                        extension: v,
                        responseType: "text",
                        key: h,
                        url: u,
                        xhrSettings: d
                    };
                    r.call(this, i, g)
                },
                onProcess: function() {
                    this.state = f.FILE_PROCESSING,
                    this.data = document.createElement("script"),
                    this.data.language = "javascript",
                    this.data.type = "text/javascript",
                    this.data.defer = !1,
                    this.data.text = this.xhrLoader.responseText,
                    document.head.appendChild(this.data),
                    this.onProcessComplete()
                }
            });
            o.register("script", function(l, i, h) {
                if (Array.isArray(l))
                    for (var u = 0; u < l.length; u++)
                        this.addFile(new s(this,l[u]));
                else
                    this.addFile(new s(this,l,i,h));
                return this
            }),
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(522)
              , f = t(157)
              , r = t(0)
              , o = t(62)
              , a = t(524)
              , n = t(525)
              , s = new r({
                initialize: function(i) {
                    this.world = i,
                    this.scene = i.scene,
                    this.sys = i.scene.sys
                },
                collider: function(l, i, h, u, d) {
                    return this.world.addCollider(l, i, h, u, d)
                },
                overlap: function(l, i, h, u, d) {
                    return this.world.addOverlap(l, i, h, u, d)
                },
                existing: function(l, i) {
                    var h = i ? o.STATIC_BODY : o.DYNAMIC_BODY;
                    return this.world.enableBody(l, h),
                    l
                },
                staticImage: function(l, i, h, u) {
                    var d = new e(this.scene,l,i,h,u);
                    return this.sys.displayList.add(d),
                    this.world.enableBody(d, o.STATIC_BODY),
                    d
                },
                image: function(l, i, h, u) {
                    var d = new e(this.scene,l,i,h,u);
                    return this.sys.displayList.add(d),
                    this.world.enableBody(d, o.DYNAMIC_BODY),
                    d
                },
                staticSprite: function(l, i, h, u) {
                    var d = new f(this.scene,l,i,h,u);
                    return this.sys.displayList.add(d),
                    this.sys.updateList.add(d),
                    this.world.enableBody(d, o.STATIC_BODY),
                    d
                },
                sprite: function(l, i, h, u) {
                    var d = new f(this.scene,l,i,h,u);
                    return this.sys.displayList.add(d),
                    this.sys.updateList.add(d),
                    this.world.enableBody(d, o.DYNAMIC_BODY),
                    d
                },
                staticGroup: function(l, i) {
                    return this.sys.updateList.add(new n(this.world,this.world.scene,l,i))
                },
                group: function(l, i) {
                    return this.sys.updateList.add(new a(this.world,this.world.scene,l,i))
                },
                destroy: function() {
                    this.world = null,
                    this.scene = null,
                    this.sys = null
                }
            });
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(243)
              , r = t(125)
              , o = new e({
                Extends: r,
                Mixins: [f.Acceleration, f.Angular, f.Bounce, f.Debug, f.Drag, f.Enable, f.Friction, f.Gravity, f.Immovable, f.Mass, f.Pushable, f.Size, f.Velocity],
                initialize: function(n, s, l, i, h) {
                    r.call(this, n, s, l, i, h),
                    this.body = null
                }
            });
            c.exports = o
        }
        , function(c, S, t) {
            var e = t(244)
              , f = t(65)
              , r = t(231)
              , o = t(151)
              , a = function(n, s, l, i, h, u) {
                var d = e(n, s - i, l - i, 2 * i, 2 * i, h, u);
                if (d.length === 0)
                    return d;
                for (var v = new f(s,l,i), p = new f, g = [], m = 0; m < d.length; m++) {
                    var x = d[m];
                    x.isCircle ? (p.setTo(x.center.x, x.center.y, x.halfWidth),
                    r(v, p) && g.push(x)) : o(v, x) && g.push(x)
                }
                return g
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(157)
              , f = t(0)
              , r = t(62)
              , o = t(2)
              , a = t(113)
              , n = t(7)
              , s = new f({
                Extends: a,
                initialize: function(i, h, u, d) {
                    if (!u && !d)
                        d = {
                            internalCreateCallback: this.createCallbackHandler,
                            internalRemoveCallback: this.removeCallbackHandler
                        };
                    else if (n(u))
                        d = u,
                        u = null,
                        d.internalCreateCallback = this.createCallbackHandler,
                        d.internalRemoveCallback = this.removeCallbackHandler;
                    else if (Array.isArray(u) && n(u[0])) {
                        d = u[0];
                        var v = this;
                        u.forEach(function(p) {
                            p.internalCreateCallback = v.createCallbackHandler,
                            p.internalRemoveCallback = v.removeCallbackHandler
                        }),
                        u = null
                    } else
                        d = {
                            internalCreateCallback: this.createCallbackHandler,
                            internalRemoveCallback: this.removeCallbackHandler
                        };
                    this.world = i,
                    d.classType = o(d, "classType", e),
                    this.physicsType = r.DYNAMIC_BODY,
                    this.defaults = {
                        setCollideWorldBounds: o(d, "collideWorldBounds", !1),
                        setBoundsRectangle: o(d, "customBoundsRectangle", null),
                        setAccelerationX: o(d, "accelerationX", 0),
                        setAccelerationY: o(d, "accelerationY", 0),
                        setAllowDrag: o(d, "allowDrag", !0),
                        setAllowGravity: o(d, "allowGravity", !0),
                        setAllowRotation: o(d, "allowRotation", !0),
                        setBounceX: o(d, "bounceX", 0),
                        setBounceY: o(d, "bounceY", 0),
                        setDragX: o(d, "dragX", 0),
                        setDragY: o(d, "dragY", 0),
                        setEnable: o(d, "enable", !0),
                        setGravityX: o(d, "gravityX", 0),
                        setGravityY: o(d, "gravityY", 0),
                        setFrictionX: o(d, "frictionX", 0),
                        setFrictionY: o(d, "frictionY", 0),
                        setMaxVelocityX: o(d, "maxVelocityX", 1e4),
                        setMaxVelocityY: o(d, "maxVelocityY", 1e4),
                        setVelocityX: o(d, "velocityX", 0),
                        setVelocityY: o(d, "velocityY", 0),
                        setAngularVelocity: o(d, "angularVelocity", 0),
                        setAngularAcceleration: o(d, "angularAcceleration", 0),
                        setAngularDrag: o(d, "angularDrag", 0),
                        setMass: o(d, "mass", 1),
                        setImmovable: o(d, "immovable", !1)
                    },
                    a.call(this, h, u, d),
                    this.type = "PhysicsGroup"
                },
                createCallbackHandler: function(l) {
                    l.body || this.world.enableBody(l, r.DYNAMIC_BODY);
                    var i = l.body;
                    for (var h in this.defaults)
                        i[h](this.defaults[h])
                },
                removeCallbackHandler: function(l) {
                    l.body && this.world.disableBody(l)
                },
                setVelocity: function(l, i, h) {
                    h === void 0 && (h = 0);
                    for (var u = this.getChildren(), d = 0; d < u.length; d++)
                        u[d].body.velocity.set(l + d * h, i + d * h);
                    return this
                },
                setVelocityX: function(l, i) {
                    i === void 0 && (i = 0);
                    for (var h = this.getChildren(), u = 0; u < h.length; u++)
                        h[u].body.velocity.x = l + u * i;
                    return this
                },
                setVelocityY: function(l, i) {
                    i === void 0 && (i = 0);
                    for (var h = this.getChildren(), u = 0; u < h.length; u++)
                        h[u].body.velocity.y = l + u * i;
                    return this
                }
            });
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(157)
              , f = t(0)
              , r = t(62)
              , o = t(2)
              , a = t(113)
              , n = t(7)
              , s = new f({
                Extends: a,
                initialize: function(i, h, u, d) {
                    !u && !d ? d = {
                        internalCreateCallback: this.createCallbackHandler,
                        internalRemoveCallback: this.removeCallbackHandler,
                        createMultipleCallback: this.createMultipleCallbackHandler,
                        classType: e
                    } : n(u) ? (d = u,
                    u = null,
                    d.internalCreateCallback = this.createCallbackHandler,
                    d.internalRemoveCallback = this.removeCallbackHandler,
                    d.createMultipleCallback = this.createMultipleCallbackHandler,
                    d.classType = o(d, "classType", e)) : Array.isArray(u) && n(u[0]) ? (d = u,
                    u = null,
                    d.forEach(function(v) {
                        v.internalCreateCallback = this.createCallbackHandler,
                        v.internalRemoveCallback = this.removeCallbackHandler,
                        v.createMultipleCallback = this.createMultipleCallbackHandler,
                        v.classType = o(v, "classType", e)
                    })) : d = {
                        internalCreateCallback: this.createCallbackHandler,
                        internalRemoveCallback: this.removeCallbackHandler
                    },
                    this.world = i,
                    this.physicsType = r.STATIC_BODY,
                    a.call(this, h, u, d),
                    this.type = "StaticPhysicsGroup"
                },
                createCallbackHandler: function(l) {
                    l.body || this.world.enableBody(l, r.STATIC_BODY)
                },
                removeCallbackHandler: function(l) {
                    l.body && this.world.disableBody(l)
                },
                createMultipleCallbackHandler: function() {
                    this.refresh()
                },
                refresh: function() {
                    for (var l = this.children.entries, i = 0; i < l.length; i++)
                        l[i].body.reset();
                    return this
                }
            });
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(350)
              , f = t(527)
              , r = t(18)
              , o = t(0)
              , a = t(528)
              , n = t(62)
              , s = t(50)
              , l = t(9)
              , i = t(245)
              , h = t(124)
              , u = t(354)
              , d = t(355)
              , v = t(246)
              , p = t(247)
              , g = t(529)
              , m = t(6)
              , x = t(14)
              , T = t(211)
              , E = t(530)
              , P = t(10)
              , M = t(531)
              , L = t(532)
              , R = t(537)
              , O = t(538)
              , F = t(149)
              , B = t(539)
              , N = t(248)
              , Y = t(25)
              , z = t(3)
              , W = t(68)
              , b = new o({
                Extends: l,
                initialize: function(I, G) {
                    l.call(this),
                    this.scene = I,
                    this.bodies = new F,
                    this.staticBodies = new F,
                    this.pendingDestroy = new F,
                    this.colliders = new T,
                    this.gravity = new z(m(G, "gravity.x", 0),m(G, "gravity.y", 0)),
                    this.bounds = new P(m(G, "x", 0),m(G, "y", 0),m(G, "width", I.sys.scale.width),m(G, "height", I.sys.scale.height)),
                    this.checkCollision = {
                        up: m(G, "checkCollision.up", !0),
                        down: m(G, "checkCollision.down", !0),
                        left: m(G, "checkCollision.left", !0),
                        right: m(G, "checkCollision.right", !0)
                    },
                    this.fps = m(G, "fps", 60),
                    this.fixedStep = m(G, "fixedStep", !0),
                    this._elapsed = 0,
                    this._frameTime = 1 / this.fps,
                    this._frameTimeMS = 1e3 * this._frameTime,
                    this.stepsLastFrame = 0,
                    this.timeScale = m(G, "timeScale", 1),
                    this.OVERLAP_BIAS = m(G, "overlapBias", 4),
                    this.TILE_BIAS = m(G, "tileBias", 16),
                    this.forceX = m(G, "forceX", !1),
                    this.isPaused = m(G, "isPaused", !1),
                    this._total = 0,
                    this.drawDebug = m(G, "debug", !1),
                    this.debugGraphic,
                    this.defaults = {
                        debugShowBody: m(G, "debugShowBody", !0),
                        debugShowStaticBody: m(G, "debugShowStaticBody", !0),
                        debugShowVelocity: m(G, "debugShowVelocity", !0),
                        bodyDebugColor: m(G, "debugBodyColor", 16711935),
                        staticBodyDebugColor: m(G, "debugStaticBodyColor", 255),
                        velocityDebugColor: m(G, "debugVelocityColor", 65280)
                    },
                    this.maxEntries = m(G, "maxEntries", 16),
                    this.useTree = m(G, "useTree", !0),
                    this.tree = new M(this.maxEntries),
                    this.staticTree = new M(this.maxEntries),
                    this.treeMinMax = {
                        minX: 0,
                        minY: 0,
                        maxX: 0,
                        maxY: 0
                    },
                    this._tempMatrix = new Y,
                    this._tempMatrix2 = new Y,
                    this.drawDebug && this.createDebugGraphic()
                },
                enable: function(D, I) {
                    I === void 0 && (I = n.DYNAMIC_BODY),
                    Array.isArray(D) || (D = [D]);
                    for (var G = 0; G < D.length; G++) {
                        var w = D[G];
                        if (w.isParent)
                            for (var U = w.getChildren(), X = 0; X < U.length; X++) {
                                var V = U[X];
                                V.isParent ? this.enable(V, I) : this.enableBody(V, I)
                            }
                        else
                            this.enableBody(w, I)
                    }
                },
                enableBody: function(D, I) {
                    return I === void 0 && (I = n.DYNAMIC_BODY),
                    D.body || (I === n.DYNAMIC_BODY ? D.body = new f(this,D) : I === n.STATIC_BODY && (D.body = new B(this,D))),
                    this.add(D.body),
                    D
                },
                add: function(D) {
                    return D.physicsType === n.DYNAMIC_BODY ? this.bodies.set(D) : D.physicsType === n.STATIC_BODY && (this.staticBodies.set(D),
                    this.staticTree.insert(D)),
                    D.enable = !0,
                    D
                },
                disable: function(D) {
                    Array.isArray(D) || (D = [D]);
                    for (var I = 0; I < D.length; I++) {
                        var G = D[I];
                        if (G.isParent)
                            for (var w = G.getChildren(), U = 0; U < w.length; U++) {
                                var X = w[U];
                                X.isParent ? this.disable(X) : this.disableBody(X.body)
                            }
                        else
                            this.disableBody(G.body)
                    }
                },
                disableBody: function(D) {
                    this.remove(D),
                    D.enable = !1
                },
                remove: function(D) {
                    D.physicsType === n.DYNAMIC_BODY ? (this.tree.remove(D),
                    this.bodies.delete(D)) : D.physicsType === n.STATIC_BODY && (this.staticBodies.delete(D),
                    this.staticTree.remove(D))
                },
                createDebugGraphic: function() {
                    var D = this.scene.sys.add.graphics({
                        x: 0,
                        y: 0
                    });
                    return D.setDepth(Number.MAX_VALUE),
                    this.debugGraphic = D,
                    this.drawDebug = !0,
                    D
                },
                setBounds: function(D, I, G, w, U, X, V, H) {
                    return this.bounds.setTo(D, I, G, w),
                    U !== void 0 && this.setBoundsCollision(U, X, V, H),
                    this
                },
                setBoundsCollision: function(D, I, G, w) {
                    return D === void 0 && (D = !0),
                    I === void 0 && (I = !0),
                    G === void 0 && (G = !0),
                    w === void 0 && (w = !0),
                    this.checkCollision.left = D,
                    this.checkCollision.right = I,
                    this.checkCollision.up = G,
                    this.checkCollision.down = w,
                    this
                },
                pause: function() {
                    return this.isPaused = !0,
                    this.emit(i.PAUSE),
                    this
                },
                resume: function() {
                    return this.isPaused = !1,
                    this.emit(i.RESUME),
                    this
                },
                addCollider: function(D, I, G, w, U) {
                    G === void 0 && (G = null),
                    w === void 0 && (w = null),
                    U === void 0 && (U = G);
                    var X = new a(this,!1,D,I,G,w,U);
                    return this.colliders.add(X),
                    X
                },
                addOverlap: function(D, I, G, w, U) {
                    G === void 0 && (G = null),
                    w === void 0 && (w = null),
                    U === void 0 && (U = G);
                    var X = new a(this,!0,D,I,G,w,U);
                    return this.colliders.add(X),
                    X
                },
                removeCollider: function(D) {
                    return this.colliders.remove(D),
                    this
                },
                setFPS: function(D) {
                    return this.fps = D,
                    this._frameTime = 1 / this.fps,
                    this._frameTimeMS = 1e3 * this._frameTime,
                    this
                },
                update: function(D, I) {
                    if (!(this.isPaused || this.bodies.size === 0)) {
                        var G, w = this._frameTime, U = this._frameTimeMS * this.timeScale;
                        this._elapsed += I;
                        var X, V = this.bodies.entries, H = this._elapsed >= U;
                        for (this.fixedStep || (w = I * .001,
                        H = !0,
                        this._elapsed = 0),
                        G = 0; G < V.length; G++)
                            X = V[G],
                            X.enable && X.preUpdate(H, w);
                        if (H) {
                            this._elapsed -= U,
                            this.stepsLastFrame = 1,
                            this.useTree && (this.tree.clear(),
                            this.tree.load(V));
                            var J = this.colliders.update();
                            for (G = 0; G < J.length; G++) {
                                var $ = J[G];
                                $.active && $.update()
                            }
                            this.emit(i.WORLD_STEP, w)
                        }
                        for (; this._elapsed >= U; )
                            this._elapsed -= U,
                            this.step(w)
                    }
                },
                step: function(D) {
                    var I, G, w = this.bodies.entries, U = w.length;
                    for (I = 0; I < U; I++)
                        G = w[I],
                        G.enable && G.update(D);
                    this.useTree && (this.tree.clear(),
                    this.tree.load(w));
                    var X = this.colliders.update();
                    for (I = 0; I < X.length; I++) {
                        var V = X[I];
                        V.active && V.update()
                    }
                    this.emit(i.WORLD_STEP, D),
                    this.stepsLastFrame++
                },
                postUpdate: function() {
                    var D, I, G = this.bodies.entries, w = G.length, U = this.bodies, X = this.staticBodies;
                    if (this.stepsLastFrame)
                        for (this.stepsLastFrame = 0,
                        D = 0; D < w; D++)
                            I = G[D],
                            I.enable && I.postUpdate();
                    if (this.drawDebug) {
                        var V = this.debugGraphic;
                        for (V.clear(),
                        D = 0; D < w; D++)
                            I = G[D],
                            I.willDrawDebug() && I.drawDebug(V);
                        for (G = X.entries,
                        w = G.length,
                        D = 0; D < w; D++)
                            I = G[D],
                            I.willDrawDebug() && I.drawDebug(V)
                    }
                    var H = this.pendingDestroy;
                    if (H.size > 0) {
                        var J = this.tree
                          , $ = this.staticTree;
                        for (G = H.entries,
                        w = G.length,
                        D = 0; D < w; D++)
                            I = G[D],
                            I.physicsType === n.DYNAMIC_BODY ? (J.remove(I),
                            U.delete(I)) : I.physicsType === n.STATIC_BODY && ($.remove(I),
                            X.delete(I)),
                            I.world = void 0,
                            I.gameObject = void 0;
                        H.clear()
                    }
                },
                updateMotion: function(D, I) {
                    D.allowRotation && this.computeAngularVelocity(D, I),
                    this.computeVelocity(D, I)
                },
                computeAngularVelocity: function(D, I) {
                    var G = D.angularVelocity
                      , w = D.angularAcceleration
                      , U = D.angularDrag
                      , X = D.maxAngular;
                    w ? G += w * I : D.allowDrag && U && (U *= I,
                    u(G - U, 0, .1) ? G -= U : d(G + U, 0, .1) ? G += U : G = 0),
                    G = r(G, -X, X);
                    var V = G - D.angularVelocity;
                    D.angularVelocity += V,
                    D.rotation += D.angularVelocity * I
                },
                computeVelocity: function(D, I) {
                    var G = D.velocity.x
                      , w = D.acceleration.x
                      , U = D.drag.x
                      , X = D.maxVelocity.x
                      , V = D.velocity.y
                      , H = D.acceleration.y
                      , J = D.drag.y
                      , $ = D.maxVelocity.y
                      , _ = D.speed
                      , nt = D.maxSpeed
                      , K = D.allowDrag
                      , Z = D.useDamping;
                    D.allowGravity && (G += (this.gravity.x + D.gravity.x) * I,
                    V += (this.gravity.y + D.gravity.y) * I),
                    w ? G += w * I : K && U && (Z ? (U = Math.pow(U, I),
                    G *= U,
                    _ = Math.sqrt(G * G + V * V),
                    h(_, 0, .001) && (G = 0)) : (U *= I,
                    u(G - U, 0, .01) ? G -= U : d(G + U, 0, .01) ? G += U : G = 0)),
                    H ? V += H * I : K && J && (Z ? (J = Math.pow(J, I),
                    V *= J,
                    _ = Math.sqrt(G * G + V * V),
                    h(_, 0, .001) && (V = 0)) : (J *= I,
                    u(V - J, 0, .01) ? V -= J : d(V + J, 0, .01) ? V += J : V = 0)),
                    G = r(G, -X, X),
                    V = r(V, -$, $),
                    D.velocity.set(G, V),
                    nt > -1 && _ > nt && (D.velocity.normalize().scale(nt),
                    _ = nt),
                    D.speed = _
                },
                separate: function(D, I, G, w, U, X) {
                    if (!X && !D.enable || !I.enable || D.checkCollision.none || I.checkCollision.none || !this.intersects(D, I) || G && G.call(w, D.gameObject, I.gameObject) === !1)
                        return !1;
                    if (D.isCircle && I.isCircle)
                        return this.separateCircle(D, I, U);
                    if (D.isCircle !== I.isCircle) {
                        var V = D.isCircle ? I : D
                          , H = D.isCircle ? D : I
                          , J = {
                            x: V.x,
                            y: V.y,
                            right: V.right,
                            bottom: V.bottom
                        }
                          , $ = H.center;
                        if (($.y < J.y || $.y > J.bottom) && ($.x < J.x || $.x > J.right))
                            return this.separateCircle(D, I, U)
                    }
                    var _ = !1
                      , nt = !1;
                    U ? (_ = R(D, I, U, this.OVERLAP_BIAS),
                    nt = O(D, I, U, this.OVERLAP_BIAS)) : this.forceX || Math.abs(this.gravity.y + D.gravity.y) < Math.abs(this.gravity.x + D.gravity.x) ? (_ = R(D, I, U, this.OVERLAP_BIAS),
                    this.intersects(D, I) && (nt = O(D, I, U, this.OVERLAP_BIAS))) : (nt = O(D, I, U, this.OVERLAP_BIAS),
                    this.intersects(D, I) && (_ = R(D, I, U, this.OVERLAP_BIAS)));
                    var K = _ || nt;
                    return K && (U ? (D.onOverlap || I.onOverlap) && this.emit(i.OVERLAP, D.gameObject, I.gameObject, D, I) : (D.onCollide || I.onCollide) && this.emit(i.COLLIDE, D.gameObject, I.gameObject, D, I)),
                    K
                },
                separateCircle: function(D, I, G, w) {
                    v(D, I, !1, w),
                    p(D, I, !1, w);
                    var U = 0;
                    if (D.isCircle !== I.isCircle) {
                        var X = {
                            x: I.isCircle ? D.position.x : I.position.x,
                            y: I.isCircle ? D.position.y : I.position.y,
                            right: I.isCircle ? D.right : I.right,
                            bottom: I.isCircle ? D.bottom : I.bottom
                        }
                          , V = {
                            x: D.isCircle ? D.center.x : I.center.x,
                            y: D.isCircle ? D.center.y : I.center.y,
                            radius: D.isCircle ? D.halfWidth : I.halfWidth
                        };
                        V.y < X.y ? V.x < X.x ? U = s(V.x, V.y, X.x, X.y) - V.radius : V.x > X.right && (U = s(V.x, V.y, X.right, X.y) - V.radius) : V.y > X.bottom && (V.x < X.x ? U = s(V.x, V.y, X.x, X.bottom) - V.radius : V.x > X.right && (U = s(V.x, V.y, X.right, X.bottom) - V.radius)),
                        U *= -1
                    } else
                        U = D.halfWidth + I.halfWidth - s(D.center.x, D.center.y, I.center.x, I.center.y);
                    if (D.overlapR = U,
                    I.overlapR = U,
                    G || U === 0 || D.immovable && I.immovable || D.customSeparateX || I.customSeparateX)
                        return U !== 0 && (D.onOverlap || I.onOverlap) && this.emit(i.OVERLAP, D.gameObject, I.gameObject, D, I),
                        U !== 0;
                    var H = D.center.x - I.center.x
                      , J = D.center.y - I.center.y
                      , $ = Math.sqrt(Math.pow(H, 2) + Math.pow(J, 2))
                      , _ = (I.center.x - D.center.x) / $ || 0
                      , nt = (I.center.y - D.center.y) / $ || 0
                      , K = 2 * (D.velocity.x * _ + D.velocity.y * nt - I.velocity.x * _ - I.velocity.y * nt) / (D.mass + I.mass);
                    (D.immovable || I.immovable) && (K *= 2),
                    D.immovable || (D.velocity.x = D.velocity.x - K / D.mass * _,
                    D.velocity.y = D.velocity.y - K / D.mass * nt),
                    I.immovable || (I.velocity.x = I.velocity.x + K / I.mass * _,
                    I.velocity.y = I.velocity.y + K / I.mass * nt),
                    !D.immovable && !I.immovable && (U /= 2);
                    var Z = e(D.center, I.center)
                      , j = (U + x.EPSILON) * Math.cos(Z)
                      , Q = (U + x.EPSILON) * Math.sin(Z);
                    return D.immovable || (D.x -= j,
                    D.y -= Q,
                    D.updateCenter()),
                    I.immovable || (I.x += j,
                    I.y += Q,
                    I.updateCenter()),
                    D.velocity.x *= D.bounce.x,
                    D.velocity.y *= D.bounce.y,
                    I.velocity.x *= I.bounce.x,
                    I.velocity.y *= I.bounce.y,
                    (D.onCollide || I.onCollide) && this.emit(i.COLLIDE, D.gameObject, I.gameObject, D, I),
                    !0
                },
                intersects: function(D, I) {
                    return D === I ? !1 : !D.isCircle && !I.isCircle ? !(D.right <= I.position.x || D.bottom <= I.position.y || D.position.x >= I.right || D.position.y >= I.bottom) : D.isCircle ? I.isCircle ? s(D.center.x, D.center.y, I.center.x, I.center.y) <= D.halfWidth + I.halfWidth : this.circleBodyIntersects(D, I) : this.circleBodyIntersects(I, D)
                },
                circleBodyIntersects: function(D, I) {
                    var G = r(D.center.x, I.left, I.right)
                      , w = r(D.center.y, I.top, I.bottom)
                      , U = (D.center.x - G) * (D.center.x - G)
                      , X = (D.center.y - w) * (D.center.y - w);
                    return U + X <= D.halfWidth * D.halfWidth
                },
                overlap: function(D, I, G, w, U) {
                    return G === void 0 && (G = null),
                    w === void 0 && (w = null),
                    U === void 0 && (U = G),
                    this.collideObjects(D, I, G, w, U, !0)
                },
                collide: function(D, I, G, w, U) {
                    return G === void 0 && (G = null),
                    w === void 0 && (w = null),
                    U === void 0 && (U = G),
                    this.collideObjects(D, I, G, w, U, !1)
                },
                collideObjects: function(D, I, G, w, U, X) {
                    var V, H;
                    D.isParent && D.physicsType === void 0 && (D = D.children.entries),
                    I && I.isParent && I.physicsType === void 0 && (I = I.children.entries);
                    var J = Array.isArray(D)
                      , $ = Array.isArray(I);
                    if (this._total = 0,
                    !J && !$)
                        this.collideHandler(D, I, G, w, U, X);
                    else if (!J && $)
                        for (V = 0; V < I.length; V++)
                            this.collideHandler(D, I[V], G, w, U, X);
                    else if (J && !$)
                        if (I)
                            for (V = 0; V < D.length; V++)
                                this.collideHandler(D[V], I, G, w, U, X);
                        else
                            for (V = 0; V < D.length; V++) {
                                var _ = D[V];
                                for (H = V + 1; H < D.length; H++)
                                    V !== H && this.collideHandler(_, D[H], G, w, U, X)
                            }
                    else
                        for (V = 0; V < D.length; V++)
                            for (H = 0; H < I.length; H++)
                                this.collideHandler(D[V], I[H], G, w, U, X);
                    return this._total > 0
                },
                collideHandler: function(D, I, G, w, U, X) {
                    if (I === void 0 && D.isParent)
                        return this.collideGroupVsGroup(D, D, G, w, U, X);
                    if (!D || !I)
                        return !1;
                    if (D.body) {
                        if (I.body)
                            return this.collideSpriteVsSprite(D, I, G, w, U, X);
                        if (I.isParent)
                            return this.collideSpriteVsGroup(D, I, G, w, U, X);
                        if (I.isTilemap)
                            return this.collideSpriteVsTilemapLayer(D, I, G, w, U, X)
                    } else if (D.isParent) {
                        if (I.body)
                            return this.collideSpriteVsGroup(I, D, G, w, U, X);
                        if (I.isParent)
                            return this.collideGroupVsGroup(D, I, G, w, U, X);
                        if (I.isTilemap)
                            return this.collideGroupVsTilemapLayer(D, I, G, w, U, X)
                    } else if (D.isTilemap) {
                        if (I.body)
                            return this.collideSpriteVsTilemapLayer(I, D, G, w, U, X);
                        if (I.isParent)
                            return this.collideGroupVsTilemapLayer(I, D, G, w, U, X)
                    }
                },
                collideSpriteVsSprite: function(D, I, G, w, U, X) {
                    return !D.body || !I.body ? !1 : (this.separate(D.body, I.body, w, U, X) && (G && G.call(U, D, I),
                    this._total++),
                    !0)
                },
                collideSpriteVsGroup: function(D, I, G, w, U, X) {
                    var V = D.body;
                    if (!(I.length === 0 || !V || !V.enable || V.checkCollision.none)) {
                        var H, J, $;
                        if (this.useTree || I.physicsType === n.STATIC_BODY) {
                            var _ = this.treeMinMax;
                            _.minX = V.left,
                            _.minY = V.top,
                            _.maxX = V.right,
                            _.maxY = V.bottom;
                            var nt = I.physicsType === n.DYNAMIC_BODY ? this.tree.search(_) : this.staticTree.search(_);
                            for (J = nt.length,
                            H = 0; H < J; H++)
                                $ = nt[H],
                                !(V === $ || !$.enable || $.checkCollision.none || !I.contains($.gameObject)) && this.separate(V, $, w, U, X, !0) && (G && G.call(U, V.gameObject, $.gameObject),
                                this._total++)
                        } else {
                            var K = I.getChildren()
                              , Z = I.children.entries.indexOf(D);
                            for (J = K.length,
                            H = 0; H < J; H++)
                                $ = K[H].body,
                                !(!$ || H === Z || !$.enable) && this.separate(V, $, w, U, X) && (G && G.call(U, V.gameObject, $.gameObject),
                                this._total++)
                        }
                    }
                },
                collideGroupVsTilemapLayer: function(D, I, G, w, U, X) {
                    var V = D.getChildren();
                    if (V.length === 0)
                        return !1;
                    for (var H = !1, J = 0; J < V.length; J++)
                        V[J].body && this.collideSpriteVsTilemapLayer(V[J], I, G, w, U, X) && (H = !0);
                    return H
                },
                collideTiles: function(D, I, G, w, U) {
                    return !D.body.enable || I.length === 0 ? !1 : this.collideSpriteVsTilesHandler(D, I, G, w, U, !1, !1)
                },
                overlapTiles: function(D, I, G, w, U) {
                    return !D.body.enable || I.length === 0 ? !1 : this.collideSpriteVsTilesHandler(D, I, G, w, U, !0, !1)
                },
                collideSpriteVsTilemapLayer: function(D, I, G, w, U, X) {
                    var V = D.body;
                    if (!V.enable || V.checkCollision.none)
                        return !1;
                    var H = V.position.x
                      , J = V.position.y
                      , $ = V.width
                      , _ = V.height
                      , nt = I.layer;
                    if (nt.tileWidth > nt.baseTileWidth) {
                        var K = (nt.tileWidth - nt.baseTileWidth) * I.scaleX;
                        H -= K,
                        $ += K
                    }
                    if (nt.tileHeight > nt.baseTileHeight) {
                        var Z = (nt.tileHeight - nt.baseTileHeight) * I.scaleY;
                        _ += Z
                    }
                    var j = g(H, J, $, _, null, I.scene.cameras.main, I.layer);
                    return j.length === 0 ? !1 : this.collideSpriteVsTilesHandler(D, j, G, w, U, X, !0)
                },
                collideSpriteVsTilesHandler: function(D, I, G, w, U, X, V) {
                    for (var H = D.body, J, $ = {
                        left: 0,
                        right: 0,
                        top: 0,
                        bottom: 0
                    }, _, nt = !1, K = 0; K < I.length; K++) {
                        J = I[K],
                        _ = J.tilemapLayer;
                        var Z = _.tileToWorldXY(J.x, J.y);
                        $.left = Z.x,
                        $.top = Z.y,
                        J.baseHeight !== J.height && ($.top -= (J.height - J.baseHeight) * _.scaleY),
                        $.right = $.left + J.width * _.scaleX,
                        $.bottom = $.top + J.height * _.scaleY,
                        N($, H) && (!w || w.call(U, D, J)) && E(J, D) && (X || L(K, H, J, $, _, this.TILE_BIAS, V)) && (this._total++,
                        nt = !0,
                        G && G.call(U, D, J),
                        X && H.onOverlap ? this.emit(i.TILE_OVERLAP, D, J, H) : H.onCollide && this.emit(i.TILE_COLLIDE, D, J, H))
                    }
                    return nt
                },
                collideGroupVsGroup: function(D, I, G, w, U, X) {
                    if (!(D.length === 0 || I.length === 0))
                        for (var V = D.getChildren(), H = 0; H < V.length; H++)
                            this.collideSpriteVsGroup(V[H], I, G, w, U, X)
                },
                wrap: function(D, I) {
                    D.body ? this.wrapObject(D, I) : D.getChildren ? this.wrapArray(D.getChildren(), I) : Array.isArray(D) ? this.wrapArray(D, I) : this.wrapObject(D, I)
                },
                wrapArray: function(D, I) {
                    for (var G = 0; G < D.length; G++)
                        this.wrapObject(D[G], I)
                },
                wrapObject: function(D, I) {
                    I === void 0 && (I = 0),
                    D.x = W(D.x, this.bounds.left - I, this.bounds.right + I),
                    D.y = W(D.y, this.bounds.top - I, this.bounds.bottom + I)
                },
                shutdown: function() {
                    this.tree.clear(),
                    this.staticTree.clear(),
                    this.bodies.clear(),
                    this.staticBodies.clear(),
                    this.colliders.destroy(),
                    this.removeAllListeners()
                },
                destroy: function() {
                    this.shutdown(),
                    this.scene = null
                }
            });
            c.exports = b
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Benjamin D. Richards <benjamindrichards@gmail.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(62)
              , r = t(245)
              , o = t(196)
              , a = t(10)
              , n = t(57)
              , s = t(3)
              , l = new e({
                initialize: function(h, u) {
                    var d = u.displayWidth ? u.displayWidth : 64
                      , v = u.displayHeight ? u.displayHeight : 64;
                    this.world = h,
                    this.gameObject = u,
                    this.transform = {
                        x: u.x,
                        y: u.y,
                        rotation: u.angle,
                        scaleX: u.scaleX,
                        scaleY: u.scaleY,
                        displayOriginX: u.displayOriginX,
                        displayOriginY: u.displayOriginY
                    },
                    this.debugShowBody = h.defaults.debugShowBody,
                    this.debugShowVelocity = h.defaults.debugShowVelocity,
                    this.debugBodyColor = h.defaults.bodyDebugColor,
                    this.enable = !0,
                    this.isCircle = !1,
                    this.radius = 0,
                    this.offset = new s,
                    this.position = new s(u.x - u.scaleX * u.displayOriginX,u.y - u.scaleY * u.displayOriginY),
                    this.prev = this.position.clone(),
                    this.prevFrame = this.position.clone(),
                    this.allowRotation = !0,
                    this.rotation = u.angle,
                    this.preRotation = u.angle,
                    this.width = d,
                    this.height = v,
                    this.sourceWidth = d,
                    this.sourceHeight = v,
                    u.frame && (this.sourceWidth = u.frame.realWidth,
                    this.sourceHeight = u.frame.realHeight),
                    this.halfWidth = Math.abs(d / 2),
                    this.halfHeight = Math.abs(v / 2),
                    this.center = new s(this.position.x + this.halfWidth,this.position.y + this.halfHeight),
                    this.velocity = new s,
                    this.newVelocity = new s,
                    this.deltaMax = new s,
                    this.acceleration = new s,
                    this.allowDrag = !0,
                    this.drag = new s,
                    this.allowGravity = !0,
                    this.gravity = new s,
                    this.bounce = new s,
                    this.worldBounce = null,
                    this.customBoundsRectangle = h.bounds,
                    this.onWorldBounds = !1,
                    this.onCollide = !1,
                    this.onOverlap = !1,
                    this.maxVelocity = new s(1e4,1e4),
                    this.maxSpeed = -1,
                    this.friction = new s(1,0),
                    this.useDamping = !1,
                    this.angularVelocity = 0,
                    this.angularAcceleration = 0,
                    this.angularDrag = 0,
                    this.maxAngular = 1e3,
                    this.mass = 1,
                    this.angle = 0,
                    this.speed = 0,
                    this.facing = f.FACING_NONE,
                    this.immovable = !1,
                    this.pushable = !0,
                    this.moves = !0,
                    this.customSeparateX = !1,
                    this.customSeparateY = !1,
                    this.overlapX = 0,
                    this.overlapY = 0,
                    this.overlapR = 0,
                    this.embedded = !1,
                    this.collideWorldBounds = !1,
                    this.checkCollision = {
                        none: !1,
                        up: !0,
                        down: !0,
                        left: !0,
                        right: !0
                    },
                    this.touching = {
                        none: !0,
                        up: !1,
                        down: !1,
                        left: !1,
                        right: !1
                    },
                    this.wasTouching = {
                        none: !0,
                        up: !1,
                        down: !1,
                        left: !1,
                        right: !1
                    },
                    this.blocked = {
                        none: !0,
                        up: !1,
                        down: !1,
                        left: !1,
                        right: !1
                    },
                    this.syncBounds = !1,
                    this.physicsType = f.DYNAMIC_BODY,
                    this._sx = u.scaleX,
                    this._sy = u.scaleY,
                    this._dx = 0,
                    this._dy = 0,
                    this._tx = 0,
                    this._ty = 0,
                    this._bounds = new a
                },
                updateBounds: function() {
                    var i = this.gameObject
                      , h = this.transform;
                    if (i.parentContainer) {
                        var u = i.getWorldTransformMatrix(this.world._tempMatrix, this.world._tempMatrix2);
                        h.x = u.tx,
                        h.y = u.ty,
                        h.rotation = o(u.rotation),
                        h.scaleX = u.scaleX,
                        h.scaleY = u.scaleY,
                        h.displayOriginX = i.displayOriginX,
                        h.displayOriginY = i.displayOriginY
                    } else
                        h.x = i.x,
                        h.y = i.y,
                        h.rotation = i.angle,
                        h.scaleX = i.scaleX,
                        h.scaleY = i.scaleY,
                        h.displayOriginX = i.displayOriginX,
                        h.displayOriginY = i.displayOriginY;
                    var d = !1;
                    if (this.syncBounds) {
                        var v = i.getBounds(this._bounds);
                        this.width = v.width,
                        this.height = v.height,
                        d = !0
                    } else {
                        var p = Math.abs(h.scaleX)
                          , g = Math.abs(h.scaleY);
                        (this._sx !== p || this._sy !== g) && (this.width = this.sourceWidth * p,
                        this.height = this.sourceHeight * g,
                        this._sx = p,
                        this._sy = g,
                        d = !0)
                    }
                    d && (this.halfWidth = Math.floor(this.width / 2),
                    this.halfHeight = Math.floor(this.height / 2),
                    this.updateCenter())
                },
                updateCenter: function() {
                    this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight)
                },
                updateFromGameObject: function() {
                    this.updateBounds();
                    var i = this.transform;
                    this.position.x = i.x + i.scaleX * (this.offset.x - i.displayOriginX),
                    this.position.y = i.y + i.scaleY * (this.offset.y - i.displayOriginY),
                    this.updateCenter()
                },
                resetFlags: function(i) {
                    i === void 0 && (i = !1);
                    var h = this.wasTouching
                      , u = this.touching
                      , d = this.blocked;
                    i ? (h.none = !0,
                    h.up = !1,
                    h.down = !1,
                    h.left = !1,
                    h.right = !1) : (h.none = u.none,
                    h.up = u.up,
                    h.down = u.down,
                    h.left = u.left,
                    h.right = u.right),
                    u.none = !0,
                    u.up = !1,
                    u.down = !1,
                    u.left = !1,
                    u.right = !1,
                    d.none = !0,
                    d.up = !1,
                    d.down = !1,
                    d.left = !1,
                    d.right = !1,
                    this.overlapR = 0,
                    this.overlapX = 0,
                    this.overlapY = 0,
                    this.embedded = !1
                },
                preUpdate: function(i, h) {
                    i && this.resetFlags(),
                    this.updateFromGameObject(),
                    this.rotation = this.transform.rotation,
                    this.preRotation = this.rotation,
                    this.moves && (this.prev.x = this.position.x,
                    this.prev.y = this.position.y,
                    this.prevFrame.x = this.position.x,
                    this.prevFrame.y = this.position.y),
                    i && this.update(h)
                },
                update: function(i) {
                    if (this.prev.x = this.position.x,
                    this.prev.y = this.position.y,
                    this.moves) {
                        this.world.updateMotion(this, i);
                        var h = this.velocity.x
                          , u = this.velocity.y;
                        this.newVelocity.set(h * i, u * i),
                        this.position.add(this.newVelocity),
                        this.updateCenter(),
                        this.angle = Math.atan2(u, h),
                        this.speed = Math.sqrt(h * h + u * u),
                        this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds && this.world.emit(r.WORLD_BOUNDS, this, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right)
                    }
                    this._dx = this.position.x - this.prev.x,
                    this._dy = this.position.y - this.prev.y
                },
                postUpdate: function() {
                    var i = this.position.x - this.prevFrame.x
                      , h = this.position.y - this.prevFrame.y;
                    if (this.moves) {
                        var u = this.deltaMax.x
                          , d = this.deltaMax.y;
                        u !== 0 && i !== 0 && (i < 0 && i < -u ? i = -u : i > 0 && i > u && (i = u)),
                        d !== 0 && h !== 0 && (h < 0 && h < -d ? h = -d : h > 0 && h > d && (h = d)),
                        this.gameObject.x += i,
                        this.gameObject.y += h
                    }
                    i < 0 ? this.facing = f.FACING_LEFT : i > 0 && (this.facing = f.FACING_RIGHT),
                    h < 0 ? this.facing = f.FACING_UP : h > 0 && (this.facing = f.FACING_DOWN),
                    this.allowRotation && (this.gameObject.angle += this.deltaZ()),
                    this._tx = i,
                    this._ty = h
                },
                setBoundsRectangle: function(i) {
                    return this.customBoundsRectangle = i || this.world.bounds,
                    this
                },
                checkWorldBounds: function() {
                    var i = this.position
                      , h = this.customBoundsRectangle
                      , u = this.world.checkCollision
                      , d = this.worldBounce ? -this.worldBounce.x : -this.bounce.x
                      , v = this.worldBounce ? -this.worldBounce.y : -this.bounce.y
                      , p = !1;
                    return i.x < h.x && u.left ? (i.x = h.x,
                    this.velocity.x *= d,
                    this.blocked.left = !0,
                    p = !0) : this.right > h.right && u.right && (i.x = h.right - this.width,
                    this.velocity.x *= d,
                    this.blocked.right = !0,
                    p = !0),
                    i.y < h.y && u.up ? (i.y = h.y,
                    this.velocity.y *= v,
                    this.blocked.up = !0,
                    p = !0) : this.bottom > h.bottom && u.down && (i.y = h.bottom - this.height,
                    this.velocity.y *= v,
                    this.blocked.down = !0,
                    p = !0),
                    p && (this.blocked.none = !1,
                    this.updateCenter()),
                    p
                },
                setOffset: function(i, h) {
                    return h === void 0 && (h = i),
                    this.offset.set(i, h),
                    this
                },
                setSize: function(i, h, u) {
                    u === void 0 && (u = !0);
                    var d = this.gameObject;
                    if (!i && d.frame && (i = d.frame.realWidth),
                    !h && d.frame && (h = d.frame.realHeight),
                    this.sourceWidth = i,
                    this.sourceHeight = h,
                    this.width = this.sourceWidth * this._sx,
                    this.height = this.sourceHeight * this._sy,
                    this.halfWidth = Math.floor(this.width / 2),
                    this.halfHeight = Math.floor(this.height / 2),
                    this.updateCenter(),
                    u && d.getCenter) {
                        var v = (d.width - i) / 2
                          , p = (d.height - h) / 2;
                        this.offset.set(v, p)
                    }
                    return this.isCircle = !1,
                    this.radius = 0,
                    this
                },
                setCircle: function(i, h, u) {
                    return h === void 0 && (h = this.offset.x),
                    u === void 0 && (u = this.offset.y),
                    i > 0 ? (this.isCircle = !0,
                    this.radius = i,
                    this.sourceWidth = i * 2,
                    this.sourceHeight = i * 2,
                    this.width = this.sourceWidth * this._sx,
                    this.height = this.sourceHeight * this._sy,
                    this.halfWidth = Math.floor(this.width / 2),
                    this.halfHeight = Math.floor(this.height / 2),
                    this.offset.set(h, u),
                    this.updateCenter()) : this.isCircle = !1,
                    this
                },
                reset: function(i, h) {
                    this.stop();
                    var u = this.gameObject;
                    u.setPosition(i, h),
                    u.getTopLeft ? u.getTopLeft(this.position) : this.position.set(i, h),
                    this.prev.copy(this.position),
                    this.prevFrame.copy(this.position),
                    this.rotation = u.angle,
                    this.preRotation = u.angle,
                    this.updateBounds(),
                    this.updateCenter(),
                    this.resetFlags(!0)
                },
                stop: function() {
                    return this.velocity.set(0),
                    this.acceleration.set(0),
                    this.speed = 0,
                    this.angularVelocity = 0,
                    this.angularAcceleration = 0,
                    this
                },
                getBounds: function(i) {
                    return i.x = this.x,
                    i.y = this.y,
                    i.right = this.right,
                    i.bottom = this.bottom,
                    i
                },
                hitTest: function(i, h) {
                    if (!this.isCircle)
                        return n(this, i, h);
                    if (this.radius > 0 && i >= this.left && i <= this.right && h >= this.top && h <= this.bottom) {
                        var u = (this.center.x - i) * (this.center.x - i)
                          , d = (this.center.y - h) * (this.center.y - h);
                        return u + d <= this.radius * this.radius
                    }
                    return !1
                },
                onFloor: function() {
                    return this.blocked.down
                },
                onCeiling: function() {
                    return this.blocked.up
                },
                onWall: function() {
                    return this.blocked.left || this.blocked.right
                },
                deltaAbsX: function() {
                    return this._dx > 0 ? this._dx : -this._dx
                },
                deltaAbsY: function() {
                    return this._dy > 0 ? this._dy : -this._dy
                },
                deltaX: function() {
                    return this._dx
                },
                deltaY: function() {
                    return this._dy
                },
                deltaXFinal: function() {
                    return this._tx
                },
                deltaYFinal: function() {
                    return this._ty
                },
                deltaZ: function() {
                    return this.rotation - this.preRotation
                },
                destroy: function() {
                    this.enable = !1,
                    this.world && this.world.pendingDestroy.set(this)
                },
                drawDebug: function(i) {
                    var h = this.position
                      , u = h.x + this.halfWidth
                      , d = h.y + this.halfHeight;
                    this.debugShowBody && (i.lineStyle(i.defaultStrokeWidth, this.debugBodyColor),
                    this.isCircle ? i.strokeCircle(u, d, this.width / 2) : (this.checkCollision.up && i.lineBetween(h.x, h.y, h.x + this.width, h.y),
                    this.checkCollision.right && i.lineBetween(h.x + this.width, h.y, h.x + this.width, h.y + this.height),
                    this.checkCollision.down && i.lineBetween(h.x, h.y + this.height, h.x + this.width, h.y + this.height),
                    this.checkCollision.left && i.lineBetween(h.x, h.y, h.x, h.y + this.height))),
                    this.debugShowVelocity && (i.lineStyle(i.defaultStrokeWidth, this.world.defaults.velocityDebugColor, 1),
                    i.lineBetween(u, d, u + this.velocity.x / 2, d + this.velocity.y / 2))
                },
                willDrawDebug: function() {
                    return this.debugShowBody || this.debugShowVelocity
                },
                setCollideWorldBounds: function(i, h, u, d) {
                    i === void 0 && (i = !0),
                    this.collideWorldBounds = i;
                    var v = h !== void 0
                      , p = u !== void 0;
                    return (v || p) && (this.worldBounce || (this.worldBounce = new s),
                    v && (this.worldBounce.x = h),
                    p && (this.worldBounce.y = u)),
                    d !== void 0 && (this.onWorldBounds = d),
                    this
                },
                setVelocity: function(i, h) {
                    return this.velocity.set(i, h),
                    i = this.velocity.x,
                    h = this.velocity.y,
                    this.speed = Math.sqrt(i * i + h * h),
                    this
                },
                setVelocityX: function(i) {
                    this.velocity.x = i;
                    var h = i
                      , u = this.velocity.y;
                    return this.speed = Math.sqrt(h * h + u * u),
                    this
                },
                setVelocityY: function(i) {
                    this.velocity.y = i;
                    var h = this.velocity.x
                      , u = i;
                    return this.speed = Math.sqrt(h * h + u * u),
                    this
                },
                setMaxVelocity: function(i, h) {
                    return this.maxVelocity.set(i, h),
                    this
                },
                setMaxVelocityX: function(i) {
                    return this.maxVelocity.x = i,
                    this
                },
                setMaxVelocityY: function(i) {
                    return this.maxVelocity.y = i,
                    this
                },
                setMaxSpeed: function(i) {
                    return this.maxSpeed = i,
                    this
                },
                setBounce: function(i, h) {
                    return this.bounce.set(i, h),
                    this
                },
                setBounceX: function(i) {
                    return this.bounce.x = i,
                    this
                },
                setBounceY: function(i) {
                    return this.bounce.y = i,
                    this
                },
                setAcceleration: function(i, h) {
                    return this.acceleration.set(i, h),
                    this
                },
                setAccelerationX: function(i) {
                    return this.acceleration.x = i,
                    this
                },
                setAccelerationY: function(i) {
                    return this.acceleration.y = i,
                    this
                },
                setAllowDrag: function(i) {
                    return i === void 0 && (i = !0),
                    this.allowDrag = i,
                    this
                },
                setAllowGravity: function(i) {
                    return i === void 0 && (i = !0),
                    this.allowGravity = i,
                    this
                },
                setAllowRotation: function(i) {
                    return i === void 0 && (i = !0),
                    this.allowRotation = i,
                    this
                },
                setDrag: function(i, h) {
                    return this.drag.set(i, h),
                    this
                },
                setDamping: function(i) {
                    return this.useDamping = i,
                    this
                },
                setDragX: function(i) {
                    return this.drag.x = i,
                    this
                },
                setDragY: function(i) {
                    return this.drag.y = i,
                    this
                },
                setGravity: function(i, h) {
                    return this.gravity.set(i, h),
                    this
                },
                setGravityX: function(i) {
                    return this.gravity.x = i,
                    this
                },
                setGravityY: function(i) {
                    return this.gravity.y = i,
                    this
                },
                setFriction: function(i, h) {
                    return this.friction.set(i, h),
                    this
                },
                setFrictionX: function(i) {
                    return this.friction.x = i,
                    this
                },
                setFrictionY: function(i) {
                    return this.friction.y = i,
                    this
                },
                setAngularVelocity: function(i) {
                    return this.angularVelocity = i,
                    this
                },
                setAngularAcceleration: function(i) {
                    return this.angularAcceleration = i,
                    this
                },
                setAngularDrag: function(i) {
                    return this.angularDrag = i,
                    this
                },
                setMass: function(i) {
                    return this.mass = i,
                    this
                },
                setImmovable: function(i) {
                    return i === void 0 && (i = !0),
                    this.immovable = i,
                    this
                },
                setEnable: function(i) {
                    return i === void 0 && (i = !0),
                    this.enable = i,
                    this
                },
                processX: function(i, h, u, d) {
                    this.x += i,
                    this.updateCenter(),
                    h !== null && (this.velocity.x = h);
                    var v = this.blocked;
                    u && (v.left = !0),
                    d && (v.right = !0)
                },
                processY: function(i, h, u, d) {
                    this.y += i,
                    this.updateCenter(),
                    h !== null && (this.velocity.y = h);
                    var v = this.blocked;
                    u && (v.up = !0),
                    d && (v.down = !0)
                },
                x: {
                    get: function() {
                        return this.position.x
                    },
                    set: function(i) {
                        this.position.x = i
                    }
                },
                y: {
                    get: function() {
                        return this.position.y
                    },
                    set: function(i) {
                        this.position.y = i
                    }
                },
                left: {
                    get: function() {
                        return this.position.x
                    }
                },
                right: {
                    get: function() {
                        return this.position.x + this.width
                    }
                },
                top: {
                    get: function() {
                        return this.position.y
                    }
                },
                bottom: {
                    get: function() {
                        return this.position.y + this.height
                    }
                }
            });
            c.exports = l
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = new e({
                initialize: function(o, a, n, s, l, i, h) {
                    this.world = o,
                    this.name = "",
                    this.active = !0,
                    this.overlapOnly = a,
                    this.object1 = n,
                    this.object2 = s,
                    this.collideCallback = l,
                    this.processCallback = i,
                    this.callbackContext = h
                },
                setName: function(r) {
                    return this.name = r,
                    this
                },
                update: function() {
                    this.world.collideObjects(this.object1, this.object2, this.collideCallback, this.processCallback, this.callbackContext, this.overlapOnly)
                },
                destroy: function() {
                    this.world.removeCollider(this),
                    this.active = !1,
                    this.world = null,
                    this.object1 = null,
                    this.object2 = null,
                    this.collideCallback = null,
                    this.processCallback = null,
                    this.callbackContext = null
                }
            });
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(26)
              , f = t(3)
              , r = new f
              , o = new f
              , a = function(n, s, l, i, h, u, d) {
                var v = d.tilemapLayer.tilemap._convert.WorldToTileXY;
                v(n, s, !0, r, u, d);
                var p = r.x
                  , g = r.y;
                v(n + l, s + i, !1, o, u, d);
                var m = Math.ceil(o.x)
                  , x = Math.ceil(o.y);
                return e(p, g, m - p, x - g, h, d)
            };
            c.exports = a
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return e.collisionCallback ? !e.collisionCallback.call(e.collisionCallbackContext, f, e) : e.layer.callbacks[e.index] ? !e.layer.callbacks[e.index].callback.call(e.layer.callbacks[e.index].callbackContext, f, e) : !0
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Vladimir Agafonkin
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(436);
            function f(x) {
                if (!(this instanceof f))
                    return new f(x);
                this._maxEntries = Math.max(4, x || 9),
                this._minEntries = Math.max(2, Math.ceil(this._maxEntries * .4)),
                this.clear()
            }
            f.prototype = {
                all: function() {
                    return this._all(this.data, [])
                },
                search: function(x) {
                    var T = this.data
                      , E = []
                      , P = this.toBBox;
                    if (!p(x, T))
                        return E;
                    for (var M = [], L, R, O, F; T; ) {
                        for (L = 0,
                        R = T.children.length; L < R; L++)
                            O = T.children[L],
                            F = T.leaf ? P(O) : O,
                            p(x, F) && (T.leaf ? E.push(O) : v(x, F) ? this._all(O, E) : M.push(O));
                        T = M.pop()
                    }
                    return E
                },
                collides: function(x) {
                    var T = this.data
                      , E = this.toBBox;
                    if (!p(x, T))
                        return !1;
                    for (var P = [], M, L, R, O; T; ) {
                        for (M = 0,
                        L = T.children.length; M < L; M++)
                            if (R = T.children[M],
                            O = T.leaf ? E(R) : R,
                            p(x, O)) {
                                if (T.leaf || v(x, O))
                                    return !0;
                                P.push(R)
                            }
                        T = P.pop()
                    }
                    return !1
                },
                load: function(x) {
                    if (!(x && x.length))
                        return this;
                    if (x.length < this._minEntries) {
                        for (var T = 0, E = x.length; T < E; T++)
                            this.insert(x[T]);
                        return this
                    }
                    var P = this._build(x.slice(), 0, x.length - 1, 0);
                    if (!this.data.children.length)
                        this.data = P;
                    else if (this.data.height === P.height)
                        this._splitRoot(this.data, P);
                    else {
                        if (this.data.height < P.height) {
                            var M = this.data;
                            this.data = P,
                            P = M
                        }
                        this._insert(P, this.data.height - P.height - 1, !0)
                    }
                    return this
                },
                insert: function(x) {
                    return x && this._insert(x, this.data.height - 1),
                    this
                },
                clear: function() {
                    return this.data = g([]),
                    this
                },
                remove: function(x, T) {
                    if (!x)
                        return this;
                    for (var E = this.data, P = this.toBBox(x), M = [], L = [], R, O, F, B; E || M.length; ) {
                        if (E || (E = M.pop(),
                        O = M[M.length - 1],
                        R = L.pop(),
                        B = !0),
                        E.leaf && (F = r(x, E.children, T),
                        F !== -1))
                            return E.children.splice(F, 1),
                            M.push(E),
                            this._condense(M),
                            this;
                        !B && !E.leaf && v(E, P) ? (M.push(E),
                        L.push(R),
                        R = 0,
                        O = E,
                        E = E.children[0]) : O ? (R++,
                        E = O.children[R],
                        B = !1) : E = null
                    }
                    return this
                },
                toBBox: function(x) {
                    return x
                },
                compareMinX: s,
                compareMinY: l,
                toJSON: function() {
                    return this.data
                },
                fromJSON: function(x) {
                    return this.data = x,
                    this
                },
                _all: function(x, T) {
                    for (var E = []; x; )
                        x.leaf ? T.push.apply(T, x.children) : E.push.apply(E, x.children),
                        x = E.pop();
                    return T
                },
                _build: function(x, T, E, P) {
                    var M = E - T + 1, L = this._maxEntries, R;
                    if (M <= L)
                        return R = g(x.slice(T, E + 1)),
                        o(R, this.toBBox),
                        R;
                    P || (P = Math.ceil(Math.log(M) / Math.log(L)),
                    L = Math.ceil(M / Math.pow(L, P - 1))),
                    R = g([]),
                    R.leaf = !1,
                    R.height = P;
                    var O = Math.ceil(M / L), F = O * Math.ceil(Math.sqrt(L)), B, N, Y, z;
                    for (m(x, T, E, F, this.compareMinX),
                    B = T; B <= E; B += F)
                        for (Y = Math.min(B + F - 1, E),
                        m(x, B, Y, O, this.compareMinY),
                        N = B; N <= Y; N += O)
                            z = Math.min(N + O - 1, Y),
                            R.children.push(this._build(x, N, z, P - 1));
                    return o(R, this.toBBox),
                    R
                },
                _chooseSubtree: function(x, T, E, P) {
                    for (var M, L, R, O, F, B, N, Y; P.push(T),
                    !(T.leaf || P.length - 1 === E); ) {
                        for (N = Y = 1 / 0,
                        M = 0,
                        L = T.children.length; M < L; M++)
                            R = T.children[M],
                            F = i(R),
                            B = u(x, R) - F,
                            B < Y ? (Y = B,
                            N = F < N ? F : N,
                            O = R) : B === Y && F < N && (N = F,
                            O = R);
                        T = O || T.children[0]
                    }
                    return T
                },
                _insert: function(x, T, E) {
                    var P = this.toBBox
                      , M = E ? x : P(x)
                      , L = []
                      , R = this._chooseSubtree(M, this.data, T, L);
                    for (R.children.push(x),
                    n(R, M); T >= 0 && L[T].children.length > this._maxEntries; )
                        this._split(L, T),
                        T--;
                    this._adjustParentBBoxes(M, L, T)
                },
                _split: function(x, T) {
                    var E = x[T]
                      , P = E.children.length
                      , M = this._minEntries;
                    this._chooseSplitAxis(E, M, P);
                    var L = this._chooseSplitIndex(E, M, P)
                      , R = g(E.children.splice(L, E.children.length - L));
                    R.height = E.height,
                    R.leaf = E.leaf,
                    o(E, this.toBBox),
                    o(R, this.toBBox),
                    T ? x[T - 1].children.push(R) : this._splitRoot(E, R)
                },
                _splitRoot: function(x, T) {
                    this.data = g([x, T]),
                    this.data.height = x.height + 1,
                    this.data.leaf = !1,
                    o(this.data, this.toBBox)
                },
                _chooseSplitIndex: function(x, T, E) {
                    var P, M, L, R, O, F, B, N;
                    for (F = B = 1 / 0,
                    P = T; P <= E - T; P++)
                        M = a(x, 0, P, this.toBBox),
                        L = a(x, P, E, this.toBBox),
                        R = d(M, L),
                        O = i(M) + i(L),
                        R < F ? (F = R,
                        N = P,
                        B = O < B ? O : B) : R === F && O < B && (B = O,
                        N = P);
                    return N
                },
                _chooseSplitAxis: function(x, T, E) {
                    var P = x.leaf ? this.compareMinX : s
                      , M = x.leaf ? this.compareMinY : l
                      , L = this._allDistMargin(x, T, E, P)
                      , R = this._allDistMargin(x, T, E, M);
                    L < R && x.children.sort(P)
                },
                _allDistMargin: function(x, T, E, P) {
                    x.children.sort(P);
                    var M = this.toBBox, L = a(x, 0, T, M), R = a(x, E - T, E, M), O = h(L) + h(R), F, B;
                    for (F = T; F < E - T; F++)
                        B = x.children[F],
                        n(L, x.leaf ? M(B) : B),
                        O += h(L);
                    for (F = E - T - 1; F >= T; F--)
                        B = x.children[F],
                        n(R, x.leaf ? M(B) : B),
                        O += h(R);
                    return O
                },
                _adjustParentBBoxes: function(x, T, E) {
                    for (var P = E; P >= 0; P--)
                        n(T[P], x)
                },
                _condense: function(x) {
                    for (var T = x.length - 1, E; T >= 0; T--)
                        x[T].children.length === 0 ? T > 0 ? (E = x[T - 1].children,
                        E.splice(E.indexOf(x[T]), 1)) : this.clear() : o(x[T], this.toBBox)
                },
                compareMinX: function(x, T) {
                    return x.left - T.left
                },
                compareMinY: function(x, T) {
                    return x.top - T.top
                },
                toBBox: function(x) {
                    return {
                        minX: x.left,
                        minY: x.top,
                        maxX: x.right,
                        maxY: x.bottom
                    }
                }
            };
            function r(x, T, E) {
                if (!E)
                    return T.indexOf(x);
                for (var P = 0; P < T.length; P++)
                    if (E(x, T[P]))
                        return P;
                return -1
            }
            function o(x, T) {
                a(x, 0, x.children.length, T, x)
            }
            function a(x, T, E, P, M) {
                M || (M = g(null)),
                M.minX = 1 / 0,
                M.minY = 1 / 0,
                M.maxX = -1 / 0,
                M.maxY = -1 / 0;
                for (var L = T, R; L < E; L++)
                    R = x.children[L],
                    n(M, x.leaf ? P(R) : R);
                return M
            }
            function n(x, T) {
                return x.minX = Math.min(x.minX, T.minX),
                x.minY = Math.min(x.minY, T.minY),
                x.maxX = Math.max(x.maxX, T.maxX),
                x.maxY = Math.max(x.maxY, T.maxY),
                x
            }
            function s(x, T) {
                return x.minX - T.minX
            }
            function l(x, T) {
                return x.minY - T.minY
            }
            function i(x) {
                return (x.maxX - x.minX) * (x.maxY - x.minY)
            }
            function h(x) {
                return x.maxX - x.minX + (x.maxY - x.minY)
            }
            function u(x, T) {
                return (Math.max(T.maxX, x.maxX) - Math.min(T.minX, x.minX)) * (Math.max(T.maxY, x.maxY) - Math.min(T.minY, x.minY))
            }
            function d(x, T) {
                var E = Math.max(x.minX, T.minX)
                  , P = Math.max(x.minY, T.minY)
                  , M = Math.min(x.maxX, T.maxX)
                  , L = Math.min(x.maxY, T.maxY);
                return Math.max(0, M - E) * Math.max(0, L - P)
            }
            function v(x, T) {
                return x.minX <= T.minX && x.minY <= T.minY && T.maxX <= x.maxX && T.maxY <= x.maxY
            }
            function p(x, T) {
                return T.minX <= x.maxX && T.minY <= x.maxY && T.maxX >= x.minX && T.maxY >= x.minY
            }
            function g(x) {
                return {
                    children: x,
                    height: 1,
                    leaf: !0,
                    minX: 1 / 0,
                    minY: 1 / 0,
                    maxX: -1 / 0,
                    maxY: -1 / 0
                }
            }
            function m(x, T, E, P, M) {
                for (var L = [T, E], R; L.length; )
                    E = L.pop(),
                    T = L.pop(),
                    !(E - T <= P) && (R = T + Math.ceil((E - T) / P / 2) * P,
                    e(x, R, T, E, M),
                    L.push(T, R, R, E))
            }
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(533)
              , f = t(535)
              , r = t(248)
              , o = function(a, n, s, l, i, h, u) {
                var d = l.left
                  , v = l.top
                  , p = l.right
                  , g = l.bottom
                  , m = s.faceLeft || s.faceRight
                  , x = s.faceTop || s.faceBottom;
                if (u || (m = !0,
                x = !0),
                !m && !x)
                    return !1;
                var T = 0
                  , E = 0
                  , P = 0
                  , M = 1;
                if (n.deltaAbsX() > n.deltaAbsY() ? P = -1 : n.deltaAbsX() < n.deltaAbsY() && (M = -1),
                n.deltaX() !== 0 && n.deltaY() !== 0 && m && x && (P = Math.min(Math.abs(n.position.x - p), Math.abs(n.right - d)),
                M = Math.min(Math.abs(n.position.y - g), Math.abs(n.bottom - v))),
                P < M) {
                    if (m && (T = e(n, s, d, p, h, u),
                    T !== 0 && !r(l, n)))
                        return !0;
                    x && (E = f(n, s, v, g, h, u))
                } else {
                    if (x && (E = f(n, s, v, g, h, u),
                    E !== 0 && !r(l, n)))
                        return !0;
                    m && (T = e(n, s, d, p, h, u))
                }
                return T !== 0 || E !== 0
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(534)
              , f = function(r, o, a, n, s, l) {
                var i = 0
                  , h = o.faceLeft
                  , u = o.faceRight
                  , d = o.collideLeft
                  , v = o.collideRight;
                return l || (h = !0,
                u = !0,
                d = !0,
                v = !0),
                r.deltaX() < 0 && v && r.checkCollision.left ? u && r.x < n && (i = r.x - n,
                i < -s && (i = 0)) : r.deltaX() > 0 && d && r.checkCollision.right && h && r.right > a && (i = r.right - a,
                i > s && (i = 0)),
                i !== 0 && (r.customSeparateX ? r.overlapX = i : e(r, i)),
                i
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                f < 0 ? (e.blocked.none = !1,
                e.blocked.left = !0) : f > 0 && (e.blocked.none = !1,
                e.blocked.right = !0),
                e.position.x -= f,
                e.bounce.x === 0 ? e.velocity.x = 0 : e.velocity.x = -e.velocity.x * e.bounce.x
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(536)
              , f = function(r, o, a, n, s, l) {
                var i = 0
                  , h = o.faceTop
                  , u = o.faceBottom
                  , d = o.collideUp
                  , v = o.collideDown;
                return l || (h = !0,
                u = !0,
                d = !0,
                v = !0),
                r.deltaY() < 0 && v && r.checkCollision.up ? u && r.y < n && (i = r.y - n,
                i < -s && (i = 0)) : r.deltaY() > 0 && d && r.checkCollision.down && h && r.bottom > a && (i = r.bottom - a,
                i > s && (i = 0)),
                i !== 0 && (r.customSeparateY ? r.overlapY = i : e(r, i)),
                i
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                f < 0 ? (e.blocked.none = !1,
                e.blocked.up = !0) : f > 0 && (e.blocked.none = !1,
                e.blocked.down = !0),
                e.position.y -= f,
                e.bounce.y === 0 ? e.velocity.y = 0 : e.velocity.y = -e.velocity.y * e.bounce.y
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(246)
              , f = t(1389)
              , r = function(o, a, n, s) {
                var l = e(o, a, n, s)
                  , i = o.immovable
                  , h = a.immovable;
                if (n || l === 0 || i && h || o.customSeparateX || a.customSeparateX)
                    return l !== 0 || o.embedded && a.embedded;
                var u = f.Set(o, a, l);
                return !i && !h ? u > 0 ? !0 : f.Check() : (i ? f.RunImmovableBody1(u) : h && f.RunImmovableBody2(u),
                !0)
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(247)
              , f = t(1390)
              , r = function(o, a, n, s) {
                var l = e(o, a, n, s)
                  , i = o.immovable
                  , h = a.immovable;
                if (n || l === 0 || i && h || o.customSeparateY || a.customSeparateY)
                    return l !== 0 || o.embedded && a.embedded;
                var u = f.Set(o, a, l);
                return !i && !h ? u > 0 ? !0 : f.Check() : (i ? f.RunImmovableBody1(u) : h && f.RunImmovableBody2(u),
                !0)
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(66)
              , f = t(0)
              , r = t(62)
              , o = t(57)
              , a = t(3)
              , n = new f({
                initialize: function(l, i) {
                    var h = i.displayWidth ? i.displayWidth : 64
                      , u = i.displayHeight ? i.displayHeight : 64;
                    this.world = l,
                    this.gameObject = i,
                    this.debugShowBody = l.defaults.debugShowStaticBody,
                    this.debugBodyColor = l.defaults.staticBodyDebugColor,
                    this.enable = !0,
                    this.isCircle = !1,
                    this.radius = 0,
                    this.offset = new a,
                    this.position = new a(i.x - h * i.originX,i.y - u * i.originY),
                    this.width = h,
                    this.height = u,
                    this.halfWidth = Math.abs(this.width / 2),
                    this.halfHeight = Math.abs(this.height / 2),
                    this.center = new a(this.position.x + this.halfWidth,this.position.y + this.halfHeight),
                    this.velocity = a.ZERO,
                    this.allowGravity = !1,
                    this.gravity = a.ZERO,
                    this.bounce = a.ZERO,
                    this.onWorldBounds = !1,
                    this.onCollide = !1,
                    this.onOverlap = !1,
                    this.mass = 1,
                    this.immovable = !0,
                    this.pushable = !1,
                    this.customSeparateX = !1,
                    this.customSeparateY = !1,
                    this.overlapX = 0,
                    this.overlapY = 0,
                    this.overlapR = 0,
                    this.embedded = !1,
                    this.collideWorldBounds = !1,
                    this.checkCollision = {
                        none: !1,
                        up: !0,
                        down: !0,
                        left: !0,
                        right: !0
                    },
                    this.touching = {
                        none: !0,
                        up: !1,
                        down: !1,
                        left: !1,
                        right: !1
                    },
                    this.wasTouching = {
                        none: !0,
                        up: !1,
                        down: !1,
                        left: !1,
                        right: !1
                    },
                    this.blocked = {
                        none: !0,
                        up: !1,
                        down: !1,
                        left: !1,
                        right: !1
                    },
                    this.physicsType = r.STATIC_BODY,
                    this._dx = 0,
                    this._dy = 0
                },
                setGameObject: function(s, l) {
                    return s && s !== this.gameObject && (this.gameObject.body = null,
                    s.body = this,
                    this.gameObject = s),
                    l && this.updateFromGameObject(),
                    this
                },
                updateFromGameObject: function() {
                    this.world.staticTree.remove(this);
                    var s = this.gameObject;
                    return s.getTopLeft(this.position),
                    this.width = s.displayWidth,
                    this.height = s.displayHeight,
                    this.halfWidth = Math.abs(this.width / 2),
                    this.halfHeight = Math.abs(this.height / 2),
                    this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight),
                    this.world.staticTree.insert(this),
                    this
                },
                setOffset: function(s, l) {
                    return l === void 0 && (l = s),
                    this.world.staticTree.remove(this),
                    this.position.x -= this.offset.x,
                    this.position.y -= this.offset.y,
                    this.offset.set(s, l),
                    this.position.x += this.offset.x,
                    this.position.y += this.offset.y,
                    this.updateCenter(),
                    this.world.staticTree.insert(this),
                    this
                },
                setSize: function(s, l, i) {
                    i === void 0 && (i = !0);
                    var h = this.gameObject;
                    if (!s && h.frame && (s = h.frame.realWidth),
                    !l && h.frame && (l = h.frame.realHeight),
                    this.world.staticTree.remove(this),
                    this.width = s,
                    this.height = l,
                    this.halfWidth = Math.floor(s / 2),
                    this.halfHeight = Math.floor(l / 2),
                    i && h.getCenter) {
                        var u = h.displayWidth / 2
                          , d = h.displayHeight / 2;
                        this.position.x -= this.offset.x,
                        this.position.y -= this.offset.y,
                        this.offset.set(u - this.halfWidth, d - this.halfHeight),
                        this.position.x += this.offset.x,
                        this.position.y += this.offset.y
                    }
                    return this.updateCenter(),
                    this.isCircle = !1,
                    this.radius = 0,
                    this.world.staticTree.insert(this),
                    this
                },
                setCircle: function(s, l, i) {
                    return l === void 0 && (l = this.offset.x),
                    i === void 0 && (i = this.offset.y),
                    s > 0 ? (this.world.staticTree.remove(this),
                    this.isCircle = !0,
                    this.radius = s,
                    this.width = s * 2,
                    this.height = s * 2,
                    this.halfWidth = Math.floor(this.width / 2),
                    this.halfHeight = Math.floor(this.height / 2),
                    this.offset.set(l, i),
                    this.updateCenter(),
                    this.world.staticTree.insert(this)) : this.isCircle = !1,
                    this
                },
                updateCenter: function() {
                    this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight)
                },
                reset: function(s, l) {
                    var i = this.gameObject;
                    s === void 0 && (s = i.x),
                    l === void 0 && (l = i.y),
                    this.world.staticTree.remove(this),
                    i.setPosition(s, l),
                    i.getTopLeft(this.position),
                    this.updateCenter(),
                    this.world.staticTree.insert(this)
                },
                stop: function() {
                    return this
                },
                getBounds: function(s) {
                    return s.x = this.x,
                    s.y = this.y,
                    s.right = this.right,
                    s.bottom = this.bottom,
                    s
                },
                hitTest: function(s, l) {
                    return this.isCircle ? e(this, s, l) : o(this, s, l)
                },
                postUpdate: function() {},
                deltaAbsX: function() {
                    return 0
                },
                deltaAbsY: function() {
                    return 0
                },
                deltaX: function() {
                    return 0
                },
                deltaY: function() {
                    return 0
                },
                deltaZ: function() {
                    return 0
                },
                destroy: function() {
                    this.enable = !1,
                    this.world.pendingDestroy.set(this)
                },
                drawDebug: function(s) {
                    var l = this.position
                      , i = l.x + this.halfWidth
                      , h = l.y + this.halfHeight;
                    this.debugShowBody && (s.lineStyle(s.defaultStrokeWidth, this.debugBodyColor, 1),
                    this.isCircle ? s.strokeCircle(i, h, this.width / 2) : s.strokeRect(l.x, l.y, this.width, this.height))
                },
                willDrawDebug: function() {
                    return this.debugShowBody
                },
                setMass: function(s) {
                    return s <= 0 && (s = .1),
                    this.mass = s,
                    this
                },
                x: {
                    get: function() {
                        return this.position.x
                    },
                    set: function(s) {
                        this.world.staticTree.remove(this),
                        this.position.x = s,
                        this.world.staticTree.insert(this)
                    }
                },
                y: {
                    get: function() {
                        return this.position.y
                    },
                    set: function(s) {
                        this.world.staticTree.remove(this),
                        this.position.y = s,
                        this.world.staticTree.insert(this)
                    }
                },
                left: {
                    get: function() {
                        return this.position.x
                    }
                },
                right: {
                    get: function() {
                        return this.position.x + this.width
                    }
                },
                top: {
                    get: function() {
                        return this.position.y
                    }
                },
                bottom: {
                    get: function() {
                        return this.position.y + this.height
                    }
                }
            });
            c.exports = n
        }
        , function(c, S, t) {
            /**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2020 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}
*/
            var e = t(0)
              , f = new e({
                initialize: function(o) {
                    this.pluginManager = o,
                    this.game = o.game
                },
                init: function() {},
                start: function() {},
                stop: function() {},
                destroy: function() {
                    this.pluginManager = null,
                    this.game = null,
                    this.scene = null,
                    this.systems = null
                }
            });
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(3)
              , f = new e
              , r = function(o, a, n, s) {
                var l = n.tilemapLayer
                  , i = l.cullPaddingX
                  , h = l.cullPaddingY
                  , u = l.tilemap.tileToWorldXY(o, a, f, s, l);
                return u.x > s.worldView.x + l.scaleX * n.tileWidth * (-i - .5) && u.x < s.worldView.right + l.scaleX * n.tileWidth * (i - .5) && u.y > s.worldView.y + l.scaleY * n.tileHeight * (-h - 1) && u.y < s.worldView.bottom + l.scaleY * n.tileHeight * (h - .5)
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(26)
              , f = function(r, o, a, n, s, l, i) {
                for (var h = e(a, n, s, l, null, i), u = 0; u < h.length; u++)
                    h[u] && h[u].index === r && (h[u].index = o)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(10)
              , f = t(139)
              , r = t(76)
              , o = new e
              , a = function(n, s) {
                var l = n.tilemapLayer.tilemap
                  , i = n.tilemapLayer
                  , h = Math.floor(l.tileWidth * i.scaleX)
                  , u = Math.floor(l.tileHeight * i.scaleY)
                  , d = r(s.worldView.x - i.x, h, 0, !0) - i.cullPaddingX
                  , v = f(s.worldView.right - i.x, h, 0, !0) + i.cullPaddingX
                  , p = r(s.worldView.y - i.y, u, 0, !0) - i.cullPaddingY
                  , g = f(s.worldView.bottom - i.y, u, 0, !0) + i.cullPaddingY;
                return o.setTo(d, p, v - d, g - p)
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(543)
              , f = t(159)
              , r = function(o, a, n, s) {
                n === void 0 && (n = []),
                s === void 0 && (s = 0),
                n.length = 0;
                var l = o.tilemapLayer
                  , i = e(o, a);
                return (l.skipCull || l.scrollFactorX !== 1 || l.scrollFactorY !== 1) && (i.left = 0,
                i.right = o.width,
                i.top = 0,
                i.bottom = o.height),
                f(o, i, s, n),
                n
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(546)
              , f = t(159)
              , r = function(o, a, n, s) {
                n === void 0 && (n = []),
                s === void 0 && (s = 0),
                n.length = 0;
                var l = o.tilemapLayer;
                if (!l.skipCull && l.scrollFactorX === 1 && l.scrollFactorY === 1) {
                    var i = e(o, a);
                    f(o, i, s, n)
                }
                return n
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(139)
              , f = t(76)
              , r = function(o, a) {
                var n = o.tilemapLayer.tilemap
                  , s = o.tilemapLayer
                  , l = Math.floor(n.tileWidth * s.scaleX)
                  , i = Math.floor(n.tileHeight * s.scaleY)
                  , h = o.hexSideLength
                  , u = (i - h) / 2 + h
                  , d = f(a.worldView.x - s.x, l, 0, !0) - s.cullPaddingX
                  , v = e(a.worldView.right - s.x, l, 0, !0) + s.cullPaddingX
                  , p = f(a.worldView.y - s.y, u, 0, !0) - s.cullPaddingY
                  , g = e(a.worldView.bottom - s.y, u, 0, !0) + s.cullPaddingY;
                return {
                    left: d,
                    right: v,
                    top: p,
                    bottom: g
                }
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(541)
              , f = function(r, o, a, n) {
                a === void 0 && (a = []),
                n === void 0 && (n = 0),
                a.length = 0;
                var s = r.tilemapLayer
                  , l = r.data
                  , i = r.width
                  , h = r.height
                  , u = 0
                  , d = i
                  , v = 0
                  , p = h;
                if (!s.skipCull) {
                    var g, m, x;
                    if (n === 0) {
                        for (m = v; m < p; m++)
                            for (g = u; l[m] && g < d; g++)
                                if (e(g, m, r, o)) {
                                    if (x = l[m][g],
                                    !x || x.index === -1 || !x.visible || x.alpha === 0)
                                        continue;
                                    a.push(x)
                                }
                    } else if (n === 1) {
                        for (m = v; m < p; m++)
                            for (g = d; l[m] && g >= u; g--)
                                if (e(g, m, r, o)) {
                                    if (x = l[m][g],
                                    !x || x.index === -1 || !x.visible || x.alpha === 0)
                                        continue;
                                    a.push(x)
                                }
                    } else if (n === 2) {
                        for (m = p; m >= v; m--)
                            for (g = u; l[m] && g < d; g++)
                                if (e(g, m, r, o)) {
                                    if (x = l[m][g],
                                    !x || x.index === -1 || !x.visible || x.alpha === 0)
                                        continue;
                                    a.push(x)
                                }
                    } else if (n === 3) {
                        for (m = p; m >= v; m--)
                            for (g = d; l[m] && g >= u; g--)
                                if (e(g, m, r, o)) {
                                    if (x = l[m][g],
                                    !x || x.index === -1 || !x.visible || x.alpha === 0)
                                        continue;
                                    a.push(x)
                                }
                    }
                }
                return s.tilesDrawn = a.length,
                s.tilesTotal = i * h,
                a
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(549)
              , f = t(159)
              , r = function(o, a, n, s) {
                n === void 0 && (n = []),
                s === void 0 && (s = 0),
                n.length = 0;
                var l = o.tilemapLayer;
                if (!l.skipCull && l.scrollFactorX === 1 && l.scrollFactorY === 1) {
                    var i = e(o, a);
                    f(o, i, s, n)
                }
                return n
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(139)
              , f = t(76)
              , r = function(o, a) {
                var n = o.tilemapLayer.tilemap
                  , s = o.tilemapLayer
                  , l = Math.floor(n.tileWidth * s.scaleX)
                  , i = Math.floor(n.tileHeight * s.scaleY)
                  , h = f(a.worldView.x - s.x, l, 0, !0) - s.cullPaddingX
                  , u = e(a.worldView.right - s.x, l, 0, !0) + s.cullPaddingX
                  , d = f(a.worldView.y - s.y, i / 2, 0, !0) - s.cullPaddingY
                  , v = e(a.worldView.bottom - s.y, i / 2, 0, !0) + s.cullPaddingY;
                return {
                    left: h,
                    right: u,
                    top: d,
                    bottom: v
                }
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(3)
              , f = function(r, o, a, n, s) {
                a || (a = new e);
                var l = s.baseTileWidth
                  , i = s.baseTileHeight
                  , h = s.tilemapLayer
                  , u = 0
                  , d = 0;
                h && (n || (n = h.scene.cameras.main),
                u = h.x + n.scrollX * (1 - h.scrollFactorX),
                l *= h.scaleX,
                d = h.y + n.scrollY * (1 - h.scrollFactorY),
                i *= h.scaleY);
                var v = s.hexSideLength
                  , p = (i - v) / 2 + v
                  , g = u + r * l + o % 2 * (l / 2)
                  , m = d + o * p;
                return a.set(g, m)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(3)
              , f = function(r, o, a, n, s) {
                a || (a = new e);
                var l = s.baseTileWidth
                  , i = s.baseTileHeight
                  , h = s.tilemapLayer
                  , u = 0
                  , d = 0;
                h && (n || (n = h.scene.cameras.main),
                u = h.x + n.scrollX * (1 - h.scrollFactorX),
                l *= h.scaleX,
                d = h.y + n.scrollY * (1 - h.scrollFactorY),
                i *= h.scaleY);
                var v = u + (r - o) * (l / 2)
                  , p = d + (r + o) * (i / 2);
                return a.set(v, p)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(3)
              , f = function(r, o, a, n, s) {
                a || (a = new e);
                var l = s.baseTileWidth
                  , i = s.baseTileHeight
                  , h = s.tilemapLayer
                  , u = 0
                  , d = 0;
                h && (n || (n = h.scene.cameras.main),
                u = h.x + n.scrollX * (1 - h.scrollFactorX),
                l *= h.scaleX,
                d = h.y + n.scrollY * (1 - h.scrollFactorY),
                i *= h.scaleY);
                var v = u + r * l + o % 2 * (l / 2)
                  , p = d + o * (i / 2);
                return a.set(v, p)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(253)
              , f = t(254)
              , r = t(3)
              , o = function(a, n, s, l, i) {
                return s || (s = new r(0,0)),
                s.x = e(a, l, i),
                s.y = f(n, l, i),
                s
            };
            c.exports = o
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                var o = r.baseTileHeight
                  , a = r.tilemapLayer
                  , n = 0;
                a && (f === void 0 && (f = a.scene.cameras.main),
                n = a.y + f.scrollY * (1 - a.scrollFactorY),
                o *= a.scaleY);
                var s = a.tilemap.hexSideLength
                  , l = (o - s) / 2 + s;
                return n + e * l
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                var o = r.baseTileHeight
                  , a = r.tilemapLayer
                  , n = 0;
                return a && (f === void 0 && (f = a.scene.cameras.main),
                n = a.y + f.scrollY * (1 - a.scrollFactorY),
                o *= a.scaleY),
                n + e * (o / 2)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(3)
              , f = function(r, o, a, n, s, l) {
                n || (n = new e);
                var i = l.baseTileWidth
                  , h = l.baseTileHeight
                  , u = l.tilemapLayer;
                u && (s || (s = u.scene.cameras.main),
                o = o - (u.y + s.scrollY * (1 - u.scrollFactorY)),
                h *= u.scaleY,
                r = r - (u.x + s.scrollX * (1 - u.scrollFactorX)),
                i *= u.scaleX);
                var d = l.hexSideLength
                  , v = (h - d) / 2 + d
                  , p = a ? Math.floor(o / v) : o / v
                  , g = a ? Math.floor((r - p % 2 * .5 * i) / i) : (r - p % 2 * .5 * i) / i;
                return n.set(g, p)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(3)
              , f = function(r, o, a, n, s, l) {
                n || (n = new e);
                var i = l.baseTileWidth
                  , h = l.baseTileHeight
                  , u = l.tilemapLayer;
                u && (s || (s = u.scene.cameras.main),
                o = o - (u.y + s.scrollY * (1 - u.scrollFactorY)),
                h *= u.scaleY,
                r = r - (u.x + s.scrollX * (1 - u.scrollFactorX)),
                i *= u.scaleX);
                var d = a ? Math.floor((r / (i / 2) + o / (h / 2)) / 2) : (r / (i / 2) + o / (h / 2)) / 2
                  , v = a ? Math.floor((o / (h / 2) - r / (i / 2)) / 2) : (o / (h / 2) - r / (i / 2)) / 2;
                return n.set(d, v)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(3)
              , f = function(r, o, a, n, s, l) {
                n || (n = new e);
                var i = l.baseTileWidth
                  , h = l.baseTileHeight
                  , u = l.tilemapLayer;
                u && (s || (s = u.scene.cameras.main),
                o = o - (u.y + s.scrollY * (1 - u.scrollFactorY)),
                h *= u.scaleY,
                r = r - (u.x + s.scrollX * (1 - u.scrollFactorX)),
                i *= u.scaleX);
                var d = a ? Math.floor(o / (h / 2)) : o / (h / 2)
                  , v = a ? Math.floor((r + d % 2 * .5 * i) / i) : (r + d % 2 * .5 * i) / i;
                return n.set(v, d)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(255)
              , f = t(256)
              , r = t(3)
              , o = function(a, n, s, l, i, h) {
                return s === void 0 && (s = !0),
                l || (l = new r(0,0)),
                l.x = e(a, s, i, h),
                l.y = f(n, s, i, h),
                l
            };
            c.exports = o
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                var a = o.baseTileHeight
                  , n = o.tilemapLayer;
                n && (r || (r = n.scene.cameras.main),
                e = e - (n.y + r.scrollY * (1 - n.scrollFactorY)),
                a *= n.scaleY);
                var s = o.hexSideLength
                  , l = (a - s) / 2 + s;
                return f ? Math.floor(e / l) : e / l
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                var a = o.baseTileHeight
                  , n = o.tilemapLayer;
                return n && (r || (r = n.scene.cameras.main),
                e = e - (n.y + r.scrollY * (1 - n.scrollFactorY)),
                a *= n.scaleY),
                f ? Math.floor(e / (a / 2)) : e / (a / 2)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(119)
              , f = function(r, o, a) {
                if (e(r, o, a)) {
                    var n = a.data[o][r];
                    return n !== null && n.index > -1
                } else
                    return !1
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(85)
              , f = t(119)
              , r = t(252)
              , o = function(a, n, s, l, i) {
                if (s === void 0 && (s = !0),
                l === void 0 && (l = !0),
                !f(a, n, i))
                    return null;
                var h = i.data[n][a];
                if (h)
                    i.data[n][a] = s ? null : new e(i,-1,a,n,i.tileWidth,i.tileHeight);
                else
                    return null;
                return l && h && h.collides && r(a, n, i),
                h
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(40)
              , f = t(259)
              , r = t(565)
              , o = t(566)
              , a = t(577)
              , n = function(s, l, i, h, u, d) {
                var v;
                switch (l) {
                case e.ARRAY_2D:
                    v = f(s, i, h, u, d);
                    break;
                case e.CSV:
                    v = r(s, i, h, u, d);
                    break;
                case e.TILED_JSON:
                    v = o(s, i, d);
                    break;
                case e.WELTMEISTER:
                    v = a(s, i, d);
                    break;
                default:
                    console.warn("Unrecognized tilemap data format: " + l),
                    v = null
                }
                return v
            };
            c.exports = n
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(40)
              , f = t(259)
              , r = function(o, a, n, s, l) {
                var i = a.trim().split(`
`).map(function(u) {
                    return u.split(",")
                })
                  , h = f(o, i, n, s, l);
                return h.format = e.CSV,
                h
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(567)
              , f = t(568)
              , r = t(29)
              , o = t(40)
              , a = t(258)
              , n = t(121)
              , s = t(569)
              , l = t(570)
              , i = t(573)
              , h = t(575)
              , u = function(d, v, p) {
                var g = new n({
                    width: v.width,
                    height: v.height,
                    name: d,
                    tileWidth: v.tilewidth,
                    tileHeight: v.tileheight,
                    orientation: a(v.orientation),
                    format: o.TILED_JSON,
                    version: v.version,
                    properties: v.properties,
                    renderOrder: v.renderorder,
                    infinite: v.infinite
                });
                g.orientation === r.HEXAGONAL && (g.hexSideLength = v.hexsidelength),
                g.layers = i(v, p),
                g.images = s(v);
                var m = h(v);
                return g.tilesets = m.tilesets,
                g.imageCollections = m.imageCollections,
                g.objects = l(v),
                g.tiles = f(g),
                e(g),
                g
            };
            c.exports = u
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(17)
              , f = function(r) {
                for (var o, a, n, s, l, i = 0; i < r.layers.length; i++) {
                    o = r.layers[i],
                    s = null;
                    for (var h = 0; h < o.data.length; h++) {
                        l = o.data[h];
                        for (var u = 0; u < l.length; u++)
                            a = l[u],
                            !(a === null || a.index < 0) && (n = r.tiles[a.index][2],
                            s = r.tilesets[n],
                            a.width = s.tileWidth,
                            a.height = s.tileHeight,
                            s.tileProperties && s.tileProperties[a.index - s.firstgid] && (a.properties = e(a.properties, s.tileProperties[a.index - s.firstgid])))
                    }
                }
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(122)
              , f = function(r) {
                var o, a, n = [];
                for (o = 0; o < r.imageCollections.length; o++)
                    for (var s = r.imageCollections[o], l = s.images, i = 0; i < l.length; i++) {
                        var h = l[i];
                        a = new e(h.image,h.gid,s.imageWidth,s.imageHeight,0,0),
                        a.updateTileData(s.imageWidth, s.imageHeight),
                        r.tilesets.push(a)
                    }
                for (o = 0; o < r.tilesets.length; o++) {
                    a = r.tilesets[o];
                    for (var u = a.tileMargin, d = a.tileMargin, v = 0, p = 0, g = 0, m = a.firstgid; m < a.firstgid + a.total && (n[m] = [u, d, o],
                    u += a.tileWidth + a.tileSpacing,
                    v++,
                    !(v === a.total || (p++,
                    p === a.columns && (u = a.tileMargin,
                    d += a.tileHeight + a.tileSpacing,
                    p = 0,
                    g++,
                    g === a.rows)))); m++)
                        ;
                }
                return n
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(2)
              , f = t(161)
              , r = function(o) {
                for (var a = [], n = [], s = f(o); s.i < s.layers.length || n.length > 0; ) {
                    if (s.i >= s.layers.length) {
                        if (n.length < 1) {
                            console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
                            break
                        }
                        s = n.pop();
                        continue
                    }
                    var l = s.layers[s.i];
                    if (s.i++,
                    l.type !== "imagelayer") {
                        if (l.type === "group") {
                            var i = f(o, l, s);
                            n.push(s),
                            s = i
                        }
                        continue
                    }
                    var h = e(l, "offsetx", 0) + e(l, "startx", 0)
                      , u = e(l, "offsety", 0) + e(l, "starty", 0);
                    a.push({
                        name: s.name + l.name,
                        image: l.image,
                        x: s.x + h + l.x,
                        y: s.y + u + l.y,
                        alpha: s.opacity * l.opacity,
                        visible: s.visible && l.visible,
                        properties: e(l, "properties", {})
                    })
                }
                return a
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(2)
              , f = t(260)
              , r = t(572)
              , o = t(161)
              , a = function(n) {
                for (var s = [], l = [], i = o(n); i.i < i.layers.length || l.length > 0; ) {
                    if (i.i >= i.layers.length) {
                        if (l.length < 1) {
                            console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
                            break
                        }
                        i = l.pop();
                        continue
                    }
                    var h = i.layers[i.i];
                    if (i.i++,
                    h.opacity *= i.opacity,
                    h.visible = i.visible && h.visible,
                    h.type !== "objectgroup") {
                        if (h.type === "group") {
                            var u = o(n, h, i);
                            l.push(i),
                            i = u
                        }
                        continue
                    }
                    h.name = i.name + h.name;
                    for (var d = i.x + e(h, "startx", 0) + e(h, "offsetx", 0), v = i.y + e(h, "starty", 0) + e(h, "offsety", 0), p = [], g = 0; g < h.objects.length; g++) {
                        var m = f(h.objects[g], d, v);
                        p.push(m)
                    }
                    var x = new r(h);
                    x.objects = p,
                    s.push(x)
                }
                return s
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(126)
              , f = function(r, o) {
                for (var a = {}, n = 0; n < o.length; n++) {
                    var s = o[n];
                    e(r, s) && (a[s] = r[s])
                }
                return a
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(2)
              , r = new e({
                initialize: function(a) {
                    a === void 0 && (a = {}),
                    this.name = f(a, "name", "object layer"),
                    this.opacity = f(a, "opacity", 1),
                    this.properties = f(a, "properties", {}),
                    this.propertyTypes = f(a, "propertytypes", {}),
                    this.type = f(a, "type", "objectgroup"),
                    this.visible = f(a, "visible", !0),
                    this.objects = f(a, "objects", [])
                }
            });
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(574)
              , f = t(29)
              , r = t(161)
              , o = t(258)
              , a = t(2)
              , n = t(120)
              , s = t(261)
              , l = t(85)
              , i = function(h, u) {
                for (var d = a(h, "infinite", !1), v = [], p = [], g = r(h); g.i < g.layers.length || p.length > 0; ) {
                    if (g.i >= g.layers.length) {
                        if (p.length < 1) {
                            console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
                            break
                        }
                        g = p.pop();
                        continue
                    }
                    var m = g.layers[g.i];
                    if (g.i++,
                    m.type !== "tilelayer") {
                        if (m.type === "group") {
                            var x = r(h, m, g);
                            p.push(g),
                            g = x
                        }
                        continue
                    }
                    if (m.compression) {
                        console.warn("TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer '" + m.name + "'");
                        continue
                    } else if (m.encoding && m.encoding === "base64") {
                        if (m.chunks)
                            for (var T = 0; T < m.chunks.length; T++)
                                m.chunks[T].data = e(m.chunks[T].data);
                        m.data && (m.data = e(m.data)),
                        delete m.encoding
                    }
                    var E, P, M, L, R = [], O = 0;
                    if (d) {
                        var F = a(m, "startx", 0) + m.x
                          , B = a(m, "starty", 0) + m.y;
                        E = new n({
                            name: g.name + m.name,
                            x: g.x + a(m, "offsetx", 0) + F * h.tilewidth,
                            y: g.y + a(m, "offsety", 0) + B * h.tileheight,
                            width: m.width,
                            height: m.height,
                            tileWidth: h.tilewidth,
                            tileHeight: h.tileheight,
                            alpha: g.opacity * m.opacity,
                            visible: g.visible && m.visible,
                            properties: a(m, "properties", []),
                            orientation: o(h.orientation)
                        }),
                        E.orientation === f.HEXAGONAL && (E.hexSideLength = h.hexsidelength);
                        for (var N = 0; N < m.height; N++) {
                            R.push([null]);
                            for (var Y = 0; Y < m.width; Y++)
                                R[N][Y] = null
                        }
                        for (N = 0,
                        H = m.chunks.length; N < H; N++)
                            for (var z = m.chunks[N], W = z.x - F, b = z.y - B, D = 0, I = 0, G = z.data.length; I < G; I++) {
                                var w = O + W
                                  , U = D + b;
                                P = s(z.data[I]),
                                P.gid > 0 ? (M = new l(E,P.gid,w,U,h.tilewidth,h.tileheight),
                                M.rotation = P.rotation,
                                M.flipX = P.flipped,
                                R[U][w] = M) : (L = u ? null : new l(E,-1,w,U,h.tilewidth,h.tileheight),
                                R[U][w] = L),
                                O++,
                                O === z.width && (D++,
                                O = 0)
                            }
                    } else {
                        E = new n({
                            name: g.name + m.name,
                            x: g.x + a(m, "offsetx", 0) + m.x,
                            y: g.y + a(m, "offsety", 0) + m.y,
                            width: m.width,
                            height: m.height,
                            tileWidth: h.tilewidth,
                            tileHeight: h.tileheight,
                            alpha: g.opacity * m.opacity,
                            visible: g.visible && m.visible,
                            properties: a(m, "properties", []),
                            orientation: o(h.orientation)
                        }),
                        E.orientation === f.HEXAGONAL && (E.hexSideLength = h.hexsidelength);
                        for (var X = [], V = 0, H = m.data.length; V < H; V++)
                            P = s(m.data[V]),
                            P.gid > 0 ? (M = new l(E,P.gid,O,R.length,h.tilewidth,h.tileheight),
                            M.rotation = P.rotation,
                            M.flipX = P.flipped,
                            X.push(M)) : (L = u ? null : new l(E,-1,O,R.length,h.tilewidth,h.tileheight),
                            X.push(L)),
                            O++,
                            O === m.width && (R.push(X),
                            O = 0,
                            X = [])
                    }
                    E.data = R,
                    v.push(E)
                }
                return v
            };
            c.exports = i
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                for (var f = window.atob(e), r = f.length, o = new Array(r / 4), a = 0; a < r; a += 4)
                    o[a / 4] = (f.charCodeAt(a) | f.charCodeAt(a + 1) << 8 | f.charCodeAt(a + 2) << 16 | f.charCodeAt(a + 3) << 24) >>> 0;
                return o
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(122)
              , f = t(576)
              , r = t(260)
              , o = t(1453)
              , a = function(n) {
                for (var s = [], l = [], i = null, h, u = 0; u < n.tilesets.length; u++) {
                    var d = n.tilesets[u];
                    if (d.source)
                        console.warn("External tilesets unsupported. Use Embed Tileset and re-export");
                    else if (d.image) {
                        var v = new e(d.name,d.firstgid,d.tilewidth,d.tileheight,d.margin,d.spacing);
                        if (n.version > 1) {
                            var p = void 0
                              , g = void 0;
                            if (Array.isArray(d.tiles)) {
                                p = p || {},
                                g = g || {};
                                for (var m = 0; m < d.tiles.length; m++) {
                                    var x = d.tiles[m];
                                    if (x.properties) {
                                        var T = {};
                                        x.properties.forEach(function(N) {
                                            T[N.name] = N.value
                                        }),
                                        g[x.id] = T
                                    }
                                    if (x.objectgroup && ((p[x.id] || (p[x.id] = {})).objectgroup = x.objectgroup,
                                    x.objectgroup.objects)) {
                                        var E = x.objectgroup.objects.map(function(N) {
                                            return r(N)
                                        });
                                        p[x.id].objectgroup.objects = E
                                    }
                                    x.animation && ((p[x.id] || (p[x.id] = {})).animation = x.animation),
                                    x.type && ((p[x.id] || (p[x.id] = {})).type = x.type)
                                }
                            }
                            Array.isArray(d.wangsets) && (p = p || {},
                            g = g || {},
                            o(d.wangsets, p)),
                            p && (v.tileData = p,
                            v.tileProperties = g)
                        } else if (d.tileproperties && (v.tileProperties = d.tileproperties),
                        d.tiles) {
                            v.tileData = d.tiles;
                            for (h in v.tileData) {
                                var P = v.tileData[h].objectgroup;
                                if (P && P.objects) {
                                    var M = P.objects.map(function(N) {
                                        return r(N)
                                    });
                                    v.tileData[h].objectgroup.objects = M
                                }
                            }
                        }
                        v.updateTileData(d.imagewidth, d.imageheight),
                        s.push(v)
                    } else {
                        var L = new f(d.name,d.firstgid,d.tilewidth,d.tileheight,d.margin,d.spacing,d.properties)
                          , R = 0;
                        for (m = 0; m < d.tiles.length; m++) {
                            x = d.tiles[m];
                            var O = x.image
                              , F = parseInt(x.id, 10)
                              , B = d.firstgid + F;
                            L.addImage(B, O),
                            R = Math.max(F, R)
                        }
                        L.maxId = R,
                        l.push(L)
                    }
                    i && (i.lastgid = d.firstgid - 1),
                    i = d
                }
                return {
                    tilesets: s,
                    imageCollections: l
                }
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = new e({
                initialize: function(o, a, n, s, l, i, h) {
                    (n === void 0 || n <= 0) && (n = 32),
                    (s === void 0 || s <= 0) && (s = 32),
                    l === void 0 && (l = 0),
                    i === void 0 && (i = 0),
                    this.name = o,
                    this.firstgid = a | 0,
                    this.imageWidth = n | 0,
                    this.imageHeight = s | 0,
                    this.imageMargin = l | 0,
                    this.imageSpacing = i | 0,
                    this.properties = h || {},
                    this.images = [],
                    this.total = 0
                },
                containsImageIndex: function(r) {
                    return r >= this.firstgid && r < this.firstgid + this.total
                },
                addImage: function(r, o) {
                    return this.images.push({
                        gid: r,
                        image: o
                    }),
                    this.total++,
                    this
                }
            });
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(40)
              , f = t(121)
              , r = t(578)
              , o = t(579)
              , a = function(n, s, l) {
                if (s.layer.length === 0)
                    return console.warn("No layers found in the Weltmeister map: " + n),
                    null;
                for (var i = 0, h = 0, u = 0; u < s.layer.length; u++)
                    s.layer[u].width > i && (i = s.layer[u].width),
                    s.layer[u].height > h && (h = s.layer[u].height);
                var d = new f({
                    width: i,
                    height: h,
                    name: n,
                    tileWidth: s.layer[0].tilesize,
                    tileHeight: s.layer[0].tilesize,
                    format: e.WELTMEISTER
                });
                return d.layers = r(s, l),
                d.tilesets = o(s),
                d
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(120)
              , f = t(85)
              , r = function(o, a) {
                for (var n = [], s = 0; s < o.layer.length; s++) {
                    for (var l = o.layer[s], i = new e({
                        name: l.name,
                        width: l.width,
                        height: l.height,
                        tileWidth: l.tilesize,
                        tileHeight: l.tilesize,
                        visible: l.visible === 1
                    }), h = [], u = [], d = 0; d < l.data.length; d++) {
                        for (var v = 0; v < l.data[d].length; v++) {
                            var p = l.data[d][v] - 1, g;
                            p > -1 ? g = new f(i,p,v,d,l.tilesize,l.tilesize) : g = a ? null : new f(i,-1,v,d,l.tilesize,l.tilesize),
                            h.push(g)
                        }
                        u.push(h),
                        h = []
                    }
                    i.data = u,
                    n.push(i)
                }
                return n
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(122)
              , f = function(r) {
                for (var o = [], a = [], n = 0; n < r.layer.length; n++) {
                    var s = r.layer[n]
                      , l = s.tilesetName;
                    l !== "" && a.indexOf(l) === -1 && (a.push(l),
                    o.push(new e(l,0,s.tilesize,s.tilesize,0,0)))
                }
                return o
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(36)
              , r = t(40)
              , o = t(2)
              , a = t(120)
              , n = t(29)
              , s = t(362)
              , l = t(74)
              , i = t(73)
              , h = t(85)
              , u = t(251)
              , d = t(581)
              , v = t(122)
              , p = new e({
                initialize: function(m, x) {
                    this.scene = m,
                    this.tileWidth = x.tileWidth,
                    this.tileHeight = x.tileHeight,
                    this.width = x.width,
                    this.height = x.height,
                    this.orientation = x.orientation,
                    this.renderOrder = x.renderOrder,
                    this.format = x.format,
                    this.version = x.version,
                    this.properties = x.properties,
                    this.widthInPixels = x.widthInPixels,
                    this.heightInPixels = x.heightInPixels,
                    this.imageCollections = x.imageCollections,
                    this.images = x.images,
                    this.layers = x.layers,
                    this.tilesets = x.tilesets,
                    this.objects = x.objects,
                    this.currentLayerIndex = 0,
                    this.hexSideLength = x.hexSideLength;
                    var T = this.orientation;
                    this._convert = {
                        WorldToTileXY: u.GetWorldToTileXYFunction(T),
                        WorldToTileX: u.GetWorldToTileXFunction(T),
                        WorldToTileY: u.GetWorldToTileYFunction(T),
                        TileToWorldXY: u.GetTileToWorldXYFunction(T),
                        TileToWorldX: u.GetTileToWorldXFunction(T),
                        TileToWorldY: u.GetTileToWorldYFunction(T)
                    }
                },
                createBlankDynamicLayer: function(g, m, x, T, E, P, M, L) {
                    return console.warn("createBlankDynamicLayer is deprecated. Use createBlankLayer"),
                    this.createBlankLayer(g, m, x, T, E, P, M, L)
                },
                createDynamicLayer: function(g, m, x, T) {
                    return console.warn("createDynamicLayer is deprecated. Use createLayer"),
                    this.createLayer(g, m, x, T)
                },
                createStaticLayer: function(g, m, x, T) {
                    return console.warn("createStaticLayer is deprecated. Use createLayer"),
                    this.createLayer(g, m, x, T)
                },
                setRenderOrder: function(g) {
                    var m = ["right-down", "left-down", "right-up", "left-up"];
                    return typeof g == "number" && (g = m[g]),
                    m.indexOf(g) > -1 && (this.renderOrder = g),
                    this
                },
                addTilesetImage: function(g, m, x, T, E, P, M) {
                    if (g === void 0)
                        return null;
                    if (m == null && (m = g),
                    !this.scene.sys.textures.exists(m))
                        return console.warn("Invalid Tileset Image: " + m),
                        null;
                    var L = this.scene.sys.textures.get(m)
                      , R = this.getTilesetIndex(g);
                    if (R === null && this.format === r.TILED_JSON)
                        return console.warn("No data found for Tileset: " + g),
                        null;
                    var O = this.tilesets[R];
                    return O ? (O.setTileSize(x, T),
                    O.setSpacing(E, P),
                    O.setImage(L),
                    O) : (x === void 0 && (x = this.tileWidth),
                    T === void 0 && (T = this.tileHeight),
                    E === void 0 && (E = 0),
                    P === void 0 && (P = 0),
                    M === void 0 && (M = 0),
                    O = new v(g,M,x,T,E,P),
                    O.setImage(L),
                    this.tilesets.push(O),
                    O)
                },
                copy: function(g, m, x, T, E, P, M, L) {
                    return L = this.getLayer(L),
                    L !== null ? (u.Copy(g, m, x, T, E, P, M, L),
                    this) : null
                },
                createBlankLayer: function(g, m, x, T, E, P, M, L) {
                    x === void 0 && (x = 0),
                    T === void 0 && (T = 0),
                    E === void 0 && (E = this.width),
                    P === void 0 && (P = this.height),
                    M === void 0 && (M = this.tileWidth),
                    L === void 0 && (L = this.tileHeight);
                    var R = this.getLayerIndex(g);
                    if (R !== null)
                        return console.warn("Invalid Tilemap Layer ID: " + g),
                        null;
                    for (var O = new a({
                        name: g,
                        tileWidth: M,
                        tileHeight: L,
                        width: E,
                        height: P,
                        orientation: this.orientation
                    }), F, B = 0; B < P; B++) {
                        F = [];
                        for (var N = 0; N < E; N++)
                            F.push(new h(O,-1,N,B,M,L,this.tileWidth,this.tileHeight));
                        O.data.push(F)
                    }
                    this.layers.push(O),
                    this.currentLayerIndex = this.layers.length - 1;
                    var Y = new d(this.scene,this,this.currentLayerIndex,m,x,T);
                    return Y.setRenderOrder(this.renderOrder),
                    this.scene.sys.displayList.add(Y),
                    Y
                },
                createLayer: function(g, m, x, T) {
                    var E = this.getLayerIndex(g);
                    if (E === null)
                        return console.warn("Invalid Tilemap Layer ID: " + g),
                        typeof g == "string" && console.warn(`Valid tilelayer names:
	` + this.getTileLayerNames().join(`,
	`)),
                        null;
                    var P = this.layers[E];
                    if (P.tilemapLayer)
                        return console.warn("Tilemap Layer ID already exists:" + g),
                        null;
                    this.currentLayerIndex = E,
                    x === void 0 && (x = P.x),
                    T === void 0 && (T = P.y);
                    var M = new d(this.scene,this,E,m,x,T);
                    return M.setRenderOrder(this.renderOrder),
                    this.scene.sys.displayList.add(M),
                    M
                },
                createFromObjects: function(g, m) {
                    var x = []
                      , T = this.getObjectLayer(g);
                    if (!T)
                        return console.warn("createFromObjects: Invalid objectLayerName given: " + g),
                        x;
                    Array.isArray(m) || (m = [m]);
                    for (var E = T.objects, P = 0; P < m.length; P++) {
                        for (var M = m[P], L = o(M, "id", null), R = o(M, "gid", null), O = o(M, "name", null), F, B = [], N = 0; N < E.length; N++)
                            F = E[N],
                            (L === null && R === null && O === null || L !== null && F.id === L || R !== null && F.gid === R || O !== null && F.name === O) && B.push(F);
                        for (var Y = o(M, "classType", i), z = o(M, "scene", this.scene), W = o(M, "container", null), b = o(M, "key", null), D = o(M, "frame", null), I = 0; I < B.length; I++) {
                            F = B[I];
                            var G = new Y(z);
                            G.setName(F.name),
                            G.setPosition(F.x, F.y),
                            G.setTexture(b, D),
                            F.width && (G.displayWidth = F.width),
                            F.height && (G.displayHeight = F.height);
                            var w = {
                                x: G.originX * F.width,
                                y: (G.originY - 1) * F.height
                            };
                            if (F.rotation) {
                                var U = f(F.rotation);
                                s(w, U),
                                G.rotation = U
                            }
                            if (G.x += w.x,
                            G.y += w.y,
                            (F.flippedHorizontal !== void 0 || F.flippedVertical !== void 0) && G.setFlip(F.flippedHorizontal, F.flippedVertical),
                            F.visible || (G.visible = !1),
                            Array.isArray(F.properties))
                                F.properties.forEach(function(V) {
                                    var H = V.name;
                                    G[H] !== void 0 ? G[H] = V.value : G.setData(H, V.value)
                                });
                            else
                                for (var X in F.properties)
                                    G[X] !== void 0 ? G[X] = F.properties[X] : G.setData(X, F.properties[X]);
                            W ? W.add(G) : z.add.existing(G),
                            x.push(G)
                        }
                    }
                    return x
                },
                createFromTiles: function(g, m, x, T, E, P) {
                    return P = this.getLayer(P),
                    P === null ? null : u.CreateFromTiles(g, m, x, T, E, P)
                },
                fill: function(g, m, x, T, E, P, M) {
                    return P === void 0 && (P = !0),
                    M = this.getLayer(M),
                    M === null ? null : (u.Fill(g, m, x, T, E, P, M),
                    this)
                },
                filterObjects: function(g, m, x) {
                    if (typeof g == "string") {
                        var T = g;
                        if (g = this.getObjectLayer(g),
                        !g)
                            return console.warn("No object layer found with the name: " + T),
                            null
                    }
                    return g.objects.filter(m, x)
                },
                filterTiles: function(g, m, x, T, E, P, M, L) {
                    return L = this.getLayer(L),
                    L === null ? null : u.FilterTiles(g, m, x, T, E, P, M, L)
                },
                findByIndex: function(g, m, x, T) {
                    return T = this.getLayer(T),
                    T === null ? null : u.FindByIndex(g, m, x, T)
                },
                findObject: function(g, m, x) {
                    if (typeof g == "string") {
                        var T = g;
                        if (g = this.getObjectLayer(g),
                        !g)
                            return console.warn("No object layer found with the name: " + T),
                            null
                    }
                    return g.objects.find(m, x) || null
                },
                findTile: function(g, m, x, T, E, P, M, L) {
                    return L = this.getLayer(L),
                    L === null ? null : u.FindTile(g, m, x, T, E, P, M, L)
                },
                forEachTile: function(g, m, x, T, E, P, M, L) {
                    return L = this.getLayer(L),
                    L === null ? null : (u.ForEachTile(g, m, x, T, E, P, M, L),
                    this)
                },
                getImageIndex: function(g) {
                    return this.getIndex(this.images, g)
                },
                getImageLayerNames: function() {
                    return !this.images || !Array.isArray(this.images) ? [] : this.images.map(function(g) {
                        return g.name
                    })
                },
                getIndex: function(g, m) {
                    for (var x = 0; x < g.length; x++)
                        if (g[x].name === m)
                            return x;
                    return null
                },
                getLayer: function(g) {
                    var m = this.getLayerIndex(g);
                    return m !== null ? this.layers[m] : null
                },
                getObjectLayer: function(g) {
                    var m = this.getIndex(this.objects, g);
                    return m !== null ? this.objects[m] : null
                },
                getObjectLayerNames: function() {
                    return !this.objects || !Array.isArray(this.objects) ? [] : this.objects.map(function(g) {
                        return g.name
                    })
                },
                getLayerIndex: function(g) {
                    return g === void 0 ? this.currentLayerIndex : typeof g == "string" ? this.getLayerIndexByName(g) : typeof g == "number" && g < this.layers.length ? g : g instanceof d ? g.layerIndex : null
                },
                getLayerIndexByName: function(g) {
                    return this.getIndex(this.layers, g)
                },
                getTileAt: function(g, m, x, T) {
                    return T = this.getLayer(T),
                    T === null ? null : u.GetTileAt(g, m, x, T)
                },
                getTileAtWorldXY: function(g, m, x, T, E) {
                    return E = this.getLayer(E),
                    E === null ? null : u.GetTileAtWorldXY(g, m, x, T, E)
                },
                getTileLayerNames: function() {
                    return !this.layers || !Array.isArray(this.layers) ? [] : this.layers.map(function(g) {
                        return g.name
                    })
                },
                getTilesWithin: function(g, m, x, T, E, P) {
                    return P = this.getLayer(P),
                    P === null ? null : u.GetTilesWithin(g, m, x, T, E, P)
                },
                getTilesWithinShape: function(g, m, x, T) {
                    return T = this.getLayer(T),
                    T === null ? null : u.GetTilesWithinShape(g, m, x, T)
                },
                getTilesWithinWorldXY: function(g, m, x, T, E, P, M) {
                    return M = this.getLayer(M),
                    M === null ? null : u.GetTilesWithinWorldXY(g, m, x, T, E, P, M)
                },
                getTileset: function(g) {
                    var m = this.getIndex(this.tilesets, g);
                    return m !== null ? this.tilesets[m] : null
                },
                getTilesetIndex: function(g) {
                    return this.getIndex(this.tilesets, g)
                },
                hasTileAt: function(g, m, x) {
                    return x = this.getLayer(x),
                    x === null ? null : u.HasTileAt(g, m, x)
                },
                hasTileAtWorldXY: function(g, m, x, T) {
                    return T = this.getLayer(T),
                    T === null ? null : u.HasTileAtWorldXY(g, m, x, T)
                },
                layer: {
                    get: function() {
                        return this.layers[this.currentLayerIndex]
                    },
                    set: function(g) {
                        this.setLayer(g)
                    }
                },
                putTileAt: function(g, m, x, T, E) {
                    return T === void 0 && (T = !0),
                    E = this.getLayer(E),
                    E === null ? null : u.PutTileAt(g, m, x, T, E)
                },
                putTileAtWorldXY: function(g, m, x, T, E, P) {
                    return T === void 0 && (T = !0),
                    P = this.getLayer(P),
                    P === null ? null : u.PutTileAtWorldXY(g, m, x, T, E, P)
                },
                putTilesAt: function(g, m, x, T, E) {
                    return T === void 0 && (T = !0),
                    E = this.getLayer(E),
                    E === null ? null : (u.PutTilesAt(g, m, x, T, E),
                    this)
                },
                randomize: function(g, m, x, T, E, P) {
                    return P = this.getLayer(P),
                    P === null ? null : (u.Randomize(g, m, x, T, E, P),
                    this)
                },
                calculateFacesAt: function(g, m, x) {
                    return x = this.getLayer(x),
                    x === null ? null : (u.CalculateFacesAt(g, m, x),
                    this)
                },
                calculateFacesWithin: function(g, m, x, T, E) {
                    return E = this.getLayer(E),
                    E === null ? null : (u.CalculateFacesWithin(g, m, x, T, E),
                    this)
                },
                removeLayer: function(g) {
                    var m = this.getLayerIndex(g);
                    if (m !== null) {
                        l(this.layers, m);
                        for (var x = m; x < this.layers.length; x++)
                            this.layers[x].tilemapLayer && this.layers[x].tilemapLayer.layerIndex--;
                        return this.currentLayerIndex === m && (this.currentLayerIndex = 0),
                        this
                    } else
                        return null
                },
                destroyLayer: function(g) {
                    var m = this.getLayerIndex(g);
                    return m !== null ? (g = this.layers[m],
                    g.destroy(),
                    l(this.layers, m),
                    this.currentLayerIndex === m && (this.currentLayerIndex = 0),
                    this) : null
                },
                removeAllLayers: function() {
                    for (var g = this.layers, m = 0; m < g.length; m++)
                        g[m].tilemapLayer && g[m].tilemapLayer.destroy(!1);
                    return g.length = 0,
                    this.currentLayerIndex = 0,
                    this
                },
                removeTile: function(g, m, x) {
                    m === void 0 && (m = -1),
                    x === void 0 && (x = !0);
                    var T = [];
                    Array.isArray(g) || (g = [g]);
                    for (var E = 0; E < g.length; E++) {
                        var P = g[E];
                        T.push(this.removeTileAt(P.x, P.y, !0, x, P.tilemapLayer)),
                        m > -1 && this.putTileAt(m, P.x, P.y, x, P.tilemapLayer)
                    }
                    return T
                },
                removeTileAt: function(g, m, x, T, E) {
                    return x === void 0 && (x = !0),
                    T === void 0 && (T = !0),
                    E = this.getLayer(E),
                    E === null ? null : u.RemoveTileAt(g, m, x, T, E)
                },
                removeTileAtWorldXY: function(g, m, x, T, E, P) {
                    return x === void 0 && (x = !0),
                    T === void 0 && (T = !0),
                    P = this.getLayer(P),
                    P === null ? null : u.RemoveTileAtWorldXY(g, m, x, T, E, P)
                },
                renderDebug: function(g, m, x) {
                    return x = this.getLayer(x),
                    x === null ? null : (this.orientation === n.ORTHOGONAL && u.RenderDebug(g, m, x),
                    this)
                },
                renderDebugFull: function(g, m) {
                    for (var x = this.layers, T = 0; T < x.length; T++)
                        u.RenderDebug(g, m, x[T]);
                    return this
                },
                replaceByIndex: function(g, m, x, T, E, P, M) {
                    return M = this.getLayer(M),
                    M === null ? null : (u.ReplaceByIndex(g, m, x, T, E, P, M),
                    this)
                },
                setCollision: function(g, m, x, T, E) {
                    return m === void 0 && (m = !0),
                    x === void 0 && (x = !0),
                    E === void 0 && (E = !0),
                    T = this.getLayer(T),
                    T === null ? null : (u.SetCollision(g, m, x, T, E),
                    this)
                },
                setCollisionBetween: function(g, m, x, T, E) {
                    return x === void 0 && (x = !0),
                    T === void 0 && (T = !0),
                    E = this.getLayer(E),
                    E === null ? null : (u.SetCollisionBetween(g, m, x, T, E),
                    this)
                },
                setCollisionByProperty: function(g, m, x, T) {
                    return m === void 0 && (m = !0),
                    x === void 0 && (x = !0),
                    T = this.getLayer(T),
                    T === null ? null : (u.SetCollisionByProperty(g, m, x, T),
                    this)
                },
                setCollisionByExclusion: function(g, m, x, T) {
                    return m === void 0 && (m = !0),
                    x === void 0 && (x = !0),
                    T = this.getLayer(T),
                    T === null ? null : (u.SetCollisionByExclusion(g, m, x, T),
                    this)
                },
                setCollisionFromCollisionGroup: function(g, m, x) {
                    return g === void 0 && (g = !0),
                    m === void 0 && (m = !0),
                    x = this.getLayer(x),
                    x === null ? null : (u.SetCollisionFromCollisionGroup(g, m, x),
                    this)
                },
                setTileIndexCallback: function(g, m, x, T) {
                    return T = this.getLayer(T),
                    T === null ? null : (u.SetTileIndexCallback(g, m, x, T),
                    this)
                },
                setTileLocationCallback: function(g, m, x, T, E, P, M) {
                    return M = this.getLayer(M),
                    M === null ? null : (u.SetTileLocationCallback(g, m, x, T, E, P, M),
                    this)
                },
                setLayer: function(g) {
                    var m = this.getLayerIndex(g);
                    return m !== null && (this.currentLayerIndex = m),
                    this
                },
                setBaseTileSize: function(g, m) {
                    this.tileWidth = g,
                    this.tileHeight = m,
                    this.widthInPixels = this.width * g,
                    this.heightInPixels = this.height * m;
                    for (var x = 0; x < this.layers.length; x++) {
                        this.layers[x].baseTileWidth = g,
                        this.layers[x].baseTileHeight = m;
                        for (var T = this.layers[x].data, E = this.layers[x].width, P = this.layers[x].height, M = 0; M < P; M++)
                            for (var L = 0; L < E; L++) {
                                var R = T[M][L];
                                R !== null && R.setSize(void 0, void 0, g, m)
                            }
                    }
                    return this
                },
                setLayerTileSize: function(g, m, x) {
                    if (x = this.getLayer(x),
                    x === null)
                        return this;
                    x.tileWidth = g,
                    x.tileHeight = m;
                    for (var T = x.data, E = x.width, P = x.height, M = 0; M < P; M++)
                        for (var L = 0; L < E; L++) {
                            var R = T[M][L];
                            R !== null && R.setSize(g, m)
                        }
                    return this
                },
                shuffle: function(g, m, x, T, E) {
                    return E = this.getLayer(E),
                    E === null ? null : (u.Shuffle(g, m, x, T, E),
                    this)
                },
                swapByIndex: function(g, m, x, T, E, P, M) {
                    return M = this.getLayer(M),
                    M === null ? null : (u.SwapByIndex(g, m, x, T, E, P, M),
                    this)
                },
                tileToWorldX: function(g, m, x) {
                    return x = this.getLayer(x),
                    x === null ? null : this._convert.TileToWorldX(g, m, x)
                },
                tileToWorldY: function(g, m, x) {
                    return x = this.getLayer(x),
                    x === null ? null : this._convert.TileToWorldY(g, m, x)
                },
                tileToWorldXY: function(g, m, x, T, E) {
                    return E = this.getLayer(E),
                    E === null ? null : this._convert.TileToWorldXY(g, m, x, T, E)
                },
                weightedRandomize: function(g, m, x, T, E, P) {
                    return P = this.getLayer(P),
                    P === null ? null : (u.WeightedRandomize(m, x, T, E, g, P),
                    this)
                },
                worldToTileX: function(g, m, x, T) {
                    return T = this.getLayer(T),
                    T === null ? null : this._convert.WorldToTileX(g, m, x, T)
                },
                worldToTileY: function(g, m, x, T) {
                    return T = this.getLayer(T),
                    T === null ? null : this._convert.WorldToTileY(g, m, x, T)
                },
                worldToTileXY: function(g, m, x, T, E, P) {
                    return P = this.getLayer(P),
                    P === null ? null : this._convert.WorldToTileXY(g, m, x, T, E, P)
                },
                destroy: function() {
                    this.removeAllLayers(),
                    this.tilesets.length = 0,
                    this.objects.length = 0,
                    this.scene = null
                }
            });
            c.exports = p
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(11)
              , r = t(15)
              , o = t(251)
              , a = t(1456)
              , n = new e({
                Extends: r,
                Mixins: [f.Alpha, f.BlendMode, f.ComputedSize, f.Depth, f.Flip, f.GetBounds, f.Origin, f.Pipeline, f.Transform, f.Visible, f.ScrollFactor, a],
                initialize: function(l, i, h, u, d, v) {
                    r.call(this, l, "TilemapLayer"),
                    this.isTilemap = !0,
                    this.tilemap = i,
                    this.layerIndex = h,
                    this.layer = i.layers[h],
                    this.layer.tilemapLayer = this,
                    this.tileset = [],
                    this.tilesDrawn = 0,
                    this.tilesTotal = this.layer.width * this.layer.height,
                    this.culledTiles = [],
                    this.skipCull = !1,
                    this.cullPaddingX = 1,
                    this.cullPaddingY = 1,
                    this.cullCallback = o.GetCullTilesFunction(this.layer.orientation),
                    this._renderOrder = 0,
                    this.gidMap = [],
                    this.setTilesets(u),
                    this.setAlpha(this.layer.alpha),
                    this.setPosition(d, v),
                    this.setOrigin(),
                    this.setSize(i.tileWidth * this.layer.width, i.tileHeight * this.layer.height),
                    this.initPipeline()
                },
                setTilesets: function(s) {
                    var l = []
                      , i = []
                      , h = this.tilemap;
                    Array.isArray(s) || (s = [s]);
                    for (var u = 0; u < s.length; u++) {
                        var d = s[u];
                        if (typeof d == "string" && (d = h.getTileset(d)),
                        d) {
                            i.push(d);
                            for (var v = d.firstgid, p = 0; p < d.total; p++)
                                l[v + p] = d
                        }
                    }
                    this.gidMap = l,
                    this.tileset = i
                },
                setRenderOrder: function(s) {
                    var l = ["right-down", "left-down", "right-up", "left-up"];
                    return typeof s == "string" && (s = l.indexOf(s)),
                    s >= 0 && s < 4 && (this._renderOrder = s),
                    this
                },
                calculateFacesAt: function(s, l) {
                    return o.CalculateFacesAt(s, l, this.layer),
                    this
                },
                calculateFacesWithin: function(s, l, i, h) {
                    return o.CalculateFacesWithin(s, l, i, h, this.layer),
                    this
                },
                createFromTiles: function(s, l, i, h, u) {
                    return o.CreateFromTiles(s, l, i, h, u, this.layer)
                },
                cull: function(s) {
                    return this.cullCallback(this.layer, s, this.culledTiles, this._renderOrder)
                },
                copy: function(s, l, i, h, u, d, v) {
                    return o.Copy(s, l, i, h, u, d, v, this.layer),
                    this
                },
                fill: function(s, l, i, h, u, d) {
                    return o.Fill(s, l, i, h, u, d, this.layer),
                    this
                },
                filterTiles: function(s, l, i, h, u, d, v) {
                    return o.FilterTiles(s, l, i, h, u, d, v, this.layer)
                },
                findByIndex: function(s, l, i) {
                    return o.FindByIndex(s, l, i, this.layer)
                },
                findTile: function(s, l, i, h, u, d, v) {
                    return o.FindTile(s, l, i, h, u, d, v, this.layer)
                },
                forEachTile: function(s, l, i, h, u, d, v) {
                    return o.ForEachTile(s, l, i, h, u, d, v, this.layer),
                    this
                },
                getTileAt: function(s, l, i) {
                    return o.GetTileAt(s, l, i, this.layer)
                },
                getTileAtWorldXY: function(s, l, i, h) {
                    return o.GetTileAtWorldXY(s, l, i, h, this.layer)
                },
                getTilesWithin: function(s, l, i, h, u) {
                    return o.GetTilesWithin(s, l, i, h, u, this.layer)
                },
                getTilesWithinShape: function(s, l, i) {
                    return o.GetTilesWithinShape(s, l, i, this.layer)
                },
                getTilesWithinWorldXY: function(s, l, i, h, u, d) {
                    return o.GetTilesWithinWorldXY(s, l, i, h, u, d, this.layer)
                },
                hasTileAt: function(s, l) {
                    return o.HasTileAt(s, l, this.layer)
                },
                hasTileAtWorldXY: function(s, l, i) {
                    return o.HasTileAtWorldXY(s, l, i, this.layer)
                },
                putTileAt: function(s, l, i, h) {
                    return o.PutTileAt(s, l, i, h, this.layer)
                },
                putTileAtWorldXY: function(s, l, i, h, u) {
                    return o.PutTileAtWorldXY(s, l, i, h, u, this.layer)
                },
                putTilesAt: function(s, l, i, h) {
                    return o.PutTilesAt(s, l, i, h, this.layer),
                    this
                },
                randomize: function(s, l, i, h, u) {
                    return o.Randomize(s, l, i, h, u, this.layer),
                    this
                },
                removeTileAt: function(s, l, i, h) {
                    return o.RemoveTileAt(s, l, i, h, this.layer)
                },
                removeTileAtWorldXY: function(s, l, i, h, u) {
                    return o.RemoveTileAtWorldXY(s, l, i, h, u, this.layer)
                },
                renderDebug: function(s, l) {
                    return o.RenderDebug(s, l, this.layer),
                    this
                },
                replaceByIndex: function(s, l, i, h, u, d) {
                    return o.ReplaceByIndex(s, l, i, h, u, d, this.layer),
                    this
                },
                setSkipCull: function(s) {
                    return s === void 0 && (s = !0),
                    this.skipCull = s,
                    this
                },
                setCullPadding: function(s, l) {
                    return s === void 0 && (s = 1),
                    l === void 0 && (l = 1),
                    this.cullPaddingX = s,
                    this.cullPaddingY = l,
                    this
                },
                setCollision: function(s, l, i, h) {
                    return o.SetCollision(s, l, i, this.layer, h),
                    this
                },
                setCollisionBetween: function(s, l, i, h) {
                    return o.SetCollisionBetween(s, l, i, h, this.layer),
                    this
                },
                setCollisionByProperty: function(s, l, i) {
                    return o.SetCollisionByProperty(s, l, i, this.layer),
                    this
                },
                setCollisionByExclusion: function(s, l, i) {
                    return o.SetCollisionByExclusion(s, l, i, this.layer),
                    this
                },
                setCollisionFromCollisionGroup: function(s, l) {
                    return o.SetCollisionFromCollisionGroup(s, l, this.layer),
                    this
                },
                setTileIndexCallback: function(s, l, i) {
                    return o.SetTileIndexCallback(s, l, i, this.layer),
                    this
                },
                setTileLocationCallback: function(s, l, i, h, u, d) {
                    return o.SetTileLocationCallback(s, l, i, h, u, d, this.layer),
                    this
                },
                shuffle: function(s, l, i, h) {
                    return o.Shuffle(s, l, i, h, this.layer),
                    this
                },
                swapByIndex: function(s, l, i, h, u, d) {
                    return o.SwapByIndex(s, l, i, h, u, d, this.layer),
                    this
                },
                tileToWorldX: function(s, l) {
                    return this.tilemap.tileToWorldX(s, l, this)
                },
                tileToWorldY: function(s, l) {
                    return this.tilemap.tileToWorldY(s, l, this)
                },
                tileToWorldXY: function(s, l, i, h) {
                    return this.tilemap.tileToWorldXY(s, l, i, h, this)
                },
                weightedRandomize: function(s, l, i, h, u) {
                    return o.WeightedRandomize(l, i, h, u, s, this.layer),
                    this
                },
                worldToTileX: function(s, l, i) {
                    return this.tilemap.worldToTileX(s, l, i, this)
                },
                worldToTileY: function(s, l, i) {
                    return this.tilemap.worldToTileY(s, l, i, this)
                },
                worldToTileXY: function(s, l, i, h, u) {
                    return this.tilemap.worldToTileXY(s, l, i, h, u, this)
                },
                destroy: function(s) {
                    s === void 0 && (s = !0),
                    this.tilemap && (this.layer.tilemapLayer === this && (this.layer.tilemapLayer = void 0),
                    s && this.tilemap.removeLayer(this),
                    this.tilemap = void 0,
                    this.layer = void 0,
                    this.culledTiles.length = 0,
                    this.cullCallback = null,
                    this.gidMap = [],
                    this.tileset = [],
                    r.prototype.destroy.call(this))
                }
            });
            c.exports = n
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(2)
              , r = new e({
                initialize: function(a) {
                    this.delay = 0,
                    this.repeat = 0,
                    this.repeatCount = 0,
                    this.loop = !1,
                    this.callback,
                    this.callbackScope,
                    this.args,
                    this.timeScale = 1,
                    this.startAt = 0,
                    this.elapsed = 0,
                    this.paused = !1,
                    this.hasDispatched = !1,
                    this.reset(a)
                },
                reset: function(o) {
                    return this.delay = f(o, "delay", 0),
                    this.repeat = f(o, "repeat", 0),
                    this.loop = f(o, "loop", !1),
                    this.callback = f(o, "callback", void 0),
                    this.callbackScope = f(o, "callbackScope", this.callback),
                    this.args = f(o, "args", []),
                    this.timeScale = f(o, "timeScale", 1),
                    this.startAt = f(o, "startAt", 0),
                    this.paused = f(o, "paused", !1),
                    this.elapsed = this.startAt,
                    this.hasDispatched = !1,
                    this.repeatCount = this.repeat === -1 || this.loop ? 999999999999 : this.repeat,
                    this
                },
                getProgress: function() {
                    return this.elapsed / this.delay
                },
                getOverallProgress: function() {
                    if (this.repeat > 0) {
                        var o = this.delay + this.delay * this.repeat
                          , a = this.elapsed + this.delay * (this.repeat - this.repeatCount);
                        return a / o
                    } else
                        return this.getProgress()
                },
                getRepeatCount: function() {
                    return this.repeatCount
                },
                getElapsed: function() {
                    return this.elapsed
                },
                getElapsedSeconds: function() {
                    return this.elapsed * .001
                },
                getRemaining: function() {
                    return this.delay - this.elapsed
                },
                getRemainingSeconds: function() {
                    return this.getRemaining() * .001
                },
                getOverallRemaining: function() {
                    return this.delay * (1 + this.repeatCount) - this.elapsed
                },
                getOverallRemainingSeconds: function() {
                    return this.getOverallRemaining() * .001
                },
                remove: function(o) {
                    o === void 0 && (o = !1),
                    this.elapsed = this.delay,
                    this.hasDispatched = !o,
                    this.repeatCount = 0
                },
                destroy: function() {
                    this.callback = void 0,
                    this.callbackScope = void 0,
                    this.args = []
                }
            });
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1465)
              , f = function(r) {
                var o, a = [];
                if (r.hasOwnProperty("props"))
                    for (o in r.props)
                        o.substr(0, 1) !== "_" && a.push({
                            key: o,
                            value: r.props[o]
                        });
                else
                    for (o in r)
                        e.indexOf(o) === -1 && o.substr(0, 1) !== "_" && a.push({
                            key: o,
                            value: r[o]
                        });
                return a
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(6)
              , f = function(r) {
                var o = e(r, "tweens", null);
                return o === null ? [] : (typeof o == "function" && (o = o.call()),
                Array.isArray(o) || (o = [o]),
                o)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(265)
              , f = t(13)
              , r = t(99)
              , o = t(80)
              , a = t(162)
              , n = t(6)
              , s = t(264)
              , l = t(266)
              , i = t(268)
              , h = function(u, d, v) {
                v === void 0 && (v = e);
                var p = n(d, "from", 0)
                  , g = n(d, "to", 1)
                  , m = [{
                    value: p
                }]
                  , x = a(d, "delay", v.delay)
                  , T = a(d, "duration", v.duration)
                  , E = n(d, "easeParams", v.easeParams)
                  , P = o(n(d, "ease", v.ease), E)
                  , M = a(d, "hold", v.hold)
                  , L = a(d, "repeat", v.repeat)
                  , R = a(d, "repeatDelay", v.repeatDelay)
                  , O = r(d, "yoyo", v.yoyo)
                  , F = []
                  , B = s("value", g)
                  , N = i(m[0], 0, "value", B.getEnd, B.getStart, B.getActive, P, x, T, O, M, L, R, !1, !1);
                N.start = p,
                N.current = p,
                N.to = g,
                F.push(N);
                var Y = new l(u,F,m);
                Y.offset = f(d, "offset", null),
                Y.completeDelay = f(d, "completeDelay", 0),
                Y.loop = Math.round(f(d, "loop", 0)),
                Y.loopDelay = Math.round(f(d, "loopDelay", 0)),
                Y.paused = r(d, "paused", !1),
                Y.useFrames = r(d, "useFrames", !1);
                for (var z = n(d, "callbackScope", Y), W = [Y, null], b = l.TYPES, D = 0; D < b.length; D++) {
                    var I = b[D]
                      , G = n(d, I, !1);
                    if (G) {
                        var w = n(d, I + "Scope", z)
                          , U = n(d, I + "Params", []);
                        Y.setCallback(I, G, W.concat(U), w)
                    }
                }
                return Y
            };
            c.exports = h
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(80)
              , f = t(6)
              , r = t(14)
              , o = function(a, n) {
                n === void 0 && (n = {});
                var s, l = f(n, "start", 0), i = f(n, "ease", null), h = f(n, "grid", null), u = f(n, "from", 0), d = u === "first", v = u === "center", p = u === "last", g = typeof u == "number", m = Array.isArray(a), x = parseFloat(m ? a[0] : a), T = m ? parseFloat(a[1]) : 0, E = Math.max(x, T);
                if (m && (l += x),
                h) {
                    var P = h[0]
                      , M = h[1]
                      , L = 0
                      , R = 0
                      , O = 0
                      , F = 0
                      , B = [];
                    p ? (L = P - 1,
                    R = M - 1) : g ? (L = u % P,
                    R = Math.floor(u / P)) : v && (L = (P - 1) / 2,
                    R = (M - 1) / 2);
                    for (var N = r.MIN_SAFE_INTEGER, Y = 0; Y < M; Y++) {
                        B[Y] = [];
                        for (var z = 0; z < P; z++) {
                            O = L - z,
                            F = R - Y;
                            var W = Math.sqrt(O * O + F * F);
                            W > N && (N = W),
                            B[Y][z] = W
                        }
                    }
                }
                var b = i ? e(i) : null;
                return h ? s = function(D, I, G, w) {
                    var U = 0
                      , X = w % P
                      , V = Math.floor(w / P);
                    X >= 0 && X < P && V >= 0 && V < M && (U = B[V][X]);
                    var H;
                    if (m) {
                        var J = T - x;
                        b ? H = U / N * J * b(U / N) : H = U / N * J
                    } else
                        b ? H = U * x * b(U / N) : H = U * x;
                    return H + l
                }
                : s = function(D, I, G, w, U) {
                    U--;
                    var X;
                    d ? X = w : v ? X = Math.abs(U / 2 - w) : p ? X = U - w : g && (X = Math.abs(u - w));
                    var V;
                    if (m) {
                        var H;
                        v ? H = (T - x) / U * (X * 2) : H = (T - x) / U * X,
                        b ? V = H * b(X / U) : V = H
                    } else
                        b ? V = U * E * b(X / U) : V = X * x;
                    return V + l
                }
                ,
                s
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(77)
              , f = t(265)
              , r = t(13)
              , o = t(99)
              , a = t(80)
              , n = t(162)
              , s = t(263)
              , l = t(584)
              , i = t(6)
              , h = t(588)
              , u = t(163)
              , d = function(v, p) {
                var g = new h(v);
                g.completeDelay = r(p, "completeDelay", 0),
                g.loop = Math.round(r(p, "loop", 0)),
                g.loopDelay = Math.round(r(p, "loopDelay", 0)),
                g.paused = o(p, "paused", !1),
                g.useFrames = o(p, "useFrames", !1);
                var m = i(p, "callbackScope", g)
                  , x = [g]
                  , T = i(p, "onStart", !1);
                if (T) {
                    var E = i(p, "onStartScope", m)
                      , P = i(p, "onStartParams", []);
                    g.setCallback("onStart", T, x.concat(P), E)
                }
                var M = i(p, "onUpdate", !1);
                if (M) {
                    var L = i(p, "onUpdateScope", m)
                      , R = i(p, "onUpdateParams", []);
                    g.setCallback("onUpdate", M, x.concat(R), L)
                }
                var O = i(p, "onLoop", !1);
                if (O) {
                    var F = i(p, "onLoopScope", m)
                      , B = i(p, "onLoopParams", []);
                    g.setCallback("onLoop", O, x.concat(B), F)
                }
                var N = i(p, "onYoyo", !1);
                if (N) {
                    var Y = i(p, "onYoyoScope", m)
                      , z = i(p, "onYoyoParams", []);
                    g.setCallback("onYoyo", N, x.concat(null, z), Y)
                }
                var W = i(p, "onComplete", !1);
                if (W) {
                    var b = i(p, "onCompleteScope", m)
                      , D = i(p, "onCompleteParams", []);
                    g.setCallback("onComplete", W, x.concat(D), b)
                }
                var I = l(p);
                if (I.length === 0)
                    return g.paused = !0,
                    g;
                var G = e(f);
                G.targets = s(p);
                var w = r(p, "totalDuration", 0);
                w > 0 ? G.duration = Math.floor(w / I.length) : G.duration = n(p, "duration", G.duration),
                G.delay = n(p, "delay", G.delay),
                G.easeParams = i(p, "easeParams", G.easeParams),
                G.ease = a(i(p, "ease", G.ease), G.easeParams),
                G.hold = n(p, "hold", G.hold),
                G.repeat = n(p, "repeat", G.repeat),
                G.repeatDelay = n(p, "repeatDelay", G.repeatDelay),
                G.yoyo = o(p, "yoyo", G.yoyo),
                G.flipX = o(p, "flipX", G.flipX),
                G.flipY = o(p, "flipY", G.flipY);
                for (var U = 0; U < I.length; U++)
                    g.queue(u(g, I[U], G));
                return g
            };
            c.exports = d
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(9)
              , r = t(267)
              , o = t(163)
              , a = t(100)
              , n = new e({
                Extends: f,
                initialize: function(l) {
                    f.call(this),
                    this.manager = l,
                    this.isTimeline = !0,
                    this.data = [],
                    this.totalData = 0,
                    this.useFrames = !1,
                    this.timeScale = 1,
                    this.loop = 0,
                    this.loopDelay = 0,
                    this.loopCounter = 0,
                    this.completeDelay = 0,
                    this.countdown = 0,
                    this.state = a.PENDING_ADD,
                    this._pausedState = a.PENDING_ADD,
                    this.paused = !1,
                    this.elapsed = 0,
                    this.totalElapsed = 0,
                    this.duration = 0,
                    this.progress = 0,
                    this.totalDuration = 0,
                    this.totalProgress = 0,
                    this.callbacks = {
                        onComplete: null,
                        onLoop: null,
                        onStart: null,
                        onUpdate: null,
                        onYoyo: null
                    },
                    this.callbackScope
                },
                dispatchTimelineEvent: function(s, l) {
                    this.emit(s, this),
                    l && l.func.apply(l.scope, l.params)
                },
                setTimeScale: function(s) {
                    return this.timeScale = s,
                    this
                },
                getTimeScale: function() {
                    return this.timeScale
                },
                isPlaying: function() {
                    return this.state === a.ACTIVE
                },
                add: function(s) {
                    return this.queue(o(this, s))
                },
                queue: function(s) {
                    return this.isPlaying() || (s.parent = this,
                    s.parentIsTimeline = !0,
                    this.data.push(s),
                    this.totalData = this.data.length),
                    this
                },
                hasOffset: function(s) {
                    return s.offset !== null
                },
                isOffsetAbsolute: function(s) {
                    return typeof s == "number"
                },
                isOffsetRelative: function(s) {
                    var l = typeof s;
                    if (l === "string") {
                        var i = s[0];
                        if (i === "-" || i === "+")
                            return !0
                    }
                    return !1
                },
                getRelativeOffset: function(s, l) {
                    var i = s[0]
                      , h = parseFloat(s.substr(2))
                      , u = l;
                    switch (i) {
                    case "+":
                        u += h;
                        break;
                    case "-":
                        u -= h;
                        break
                    }
                    return Math.max(0, u)
                },
                calcDuration: function() {
                    for (var s = 0, l = 0, i = 0, h = 0; h < this.totalData; h++) {
                        var u = this.data[h];
                        u.init(),
                        this.hasOffset(u) ? this.isOffsetAbsolute(u.offset) ? (u.calculatedOffset = u.offset,
                        u.offset === 0 && (i = 0)) : this.isOffsetRelative(u.offset) && (u.calculatedOffset = this.getRelativeOffset(u.offset, s)) : u.calculatedOffset = i,
                        s = u.totalDuration + u.calculatedOffset,
                        l += u.totalDuration,
                        i += u.totalDuration
                    }
                    this.duration = l,
                    this.loopCounter = this.loop === -1 ? 999999999999 : this.loop,
                    this.loopCounter > 0 ? this.totalDuration = this.duration + this.completeDelay + (this.duration + this.loopDelay) * this.loopCounter : this.totalDuration = this.duration + this.completeDelay
                },
                init: function() {
                    return this.calcDuration(),
                    this.progress = 0,
                    this.totalProgress = 0,
                    this.paused ? (this.state = a.PAUSED,
                    !1) : !0
                },
                resetTweens: function(s) {
                    for (var l = 0; l < this.totalData; l++) {
                        var i = this.data[l];
                        i.play(s)
                    }
                },
                setCallback: function(s, l, i, h) {
                    return n.TYPES.indexOf(s) !== -1 && (this.callbacks[s] = {
                        func: l,
                        scope: h,
                        params: i
                    }),
                    this
                },
                makeActive: function(s) {
                    return this.manager.makeActive(s)
                },
                play: function() {
                    if (this.state !== a.ACTIVE) {
                        if (this.paused) {
                            this.paused = !1,
                            this.manager.makeActive(this);
                            return
                        } else
                            this.resetTweens(!1),
                            this.state = a.ACTIVE;
                        this.dispatchTimelineEvent(r.TIMELINE_START, this.callbacks.onStart)
                    }
                },
                nextState: function() {
                    this.loopCounter > 0 ? (this.elapsed = 0,
                    this.progress = 0,
                    this.loopCounter--,
                    this.resetTweens(!0),
                    this.loopDelay > 0 ? (this.countdown = this.loopDelay,
                    this.state = a.LOOP_DELAY) : (this.state = a.ACTIVE,
                    this.dispatchTimelineEvent(r.TIMELINE_LOOP, this.callbacks.onLoop))) : this.completeDelay > 0 ? (this.state = a.COMPLETE_DELAY,
                    this.countdown = this.completeDelay) : (this.state = a.PENDING_REMOVE,
                    this.dispatchTimelineEvent(r.TIMELINE_COMPLETE, this.callbacks.onComplete))
                },
                update: function(s, l) {
                    if (this.state !== a.PAUSED) {
                        switch (this.useFrames && (l = 1 * this.manager.timeScale),
                        l *= this.timeScale,
                        this.elapsed += l,
                        this.progress = Math.min(this.elapsed / this.duration, 1),
                        this.totalElapsed += l,
                        this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1),
                        this.state) {
                        case a.ACTIVE:
                            for (var i = this.totalData, h = 0; h < this.totalData; h++) {
                                var u = this.data[h];
                                u.update(s, l) && i--
                            }
                            this.dispatchTimelineEvent(r.TIMELINE_UPDATE, this.callbacks.onUpdate),
                            i === 0 && this.nextState();
                            break;
                        case a.LOOP_DELAY:
                            this.countdown -= l,
                            this.countdown <= 0 && (this.state = a.ACTIVE,
                            this.dispatchTimelineEvent(r.TIMELINE_LOOP, this.callbacks.onLoop));
                            break;
                        case a.COMPLETE_DELAY:
                            this.countdown -= l,
                            this.countdown <= 0 && (this.state = a.PENDING_REMOVE,
                            this.dispatchTimelineEvent(r.TIMELINE_COMPLETE, this.callbacks.onComplete));
                            break
                        }
                        return this.state === a.PENDING_REMOVE
                    }
                },
                stop: function() {
                    this.state = a.PENDING_REMOVE
                },
                pause: function() {
                    if (this.state !== a.PAUSED)
                        return this.paused = !0,
                        this._pausedState = this.state,
                        this.state = a.PAUSED,
                        this.emit(r.TIMELINE_PAUSE, this),
                        this
                },
                resume: function() {
                    return this.state === a.PAUSED && (this.paused = !1,
                    this.state = this._pausedState,
                    this.emit(r.TIMELINE_RESUME, this)),
                    this
                },
                hasTarget: function(s) {
                    for (var l = 0; l < this.data.length; l++)
                        if (this.data[l].hasTarget(s))
                            return !0;
                    return !1
                },
                destroy: function() {
                    for (var s = 0; s < this.data.length; s++)
                        this.data[s].stop()
                }
            });
            n.TYPES = ["onStart", "onUpdate", "onLoop", "onComplete", "onYoyo"],
            c.exports = n
        }
        , function(c, S, t) {
            /**
 * @author       Joachim Grill <joachim@codeandweb.com>
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 CodeAndWeb GmbH
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(86)
              , f = t(41)
              , r = t(32)
              , o = t(2)
              , a = t(64)
              , n = {
                parseBody: function(s, l, i, h) {
                    h === void 0 && (h = {});
                    for (var u = o(i, "fixtures", []), d = [], v = 0; v < u.length; v++)
                        for (var p = this.parseFixture(u[v]), g = 0; g < p.length; g++)
                            d.push(p[g]);
                    var m = r.clone(i, !0);
                    r.extend(m, h, !0),
                    delete m.fixtures,
                    delete m.type;
                    var x = f.create(m);
                    return f.setParts(x, d),
                    f.setPosition(x, {
                        x: s,
                        y: l
                    }),
                    x
                },
                parseFixture: function(s) {
                    var l = r.extend({}, !1, s);
                    delete l.circle,
                    delete l.vertices;
                    var i;
                    if (s.circle) {
                        var h = o(s.circle, "x")
                          , u = o(s.circle, "y")
                          , d = o(s.circle, "radius");
                        i = [e.circle(h, u, d, l)]
                    } else
                        s.vertices && (i = this.parseVertices(s.vertices, l));
                    return i
                },
                parseVertices: function(s, l) {
                    l === void 0 && (l = {});
                    for (var i = [], h = 0; h < s.length; h++)
                        a.clockwiseSort(s[h]),
                        i.push(f.create(r.extend({
                            position: a.centre(s[h]),
                            vertices: s[h]
                        }, l)));
                    return e.flagCoincidentParts(i)
                }
            };
            c.exports = n
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(86)
              , f = t(41)
              , r = {
                parseBody: function(o, a, n, s) {
                    s === void 0 && (s = {});
                    var l, i = n.vertices;
                    if (i.length === 1)
                        s.vertices = i[0],
                        l = f.create(s),
                        e.flagCoincidentParts(l.parts);
                    else {
                        for (var h = [], u = 0; u < i.length; u++) {
                            var d = f.create({
                                vertices: i[u]
                            });
                            h.push(d)
                        }
                        e.flagCoincidentParts(h),
                        s.parts = h,
                        l = f.create(s)
                    }
                    return l.label = n.label,
                    f.setPosition(l, {
                        x: o,
                        y: a
                    }),
                    l
                }
            };
            c.exports = r
        }
        , function(c, S, t) {
            var e = {};
            c.exports = e;
            var f = t(118)
              , r = t(128)
              , o = t(32)
              , a = t(41)
              , n = t(86);
            (function() {
                e.stack = function(s, l, i, h, u, d, v) {
                    for (var p = f.create({
                        label: "Stack"
                    }), g = s, m = l, x, T = 0, E = 0; E < h; E++) {
                        for (var P = 0, M = 0; M < i; M++) {
                            var L = v(g, m, M, E, x, T);
                            if (L) {
                                var R = L.bounds.max.y - L.bounds.min.y
                                  , O = L.bounds.max.x - L.bounds.min.x;
                                R > P && (P = R),
                                a.translate(L, {
                                    x: O * .5,
                                    y: R * .5
                                }),
                                g = L.bounds.max.x + u,
                                f.addBody(p, L),
                                x = L,
                                T += 1
                            } else
                                g += u
                        }
                        m += P + d,
                        g = s
                    }
                    return p
                }
                ,
                e.chain = function(s, l, i, h, u, d) {
                    for (var v = s.bodies, p = 1; p < v.length; p++) {
                        var g = v[p - 1]
                          , m = v[p]
                          , x = g.bounds.max.y - g.bounds.min.y
                          , T = g.bounds.max.x - g.bounds.min.x
                          , E = m.bounds.max.y - m.bounds.min.y
                          , P = m.bounds.max.x - m.bounds.min.x
                          , M = {
                            bodyA: g,
                            pointA: {
                                x: T * l,
                                y: x * i
                            },
                            bodyB: m,
                            pointB: {
                                x: P * h,
                                y: E * u
                            }
                        }
                          , L = o.extend(M, d);
                        f.addConstraint(s, r.create(L))
                    }
                    return s.label += " Chain",
                    s
                }
                ,
                e.mesh = function(s, l, i, h, u) {
                    var d = s.bodies, v, p, g, m, x;
                    for (v = 0; v < i; v++) {
                        for (p = 1; p < l; p++)
                            g = d[p - 1 + v * l],
                            m = d[p + v * l],
                            f.addConstraint(s, r.create(o.extend({
                                bodyA: g,
                                bodyB: m
                            }, u)));
                        if (v > 0)
                            for (p = 0; p < l; p++)
                                g = d[p + (v - 1) * l],
                                m = d[p + v * l],
                                f.addConstraint(s, r.create(o.extend({
                                    bodyA: g,
                                    bodyB: m
                                }, u))),
                                h && p > 0 && (x = d[p - 1 + (v - 1) * l],
                                f.addConstraint(s, r.create(o.extend({
                                    bodyA: x,
                                    bodyB: m
                                }, u)))),
                                h && p < l - 1 && (x = d[p + 1 + (v - 1) * l],
                                f.addConstraint(s, r.create(o.extend({
                                    bodyA: x,
                                    bodyB: m
                                }, u))))
                    }
                    return s.label += " Mesh",
                    s
                }
                ,
                e.pyramid = function(s, l, i, h, u, d, v) {
                    return e.stack(s, l, i, h, u, d, function(p, g, m, x, T, E) {
                        var P = Math.min(h, Math.ceil(i / 2))
                          , M = T ? T.bounds.max.x - T.bounds.min.x : 0;
                        if (!(x > P)) {
                            x = P - x;
                            var L = x
                              , R = i - 1 - x;
                            if (!(m < L || m > R)) {
                                E === 1 && a.translate(T, {
                                    x: (m + (i % 2 === 1 ? 1 : -1)) * M,
                                    y: 0
                                });
                                var O = T ? m * M : 0;
                                return v(s + O + m * u, g, m, x, T, E)
                            }
                        }
                    })
                }
                ,
                e.newtonsCradle = function(s, l, i, h, u) {
                    for (var d = f.create({
                        label: "Newtons Cradle"
                    }), v = 0; v < i; v++) {
                        var p = 1.9
                          , g = n.circle(s + v * (h * p), l + u, h, {
                            inertia: 1 / 0,
                            restitution: 1,
                            friction: 0,
                            frictionAir: 1e-4,
                            slop: 1
                        })
                          , m = r.create({
                            pointA: {
                                x: s + v * (h * p),
                                y: l
                            },
                            bodyB: g
                        });
                        f.addBody(d, g),
                        f.addConstraint(d, m)
                    }
                    return d
                }
                ,
                e.car = function(s, l, i, h, u) {
                    var d = a.nextGroup(!0)
                      , v = 20
                      , p = -i * .5 + v
                      , g = i * .5 - v
                      , m = 0
                      , x = f.create({
                        label: "Car"
                    })
                      , T = n.rectangle(s, l, i, h, {
                        collisionFilter: {
                            group: d
                        },
                        chamfer: {
                            radius: h * .5
                        },
                        density: 2e-4
                    })
                      , E = n.circle(s + p, l + m, u, {
                        collisionFilter: {
                            group: d
                        },
                        friction: .8
                    })
                      , P = n.circle(s + g, l + m, u, {
                        collisionFilter: {
                            group: d
                        },
                        friction: .8
                    })
                      , M = r.create({
                        bodyB: T,
                        pointB: {
                            x: p,
                            y: m
                        },
                        bodyA: E,
                        stiffness: 1,
                        length: 0
                    })
                      , L = r.create({
                        bodyB: T,
                        pointB: {
                            x: g,
                            y: m
                        },
                        bodyA: P,
                        stiffness: 1,
                        length: 0
                    });
                    return f.addBody(x, T),
                    f.addBody(x, E),
                    f.addBody(x, P),
                    f.addConstraint(x, M),
                    f.addConstraint(x, L),
                    x
                }
                ,
                e.softBody = function(s, l, i, h, u, d, v, p, g, m) {
                    g = o.extend({
                        inertia: 1 / 0
                    }, g),
                    m = o.extend({
                        stiffness: .2,
                        render: {
                            type: "line",
                            anchors: !1
                        }
                    }, m);
                    var x = e.stack(s, l, i, h, u, d, function(T, E) {
                        return n.circle(T, E, p, g)
                    });
                    return e.mesh(x, i, h, v, m),
                    x.label = "Soft Body",
                    x
                }
            }
            )()
        }
        , function(c, S, t) {
            var e = {};
            c.exports = e,
            t(84);
            var f = t(32);
            (function() {
                e.pathToVertices = function(r, o) {
                    typeof window < "u" && !("SVGPathSeg"in window) && f.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.");
                    var a, n, s, l, i, h, u, d, v, p, g = [], m, x, T = 0, E = 0, P = 0;
                    o = o || 15;
                    var M = function(R, O, F) {
                        var B = F % 2 === 1 && F > 1;
                        if (!v || R != v.x || O != v.y) {
                            v && B ? (m = v.x,
                            x = v.y) : (m = 0,
                            x = 0);
                            var N = {
                                x: m + R,
                                y: x + O
                            };
                            (B || !v) && (v = N),
                            g.push(N),
                            E = m + R,
                            P = x + O
                        }
                    }
                      , L = function(R) {
                        var O = R.pathSegTypeAsLetter.toUpperCase();
                        if (O !== "Z") {
                            switch (O) {
                            case "M":
                            case "L":
                            case "T":
                            case "C":
                            case "S":
                            case "Q":
                                E = R.x,
                                P = R.y;
                                break;
                            case "H":
                                E = R.x;
                                break;
                            case "V":
                                P = R.y;
                                break
                            }
                            M(E, P, R.pathSegType)
                        }
                    };
                    for (e._svgPathToAbsolute(r),
                    s = r.getTotalLength(),
                    h = [],
                    a = 0; a < r.pathSegList.numberOfItems; a += 1)
                        h.push(r.pathSegList.getItem(a));
                    for (u = h.concat(); T < s; ) {
                        if (p = r.getPathSegAtLength(T),
                        i = h[p],
                        i != d) {
                            for (; u.length && u[0] != i; )
                                L(u.shift());
                            d = i
                        }
                        switch (i.pathSegTypeAsLetter.toUpperCase()) {
                        case "C":
                        case "T":
                        case "S":
                        case "Q":
                        case "A":
                            l = r.getPointAtLength(T),
                            M(l.x, l.y, 0);
                            break
                        }
                        T += o
                    }
                    for (a = 0,
                    n = u.length; a < n; ++a)
                        L(u[a]);
                    return g
                }
                ,
                e._svgPathToAbsolute = function(r) {
                    for (var o, a, n, s, l, i, h = r.pathSegList, u = 0, d = 0, v = h.numberOfItems, p = 0; p < v; ++p) {
                        var g = h.getItem(p)
                          , m = g.pathSegTypeAsLetter;
                        if (/[MLHVCSQTA]/.test(m))
                            "x"in g && (u = g.x),
                            "y"in g && (d = g.y);
                        else
                            switch ("x1"in g && (n = u + g.x1),
                            "x2"in g && (l = u + g.x2),
                            "y1"in g && (s = d + g.y1),
                            "y2"in g && (i = d + g.y2),
                            "x"in g && (u += g.x),
                            "y"in g && (d += g.y),
                            m) {
                            case "m":
                                h.replaceItem(r.createSVGPathSegMovetoAbs(u, d), p);
                                break;
                            case "l":
                                h.replaceItem(r.createSVGPathSegLinetoAbs(u, d), p);
                                break;
                            case "h":
                                h.replaceItem(r.createSVGPathSegLinetoHorizontalAbs(u), p);
                                break;
                            case "v":
                                h.replaceItem(r.createSVGPathSegLinetoVerticalAbs(d), p);
                                break;
                            case "c":
                                h.replaceItem(r.createSVGPathSegCurvetoCubicAbs(u, d, n, s, l, i), p);
                                break;
                            case "s":
                                h.replaceItem(r.createSVGPathSegCurvetoCubicSmoothAbs(u, d, l, i), p);
                                break;
                            case "q":
                                h.replaceItem(r.createSVGPathSegCurvetoQuadraticAbs(u, d, n, s), p);
                                break;
                            case "t":
                                h.replaceItem(r.createSVGPathSegCurvetoQuadraticSmoothAbs(u, d), p);
                                break;
                            case "a":
                                h.replaceItem(r.createSVGPathSegArcAbs(u, d, g.r1, g.r2, g.angle, g.largeArcFlag, g.sweepFlag), p);
                                break;
                            case "z":
                            case "Z":
                                u = o,
                                d = a;
                                break
                            }
                        (m == "M" || m == "m") && (o = u,
                        a = d)
                    }
                }
            }
            )()
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(86)
              , f = t(41)
              , r = t(0)
              , o = t(249)
              , a = t(9)
              , n = t(2)
              , s = t(126)
              , l = t(64)
              , i = new r({
                Extends: a,
                Mixins: [o.Bounce, o.Collision, o.Friction, o.Gravity, o.Mass, o.Sensor, o.Sleep, o.Static],
                initialize: function(u, d, v) {
                    a.call(this),
                    this.tile = d,
                    this.world = u,
                    d.physics.matterBody && d.physics.matterBody.destroy(),
                    d.physics.matterBody = this;
                    var p = n(v, "body", null)
                      , g = n(v, "addToWorld", !0);
                    if (p)
                        this.setBody(p, g);
                    else {
                        var m = d.getCollisionGroup()
                          , x = n(m, "objects", []);
                        x.length > 0 ? this.setFromTileCollision(v) : this.setFromTileRectangle(v)
                    }
                },
                setFromTileRectangle: function(h) {
                    h === void 0 && (h = {}),
                    s(h, "isStatic") || (h.isStatic = !0),
                    s(h, "addToWorld") || (h.addToWorld = !0);
                    var u = this.tile.getBounds()
                      , d = u.x + u.width / 2
                      , v = u.y + u.height / 2
                      , p = e.rectangle(d, v, u.width, u.height, h);
                    return this.setBody(p, h.addToWorld),
                    this
                },
                setFromTileCollision: function(h) {
                    h === void 0 && (h = {}),
                    s(h, "isStatic") || (h.isStatic = !0),
                    s(h, "addToWorld") || (h.addToWorld = !0);
                    for (var u = this.tile.tilemapLayer.scaleX, d = this.tile.tilemapLayer.scaleY, v = this.tile.getLeft(), p = this.tile.getTop(), g = this.tile.getCollisionGroup(), m = n(g, "objects", []), x = [], T = 0; T < m.length; T++) {
                        var E = m[T]
                          , P = v + E.x * u
                          , M = p + E.y * d
                          , L = E.width * u
                          , R = E.height * d
                          , O = null;
                        if (E.rectangle)
                            O = e.rectangle(P + L / 2, M + R / 2, L, R, h);
                        else if (E.ellipse)
                            O = e.circle(P + L / 2, M + R / 2, L / 2, h);
                        else if (E.polygon || E.polyline) {
                            var F = E.polygon ? E.polygon : E.polyline
                              , B = F.map(function(z) {
                                return {
                                    x: z.x * u,
                                    y: z.y * d
                                }
                            })
                              , N = l.create(B)
                              , Y = l.centre(N);
                            P += Y.x,
                            M += Y.y,
                            O = e.fromVertices(P, M, N, h)
                        }
                        O && x.push(O)
                    }
                    return x.length === 1 ? this.setBody(x[0], h.addToWorld) : x.length > 1 && (h.parts = x,
                    this.setBody(f.create(h), h.addToWorld)),
                    this
                },
                setBody: function(h, u) {
                    return u === void 0 && (u = !0),
                    this.body && this.removeBody(),
                    this.body = h,
                    this.body.gameObject = this,
                    u && this.world.add(this.body),
                    this
                },
                removeBody: function() {
                    return this.body && (this.world.remove(this.body),
                    this.body.gameObject = void 0,
                    this.body = void 0),
                    this
                },
                destroy: function() {
                    this.removeBody(),
                    this.tile.physics.matterBody = void 0,
                    this.removeAllListeners()
                }
            });
            c.exports = i
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1399);
            e.Body = t(41),
            e.Composite = t(118),
            e.World = t(596),
            e.Detector = t(273),
            e.Grid = t(597),
            e.Pairs = t(598),
            e.Pair = t(250),
            e.Query = t(1400),
            e.Resolver = t(599),
            e.SAT = t(274),
            e.Constraint = t(128),
            e.Common = t(32),
            e.Engine = t(1401),
            e.Events = t(166),
            e.Sleeping = t(165),
            e.Plugin = t(595),
            e.Bodies = t(86),
            e.Composites = t(591),
            e.Axes = t(271),
            e.Bounds = t(84),
            e.Svg = t(592),
            e.Vector = t(83),
            e.Vertices = t(64),
            e.World.add = e.Composite.add,
            e.World.remove = e.Composite.remove,
            e.World.addComposite = e.Composite.addComposite,
            e.World.addBody = e.Composite.addBody,
            e.World.addConstraint = e.Composite.addConstraint,
            e.World.clear = e.Composite.clear,
            c.exports = e
        }
        , function(c, S, t) {
            var e = {};
            c.exports = e;
            var f = t(32);
            (function() {
                e._registry = {},
                e.register = function(r) {
                    if (e.isPlugin(r) || f.warn("Plugin.register:", e.toString(r), "does not implement all required fields."),
                    r.name in e._registry) {
                        var o = e._registry[r.name]
                          , a = e.versionParse(r.version).number
                          , n = e.versionParse(o.version).number;
                        a > n ? (f.warn("Plugin.register:", e.toString(o), "was upgraded to", e.toString(r)),
                        e._registry[r.name] = r) : a < n ? f.warn("Plugin.register:", e.toString(o), "can not be downgraded to", e.toString(r)) : r !== o && f.warn("Plugin.register:", e.toString(r), "is already registered to different plugin object")
                    } else
                        e._registry[r.name] = r;
                    return r
                }
                ,
                e.resolve = function(r) {
                    return e._registry[e.dependencyParse(r).name]
                }
                ,
                e.toString = function(r) {
                    return typeof r == "string" ? r : (r.name || "anonymous") + "@" + (r.version || r.range || "0.0.0")
                }
                ,
                e.isPlugin = function(r) {
                    return r && r.name && r.version && r.install
                }
                ,
                e.isUsed = function(r, o) {
                    return r.used.indexOf(o) > -1
                }
                ,
                e.isFor = function(r, o) {
                    var a = r.for && e.dependencyParse(r.for);
                    return !r.for || o.name === a.name && e.versionSatisfies(o.version, a.range)
                }
                ,
                e.use = function(r, o) {
                    if (r.uses = (r.uses || []).concat(o || []),
                    r.uses.length === 0) {
                        f.warn("Plugin.use:", e.toString(r), "does not specify any dependencies to install.");
                        return
                    }
                    for (var a = e.dependencies(r), n = f.topologicalSort(a), s = [], l = 0; l < n.length; l += 1)
                        if (n[l] !== r.name) {
                            var i = e.resolve(n[l]);
                            if (!i) {
                                s.push("❌ " + n[l]);
                                continue
                            }
                            e.isUsed(r, i.name) || (e.isFor(i, r) || (f.warn("Plugin.use:", e.toString(i), "is for", i.for, "but installed on", e.toString(r) + "."),
                            i._warned = !0),
                            i.install ? i.install(r) : (f.warn("Plugin.use:", e.toString(i), "does not specify an install function."),
                            i._warned = !0),
                            i._warned ? (s.push("🔶 " + e.toString(i)),
                            delete i._warned) : s.push("✅ " + e.toString(i)),
                            r.used.push(i.name))
                        }
                    s.length > 0 && !i.silent && f.info(s.join("  "))
                }
                ,
                e.dependencies = function(r, o) {
                    var a = e.dependencyParse(r)
                      , n = a.name;
                    if (o = o || {},
                    !(n in o)) {
                        r = e.resolve(r) || r,
                        o[n] = f.map(r.uses || [], function(l) {
                            e.isPlugin(l) && e.register(l);
                            var i = e.dependencyParse(l)
                              , h = e.resolve(l);
                            return h && !e.versionSatisfies(h.version, i.range) ? (f.warn("Plugin.dependencies:", e.toString(h), "does not satisfy", e.toString(i), "used by", e.toString(a) + "."),
                            h._warned = !0,
                            r._warned = !0) : h || (f.warn("Plugin.dependencies:", e.toString(l), "used by", e.toString(a), "could not be resolved."),
                            r._warned = !0),
                            i.name
                        });
                        for (var s = 0; s < o[n].length; s += 1)
                            e.dependencies(o[n][s], o);
                        return o
                    }
                }
                ,
                e.dependencyParse = function(r) {
                    if (f.isString(r)) {
                        var o = /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?))?$/;
                        return o.test(r) || f.warn("Plugin.dependencyParse:", r, "is not a valid dependency string."),
                        {
                            name: r.split("@")[0],
                            range: r.split("@")[1] || "*"
                        }
                    }
                    return {
                        name: r.name,
                        range: r.range || r.version
                    }
                }
                ,
                e.versionParse = function(r) {
                    var o = /^\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?$/;
                    o.test(r) || f.warn("Plugin.versionParse:", r, "is not a valid version or range.");
                    var a = r.split("-");
                    r = a[0];
                    var n = isNaN(Number(r[0]))
                      , s = n ? r.substr(1) : r
                      , l = f.map(s.split("."), function(i) {
                        return Number(i)
                    });
                    return {
                        isRange: n,
                        version: s,
                        range: r,
                        operator: n ? r[0] : "",
                        parts: l,
                        prerelease: a[1],
                        number: l[0] * 1e8 + l[1] * 1e4 + l[2]
                    }
                }
                ,
                e.versionSatisfies = function(r, o) {
                    o = o || "*";
                    var a = e.versionParse(o)
                      , n = a.parts
                      , s = e.versionParse(r)
                      , l = s.parts;
                    if (a.isRange) {
                        if (a.operator === "*" || r === "*")
                            return !0;
                        if (a.operator === "~")
                            return l[0] === n[0] && l[1] === n[1] && l[2] >= n[2];
                        if (a.operator === "^")
                            return n[0] > 0 ? l[0] === n[0] && s.number >= a.number : n[1] > 0 ? l[1] === n[1] && l[2] >= n[2] : l[2] === n[2]
                    }
                    return r === o || r === "*"
                }
            }
            )()
        }
        , function(c, S, t) {
            var e = {};
            c.exports = e;
            var f = t(118);
            t(128);
            var r = t(32);
            (function() {
                e.create = function(o) {
                    var a = f.create()
                      , n = {
                        label: "World",
                        gravity: {
                            x: 0,
                            y: 1,
                            scale: .001
                        },
                        bounds: {
                            min: {
                                x: -1 / 0,
                                y: -1 / 0
                            },
                            max: {
                                x: 1 / 0,
                                y: 1 / 0
                            }
                        }
                    };
                    return r.extend(a, n, o)
                }
            }
            )()
        }
        , function(c, S, t) {
            var e = {};
            c.exports = e;
            var f = t(250)
              , r = t(273)
              , o = t(32);
            (function() {
                e.create = function(a) {
                    var n = {
                        controller: e,
                        detector: r.collisions,
                        buckets: {},
                        pairs: {},
                        pairsList: [],
                        bucketWidth: 48,
                        bucketHeight: 48
                    };
                    return o.extend(n, a)
                }
                ,
                e.update = function(a, n, s, l) {
                    var i, h, u, d = s.world, v = a.buckets, p, g, m = !1, x = s.metrics;
                    for (x.broadphaseTests = 0,
                    i = 0; i < n.length; i++) {
                        var T = n[i];
                        if (!(T.isSleeping && !l) && !(T.bounds.max.x < d.bounds.min.x || T.bounds.min.x > d.bounds.max.x || T.bounds.max.y < d.bounds.min.y || T.bounds.min.y > d.bounds.max.y)) {
                            var E = e._getRegion(a, T);
                            if (!T.region || E.id !== T.region.id || l) {
                                x.broadphaseTests += 1,
                                (!T.region || l) && (T.region = E);
                                var P = e._regionUnion(E, T.region);
                                for (h = P.startCol; h <= P.endCol; h++)
                                    for (u = P.startRow; u <= P.endRow; u++) {
                                        g = e._getBucketId(h, u),
                                        p = v[g];
                                        var M = h >= E.startCol && h <= E.endCol && u >= E.startRow && u <= E.endRow
                                          , L = h >= T.region.startCol && h <= T.region.endCol && u >= T.region.startRow && u <= T.region.endRow;
                                        !M && L && L && p && e._bucketRemoveBody(a, p, T),
                                        (T.region === E || M && !L || l) && (p || (p = e._createBucket(v, g)),
                                        e._bucketAddBody(a, p, T))
                                    }
                                T.region = E,
                                m = !0
                            }
                        }
                    }
                    m && (a.pairsList = e._createActivePairsList(a))
                }
                ,
                e.clear = function(a) {
                    a.buckets = {},
                    a.pairs = {},
                    a.pairsList = []
                }
                ,
                e._regionUnion = function(a, n) {
                    var s = Math.min(a.startCol, n.startCol)
                      , l = Math.max(a.endCol, n.endCol)
                      , i = Math.min(a.startRow, n.startRow)
                      , h = Math.max(a.endRow, n.endRow);
                    return e._createRegion(s, l, i, h)
                }
                ,
                e._getRegion = function(a, n) {
                    var s = n.bounds
                      , l = Math.floor(s.min.x / a.bucketWidth)
                      , i = Math.floor(s.max.x / a.bucketWidth)
                      , h = Math.floor(s.min.y / a.bucketHeight)
                      , u = Math.floor(s.max.y / a.bucketHeight);
                    return e._createRegion(l, i, h, u)
                }
                ,
                e._createRegion = function(a, n, s, l) {
                    return {
                        id: a + "," + n + "," + s + "," + l,
                        startCol: a,
                        endCol: n,
                        startRow: s,
                        endRow: l
                    }
                }
                ,
                e._getBucketId = function(a, n) {
                    return "C" + a + "R" + n
                }
                ,
                e._createBucket = function(a, n) {
                    var s = a[n] = [];
                    return s
                }
                ,
                e._bucketAddBody = function(a, n, s) {
                    for (var l = 0; l < n.length; l++) {
                        var i = n[l];
                        if (!(s.id === i.id || s.isStatic && i.isStatic)) {
                            var h = f.id(s, i)
                              , u = a.pairs[h];
                            u ? u[2] += 1 : a.pairs[h] = [s, i, 1]
                        }
                    }
                    n.push(s)
                }
                ,
                e._bucketRemoveBody = function(a, n, s) {
                    n.splice(n.indexOf(s), 1);
                    for (var l = 0; l < n.length; l++) {
                        var i = n[l]
                          , h = f.id(s, i)
                          , u = a.pairs[h];
                        u && (u[2] -= 1)
                    }
                }
                ,
                e._createActivePairsList = function(a) {
                    var n, s, l = [];
                    n = o.keys(a.pairs);
                    for (var i = 0; i < n.length; i++)
                        s = a.pairs[n[i]],
                        s[2] > 0 ? l.push(s) : delete a.pairs[n[i]];
                    return l
                }
            }
            )()
        }
        , function(c, S, t) {
            var e = {};
            c.exports = e;
            var f = t(250)
              , r = t(32);
            (function() {
                e._pairMaxIdleLife = 1e3,
                e.create = function(o) {
                    return r.extend({
                        table: {},
                        list: [],
                        collisionStart: [],
                        collisionActive: [],
                        collisionEnd: []
                    }, o)
                }
                ,
                e.update = function(o, a, n) {
                    var s = o.list, l = o.table, i = o.collisionStart, h = o.collisionEnd, u = o.collisionActive, d, v, p, g;
                    for (i.length = 0,
                    h.length = 0,
                    u.length = 0,
                    g = 0; g < s.length; g++)
                        s[g].confirmedActive = !1;
                    for (g = 0; g < a.length; g++)
                        d = a[g],
                        d.collided && (v = f.id(d.bodyA, d.bodyB),
                        p = l[v],
                        p ? (p.isActive ? u.push(p) : i.push(p),
                        f.update(p, d, n),
                        p.confirmedActive = !0) : (p = f.create(d, n),
                        l[v] = p,
                        i.push(p),
                        s.push(p)));
                    for (g = 0; g < s.length; g++)
                        p = s[g],
                        p.isActive && !p.confirmedActive && (f.setActive(p, !1, n),
                        h.push(p))
                }
                ,
                e.removeOld = function(o, a) {
                    var n = o.list, s = o.table, l = [], i, h, u, d;
                    for (d = 0; d < n.length; d++) {
                        if (i = n[d],
                        h = i.collision,
                        h.bodyA.isSleeping || h.bodyB.isSleeping) {
                            i.timeUpdated = a;
                            continue
                        }
                        a - i.timeUpdated > e._pairMaxIdleLife && l.push(d)
                    }
                    for (d = 0; d < l.length; d++)
                        u = l[d] - d,
                        i = n[u],
                        delete s[i.id],
                        n.splice(u, 1)
                }
                ,
                e.clear = function(o) {
                    return o.table = {},
                    o.list.length = 0,
                    o.collisionStart.length = 0,
                    o.collisionActive.length = 0,
                    o.collisionEnd.length = 0,
                    o
                }
            }
            )()
        }
        , function(c, S, t) {
            var e = {};
            c.exports = e;
            var f = t(64)
              , r = t(83)
              , o = t(32)
              , a = t(84);
            (function() {
                e._restingThresh = 4,
                e._restingThreshTangent = 6,
                e._positionDampen = .9,
                e._positionWarming = .8,
                e._frictionNormalMultiplier = 5,
                e.preSolvePosition = function(n) {
                    var s, l, i;
                    for (s = 0; s < n.length; s++)
                        l = n[s],
                        l.isActive && (i = l.activeContacts.length,
                        l.collision.parentA.totalContacts += i,
                        l.collision.parentB.totalContacts += i)
                }
                ,
                e.solvePosition = function(n, s, l) {
                    var i, h, u, d, v, p, g, m, x, T, E, P, M, L, R, O, F = l * e._positionDampen;
                    for (i = 0; i < s.length; i++) {
                        var B = s[i];
                        B.previousPositionImpulse.x = B.positionImpulse.x,
                        B.previousPositionImpulse.y = B.positionImpulse.y
                    }
                    for (i = 0; i < n.length; i++)
                        d = n[i],
                        !(!d.isActive || d.isSensor) && (v = d.collision,
                        p = v.parentA,
                        g = v.parentB,
                        m = v.normal,
                        E = p.previousPositionImpulse,
                        P = g.previousPositionImpulse,
                        T = v.penetration,
                        L = P.x - E.x + T.x,
                        R = P.y - E.y + T.y,
                        h = m.x,
                        u = m.y,
                        x = h * L + u * R,
                        d.separation = x,
                        O = (x - d.slop) * F,
                        (p.isStatic || g.isStatic) && (O *= 2),
                        p.isStatic || p.isSleeping || (M = O / p.totalContacts,
                        p.positionImpulse.x += h * M,
                        p.positionImpulse.y += u * M),
                        g.isStatic || g.isSleeping || (M = O / g.totalContacts,
                        g.positionImpulse.x -= h * M,
                        g.positionImpulse.y -= u * M))
                }
                ,
                e.postSolvePosition = function(n) {
                    for (var s = 0; s < n.length; s++) {
                        var l = n[s];
                        if (l.totalContacts = 0,
                        l.positionImpulse.x !== 0 || l.positionImpulse.y !== 0) {
                            for (var i = 0; i < l.parts.length; i++) {
                                var h = l.parts[i];
                                f.translate(h.vertices, l.positionImpulse),
                                a.update(h.bounds, h.vertices, l.velocity),
                                h.position.x += l.positionImpulse.x,
                                h.position.y += l.positionImpulse.y
                            }
                            l.positionPrev.x += l.positionImpulse.x,
                            l.positionPrev.y += l.positionImpulse.y,
                            r.dot(l.positionImpulse, l.velocity) < 0 ? (l.positionImpulse.x = 0,
                            l.positionImpulse.y = 0) : (l.positionImpulse.x *= e._positionWarming,
                            l.positionImpulse.y *= e._positionWarming)
                        }
                    }
                }
                ,
                e.preSolveVelocity = function(n) {
                    var s, l, i, h, u, d, v, p, g, m, x, T, E, P, M = r._temp[0], L = r._temp[1];
                    for (s = 0; s < n.length; s++)
                        if (i = n[s],
                        !(!i.isActive || i.isSensor))
                            for (h = i.activeContacts,
                            u = i.collision,
                            d = u.parentA,
                            v = u.parentB,
                            p = u.normal,
                            g = u.tangent,
                            l = 0; l < h.length; l++)
                                m = h[l],
                                x = m.vertex,
                                T = m.normalImpulse,
                                E = m.tangentImpulse,
                                (T !== 0 || E !== 0) && (M.x = p.x * T + g.x * E,
                                M.y = p.y * T + g.y * E,
                                d.isStatic || d.isSleeping || (P = r.sub(x, d.position, L),
                                d.positionPrev.x += M.x * d.inverseMass,
                                d.positionPrev.y += M.y * d.inverseMass,
                                d.anglePrev += r.cross(P, M) * d.inverseInertia),
                                v.isStatic || v.isSleeping || (P = r.sub(x, v.position, L),
                                v.positionPrev.x -= M.x * v.inverseMass,
                                v.positionPrev.y -= M.y * v.inverseMass,
                                v.anglePrev -= r.cross(P, M) * v.inverseInertia))
                }
                ,
                e.solveVelocity = function(n, s) {
                    for (var l = s * s, i = r._temp[0], h = r._temp[1], u = r._temp[2], d = r._temp[3], v = r._temp[4], p = r._temp[5], g = 0; g < n.length; g++) {
                        var m = n[g];
                        if (!(!m.isActive || m.isSensor)) {
                            var x = m.collision
                              , T = x.parentA
                              , E = x.parentB
                              , P = x.normal
                              , M = x.tangent
                              , L = m.activeContacts
                              , R = 1 / L.length;
                            T.velocity.x = T.position.x - T.positionPrev.x,
                            T.velocity.y = T.position.y - T.positionPrev.y,
                            E.velocity.x = E.position.x - E.positionPrev.x,
                            E.velocity.y = E.position.y - E.positionPrev.y,
                            T.angularVelocity = T.angle - T.anglePrev,
                            E.angularVelocity = E.angle - E.anglePrev;
                            for (var O = 0; O < L.length; O++) {
                                var F = L[O]
                                  , B = F.vertex
                                  , N = r.sub(B, T.position, h)
                                  , Y = r.sub(B, E.position, u)
                                  , z = r.add(T.velocity, r.mult(r.perp(N), T.angularVelocity), d)
                                  , W = r.add(E.velocity, r.mult(r.perp(Y), E.angularVelocity), v)
                                  , b = r.sub(z, W, p)
                                  , D = r.dot(P, b)
                                  , I = r.dot(M, b)
                                  , G = Math.abs(I)
                                  , w = o.sign(I)
                                  , U = (1 + m.restitution) * D
                                  , X = o.clamp(m.separation + D, 0, 1) * e._frictionNormalMultiplier
                                  , V = I
                                  , H = 1 / 0;
                                G > m.friction * m.frictionStatic * X * l && (H = G,
                                V = o.clamp(m.friction * w * l, -H, H));
                                var J = r.cross(N, P)
                                  , $ = r.cross(Y, P)
                                  , _ = R / (T.inverseMass + E.inverseMass + T.inverseInertia * J * J + E.inverseInertia * $ * $);
                                if (U *= _,
                                V *= _,
                                D < 0 && D * D > e._restingThresh * l)
                                    F.normalImpulse = 0;
                                else {
                                    var nt = F.normalImpulse;
                                    F.normalImpulse = Math.min(F.normalImpulse + U, 0),
                                    U = F.normalImpulse - nt
                                }
                                if (I * I > e._restingThreshTangent * l)
                                    F.tangentImpulse = 0;
                                else {
                                    var K = F.tangentImpulse;
                                    F.tangentImpulse = o.clamp(F.tangentImpulse + V, -H, H),
                                    V = F.tangentImpulse - K
                                }
                                i.x = P.x * U + M.x * V,
                                i.y = P.y * U + M.y * V,
                                T.isStatic || T.isSleeping || (T.positionPrev.x += i.x * T.inverseMass,
                                T.positionPrev.y += i.y * T.inverseMass,
                                T.anglePrev += r.cross(N, i) * T.inverseInertia),
                                E.isStatic || E.isSleeping || (E.positionPrev.x -= i.x * E.inverseMass,
                                E.positionPrev.y -= i.y * E.inverseMass,
                                E.anglePrev -= r.cross(Y, i) * E.inverseInertia)
                            }
                        }
                    }
                }
            }
            )()
        }
        , function(c, S) {
            var t;
            t = function() {
                return this
            }();
            try {
                t = t || new Function("return this")()
            } catch {
                typeof window == "object" && (t = window)
            }
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       samme
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(276)
              , f = function(r, o, a, n) {
                for (var s = r[0], l = 1; l < r.length; l++) {
                    var i = r[l];
                    e(i, s, o, a, n),
                    s = i
                }
                return r
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(46)
              , f = function(r, o, a, n, s) {
                return e(r, "angle", o, a, n, s)
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                for (var o = 0; o < e.length; o++) {
                    var a = e[o];
                    f.call(r, a)
                }
                return e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                r === void 0 && (r = 0);
                for (var o = r; o < e.length; o++) {
                    var a = e[o]
                      , n = !0;
                    for (var s in f)
                        a[s] !== f[s] && (n = !1);
                    if (n)
                        return a
                }
                return null
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                r === void 0 && (r = 0);
                for (var o = r; o < e.length; o++) {
                    var a = e[o]
                      , n = !0;
                    for (var s in f)
                        a[s] !== f[s] && (n = !1);
                    if (n)
                        return a
                }
                return null
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(289)
              , f = t(123)
              , r = t(2)
              , o = t(1)
              , a = t(129)
              , n = new a({
                sys: {
                    queueDepthSort: o,
                    events: {
                        once: o
                    }
                }
            },0,0,1,1)
              , s = function(l, i) {
                i === void 0 && (i = {});
                var h = i.hasOwnProperty("width")
                  , u = i.hasOwnProperty("height")
                  , d = r(i, "width", -1)
                  , v = r(i, "height", -1)
                  , p = r(i, "cellWidth", 1)
                  , g = r(i, "cellHeight", p)
                  , m = r(i, "position", f.TOP_LEFT)
                  , x = r(i, "x", 0)
                  , T = r(i, "y", 0)
                  , E = 0
                  , P = 0
                  , M = d * p
                  , L = v * g;
                n.setPosition(x, T),
                n.setSize(p, g);
                for (var R = 0; R < l.length; R++)
                    if (e(l[R], n, m),
                    h && d === -1)
                        n.x += p;
                    else if (u && v === -1)
                        n.y += g;
                    else if (u && !h) {
                        if (P += g,
                        n.y += g,
                        P === L && (P = 0,
                        E += p,
                        n.y = T,
                        n.x += p,
                        E === M))
                            break
                    } else if (E += p,
                    n.x += p,
                    E === M && (E = 0,
                    P += g,
                    n.x = x,
                    n.y += g,
                    P === L))
                        break;
                return l
            };
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(18)
              , f = 2
              , r = {
                _alpha: 1,
                _alphaTL: 1,
                _alphaTR: 1,
                _alphaBL: 1,
                _alphaBR: 1,
                clearAlpha: function() {
                    return this.setAlpha(1)
                },
                setAlpha: function(o, a, n, s) {
                    return o === void 0 && (o = 1),
                    a === void 0 ? this.alpha = o : (this._alphaTL = e(o, 0, 1),
                    this._alphaTR = e(a, 0, 1),
                    this._alphaBL = e(n, 0, 1),
                    this._alphaBR = e(s, 0, 1)),
                    this
                },
                alpha: {
                    get: function() {
                        return this._alpha
                    },
                    set: function(o) {
                        var a = e(o, 0, 1);
                        this._alpha = a,
                        this._alphaTL = a,
                        this._alphaTR = a,
                        this._alphaBL = a,
                        this._alphaBR = a,
                        a === 0 ? this.renderFlags &= ~f : this.renderFlags |= f
                    }
                },
                alphaTopLeft: {
                    get: function() {
                        return this._alphaTL
                    },
                    set: function(o) {
                        var a = e(o, 0, 1);
                        this._alphaTL = a,
                        a !== 0 && (this.renderFlags |= f)
                    }
                },
                alphaTopRight: {
                    get: function() {
                        return this._alphaTR
                    },
                    set: function(o) {
                        var a = e(o, 0, 1);
                        this._alphaTR = a,
                        a !== 0 && (this.renderFlags |= f)
                    }
                },
                alphaBottomLeft: {
                    get: function() {
                        return this._alphaBL
                    },
                    set: function(o) {
                        var a = e(o, 0, 1);
                        this._alphaBL = a,
                        a !== 0 && (this.renderFlags |= f)
                    }
                },
                alphaBottomRight: {
                    get: function() {
                        return this._alphaBR
                    },
                    set: function(o) {
                        var a = e(o, 0, 1);
                        this._alphaBR = a,
                        a !== 0 && (this.renderFlags |= f)
                    }
                }
            };
            c.exports = r
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                width: 0,
                height: 0,
                displayWidth: {
                    get: function() {
                        return this.scaleX * this.width
                    },
                    set: function(e) {
                        this.scaleX = e / this.width
                    }
                },
                displayHeight: {
                    get: function() {
                        return this.scaleY * this.height
                    },
                    set: function(e) {
                        this.scaleY = e / this.height
                    }
                },
                setSize: function(e, f) {
                    return this.width = e,
                    this.height = f,
                    this
                },
                setDisplaySize: function(e, f) {
                    return this.displayWidth = e,
                    this.displayHeight = f,
                    this
                }
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                texture: null,
                frame: null,
                isCropped: !1,
                setCrop: function(e, f, r, o) {
                    if (e === void 0)
                        this.isCropped = !1;
                    else if (this.frame) {
                        if (typeof e == "number")
                            this.frame.setCropUVs(this._crop, e, f, r, o, this.flipX, this.flipY);
                        else {
                            var a = e;
                            this.frame.setCropUVs(this._crop, a.x, a.y, a.width, a.height, this.flipX, this.flipY)
                        }
                        this.isCropped = !0
                    }
                    return this
                },
                resetCropObject: function() {
                    return {
                        u0: 0,
                        v0: 0,
                        u1: 0,
                        v1: 0,
                        width: 0,
                        height: 0,
                        x: 0,
                        y: 0,
                        flipX: !1,
                        flipY: !1,
                        cx: 0,
                        cy: 0,
                        cw: 0,
                        ch: 0
                    }
                }
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                flipX: !1,
                flipY: !1,
                toggleFlipX: function() {
                    return this.flipX = !this.flipX,
                    this
                },
                toggleFlipY: function() {
                    return this.flipY = !this.flipY,
                    this
                },
                setFlipX: function(e) {
                    return this.flipX = e,
                    this
                },
                setFlipY: function(e) {
                    return this.flipY = e,
                    this
                },
                setFlip: function(e, f) {
                    return this.flipX = e,
                    this.flipY = f,
                    this
                },
                resetFlip: function() {
                    return this.flipX = !1,
                    this.flipY = !1,
                    this
                }
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(10)
              , f = t(308)
              , r = t(3)
              , o = {
                prepareBoundsOutput: function(a, n) {
                    if (n === void 0 && (n = !1),
                    this.rotation !== 0 && f(a, this.x, this.y, this.rotation),
                    n && this.parentContainer) {
                        var s = this.parentContainer.getBoundsTransformMatrix();
                        s.transformPoint(a.x, a.y, a)
                    }
                    return a
                },
                getCenter: function(a) {
                    return a === void 0 && (a = new r),
                    a.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2,
                    a.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2,
                    a
                },
                getTopLeft: function(a, n) {
                    return a || (a = new r),
                    a.x = this.x - this.displayWidth * this.originX,
                    a.y = this.y - this.displayHeight * this.originY,
                    this.prepareBoundsOutput(a, n)
                },
                getTopCenter: function(a, n) {
                    return a || (a = new r),
                    a.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2,
                    a.y = this.y - this.displayHeight * this.originY,
                    this.prepareBoundsOutput(a, n)
                },
                getTopRight: function(a, n) {
                    return a || (a = new r),
                    a.x = this.x - this.displayWidth * this.originX + this.displayWidth,
                    a.y = this.y - this.displayHeight * this.originY,
                    this.prepareBoundsOutput(a, n)
                },
                getLeftCenter: function(a, n) {
                    return a || (a = new r),
                    a.x = this.x - this.displayWidth * this.originX,
                    a.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2,
                    this.prepareBoundsOutput(a, n)
                },
                getRightCenter: function(a, n) {
                    return a || (a = new r),
                    a.x = this.x - this.displayWidth * this.originX + this.displayWidth,
                    a.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2,
                    this.prepareBoundsOutput(a, n)
                },
                getBottomLeft: function(a, n) {
                    return a || (a = new r),
                    a.x = this.x - this.displayWidth * this.originX,
                    a.y = this.y - this.displayHeight * this.originY + this.displayHeight,
                    this.prepareBoundsOutput(a, n)
                },
                getBottomCenter: function(a, n) {
                    return a || (a = new r),
                    a.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2,
                    a.y = this.y - this.displayHeight * this.originY + this.displayHeight,
                    this.prepareBoundsOutput(a, n)
                },
                getBottomRight: function(a, n) {
                    return a || (a = new r),
                    a.x = this.x - this.displayWidth * this.originX + this.displayWidth,
                    a.y = this.y - this.displayHeight * this.originY + this.displayHeight,
                    this.prepareBoundsOutput(a, n)
                },
                getBounds: function(a) {
                    a === void 0 && (a = new e);
                    var n, s, l, i, h, u, d, v;
                    if (this.parentContainer) {
                        var p = this.parentContainer.getBoundsTransformMatrix();
                        this.getTopLeft(a),
                        p.transformPoint(a.x, a.y, a),
                        n = a.x,
                        s = a.y,
                        this.getTopRight(a),
                        p.transformPoint(a.x, a.y, a),
                        l = a.x,
                        i = a.y,
                        this.getBottomLeft(a),
                        p.transformPoint(a.x, a.y, a),
                        h = a.x,
                        u = a.y,
                        this.getBottomRight(a),
                        p.transformPoint(a.x, a.y, a),
                        d = a.x,
                        v = a.y
                    } else
                        this.getTopLeft(a),
                        n = a.x,
                        s = a.y,
                        this.getTopRight(a),
                        l = a.x,
                        i = a.y,
                        this.getBottomLeft(a),
                        h = a.x,
                        u = a.y,
                        this.getBottomRight(a),
                        d = a.x,
                        v = a.y;
                    return a.x = Math.min(n, l, h, d),
                    a.y = Math.min(s, i, u, v),
                    a.width = Math.max(n, l, h, d) - a.x,
                    a.height = Math.max(s, i, u, v) - a.y,
                    a
                }
            };
            c.exports = o
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "blur"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "boot"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "contextlost"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "contextrestored"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "destroy"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "focus"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "hidden"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pause"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "postrender"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "poststep"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "prerender"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "prestep"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "ready"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "resume"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "step"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "visible"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "postrender"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "prerender"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "render"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "resize"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                _originComponent: !0,
                originX: .5,
                originY: .5,
                _displayOriginX: 0,
                _displayOriginY: 0,
                displayOriginX: {
                    get: function() {
                        return this._displayOriginX
                    },
                    set: function(e) {
                        this._displayOriginX = e,
                        this.originX = e / this.width
                    }
                },
                displayOriginY: {
                    get: function() {
                        return this._displayOriginY
                    },
                    set: function(e) {
                        this._displayOriginY = e,
                        this.originY = e / this.height
                    }
                },
                setOrigin: function(e, f) {
                    return e === void 0 && (e = .5),
                    f === void 0 && (f = e),
                    this.originX = e,
                    this.originY = f,
                    this.updateDisplayOrigin()
                },
                setOriginFromFrame: function() {
                    return !this.frame || !this.frame.customPivot ? this.setOrigin() : (this.originX = this.frame.pivotX,
                    this.originY = this.frame.pivotY,
                    this.updateDisplayOrigin())
                },
                setDisplayOrigin: function(e, f) {
                    return e === void 0 && (e = 0),
                    f === void 0 && (f = e),
                    this.displayOriginX = e,
                    this.displayOriginY = f,
                    this
                },
                updateDisplayOrigin: function() {
                    return this._displayOriginX = this.originX * this.width,
                    this._displayOriginY = this.originY * this.height,
                    this
                }
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(36)
              , f = t(99)
              , r = t(6)
              , o = t(100)
              , a = t(3)
              , n = {
                path: null,
                rotateToPath: !1,
                pathRotationOffset: 0,
                pathOffset: null,
                pathVector: null,
                pathDelta: null,
                pathTween: null,
                pathConfig: null,
                _prevDirection: o.PLAYING_FORWARD,
                setPath: function(s, l) {
                    l === void 0 && (l = this.pathConfig);
                    var i = this.pathTween;
                    return i && i.isPlaying() && i.stop(),
                    this.path = s,
                    l && this.startFollow(l),
                    this
                },
                setRotateToPath: function(s, l) {
                    return l === void 0 && (l = 0),
                    this.rotateToPath = s,
                    this.pathRotationOffset = l,
                    this
                },
                isFollowing: function() {
                    var s = this.pathTween;
                    return s && s.isPlaying()
                },
                startFollow: function(s, l) {
                    s === void 0 && (s = {}),
                    l === void 0 && (l = 0);
                    var i = this.pathTween;
                    i && i.isPlaying() && i.stop(),
                    typeof s == "number" && (s = {
                        duration: s
                    }),
                    s.from = r(s, "from", 0),
                    s.to = r(s, "to", 1);
                    var h = f(s, "positionOnPath", !1);
                    this.rotateToPath = f(s, "rotateToPath", !1),
                    this.pathRotationOffset = r(s, "rotationOffset", 0);
                    var u = r(s, "startAt", l);
                    if (u && (s.onStart = function(v) {
                        var p = v.data[0];
                        p.progress = u,
                        p.elapsed = p.duration * u;
                        var g = p.ease(p.progress);
                        p.current = p.start + (p.end - p.start) * g,
                        p.target[p.key] = p.current
                    }
                    ),
                    this.pathOffset || (this.pathOffset = new a(this.x,this.y)),
                    this.pathVector || (this.pathVector = new a),
                    this.pathDelta || (this.pathDelta = new a),
                    this.pathDelta.reset(),
                    this.pathTween = this.scene.sys.tweens.addCounter(s),
                    this.path.getStartPoint(this.pathOffset),
                    h && (this.x = this.pathOffset.x,
                    this.y = this.pathOffset.y),
                    this.pathOffset.x = this.x - this.pathOffset.x,
                    this.pathOffset.y = this.y - this.pathOffset.y,
                    this._prevDirection = o.PLAYING_FORWARD,
                    this.rotateToPath) {
                        var d = this.path.getPoint(.1);
                        this.rotation = Math.atan2(d.y - this.y, d.x - this.x) + e(this.pathRotationOffset)
                    }
                    return this.pathConfig = s,
                    this
                },
                pauseFollow: function() {
                    var s = this.pathTween;
                    return s && s.isPlaying() && s.pause(),
                    this
                },
                resumeFollow: function() {
                    var s = this.pathTween;
                    return s && s.isPaused() && s.resume(),
                    this
                },
                stopFollow: function() {
                    var s = this.pathTween;
                    return s && s.isPlaying() && s.stop(),
                    this
                },
                pathUpdate: function() {
                    var s = this.pathTween;
                    if (s) {
                        var l = s.data[0]
                          , i = this.pathDelta
                          , h = this.pathVector;
                        if (i.copy(h).negate(),
                        l.state === o.COMPLETE) {
                            this.path.getPoint(1, h),
                            i.add(h),
                            h.add(this.pathOffset),
                            this.setPosition(h.x, h.y);
                            return
                        } else if (l.state !== o.PLAYING_FORWARD && l.state !== o.PLAYING_BACKWARD)
                            return;
                        this.path.getPoint(s.getValue(), h),
                        i.add(h),
                        h.add(this.pathOffset);
                        var u = this.x
                          , d = this.y;
                        this.setPosition(h.x, h.y);
                        var v = this.x - u
                          , p = this.y - d;
                        if (v === 0 && p === 0)
                            return;
                        if (l.state !== this._prevDirection) {
                            this._prevDirection = l.state;
                            return
                        }
                        this.rotateToPath && (this.rotation = Math.atan2(p, v) + e(this.pathRotationOffset))
                    }
                }
            };
            c.exports = n
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                _sizeComponent: !0,
                width: 0,
                height: 0,
                displayWidth: {
                    get: function() {
                        return Math.abs(this.scaleX * this.frame.realWidth)
                    },
                    set: function(e) {
                        this.scaleX = e / this.frame.realWidth
                    }
                },
                displayHeight: {
                    get: function() {
                        return Math.abs(this.scaleY * this.frame.realHeight)
                    },
                    set: function(e) {
                        this.scaleY = e / this.frame.realHeight
                    }
                },
                setSizeToFrame: function(e) {
                    return e === void 0 && (e = this.frame),
                    this.width = e.realWidth,
                    this.height = e.realHeight,
                    this
                },
                setSize: function(e, f) {
                    return this.width = e,
                    this.height = f,
                    this
                },
                setDisplaySize: function(e, f) {
                    return this.displayWidth = e,
                    this.displayHeight = f,
                    this
                }
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = 8
              , e = {
                texture: null,
                frame: null,
                isCropped: !1,
                setTexture: function(f, r) {
                    return this.texture = this.scene.sys.textures.get(f),
                    this.setFrame(r)
                },
                setFrame: function(f, r, o) {
                    return r === void 0 && (r = !0),
                    o === void 0 && (o = !0),
                    this.frame = this.texture.get(f),
                    !this.frame.cutWidth || !this.frame.cutHeight ? this.renderFlags &= ~t : this.renderFlags |= t,
                    this._sizeComponent && r && this.setSizeToFrame(),
                    this._originComponent && o && (this.frame.customPivot ? this.setOrigin(this.frame.pivotX, this.frame.pivotY) : this.updateDisplayOrigin()),
                    this
                }
            };
            c.exports = e
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = 8
              , e = {
                texture: null,
                frame: null,
                isCropped: !1,
                setCrop: function(f, r, o, a) {
                    if (f === void 0)
                        this.isCropped = !1;
                    else if (this.frame) {
                        if (typeof f == "number")
                            this.frame.setCropUVs(this._crop, f, r, o, a, this.flipX, this.flipY);
                        else {
                            var n = f;
                            this.frame.setCropUVs(this._crop, n.x, n.y, n.width, n.height, this.flipX, this.flipY)
                        }
                        this.isCropped = !0
                    }
                    return this
                },
                setTexture: function(f, r) {
                    return this.texture = this.scene.sys.textures.get(f),
                    this.setFrame(r)
                },
                setFrame: function(f, r, o) {
                    return r === void 0 && (r = !0),
                    o === void 0 && (o = !0),
                    this.frame = this.texture.get(f),
                    !this.frame.cutWidth || !this.frame.cutHeight ? this.renderFlags &= ~t : this.renderFlags |= t,
                    this._sizeComponent && r && this.setSizeToFrame(),
                    this._originComponent && o && (this.frame.customPivot ? this.setOrigin(this.frame.pivotX, this.frame.pivotY) : this.updateDisplayOrigin()),
                    this.isCropped && this.frame.updateCropUVs(this._crop, this.flipX, this.flipY),
                    this
                },
                resetCropObject: function() {
                    return {
                        u0: 0,
                        v0: 0,
                        u1: 0,
                        v1: 0,
                        width: 0,
                        height: 0,
                        x: 0,
                        y: 0,
                        flipX: !1,
                        flipY: !1,
                        cx: 0,
                        cy: 0,
                        cw: 0,
                        ch: 0
                    }
                }
            };
            c.exports = e
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                tintTopLeft: 16777215,
                tintTopRight: 16777215,
                tintBottomLeft: 16777215,
                tintBottomRight: 16777215,
                tintFill: !1,
                clearTint: function() {
                    return this.setTint(16777215),
                    this
                },
                setTint: function(e, f, r, o) {
                    return e === void 0 && (e = 16777215),
                    f === void 0 && (f = e,
                    r = e,
                    o = e),
                    this.tintTopLeft = e,
                    this.tintTopRight = f,
                    this.tintBottomLeft = r,
                    this.tintBottomRight = o,
                    this.tintFill = !1,
                    this
                },
                setTintFill: function(e, f, r, o) {
                    return this.setTint(e, f, r, o),
                    this.tintFill = !0,
                    this
                },
                tint: {
                    set: function(e) {
                        this.setTint(e, e, e, e)
                    }
                },
                isTinted: {
                    get: function() {
                        var e = 16777215;
                        return this.tintFill || this.tintTopLeft !== e || this.tintTopRight !== e || this.tintBottomLeft !== e || this.tintBottomRight !== e
                    }
                }
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "changedata"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "changedata-"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "destroy"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "removedata"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "setdata"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "addedtoscene"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "destroy"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "removedfromscene"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "complete"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "created"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "error"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "loop"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "play"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "seeked"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "seeking"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "stop"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "timeout"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "unlocked"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "addedtoscene"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "boot"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "create"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "destroy"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pause"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "postupdate"
        }
        , function(c, S) {
            /**
 * @author       samme
 * @copyright    2021 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "prerender"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "preupdate"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "ready"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "removedfromscene"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "render"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "resume"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "shutdown"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "sleep"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "start"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "transitioncomplete"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "transitioninit"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "transitionout"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "transitionstart"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "transitionwake"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "update"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "wake"
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(46)
              , f = function(r, o, a, n, s) {
                return e(r, "alpha", o, a, n, s)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(46)
              , f = function(r, o, a, n, s) {
                return e(r, "x", o, a, n, s)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(46)
              , f = function(r, o, a, n, s, l, i) {
                return a == null && (a = o),
                e(r, "x", o, n, l, i),
                e(r, "y", a, s, l, i)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(46)
              , f = function(r, o, a, n, s) {
                return e(r, "y", o, a, n, s)
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                r === void 0 && (r = 0),
                o === void 0 && (o = 6.28);
                for (var a = r, n = (o - r) / e.length, s = 0; s < e.length; s++)
                    e[s].x = f.x + f.radius * Math.cos(a),
                    e[s].y = f.y + f.radius * Math.sin(a),
                    a += n;
                return e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                r === void 0 && (r = 0),
                o === void 0 && (o = 6.28);
                for (var a = r, n = (o - r) / e.length, s = f.width / 2, l = f.height / 2, i = 0; i < e.length; i++)
                    e[i].x = f.x + s * Math.cos(a),
                    e[i].y = f.y + l * Math.sin(a),
                    a += n;
                return e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(172)
              , f = function(r, o) {
                for (var a = e(o, r.length), n = 0; n < r.length; n++) {
                    var s = r[n]
                      , l = a[n];
                    s.x = l.x,
                    s.y = l.y
                }
                return r
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(316)
              , f = t(178)
              , r = t(179)
              , o = function(a, n, s) {
                s === void 0 && (s = 0);
                var l = e(n, !1, a.length);
                s > 0 ? f(l, s) : s < 0 && r(l, Math.abs(s));
                for (var i = 0; i < a.length; i++)
                    a[i].x = l[i].x,
                    a[i].y = l[i].y;
                return a
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(317)
              , f = function(r, o, a) {
                var n = e({
                    x1: o.x1,
                    y1: o.y1,
                    x2: o.x2,
                    y2: o.y2
                }, a)
                  , s = e({
                    x1: o.x2,
                    y1: o.y2,
                    x2: o.x3,
                    y2: o.y3
                }, a)
                  , l = e({
                    x1: o.x3,
                    y1: o.y3,
                    x2: o.x1,
                    y2: o.y1
                }, a);
                n.pop(),
                s.pop(),
                l.pop(),
                n = n.concat(s, l);
                for (var i = n.length / r.length, h = 0, u = 0; u < r.length; u++) {
                    var d = r[u]
                      , v = n[Math.floor(h)];
                    d.x = v.x,
                    d.y = v.y,
                    h += i
                }
                return r
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                for (var o = 0; o < e.length; o++) {
                    var a = e[o];
                    a.anims && a.anims.play(f, r)
                }
                return e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(170)
              , f = function(r, o) {
                for (var a = 0; a < r.length; a++)
                    e(o, r[a]);
                return r
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(180)
              , f = function(r, o) {
                for (var a = 0; a < r.length; a++)
                    e(o, r[a]);
                return r
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(173)
              , f = function(r, o) {
                for (var a = 0; a < r.length; a++)
                    e(o, r[a]);
                return r
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(174)
              , f = function(r, o) {
                for (var a = 0; a < r.length; a++)
                    e(o, r[a]);
                return r
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(181)
              , f = function(r, o) {
                for (var a = 0; a < r.length; a++)
                    e(o, r[a]);
                return r
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(46)
              , f = function(r, o, a, n, s) {
                return e(r, "rotation", o, a, n, s)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(182)
              , f = t(50)
              , r = function(o, a, n) {
                for (var s = a.x, l = a.y, i = 0; i < o.length; i++) {
                    var h = o[i];
                    e(h, s, l, n, Math.max(1, f(h.x, h.y, s, l)))
                }
                return o
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(182)
              , f = function(r, o, a, n) {
                var s = o.x
                  , l = o.y;
                if (n === 0)
                    return r;
                for (var i = 0; i < r.length; i++)
                    e(r[i], s, l, a, n);
                return r
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(46)
              , f = function(r, o, a, n, s) {
                return e(r, "scaleX", o, a, n, s)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(46)
              , f = function(r, o, a, n, s, l, i) {
                return a == null && (a = o),
                e(r, "scaleX", o, n, l, i),
                e(r, "scaleY", a, s, l, i)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(46)
              , f = function(r, o, a, n, s) {
                return e(r, "scaleY", o, a, n, s)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(27)
              , f = function(r, o, a, n, s) {
                return e(r, "alpha", o, a, n, s)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(27)
              , f = function(r, o, a, n) {
                return e(r, "blendMode", o, 0, a, n)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(27)
              , f = function(r, o, a, n, s) {
                return e(r, "depth", o, a, n, s)
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                for (var o = 0; o < e.length; o++)
                    e[o].setInteractive(f, r);
                return e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(27)
              , f = function(r, o, a, n, s, l, i) {
                return a == null && (a = o),
                e(r, "originX", o, n, l, i),
                e(r, "originY", a, s, l, i),
                r.forEach(function(h) {
                    h.updateDisplayOrigin()
                }),
                r
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(27)
              , f = function(r, o, a, n, s) {
                return e(r, "rotation", o, a, n, s)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(27)
              , f = function(r, o, a, n, s, l, i) {
                return a == null && (a = o),
                e(r, "scaleX", o, n, l, i),
                e(r, "scaleY", a, s, l, i)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(27)
              , f = function(r, o, a, n, s) {
                return e(r, "scaleX", o, a, n, s)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(27)
              , f = function(r, o, a, n, s) {
                return e(r, "scaleY", o, a, n, s)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(27)
              , f = function(r, o, a, n, s, l, i) {
                return a == null && (a = o),
                e(r, "scrollFactorX", o, n, l, i),
                e(r, "scrollFactorY", a, s, l, i)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(27)
              , f = function(r, o, a, n, s) {
                return e(r, "scrollFactorX", o, a, n, s)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(27)
              , f = function(r, o, a, n, s) {
                return e(r, "scrollFactorY", o, a, n, s)
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o, a) {
                for (var n = 0; n < e.length; n++)
                    e[n].setTint(f, r, o, a);
                return e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(27)
              , f = function(r, o, a, n) {
                return e(r, "visible", o, 0, a, n)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(27)
              , f = function(r, o, a, n, s) {
                return e(r, "x", o, a, n, s)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(27)
              , f = function(r, o, a, n, s, l, i) {
                return a == null && (a = o),
                e(r, "x", o, n, l, i),
                e(r, "y", a, s, l, i)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(27)
              , f = function(r, o, a, n, s) {
                return e(r, "y", o, a, n, s)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(3)
              , f = function(r, o, a, n, s) {
                n === void 0 && (n = 0),
                s === void 0 && (s = new e);
                var l, i;
                if (r.length > 1) {
                    var h, u, d, v;
                    if (n === 0) {
                        var p = r.length - 1;
                        for (l = r[p].x,
                        i = r[p].y,
                        h = p - 1; h >= 0; h--)
                            v = r[h],
                            u = v.x,
                            d = v.y,
                            v.x = l,
                            v.y = i,
                            l = u,
                            i = d;
                        r[p].x = o,
                        r[p].y = a
                    } else {
                        for (l = r[0].x,
                        i = r[0].y,
                        h = 1; h < r.length; h++)
                            v = r[h],
                            u = v.x,
                            d = v.y,
                            v.x = l,
                            v.y = i,
                            l = u,
                            i = d;
                        r[0].x = o,
                        r[0].y = a
                    }
                } else
                    l = r[0].x,
                    i = r[0].y,
                    r[0].x = o,
                    r[0].y = a;
                return s.x = l,
                s.y = i,
                s
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(131)
              , f = function(r) {
                return e(r)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(183)
              , f = function(r, o, a, n, s) {
                s === void 0 && (s = !1);
                var l = Math.abs(n - a) / r.length, i;
                if (s)
                    for (i = 0; i < r.length; i++)
                        r[i][o] += e(i * l, a, n);
                else
                    for (i = 0; i < r.length; i++)
                        r[i][o] = e(i * l, a, n);
                return r
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(184)
              , f = function(r, o, a, n, s) {
                s === void 0 && (s = !1);
                var l = Math.abs(n - a) / r.length, i;
                if (s)
                    for (i = 0; i < r.length; i++)
                        r[i][o] += e(i * l, a, n);
                else
                    for (i = 0; i < r.length; i++)
                        r[i][o] = e(i * l, a, n);
                return r
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o, a) {
                a === void 0 && (a = !1);
                var n = Math.abs(o - r) / e.length, s;
                if (a)
                    for (s = 0; s < e.length; s++)
                        e[s][f] += s * n + r;
                else
                    for (s = 0; s < e.length; s++)
                        e[s][f] = s * n + r;
                return e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                for (var f = 0; f < e.length; f++)
                    e[f].visible = !e[f].visible;
                return e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       samme <samme.npm@gmail.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(68)
              , f = function(r, o, a) {
                a === void 0 && (a = 0);
                for (var n = 0; n < r.length; n++) {
                    var s = r[n];
                    s.x = e(s.x, o.left - a, o.right + a),
                    s.y = e(s.y, o.top - a, o.bottom + a)
                }
                return r
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Animation: t(185),
                AnimationFrame: t(319),
                AnimationManager: t(321),
                AnimationState: t(164),
                Events: t(132)
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "add"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "animationcomplete"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "animationcomplete-"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "animationrepeat"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "animationrestart"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "animationstart"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "animationstop"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "animationupdate"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pauseall"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "remove"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "resumeall"
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                BaseCache: t(323),
                CacheManager: t(325),
                Events: t(324)
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "add"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "remove"
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Controls: t(739),
                Scene2D: t(742)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                FixedKeyControl: t(740),
                SmoothedKeyControl: t(741)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(6)
              , r = new e({
                initialize: function(a) {
                    this.camera = f(a, "camera", null),
                    this.left = f(a, "left", null),
                    this.right = f(a, "right", null),
                    this.up = f(a, "up", null),
                    this.down = f(a, "down", null),
                    this.zoomIn = f(a, "zoomIn", null),
                    this.zoomOut = f(a, "zoomOut", null),
                    this.zoomSpeed = f(a, "zoomSpeed", .01),
                    this.minZoom = f(a, "minZoom", .001),
                    this.maxZoom = f(a, "maxZoom", 1e3),
                    this.speedX = 0,
                    this.speedY = 0;
                    var n = f(a, "speed", null);
                    typeof n == "number" ? (this.speedX = n,
                    this.speedY = n) : (this.speedX = f(a, "speed.x", 0),
                    this.speedY = f(a, "speed.y", 0)),
                    this._zoom = 0,
                    this.active = this.camera !== null
                },
                start: function() {
                    return this.active = this.camera !== null,
                    this
                },
                stop: function() {
                    return this.active = !1,
                    this
                },
                setCamera: function(o) {
                    return this.camera = o,
                    this
                },
                update: function(o) {
                    if (this.active) {
                        o === void 0 && (o = 1);
                        var a = this.camera;
                        this.up && this.up.isDown ? a.scrollY -= this.speedY * o | 0 : this.down && this.down.isDown && (a.scrollY += this.speedY * o | 0),
                        this.left && this.left.isDown ? a.scrollX -= this.speedX * o | 0 : this.right && this.right.isDown && (a.scrollX += this.speedX * o | 0),
                        this.zoomIn && this.zoomIn.isDown ? (a.zoom -= this.zoomSpeed,
                        a.zoom < this.minZoom && (a.zoom = this.minZoom)) : this.zoomOut && this.zoomOut.isDown && (a.zoom += this.zoomSpeed,
                        a.zoom > this.maxZoom && (a.zoom = this.maxZoom))
                    }
                },
                destroy: function() {
                    this.camera = null,
                    this.left = null,
                    this.right = null,
                    this.up = null,
                    this.down = null,
                    this.zoomIn = null,
                    this.zoomOut = null
                }
            });
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(6)
              , r = new e({
                initialize: function(a) {
                    this.camera = f(a, "camera", null),
                    this.left = f(a, "left", null),
                    this.right = f(a, "right", null),
                    this.up = f(a, "up", null),
                    this.down = f(a, "down", null),
                    this.zoomIn = f(a, "zoomIn", null),
                    this.zoomOut = f(a, "zoomOut", null),
                    this.zoomSpeed = f(a, "zoomSpeed", .01),
                    this.minZoom = f(a, "minZoom", .001),
                    this.maxZoom = f(a, "maxZoom", 1e3),
                    this.accelX = 0,
                    this.accelY = 0;
                    var n = f(a, "acceleration", null);
                    typeof n == "number" ? (this.accelX = n,
                    this.accelY = n) : (this.accelX = f(a, "acceleration.x", 0),
                    this.accelY = f(a, "acceleration.y", 0)),
                    this.dragX = 0,
                    this.dragY = 0;
                    var s = f(a, "drag", null);
                    typeof s == "number" ? (this.dragX = s,
                    this.dragY = s) : (this.dragX = f(a, "drag.x", 0),
                    this.dragY = f(a, "drag.y", 0)),
                    this.maxSpeedX = 0,
                    this.maxSpeedY = 0;
                    var l = f(a, "maxSpeed", null);
                    typeof l == "number" ? (this.maxSpeedX = l,
                    this.maxSpeedY = l) : (this.maxSpeedX = f(a, "maxSpeed.x", 0),
                    this.maxSpeedY = f(a, "maxSpeed.y", 0)),
                    this._speedX = 0,
                    this._speedY = 0,
                    this._zoom = 0,
                    this.active = this.camera !== null
                },
                start: function() {
                    return this.active = this.camera !== null,
                    this
                },
                stop: function() {
                    return this.active = !1,
                    this
                },
                setCamera: function(o) {
                    return this.camera = o,
                    this
                },
                update: function(o) {
                    if (this.active) {
                        o === void 0 && (o = 1);
                        var a = this.camera;
                        this._speedX > 0 ? (this._speedX -= this.dragX * o,
                        this._speedX < 0 && (this._speedX = 0)) : this._speedX < 0 && (this._speedX += this.dragX * o,
                        this._speedX > 0 && (this._speedX = 0)),
                        this._speedY > 0 ? (this._speedY -= this.dragY * o,
                        this._speedY < 0 && (this._speedY = 0)) : this._speedY < 0 && (this._speedY += this.dragY * o,
                        this._speedY > 0 && (this._speedY = 0)),
                        this.up && this.up.isDown ? (this._speedY += this.accelY,
                        this._speedY > this.maxSpeedY && (this._speedY = this.maxSpeedY)) : this.down && this.down.isDown && (this._speedY -= this.accelY,
                        this._speedY < -this.maxSpeedY && (this._speedY = -this.maxSpeedY)),
                        this.left && this.left.isDown ? (this._speedX += this.accelX,
                        this._speedX > this.maxSpeedX && (this._speedX = this.maxSpeedX)) : this.right && this.right.isDown && (this._speedX -= this.accelX,
                        this._speedX < -this.maxSpeedX && (this._speedX = -this.maxSpeedX)),
                        this.zoomIn && this.zoomIn.isDown ? this._zoom = -this.zoomSpeed : this.zoomOut && this.zoomOut.isDown ? this._zoom = this.zoomSpeed : this._zoom = 0,
                        this._speedX !== 0 && (a.scrollX -= this._speedX * o | 0),
                        this._speedY !== 0 && (a.scrollY -= this._speedY * o | 0),
                        this._zoom !== 0 && (a.zoom += this._zoom,
                        a.zoom < this.minZoom ? a.zoom = this.minZoom : a.zoom > this.maxZoom && (a.zoom = this.maxZoom))
                    }
                },
                destroy: function() {
                    this.camera = null,
                    this.left = null,
                    this.right = null,
                    this.up = null,
                    this.down = null,
                    this.zoomIn = null,
                    this.zoomOut = null
                }
            });
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Camera: t(326),
                BaseCamera: t(133),
                CameraManager: t(799),
                Effects: t(333),
                Events: t(37)
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "cameradestroy"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "camerafadeincomplete"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "camerafadeinstart"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "camerafadeoutcomplete"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "camerafadeoutstart"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "cameraflashcomplete"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "cameraflashstart"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "followupdate"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "camerapancomplete"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "camerapanstart"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "postrender"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "prerender"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "camerarotatecomplete"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "camerarotatestart"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "camerashakecomplete"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "camerashakestart"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "camerazoomcomplete"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "camerazoomstart"
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(18)
              , f = t(0)
              , r = t(37)
              , o = new f({
                initialize: function(n) {
                    this.camera = n,
                    this.isRunning = !1,
                    this.isComplete = !1,
                    this.direction = !0,
                    this.duration = 0,
                    this.red = 0,
                    this.green = 0,
                    this.blue = 0,
                    this.alpha = 0,
                    this.progress = 0,
                    this._elapsed = 0,
                    this._onUpdate,
                    this._onUpdateScope
                },
                start: function(a, n, s, l, i, h, u, d) {
                    if (a === void 0 && (a = !0),
                    n === void 0 && (n = 1e3),
                    s === void 0 && (s = 0),
                    l === void 0 && (l = 0),
                    i === void 0 && (i = 0),
                    h === void 0 && (h = !1),
                    u === void 0 && (u = null),
                    d === void 0 && (d = this.camera.scene),
                    !h && this.isRunning)
                        return this.camera;
                    this.isRunning = !0,
                    this.isComplete = !1,
                    this.duration = n,
                    this.direction = a,
                    this.progress = 0,
                    this.red = s,
                    this.green = l,
                    this.blue = i,
                    this.alpha = a ? Number.MIN_VALUE : 1,
                    this._elapsed = 0,
                    this._onUpdate = u,
                    this._onUpdateScope = d;
                    var v = a ? r.FADE_OUT_START : r.FADE_IN_START;
                    return this.camera.emit(v, this.camera, this, n, s, l, i),
                    this.camera
                },
                update: function(a, n) {
                    this.isRunning && (this._elapsed += n,
                    this.progress = e(this._elapsed / this.duration, 0, 1),
                    this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress),
                    this._elapsed < this.duration ? this.alpha = this.direction ? this.progress : 1 - this.progress : (this.alpha = this.direction ? 1 : 0,
                    this.effectComplete()))
                },
                postRenderCanvas: function(a) {
                    if (!this.isRunning && !this.isComplete)
                        return !1;
                    var n = this.camera;
                    return a.fillStyle = "rgba(" + this.red + "," + this.green + "," + this.blue + "," + this.alpha + ")",
                    a.fillRect(n.x, n.y, n.width, n.height),
                    !0
                },
                postRenderWebGL: function(a, n) {
                    if (!this.isRunning && !this.isComplete)
                        return !1;
                    var s = this.camera
                      , l = this.red / 255
                      , i = this.green / 255
                      , h = this.blue / 255;
                    return a.drawFillRect(s.x, s.y, s.width, s.height, n(h, i, l, 1), this.alpha),
                    !0
                },
                effectComplete: function() {
                    this._onUpdate = null,
                    this._onUpdateScope = null,
                    this.isRunning = !1,
                    this.isComplete = !0;
                    var a = this.direction ? r.FADE_OUT_COMPLETE : r.FADE_IN_COMPLETE;
                    this.camera.emit(a, this.camera, this)
                },
                reset: function() {
                    this.isRunning = !1,
                    this.isComplete = !1,
                    this._onUpdate = null,
                    this._onUpdateScope = null
                },
                destroy: function() {
                    this.reset(),
                    this.camera = null
                }
            });
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(18)
              , f = t(0)
              , r = t(37)
              , o = new f({
                initialize: function(n) {
                    this.camera = n,
                    this.isRunning = !1,
                    this.duration = 0,
                    this.red = 0,
                    this.green = 0,
                    this.blue = 0,
                    this.alpha = 0,
                    this.progress = 0,
                    this._elapsed = 0,
                    this._onUpdate,
                    this._onUpdateScope
                },
                start: function(a, n, s, l, i, h, u) {
                    return a === void 0 && (a = 250),
                    n === void 0 && (n = 255),
                    s === void 0 && (s = 255),
                    l === void 0 && (l = 255),
                    i === void 0 && (i = !1),
                    h === void 0 && (h = null),
                    u === void 0 && (u = this.camera.scene),
                    !i && this.isRunning ? this.camera : (this.isRunning = !0,
                    this.duration = a,
                    this.progress = 0,
                    this.red = n,
                    this.green = s,
                    this.blue = l,
                    this.alpha = 1,
                    this._elapsed = 0,
                    this._onUpdate = h,
                    this._onUpdateScope = u,
                    this.camera.emit(r.FLASH_START, this.camera, this, a, n, s, l),
                    this.camera)
                },
                update: function(a, n) {
                    this.isRunning && (this._elapsed += n,
                    this.progress = e(this._elapsed / this.duration, 0, 1),
                    this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress),
                    this._elapsed < this.duration ? this.alpha = 1 - this.progress : this.effectComplete())
                },
                postRenderCanvas: function(a) {
                    if (!this.isRunning)
                        return !1;
                    var n = this.camera;
                    return a.fillStyle = "rgba(" + this.red + "," + this.green + "," + this.blue + "," + this.alpha + ")",
                    a.fillRect(n.x, n.y, n.width, n.height),
                    !0
                },
                postRenderWebGL: function(a, n) {
                    if (!this.isRunning)
                        return !1;
                    var s = this.camera
                      , l = this.red / 255
                      , i = this.green / 255
                      , h = this.blue / 255;
                    return a.drawFillRect(s.x, s.y, s.width, s.height, n(h, i, l, 1), this.alpha),
                    !0
                },
                effectComplete: function() {
                    this._onUpdate = null,
                    this._onUpdateScope = null,
                    this.isRunning = !1,
                    this.camera.emit(r.FLASH_COMPLETE, this.camera, this)
                },
                reset: function() {
                    this.isRunning = !1,
                    this._onUpdate = null,
                    this._onUpdateScope = null
                },
                destroy: function() {
                    this.reset(),
                    this.camera = null
                }
            });
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(18)
              , f = t(0)
              , r = t(134)
              , o = t(37)
              , a = t(3)
              , n = new f({
                initialize: function(l) {
                    this.camera = l,
                    this.isRunning = !1,
                    this.duration = 0,
                    this.source = new a,
                    this.current = new a,
                    this.destination = new a,
                    this.ease,
                    this.progress = 0,
                    this._elapsed = 0,
                    this._onUpdate,
                    this._onUpdateScope
                },
                start: function(s, l, i, h, u, d, v) {
                    i === void 0 && (i = 1e3),
                    h === void 0 && (h = r.Linear),
                    u === void 0 && (u = !1),
                    d === void 0 && (d = null),
                    v === void 0 && (v = this.camera.scene);
                    var p = this.camera;
                    return !u && this.isRunning || (this.isRunning = !0,
                    this.duration = i,
                    this.progress = 0,
                    this.source.set(p.scrollX, p.scrollY),
                    this.destination.set(s, l),
                    p.getScroll(s, l, this.current),
                    typeof h == "string" && r.hasOwnProperty(h) ? this.ease = r[h] : typeof h == "function" && (this.ease = h),
                    this._elapsed = 0,
                    this._onUpdate = d,
                    this._onUpdateScope = v,
                    this.camera.emit(o.PAN_START, this.camera, this, i, s, l)),
                    p
                },
                update: function(s, l) {
                    if (this.isRunning) {
                        this._elapsed += l;
                        var i = e(this._elapsed / this.duration, 0, 1);
                        this.progress = i;
                        var h = this.camera;
                        if (this._elapsed < this.duration) {
                            var u = this.ease(i);
                            h.getScroll(this.destination.x, this.destination.y, this.current);
                            var d = this.source.x + (this.current.x - this.source.x) * u
                              , v = this.source.y + (this.current.y - this.source.y) * u;
                            h.setScroll(d, v),
                            this._onUpdate && this._onUpdate.call(this._onUpdateScope, h, i, d, v)
                        } else
                            h.centerOn(this.destination.x, this.destination.y),
                            this._onUpdate && this._onUpdate.call(this._onUpdateScope, h, i, h.scrollX, h.scrollY),
                            this.effectComplete()
                    }
                },
                effectComplete: function() {
                    this._onUpdate = null,
                    this._onUpdateScope = null,
                    this.isRunning = !1,
                    this.camera.emit(o.PAN_COMPLETE, this.camera, this)
                },
                reset: function() {
                    this.isRunning = !1,
                    this._onUpdate = null,
                    this._onUpdateScope = null
                },
                destroy: function() {
                    this.reset(),
                    this.camera = null,
                    this.source = null,
                    this.destination = null
                }
            });
            c.exports = n
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return f === void 0 && (f = 1.70158),
                e * e * ((f + 1) * e - f)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return f === void 0 && (f = 1.70158),
                --e * e * ((f + 1) * e + f) + 1
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                f === void 0 && (f = 1.70158);
                var r = f * 1.525;
                return (e *= 2) < 1 ? .5 * (e * e * ((r + 1) * e - r)) : .5 * ((e -= 2) * e * ((r + 1) * e + r) + 2)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e = 1 - e,
                e < .36363636363636365 ? 1 - 7.5625 * e * e : e < .7272727272727273 ? 1 - (7.5625 * (e -= .5454545454545454) * e + .75) : e < .9090909090909091 ? 1 - (7.5625 * (e -= .8181818181818182) * e + .9375) : 1 - (7.5625 * (e -= .9545454545454546) * e + .984375)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e < .36363636363636365 ? 7.5625 * e * e : e < .7272727272727273 ? 7.5625 * (e -= .5454545454545454) * e + .75 : e < .9090909090909091 ? 7.5625 * (e -= .8181818181818182) * e + .9375 : 7.5625 * (e -= .9545454545454546) * e + .984375
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                var f = !1;
                return e < .5 ? (e = 1 - e * 2,
                f = !0) : e = e * 2 - 1,
                e < .36363636363636365 ? e = 7.5625 * e * e : e < .7272727272727273 ? e = 7.5625 * (e -= .5454545454545454) * e + .75 : e < .9090909090909091 ? e = 7.5625 * (e -= .8181818181818182) * e + .9375 : e = 7.5625 * (e -= .9545454545454546) * e + .984375,
                f ? (1 - e) * .5 : e * .5 + .5
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return 1 - Math.sqrt(1 - e * e)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return Math.sqrt(1 - --e * e)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return (e *= 2) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e * e * e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return --e * e * e + 1
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return (e *= 2) < 1 ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                if (f === void 0 && (f = .1),
                r === void 0 && (r = .1),
                e === 0)
                    return 0;
                if (e === 1)
                    return 1;
                var o = r / 4;
                return f < 1 ? f = 1 : o = r * Math.asin(1 / f) / (2 * Math.PI),
                -(f * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - o) * (2 * Math.PI) / r))
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                if (f === void 0 && (f = .1),
                r === void 0 && (r = .1),
                e === 0)
                    return 0;
                if (e === 1)
                    return 1;
                var o = r / 4;
                return f < 1 ? f = 1 : o = r * Math.asin(1 / f) / (2 * Math.PI),
                f * Math.pow(2, -10 * e) * Math.sin((e - o) * (2 * Math.PI) / r) + 1
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                if (f === void 0 && (f = .1),
                r === void 0 && (r = .1),
                e === 0)
                    return 0;
                if (e === 1)
                    return 1;
                var o = r / 4;
                return f < 1 ? f = 1 : o = r * Math.asin(1 / f) / (2 * Math.PI),
                (e *= 2) < 1 ? -.5 * (f * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - o) * (2 * Math.PI) / r)) : f * Math.pow(2, -10 * (e -= 1)) * Math.sin((e - o) * (2 * Math.PI) / r) * .5 + 1
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return Math.pow(2, 10 * (e - 1)) - .001
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return 1 - Math.pow(2, -10 * e)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return (e *= 2) < 1 ? .5 * Math.pow(2, 10 * (e - 1)) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e * e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e * (2 - e)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return (e *= 2) < 1 ? .5 * e * e : -.5 * (--e * (e - 2) - 1)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e * e * e * e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return 1 - --e * e * e * e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return (e *= 2) < 1 ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e * e * e * e * e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return --e * e * e * e * e + 1
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return (e *= 2) < 1 ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e === 0 ? 0 : e === 1 ? 1 : 1 - Math.cos(e * Math.PI / 2)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e === 0 ? 0 : e === 1 ? 1 : Math.sin(e * Math.PI / 2)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e === 0 ? 0 : e === 1 ? 1 : .5 * (1 - Math.cos(Math.PI * e))
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return f === void 0 && (f = 1),
                e <= 0 ? 0 : e >= 1 ? 1 : ((f * e | 0) + 1) * (1 / f)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(18)
              , f = t(0)
              , r = t(37)
              , o = t(3)
              , a = new f({
                initialize: function(s) {
                    this.camera = s,
                    this.isRunning = !1,
                    this.duration = 0,
                    this.intensity = new o,
                    this.progress = 0,
                    this._elapsed = 0,
                    this._offsetX = 0,
                    this._offsetY = 0,
                    this._onUpdate,
                    this._onUpdateScope
                },
                start: function(n, s, l, i, h) {
                    return n === void 0 && (n = 100),
                    s === void 0 && (s = .05),
                    l === void 0 && (l = !1),
                    i === void 0 && (i = null),
                    h === void 0 && (h = this.camera.scene),
                    !l && this.isRunning ? this.camera : (this.isRunning = !0,
                    this.duration = n,
                    this.progress = 0,
                    typeof s == "number" ? this.intensity.set(s) : this.intensity.set(s.x, s.y),
                    this._elapsed = 0,
                    this._offsetX = 0,
                    this._offsetY = 0,
                    this._onUpdate = i,
                    this._onUpdateScope = h,
                    this.camera.emit(r.SHAKE_START, this.camera, this, n, s),
                    this.camera)
                },
                preRender: function() {
                    this.isRunning && this.camera.matrix.translate(this._offsetX, this._offsetY)
                },
                update: function(n, s) {
                    if (this.isRunning)
                        if (this._elapsed += s,
                        this.progress = e(this._elapsed / this.duration, 0, 1),
                        this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress),
                        this._elapsed < this.duration) {
                            var l = this.intensity
                              , i = this.camera.width
                              , h = this.camera.height
                              , u = this.camera.zoom;
                            this._offsetX = (Math.random() * l.x * i * 2 - l.x * i) * u,
                            this._offsetY = (Math.random() * l.y * h * 2 - l.y * h) * u,
                            this.camera.roundPixels && (this._offsetX = Math.round(this._offsetX),
                            this._offsetY = Math.round(this._offsetY))
                        } else
                            this.effectComplete()
                },
                effectComplete: function() {
                    this._offsetX = 0,
                    this._offsetY = 0,
                    this._onUpdate = null,
                    this._onUpdateScope = null,
                    this.isRunning = !1,
                    this.camera.emit(r.SHAKE_COMPLETE, this.camera, this)
                },
                reset: function() {
                    this.isRunning = !1,
                    this._offsetX = 0,
                    this._offsetY = 0,
                    this._onUpdate = null,
                    this._onUpdateScope = null
                },
                destroy: function() {
                    this.reset(),
                    this.camera = null,
                    this.intensity = null
                }
            });
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Jason Nicholls <nicholls.jason@gmail.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */
            var e = t(18)
              , f = t(0)
              , r = t(37)
              , o = t(134)
              , a = new f({
                initialize: function(s) {
                    this.camera = s,
                    this.isRunning = !1,
                    this.duration = 0,
                    this.source = 0,
                    this.current = 0,
                    this.destination = 0,
                    this.ease,
                    this.progress = 0,
                    this._elapsed = 0,
                    this._onUpdate,
                    this._onUpdateScope,
                    this.clockwise = !0,
                    this.shortestPath = !1
                },
                start: function(n, s, l, i, h, u, d) {
                    l === void 0 && (l = 1e3),
                    i === void 0 && (i = o.Linear),
                    h === void 0 && (h = !1),
                    u === void 0 && (u = null),
                    d === void 0 && (d = this.camera.scene),
                    s === void 0 && (s = !1),
                    this.shortestPath = s;
                    var v = n;
                    n < 0 ? (v = -1 * n,
                    this.clockwise = !1) : this.clockwise = !0;
                    var p = 360 * Math.PI / 180;
                    v = v - Math.floor(v / p) * p;
                    var g = this.camera;
                    if (!h && this.isRunning)
                        return g;
                    if (this.isRunning = !0,
                    this.duration = l,
                    this.progress = 0,
                    this.source = g.rotation,
                    this.destination = v,
                    typeof i == "string" && o.hasOwnProperty(i) ? this.ease = o[i] : typeof i == "function" && (this.ease = i),
                    this._elapsed = 0,
                    this._onUpdate = u,
                    this._onUpdateScope = d,
                    this.shortestPath) {
                        var m = 0
                          , x = 0;
                        this.destination > this.source ? m = Math.abs(this.destination - this.source) : m = Math.abs(this.destination + p) - this.source,
                        this.source > this.destination ? x = Math.abs(this.source - this.destination) : x = Math.abs(this.source + p) - this.destination,
                        m < x ? this.clockwise = !0 : m > x && (this.clockwise = !1)
                    }
                    return this.camera.emit(r.ROTATE_START, this.camera, this, l, v),
                    g
                },
                update: function(n, s) {
                    if (this.isRunning) {
                        this._elapsed += s;
                        var l = e(this._elapsed / this.duration, 0, 1);
                        this.progress = l;
                        var i = this.camera;
                        if (this._elapsed < this.duration) {
                            var h = this.ease(l);
                            this.current = i.rotation;
                            var u = 0
                              , d = 360 * Math.PI / 180
                              , v = this.destination
                              , p = this.current;
                            this.clockwise === !1 && (v = this.current,
                            p = this.destination),
                            v >= p ? u = Math.abs(v - p) : u = Math.abs(v + d) - p;
                            var g = 0;
                            this.clockwise ? g = i.rotation + u * h : g = i.rotation - u * h,
                            i.rotation = g,
                            this._onUpdate && this._onUpdate.call(this._onUpdateScope, i, l, g)
                        } else
                            i.rotation = this.destination,
                            this._onUpdate && this._onUpdate.call(this._onUpdateScope, i, l, this.destination),
                            this.effectComplete()
                    }
                },
                effectComplete: function() {
                    this._onUpdate = null,
                    this._onUpdateScope = null,
                    this.isRunning = !1,
                    this.camera.emit(r.ROTATE_COMPLETE, this.camera, this)
                },
                reset: function() {
                    this.isRunning = !1,
                    this._onUpdate = null,
                    this._onUpdateScope = null
                },
                destroy: function() {
                    this.reset(),
                    this.camera = null,
                    this.source = null,
                    this.destination = null
                }
            });
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(18)
              , f = t(0)
              , r = t(134)
              , o = t(37)
              , a = new f({
                initialize: function(s) {
                    this.camera = s,
                    this.isRunning = !1,
                    this.duration = 0,
                    this.source = 1,
                    this.destination = 1,
                    this.ease,
                    this.progress = 0,
                    this._elapsed = 0,
                    this._onUpdate,
                    this._onUpdateScope
                },
                start: function(n, s, l, i, h, u) {
                    s === void 0 && (s = 1e3),
                    l === void 0 && (l = r.Linear),
                    i === void 0 && (i = !1),
                    h === void 0 && (h = null),
                    u === void 0 && (u = this.camera.scene);
                    var d = this.camera;
                    return !i && this.isRunning || (this.isRunning = !0,
                    this.duration = s,
                    this.progress = 0,
                    this.source = d.zoom,
                    this.destination = n,
                    typeof l == "string" && r.hasOwnProperty(l) ? this.ease = r[l] : typeof l == "function" && (this.ease = l),
                    this._elapsed = 0,
                    this._onUpdate = h,
                    this._onUpdateScope = u,
                    this.camera.emit(o.ZOOM_START, this.camera, this, s, n)),
                    d
                },
                update: function(n, s) {
                    this.isRunning && (this._elapsed += s,
                    this.progress = e(this._elapsed / this.duration, 0, 1),
                    this._elapsed < this.duration ? (this.camera.zoom = this.source + (this.destination - this.source) * this.ease(this.progress),
                    this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.camera.zoom)) : (this.camera.zoom = this.destination,
                    this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.destination),
                    this.effectComplete()))
                },
                effectComplete: function() {
                    this._onUpdate = null,
                    this._onUpdateScope = null,
                    this.isRunning = !1,
                    this.camera.emit(o.ZOOM_COMPLETE, this.camera, this)
                },
                reset: function() {
                    this.isRunning = !1,
                    this._onUpdate = null,
                    this._onUpdateScope = null
                },
                destroy: function() {
                    this.reset(),
                    this.camera = null
                }
            });
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(326)
              , f = t(0)
              , r = t(2)
              , o = t(24)
              , a = t(57)
              , n = t(104)
              , s = t(20)
              , l = new f({
                initialize: function(h) {
                    this.scene = h,
                    this.systems = h.sys,
                    this.roundPixels = h.sys.game.config.roundPixels,
                    this.cameras = [],
                    this.main,
                    this.default,
                    h.sys.events.once(s.BOOT, this.boot, this),
                    h.sys.events.on(s.START, this.start, this)
                },
                boot: function() {
                    var i = this.systems;
                    i.settings.cameras ? this.fromJSON(i.settings.cameras) : this.add(),
                    this.main = this.cameras[0],
                    this.default = new e(0,0,i.scale.width,i.scale.height).setScene(this.scene),
                    i.game.scale.on(n.RESIZE, this.onResize, this),
                    this.systems.events.once(s.DESTROY, this.destroy, this)
                },
                start: function() {
                    if (!this.main) {
                        var i = this.systems;
                        i.settings.cameras ? this.fromJSON(i.settings.cameras) : this.add(),
                        this.main = this.cameras[0]
                    }
                    var h = this.systems.events;
                    h.on(s.UPDATE, this.update, this),
                    h.once(s.SHUTDOWN, this.shutdown, this)
                },
                add: function(i, h, u, d, v, p) {
                    i === void 0 && (i = 0),
                    h === void 0 && (h = 0),
                    u === void 0 && (u = this.scene.sys.scale.width),
                    d === void 0 && (d = this.scene.sys.scale.height),
                    v === void 0 && (v = !1),
                    p === void 0 && (p = "");
                    var g = new e(i,h,u,d);
                    return g.setName(p),
                    g.setScene(this.scene),
                    g.setRoundPixels(this.roundPixels),
                    g.id = this.getNextID(),
                    this.cameras.push(g),
                    v && (this.main = g),
                    g
                },
                addExisting: function(i, h) {
                    h === void 0 && (h = !1);
                    var u = this.cameras.indexOf(i);
                    return u === -1 ? (i.id = this.getNextID(),
                    i.setRoundPixels(this.roundPixels),
                    this.cameras.push(i),
                    h && (this.main = i),
                    i) : null
                },
                getNextID: function() {
                    for (var i = this.cameras, h = 1, u = 0; u < 32; u++) {
                        for (var d = !1, v = 0; v < i.length; v++) {
                            var p = i[v];
                            if (p && p.id === h) {
                                d = !0;
                                continue
                            }
                        }
                        if (d)
                            h = h << 1;
                        else
                            return h
                    }
                    return 0
                },
                getTotal: function(i) {
                    i === void 0 && (i = !1);
                    for (var h = 0, u = this.cameras, d = 0; d < u.length; d++) {
                        var v = u[d];
                        (!i || i && v.visible) && h++
                    }
                    return h
                },
                fromJSON: function(i) {
                    Array.isArray(i) || (i = [i]);
                    for (var h = this.scene.sys.scale.width, u = this.scene.sys.scale.height, d = 0; d < i.length; d++) {
                        var v = i[d]
                          , p = r(v, "x", 0)
                          , g = r(v, "y", 0)
                          , m = r(v, "width", h)
                          , x = r(v, "height", u)
                          , T = this.add(p, g, m, x);
                        T.name = r(v, "name", ""),
                        T.zoom = r(v, "zoom", 1),
                        T.rotation = r(v, "rotation", 0),
                        T.scrollX = r(v, "scrollX", 0),
                        T.scrollY = r(v, "scrollY", 0),
                        T.roundPixels = r(v, "roundPixels", !1),
                        T.visible = r(v, "visible", !0);
                        var E = r(v, "backgroundColor", !1);
                        E && T.setBackgroundColor(E);
                        var P = r(v, "bounds", null);
                        if (P) {
                            var M = r(P, "x", 0)
                              , L = r(P, "y", 0)
                              , R = r(P, "width", h)
                              , O = r(P, "height", u);
                            T.setBounds(M, L, R, O)
                        }
                    }
                    return this
                },
                getCamera: function(i) {
                    for (var h = this.cameras, u = 0; u < h.length; u++)
                        if (h[u].name === i)
                            return h[u];
                    return null
                },
                getCamerasBelowPointer: function(i) {
                    for (var h = this.cameras, u = i.x, d = i.y, v = [], p = 0; p < h.length; p++) {
                        var g = h[p];
                        g.visible && g.inputEnabled && a(g, u, d) && v.unshift(g)
                    }
                    return v
                },
                remove: function(i, h) {
                    h === void 0 && (h = !0),
                    Array.isArray(i) || (i = [i]);
                    for (var u = 0, d = this.cameras, v = 0; v < i.length; v++) {
                        var p = d.indexOf(i[v]);
                        p !== -1 && (h ? d[p].destroy() : d[p].renderList = [],
                        d.splice(p, 1),
                        u++)
                    }
                    return !this.main && d[0] && (this.main = d[0]),
                    u
                },
                render: function(i, h) {
                    for (var u = this.scene, d = this.cameras, v = 0; v < this.cameras.length; v++) {
                        var p = d[v];
                        if (p.visible && p.alpha > 0) {
                            p.preRender();
                            var g = this.getVisibleChildren(h.getChildren(), p);
                            i.render(u, g, p)
                        }
                    }
                },
                getVisibleChildren: function(i, h) {
                    for (var u = [], d = 0; d < i.length; d++) {
                        var v = i[d];
                        v.willRender(h) && u.push(v)
                    }
                    return u
                },
                resetAll: function() {
                    for (var i = 0; i < this.cameras.length; i++)
                        this.cameras[i].destroy();
                    return this.cameras = [],
                    this.main = this.add(),
                    this.main
                },
                update: function(i, h) {
                    for (var u = 0; u < this.cameras.length; u++)
                        this.cameras[u].update(i, h)
                },
                onResize: function(i, h, u, d, v) {
                    for (var p = 0; p < this.cameras.length; p++) {
                        var g = this.cameras[p];
                        g._x === 0 && g._y === 0 && g._width === d && g._height === v && g.setSize(h.width, h.height)
                    }
                },
                resize: function(i, h) {
                    for (var u = 0; u < this.cameras.length; u++)
                        this.cameras[u].setSize(i, h)
                },
                shutdown: function() {
                    this.main = void 0;
                    for (var i = 0; i < this.cameras.length; i++)
                        this.cameras[i].destroy();
                    this.cameras = [];
                    var h = this.systems.events;
                    h.off(s.UPDATE, this.update, this),
                    h.off(s.SHUTDOWN, this.shutdown, this)
                },
                destroy: function() {
                    this.shutdown(),
                    this.default.destroy(),
                    this.scene.sys.events.off(s.START, this.start, this),
                    this.scene = null,
                    this.systems = null
                }
            });
            o.register("CameraManager", l, "cameras"),
            c.exports = l
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "enterfullscreen"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "fullscreenfailed"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "fullscreenunsupported"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "leavefullscreen"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "orientationchange"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "resize"
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Config: t(346),
                CreateRenderer: t(366),
                DebugHeader: t(384),
                Events: t(22),
                TimeStep: t(385),
                VisibilityHandler: t(387)
            }
        }
        , function(c, S) {
            var t = c.exports = {}, e, f;
            function r() {
                throw new Error("setTimeout has not been defined")
            }
            function o() {
                throw new Error("clearTimeout has not been defined")
            }
            (function() {
                try {
                    typeof setTimeout == "function" ? e = setTimeout : e = r
                } catch {
                    e = r
                }
                try {
                    typeof clearTimeout == "function" ? f = clearTimeout : f = o
                } catch {
                    f = o
                }
            }
            )();
            function a(g) {
                if (e === setTimeout)
                    return setTimeout(g, 0);
                if ((e === r || !e) && setTimeout)
                    return e = setTimeout,
                    setTimeout(g, 0);
                try {
                    return e(g, 0)
                } catch {
                    try {
                        return e.call(null, g, 0)
                    } catch {
                        return e.call(this, g, 0)
                    }
                }
            }
            function n(g) {
                if (f === clearTimeout)
                    return clearTimeout(g);
                if ((f === o || !f) && clearTimeout)
                    return f = clearTimeout,
                    clearTimeout(g);
                try {
                    return f(g)
                } catch {
                    try {
                        return f.call(null, g)
                    } catch {
                        return f.call(this, g)
                    }
                }
            }
            var s = [], l = !1, i, h = -1;
            function u() {
                !l || !i || (l = !1,
                i.length ? s = i.concat(s) : h = -1,
                s.length && d())
            }
            function d() {
                if (!l) {
                    var g = a(u);
                    l = !0;
                    for (var m = s.length; m; ) {
                        for (i = s,
                        s = []; ++h < m; )
                            i && i[h].run();
                        h = -1,
                        m = s.length
                    }
                    i = null,
                    l = !1,
                    n(g)
                }
            }
            t.nextTick = function(g) {
                var m = new Array(arguments.length - 1);
                if (arguments.length > 1)
                    for (var x = 1; x < arguments.length; x++)
                        m[x - 1] = arguments[x];
                s.push(new v(g,m)),
                s.length === 1 && !l && a(d)
            }
            ;
            function v(g, m) {
                this.fun = g,
                this.array = m
            }
            v.prototype.run = function() {
                this.fun.apply(null, this.array)
            }
            ,
            t.title = "browser",
            t.browser = !0,
            t.env = {},
            t.argv = [],
            t.version = "",
            t.versions = {};
            function p() {}
            t.on = p,
            t.addListener = p,
            t.once = p,
            t.off = p,
            t.removeListener = p,
            t.removeAllListeners = p,
            t.emit = p,
            t.prependListener = p,
            t.prependOnceListener = p,
            t.listeners = function(g) {
                return []
            }
            ,
            t.binding = function(g) {
                throw new Error("process.binding is not supported")
            }
            ,
            t.cwd = function() {
                return "/"
            }
            ,
            t.chdir = function(g) {
                throw new Error("process.chdir is not supported")
            }
            ,
            t.umask = function() {
                return 0
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(136)
              , f = {
                gamepads: !1,
                mspointer: !1,
                touch: !1,
                wheelEvent: null
            };
            function r() {
                return typeof importScripts == "function" || (("ontouchstart"in document.documentElement || navigator.maxTouchPoints && navigator.maxTouchPoints >= 1) && (f.touch = !0),
                (navigator.msPointerEnabled || navigator.pointerEnabled) && (f.mspointer = !0),
                navigator.getGamepads && (f.gamepads = !0),
                "onwheel"in window || e.ie && "WheelEvent"in window ? f.wheelEvent = "wheel" : "onmousewheel"in window ? f.wheelEvent = "mousewheel" : e.firefox && "MouseScrollEvent"in window && (f.wheelEvent = "DOMMouseScroll")),
                f
            }
            c.exports = r()
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(136)
              , f = {
                audioData: !1,
                dolby: !1,
                m4a: !1,
                mp3: !1,
                ogg: !1,
                opus: !1,
                wav: !1,
                webAudio: !1,
                webm: !1
            };
            function r() {
                if (typeof importScripts == "function")
                    return f;
                f.audioData = !!window.Audio,
                f.webAudio = !!(window.AudioContext || window.webkitAudioContext);
                var o = document.createElement("audio")
                  , a = !!o.canPlayType;
                try {
                    if (a && (o.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (f.ogg = !0),
                    (o.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || o.canPlayType("audio/opus;").replace(/^no$/, "")) && (f.opus = !0),
                    o.canPlayType("audio/mpeg;").replace(/^no$/, "") && (f.mp3 = !0),
                    o.canPlayType("audio/wav").replace(/^no$/, "") && (f.wav = !0),
                    (o.canPlayType("audio/x-m4a;") || o.canPlayType("audio/aac;").replace(/^no$/, "")) && (f.m4a = !0),
                    o.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "") && (f.webm = !0),
                    o.canPlayType('audio/mp4;codecs="ec-3"') !== "")) {
                        if (e.edge)
                            f.dolby = !0;
                        else if (e.safari && e.safariVersion >= 9 && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) {
                            var n = parseInt(RegExp.$1, 10)
                              , s = parseInt(RegExp.$2, 10);
                            (n === 10 && s >= 11 || n > 10) && (f.dolby = !0)
                        }
                    }
                } catch {}
                return f
            }
            c.exports = r()
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                h264: !1,
                hls: !1,
                mp4: !1,
                ogg: !1,
                vp9: !1,
                webm: !1
            };
            function e() {
                if (typeof importScripts == "function")
                    return t;
                var f = document.createElement("video")
                  , r = !!f.canPlayType;
                try {
                    r && (f.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "") && (t.ogg = !0),
                    f.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "") && (t.h264 = !0,
                    t.mp4 = !0),
                    f.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "") && (t.webm = !0),
                    f.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "") && (t.vp9 = !0),
                    f.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "") && (t.hls = !0))
                } catch {}
                return t
            }
            c.exports = e()
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                available: !1,
                cancel: "",
                keyboard: !1,
                request: ""
            };
            function e() {
                if (typeof importScripts == "function")
                    return t;
                var f, r = "Fullscreen", o = "FullScreen", a = ["request" + r, "request" + o, "webkitRequest" + r, "webkitRequest" + o, "msRequest" + r, "msRequest" + o, "mozRequest" + o, "mozRequest" + r];
                for (f = 0; f < a.length; f++)
                    if (document.documentElement[a[f]]) {
                        t.available = !0,
                        t.request = a[f];
                        break
                    }
                var n = ["cancel" + o, "exit" + r, "webkitCancel" + o, "webkitExit" + r, "msCancel" + o, "msExit" + r, "mozCancel" + o, "mozExit" + r];
                if (t.available) {
                    for (f = 0; f < n.length; f++)
                        if (document[n[f]]) {
                            t.cancel = n[f];
                            break
                        }
                }
                return window.Element && Element.ALLOW_KEYBOARD_INPUT && !/ Version\/5\.1(?:\.\d+)? Safari\//.test(navigator.userAgent) && (t.keyboard = !0),
                Object.defineProperty(t, "active", {
                    get: function() {
                        return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)
                    }
                }),
                t
            }
            c.exports = e()
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Between: t(349),
                BetweenPoints: t(350),
                BetweenPointsY: t(813),
                BetweenY: t(814),
                CounterClockwise: t(815),
                Normalize: t(351),
                Random: t(816),
                RandomDegrees: t(817),
                Reverse: t(818),
                RotateTo: t(819),
                ShortestBetween: t(820),
                Wrap: t(269),
                WrapDegrees: t(270)
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return Math.atan2(f.x - e.x, f.y - e.y)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                return Math.atan2(r - e, o - f)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(14)
              , f = function(r) {
                return r > Math.PI && (r -= e.PI2),
                Math.abs(((r + e.TAU) % e.PI2 - e.PI2) % e.PI2)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       @samme
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(137)
              , f = function() {
                return e(-Math.PI, Math.PI)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       @samme
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(137)
              , f = function() {
                return e(-180, 180)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(351)
              , f = function(r) {
                return e(r + Math.PI)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(14)
              , f = function(r, o, a) {
                return a === void 0 && (a = .05),
                r === o || (Math.abs(o - r) <= a || Math.abs(o - r) >= e.PI2 - a ? r = o : (Math.abs(o - r) > Math.PI && (o < r ? o += e.PI2 : o -= e.PI2),
                o > r ? r += a : o < r && (r -= a))),
                r
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                var r = f - e;
                if (r === 0)
                    return 0;
                var o = Math.floor((r - -180) / 360);
                return r - o * 360
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Between: t(50),
                BetweenPoints: t(352),
                BetweenPointsSquared: t(822),
                Chebyshev: t(823),
                Power: t(824),
                Snake: t(825),
                Squared: t(353)
            }
        }
        , function(c, S) {
            /**
 * @author       samme
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                var r = e.x - f.x
                  , o = e.y - f.y;
                return r * r + o * o
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       samme
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                return Math.max(Math.abs(e - r), Math.abs(f - o))
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o, a) {
                return a === void 0 && (a = 2),
                Math.sqrt(Math.pow(r - e, a) + Math.pow(o - f, a))
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       samme
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                return Math.abs(e - r) + Math.abs(f - o)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Back: t(334),
                Bounce: t(335),
                Circular: t(336),
                Cubic: t(337),
                Elastic: t(338),
                Expo: t(339),
                Linear: t(340),
                Quadratic: t(341),
                Quartic: t(342),
                Quintic: t(343),
                Sine: t(344),
                Stepped: t(345)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Ceil: t(828),
                Equal: t(124),
                Floor: t(829),
                GreaterThan: t(354),
                LessThan: t(355)
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return f === void 0 && (f = 1e-4),
                Math.ceil(e - f)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return f === void 0 && (f = 1e-4),
                Math.floor(e + f)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Bezier: t(831),
                CatmullRom: t(832),
                CubicBezier: t(358),
                Linear: t(833),
                QuadraticBezier: t(359),
                SmoothStep: t(360),
                SmootherStep: t(834)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(356)
              , f = function(r, o) {
                for (var a = 0, n = r.length - 1, s = 0; s <= n; s++)
                    a += Math.pow(1 - o, n - s) * Math.pow(o, s) * r[s] * e(n, s);
                return a
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(194)
              , f = function(r, o) {
                var a = r.length - 1
                  , n = a * o
                  , s = Math.floor(n);
                return r[0] === r[a] ? (o < 0 && (s = Math.floor(n = a * (1 + o))),
                e(n - s, r[(s - 1 + a) % a], r[s], r[(s + 1) % a], r[(s + 2) % a])) : o < 0 ? r[0] - (e(-n, r[0], r[0], r[1], r[1]) - r[0]) : o > 1 ? r[a] - (e(n - a, r[a], r[a], r[a - 1], r[a - 1]) - r[a]) : e(n - s, r[s ? s - 1 : 0], r[s], r[a < s + 1 ? a : s + 1], r[a < s + 2 ? a : s + 2])
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(135)
              , f = function(r, o) {
                var a = r.length - 1
                  , n = a * o
                  , s = Math.floor(n);
                return o < 0 ? e(r[0], r[1], n) : o > 1 ? e(r[a], r[a - 1], a - n) : e(r[s], r[s + 1 > a ? a : s + 1], n - s)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(183)
              , f = function(r, o, a) {
                return o + (a - o) * e(r, 0, 1)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                GetNext: t(361),
                IsSize: t(138),
                IsValue: t(836)
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e > 0 && (e & e - 1) === 0
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Ceil: t(139),
                Floor: t(76),
                To: t(838)
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                return r === void 0 && (r = 0),
                f === 0 ? e : (e -= r,
                e = f * Math.round(e / f),
                o ? (r + e) / f : r + e)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = new e({
                initialize: function(o) {
                    o === void 0 && (o = [(Date.now() * Math.random()).toString()]),
                    this.c = 1,
                    this.s0 = 0,
                    this.s1 = 0,
                    this.s2 = 0,
                    this.n = 0,
                    this.signs = [-1, 1],
                    o && this.init(o)
                },
                rnd: function() {
                    var r = 2091639 * this.s0 + this.c * 23283064365386963e-26;
                    return this.c = r | 0,
                    this.s0 = this.s1,
                    this.s1 = this.s2,
                    this.s2 = r - this.c,
                    this.s2
                },
                hash: function(r) {
                    var o, a = this.n;
                    r = r.toString();
                    for (var n = 0; n < r.length; n++)
                        a += r.charCodeAt(n),
                        o = .02519603282416938 * a,
                        a = o >>> 0,
                        o -= a,
                        o *= a,
                        a = o >>> 0,
                        o -= a,
                        a += o * 4294967296;
                    return this.n = a,
                    (a >>> 0) * 23283064365386963e-26
                },
                init: function(r) {
                    typeof r == "string" ? this.state(r) : this.sow(r)
                },
                sow: function(r) {
                    if (this.n = 4022871197,
                    this.s0 = this.hash(" "),
                    this.s1 = this.hash(" "),
                    this.s2 = this.hash(" "),
                    this.c = 1,
                    !!r)
                        for (var o = 0; o < r.length && r[o] != null; o++) {
                            var a = r[o];
                            this.s0 -= this.hash(a),
                            this.s0 += ~~(this.s0 < 0),
                            this.s1 -= this.hash(a),
                            this.s1 += ~~(this.s1 < 0),
                            this.s2 -= this.hash(a),
                            this.s2 += ~~(this.s2 < 0)
                        }
                },
                integer: function() {
                    return this.rnd() * 4294967296
                },
                frac: function() {
                    return this.rnd() + (this.rnd() * 2097152 | 0) * 11102230246251565e-32
                },
                real: function() {
                    return this.integer() + this.frac()
                },
                integerInRange: function(r, o) {
                    return Math.floor(this.realInRange(0, o - r + 1) + r)
                },
                between: function(r, o) {
                    return Math.floor(this.realInRange(0, o - r + 1) + r)
                },
                realInRange: function(r, o) {
                    return this.frac() * (o - r) + r
                },
                normal: function() {
                    return 1 - 2 * this.frac()
                },
                uuid: function() {
                    var r = ""
                      , o = "";
                    for (o = r = ""; r++ < 36; o += ~r % 5 | r * 3 & 4 ? (r ^ 15 ? 8 ^ this.frac() * (r ^ 20 ? 16 : 4) : 4).toString(16) : "-")
                        ;
                    return o
                },
                pick: function(r) {
                    return r[this.integerInRange(0, r.length - 1)]
                },
                sign: function() {
                    return this.pick(this.signs)
                },
                weightedPick: function(r) {
                    return r[~~(Math.pow(this.frac(), 2) * (r.length - 1) + .5)]
                },
                timestamp: function(r, o) {
                    return this.realInRange(r || 9466848e5, o || 1577862e6)
                },
                angle: function() {
                    return this.integerInRange(-180, 180)
                },
                rotation: function() {
                    return this.realInRange(-3.1415926, 3.1415926)
                },
                state: function(r) {
                    return typeof r == "string" && r.match(/^!rnd/) && (r = r.split(","),
                    this.c = parseFloat(r[1]),
                    this.s0 = parseFloat(r[2]),
                    this.s1 = parseFloat(r[3]),
                    this.s2 = parseFloat(r[4])),
                    ["!rnd", this.c, this.s0, this.s1, this.s2].join(",")
                },
                shuffle: function(r) {
                    for (var o = r.length - 1, a = o; a > 0; a--) {
                        var n = Math.floor(this.frac() * (a + 1))
                          , s = r[n];
                        r[n] = r[a],
                        r[a] = s
                    }
                    return r
                }
            });
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                for (var f = 0, r = 0; r < e.length; r++)
                    f += +e[r];
                return f / e.length
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                f === void 0 && (f = 0),
                r === void 0 && (r = 10);
                var o = Math.pow(r, -f);
                return Math.ceil(e * o) / o
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return Math.abs(e - f)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(18)
              , f = t(0)
              , r = t(69)
              , o = t(1)
              , a = new r
              , n = new f({
                initialize: function s(l, i, h, u) {
                    l === void 0 && (l = 0),
                    i === void 0 && (i = 0),
                    h === void 0 && (h = 0),
                    u === void 0 && (u = s.DefaultOrder),
                    this._x = l,
                    this._y = i,
                    this._z = h,
                    this._order = u,
                    this.onChangeCallback = o
                },
                x: {
                    get: function() {
                        return this._x
                    },
                    set: function(s) {
                        this._x = s,
                        this.onChangeCallback(this)
                    }
                },
                y: {
                    get: function() {
                        return this._y
                    },
                    set: function(s) {
                        this._y = s,
                        this.onChangeCallback(this)
                    }
                },
                z: {
                    get: function() {
                        return this._z
                    },
                    set: function(s) {
                        this._z = s,
                        this.onChangeCallback(this)
                    }
                },
                order: {
                    get: function() {
                        return this._order
                    },
                    set: function(s) {
                        this._order = s,
                        this.onChangeCallback(this)
                    }
                },
                set: function(s, l, i, h) {
                    return h === void 0 && (h = this._order),
                    this._x = s,
                    this._y = l,
                    this._z = i,
                    this._order = h,
                    this.onChangeCallback(this),
                    this
                },
                copy: function(s) {
                    return this.set(s.x, s.y, s.z, s.order)
                },
                setFromQuaternion: function(s, l, i) {
                    return l === void 0 && (l = this._order),
                    i === void 0 && (i = !1),
                    a.fromQuat(s),
                    this.setFromRotationMatrix(a, l, i)
                },
                setFromRotationMatrix: function(s, l, i) {
                    l === void 0 && (l = this._order),
                    i === void 0 && (i = !1);
                    var h = s.val
                      , u = h[0]
                      , d = h[4]
                      , v = h[8]
                      , p = h[1]
                      , g = h[5]
                      , m = h[9]
                      , x = h[2]
                      , T = h[6]
                      , E = h[10]
                      , P = 0
                      , M = 0
                      , L = 0
                      , R = .99999;
                    switch (l) {
                    case "XYZ":
                        {
                            M = Math.asin(e(v, -1, 1)),
                            Math.abs(v) < R ? (P = Math.atan2(-m, E),
                            L = Math.atan2(-d, u)) : P = Math.atan2(T, g);
                            break
                        }
                    case "YXZ":
                        {
                            P = Math.asin(-e(m, -1, 1)),
                            Math.abs(m) < R ? (M = Math.atan2(v, E),
                            L = Math.atan2(p, g)) : M = Math.atan2(-x, u);
                            break
                        }
                    case "ZXY":
                        {
                            P = Math.asin(e(T, -1, 1)),
                            Math.abs(T) < R ? (M = Math.atan2(-x, E),
                            L = Math.atan2(-d, g)) : L = Math.atan2(p, u);
                            break
                        }
                    case "ZYX":
                        {
                            M = Math.asin(-e(x, -1, 1)),
                            Math.abs(x) < R ? (P = Math.atan2(T, E),
                            L = Math.atan2(p, u)) : L = Math.atan2(-d, g);
                            break
                        }
                    case "YZX":
                        {
                            L = Math.asin(e(p, -1, 1)),
                            Math.abs(p) < R ? (P = Math.atan2(-m, g),
                            M = Math.atan2(-x, u)) : M = Math.atan2(v, E);
                            break
                        }
                    case "XZY":
                        {
                            L = Math.asin(-e(d, -1, 1)),
                            Math.abs(d) < R ? (P = Math.atan2(T, g),
                            M = Math.atan2(v, u)) : P = Math.atan2(-m, E);
                            break
                        }
                    }
                    return this._x = P,
                    this._y = M,
                    this._z = L,
                    this._order = l,
                    i && this.onChangeCallback(this),
                    this
                }
            });
            n.RotationOrders = ["XYZ", "YXZ", "ZXY", "ZYX", "YZX", "XZY"],
            n.DefaultOrder = "XYZ",
            c.exports = n
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                f === void 0 && (f = 0),
                r === void 0 && (r = 10);
                var o = Math.pow(r, -f);
                return Math.floor(e * o) / o
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return e / f / 1e3
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e == parseFloat(e) ? !(e % 2) : void 0
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e === parseFloat(e) ? !(e % 2) : void 0
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                return Math.min(e + f, r)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Vladislav Forsh <vlad@robowhale.com>
 * @copyright    2021 RoboWhale
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                var f = e.length;
                if (f === 0)
                    return 0;
                e.sort(function(o, a) {
                    return o - a
                });
                var r = Math.floor(f / 2);
                return f % 2 === 0 ? (e[r] + e[r - 1]) / 2 : e[r]
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                return Math.max(e - f, r)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                r === void 0 && (r = f + 1);
                var a = (e - f) / (r - f);
                return a > 1 ? o !== void 0 ? (a = (o - e) / (o - r),
                a < 0 && (a = 0)) : a = 1 : a < 0 && (a = 0),
                a
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                f === void 0 && (f = 1);
                var r = Math.random() * 2 * Math.PI;
                return e.x = Math.cos(r) * f,
                e.y = Math.sin(r) * f,
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                f === void 0 && (f = 1);
                var r = Math.random() * 2 * Math.PI
                  , o = Math.random() * 2 - 1
                  , a = Math.sqrt(1 - o * o) * f;
                return e.x = Math.cos(r) * a,
                e.y = Math.sin(r) * a,
                e.z = o * f,
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return f === void 0 && (f = 1),
                e.x = (Math.random() * 2 - 1) * f,
                e.y = (Math.random() * 2 - 1) * f,
                e.z = (Math.random() * 2 - 1) * f,
                e.w = (Math.random() * 2 - 1) * f,
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       samme
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o, a) {
                return e.x = f + a * Math.cos(o),
                e.y = r + a * Math.sin(o),
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                f === void 0 && (f = 0),
                r === void 0 && (r = 10);
                var o = Math.pow(r, -f);
                return Math.round(e * o) / o
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                f === void 0 && (f = 1),
                r === void 0 && (r = 1),
                o === void 0 && (o = 1),
                o *= Math.PI / e;
                for (var a = [], n = [], s = 0; s < e; s++)
                    r -= f * o,
                    f += r * o,
                    a[s] = r,
                    n[s] = f;
                return {
                    sin: n,
                    cos: a,
                    length: e
                }
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(3)
              , f = function(r, o, a, n) {
                n === void 0 && (n = new e);
                var s = 0
                  , l = 0
                  , i = o * a;
                return r > 0 && r <= i && (r > o - 1 ? (l = Math.floor(r / o),
                s = r - l * o) : s = r),
                n.set(s, l)
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                return Math.abs(e - f) <= r
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(39)
              , f = t(69)
              , r = t(365)
              , o = new f
              , a = new r
              , n = new e
              , s = function(l, i, h) {
                return a.setAxisAngle(i, h),
                o.fromRotationTranslation(a, n.set(0, 0, 0)),
                l.transformMat4(o)
            };
            c.exports = s
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "addtexture"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "onerror"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "onload"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "ready"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "removetexture"
        }
        , function(c, S) {
            c.exports = ["#define SHADER_NAME PHASER_BITMAP_MASK_FS", "", "precision mediump float;", "", "uniform vec2 uResolution;", "uniform sampler2D uMainSampler;", "uniform sampler2D uMaskSampler;", "uniform bool uInvertMaskAlpha;", "", "void main ()", "{", "    vec2 uv = gl_FragCoord.xy / uResolution;", "    vec4 mainColor = texture2D(uMainSampler, uv);", "    vec4 maskColor = texture2D(uMaskSampler, uv);", "    float alpha = mainColor.a;", "", "    if (!uInvertMaskAlpha)", "    {", "        alpha *= (maskColor.a);", "    }", "    else", "    {", "        alpha *= (1.0 - maskColor.a);", "    }", "", "    gl_FragColor = vec4(mainColor.rgb * alpha, alpha);", "}", ""].join(`
`)
        }
        , function(c, S) {
            c.exports = ["#define SHADER_NAME PHASER_BITMAP_MASK_VS", "", "precision mediump float;", "", "attribute vec2 inPosition;", "", "void main ()", "{", "    gl_Position = vec4(inPosition, 0.0, 1.0);", "}", ""].join(`
`)
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pipelineafterflush"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pipelinebeforeflush"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pipelinebind"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pipelineboot"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pipelinedestroy"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pipelinerebind"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pipelineresize"
        }
        , function(c, S) {
            c.exports = ["#define SHADER_NAME PHASER_GRAPHICS_FS", "", "precision mediump float;", "", "varying vec4 outColor;", "", "void main ()", "{", "    gl_FragColor = vec4(outColor.bgr * outColor.a, outColor.a);", "}", ""].join(`
`)
        }
        , function(c, S) {
            c.exports = ["#define SHADER_NAME PHASER_GRAPHICS_VS", "", "precision mediump float;", "", "uniform mat4 uProjectionMatrix;", "", "attribute vec2 inPosition;", "attribute vec4 inColor;", "", "varying vec4 outColor;", "", "void main ()", "{", "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);", "", "    outColor = inColor;", "}", ""].join(`
`)
        }
        , function(c, S) {
            c.exports = ["#define SHADER_NAME PHASER_LIGHT_FS", "", "precision mediump float;", "", "struct Light", "{", "    vec2 position;", "    vec3 color;", "    float intensity;", "    float radius;", "};", "", "const int kMaxLights = %LIGHT_COUNT%;", "", "uniform vec4 uCamera; /* x, y, rotation, zoom */", "uniform vec2 uResolution;", "uniform sampler2D uMainSampler;", "uniform sampler2D uNormSampler;", "uniform vec3 uAmbientLightColor;", "uniform Light uLights[kMaxLights];", "uniform mat3 uInverseRotationMatrix;", "", "varying vec2 outTexCoord;", "varying vec4 outTint;", "", "void main()", "{", "    vec3 finalColor = vec3(0.0, 0.0, 0.0);", "    vec4 color = texture2D(uMainSampler, outTexCoord) * vec4(outTint.bgr * outTint.a, outTint.a);", "    vec3 normalMap = texture2D(uNormSampler, outTexCoord).rgb;", "    vec3 normal = normalize(uInverseRotationMatrix * vec3(normalMap * 2.0 - 1.0));", "    vec2 res = vec2(min(uResolution.x, uResolution.y)) * uCamera.w;", "", "    for (int index = 0; index < kMaxLights; ++index)", "    {", "        Light light = uLights[index];", "        vec3 lightDir = vec3((light.position.xy / res) - (gl_FragCoord.xy / res), 0.1);", "        vec3 lightNormal = normalize(lightDir);", "        float distToSurf = length(lightDir) * uCamera.w;", "        float diffuseFactor = max(dot(normal, lightNormal), 0.0);", "        float radius = (light.radius / res.x * uCamera.w) * uCamera.w;", "        float attenuation = clamp(1.0 - distToSurf * distToSurf / (radius * radius), 0.0, 1.0);", "        vec3 diffuse = light.color * diffuseFactor;", "        finalColor += (attenuation * diffuse) * light.intensity;", "    }", "", "    vec4 colorOutput = vec4(uAmbientLightColor + finalColor, 1.0);", "", "    gl_FragColor = color * vec4(colorOutput.rgb * colorOutput.a, colorOutput.a);", "}", ""].join(`
`)
        }
        , function(c, S) {
            c.exports = ["#define SHADER_NAME PHASER_MULTI_FS", "", "precision mediump float;", "", "uniform sampler2D uMainSampler[%count%];", "", "varying vec2 outTexCoord;", "varying float outTexId;", "varying float outTintEffect;", "varying vec4 outTint;", "", "void main ()", "{", "    vec4 texture;", "", "    %forloop%", "", "    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);", "", "    //  Multiply texture tint", "    vec4 color = texture * texel;", "", "    if (outTintEffect == 1.0)", "    {", "        //  Solid color + texture alpha", "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);", "    }", "    else if (outTintEffect == 2.0)", "    {", "        //  Solid color, no texture", "        color = texel;", "    }", "", "    gl_FragColor = color;", "}", ""].join(`
`)
        }
        , function(c, S) {
            c.exports = ["#define SHADER_NAME PHASER_MULTI_VS", "", "precision mediump float;", "", "uniform mat4 uProjectionMatrix;", "", "attribute vec2 inPosition;", "attribute vec2 inTexCoord;", "attribute float inTexId;", "attribute float inTintEffect;", "attribute vec4 inTint;", "", "varying vec2 outTexCoord;", "varying float outTexId;", "varying float outTintEffect;", "varying vec4 outTint;", "", "void main ()", "{", "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);", "", "    outTexCoord = inTexCoord;", "    outTexId = inTexId;", "    outTint = inTint;", "    outTintEffect = inTintEffect;", "}", ""].join(`
`)
        }
        , function(c, S) {
            c.exports = ["#define SHADER_NAME PHASER_POINTLIGHT_FS", "", "precision mediump float;", "", "uniform vec2 uResolution;", "uniform float uCameraZoom;", "", "varying vec4 lightPosition;", "varying vec4 lightColor;", "varying float lightRadius;", "varying float lightAttenuation;", "", "void main ()", "{", "    vec2 center = (lightPosition.xy + 1.0) * (uResolution.xy * 0.5);", "", "    float distToSurf = length(center - gl_FragCoord.xy);", "", "    float radius = 1.0 - distToSurf / (lightRadius * uCameraZoom);", "", "    float intensity = smoothstep(0.0, 1.0, radius * lightAttenuation);", "", "    vec4 color = vec4(intensity, intensity, intensity, 0.0) * lightColor;", "", "    gl_FragColor = vec4(color.rgb * lightColor.a, color.a);", "}", ""].join(`
`)
        }
        , function(c, S) {
            c.exports = ["#define SHADER_NAME PHASER_POINTLIGHT_VS", "", "precision mediump float;", "", "uniform mat4 uProjectionMatrix;", "", "attribute vec2 inPosition;", "attribute vec2 inLightPosition;", "attribute vec4 inLightColor;", "attribute float inLightRadius;", "attribute float inLightAttenuation;", "", "varying vec4 lightPosition;", "varying vec4 lightColor;", "varying float lightRadius;", "varying float lightAttenuation;", "", "void main ()", "{", "    lightColor = inLightColor;", "    lightRadius = inLightRadius;", "    lightAttenuation = inLightAttenuation;", "    lightPosition = uProjectionMatrix * vec4(inLightPosition, 1.0, 1.0);", "", "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);", "}", ""].join(`
`)
        }
        , function(c, S) {
            c.exports = ["#define SHADER_NAME PHASER_SINGLE_FS", "", "precision mediump float;", "", "uniform sampler2D uMainSampler;", "", "varying vec2 outTexCoord;", "varying float outTintEffect;", "varying vec4 outTint;", "", "void main ()", "{", "    vec4 texture = texture2D(uMainSampler, outTexCoord);", "    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);", "", "    //  Multiply texture tint", "    vec4 color = texture * texel;", "", "    if (outTintEffect == 1.0)", "    {", "        //  Solid color + texture alpha", "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);", "    }", "    else if (outTintEffect == 2.0)", "    {", "        //  Solid color, no texture", "        color = texel;", "    }", "", "    gl_FragColor = color;", "}", ""].join(`
`)
        }
        , function(c, S) {
            c.exports = ["#define SHADER_NAME PHASER_SINGLE_VS", "", "precision mediump float;", "", "uniform mat4 uProjectionMatrix;", "", "attribute vec2 inPosition;", "attribute vec2 inTexCoord;", "attribute float inTexId;", "attribute float inTintEffect;", "attribute vec4 inTint;", "", "varying vec2 outTexCoord;", "varying float outTintEffect;", "varying vec4 outTint;", "", "void main ()", "{", "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);", "", "    outTexCoord = inTexCoord;", "    outTint = inTint;", "    outTintEffect = inTintEffect;", "}", ""].join(`
`)
        }
        , function(c, S) {
            c.exports = ["#define SHADER_NAME PHASER_ADD_BLEND_FS", "", "precision mediump float;", "", "uniform sampler2D uMainSampler1;", "uniform sampler2D uMainSampler2;", "uniform float uStrength;", "", "varying vec2 outTexCoord;", "", "void main ()", "{", "    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);", "    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);", "", "    gl_FragColor = frame1 + frame2 * uStrength;", "}", ""].join(`
`)
        }
        , function(c, S) {
            c.exports = ["#define SHADER_NAME PHASER_COLORMATRIX_FS", "", "precision mediump float;", "", "uniform sampler2D uMainSampler;", "uniform float uColorMatrix[20];", "uniform float uAlpha;", "", "varying vec2 outTexCoord;", "", "void main ()", "{", "    vec4 c = texture2D(uMainSampler, outTexCoord);", "", "    if (uAlpha == 0.0)", "    {", "        gl_FragColor = c;", "", "        return;", "    }", "", "    if (c.a > 0.0)", "    {", "        c.rgb /= c.a;", "    }", "", "    vec4 result;", "", "    result.r = (uColorMatrix[0] * c.r) + (uColorMatrix[1] * c.g) + (uColorMatrix[2] * c.b) + (uColorMatrix[3] * c.a) + uColorMatrix[4];", "    result.g = (uColorMatrix[5] * c.r) + (uColorMatrix[6] * c.g) + (uColorMatrix[7] * c.b) + (uColorMatrix[8] * c.a) + uColorMatrix[9];", "    result.b = (uColorMatrix[10] * c.r) + (uColorMatrix[11] * c.g) + (uColorMatrix[12] * c.b) + (uColorMatrix[13] * c.a) + uColorMatrix[14];", "    result.a = (uColorMatrix[15] * c.r) + (uColorMatrix[16] * c.g) + (uColorMatrix[17] * c.b) + (uColorMatrix[18] * c.a) + uColorMatrix[19];", "", "    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);", "", "    rgb *= result.a;", "", "    gl_FragColor = vec4(rgb, result.a);", "}", ""].join(`
`)
        }
        , function(c, S) {
            c.exports = ["#define SHADER_NAME PHASER_COPY_FS", "", "precision mediump float;", "", "uniform sampler2D uMainSampler;", "uniform float uBrightness;", "", "varying vec2 outTexCoord;", "", "void main ()", "{", "    gl_FragColor = texture2D(uMainSampler, outTexCoord) * uBrightness;", "}", ""].join(`
`)
        }
        , function(c, S) {
            c.exports = ["#define SHADER_NAME PHASER_LINEAR_BLEND_FS", "", "precision mediump float;", "", "uniform sampler2D uMainSampler1;", "uniform sampler2D uMainSampler2;", "uniform float uStrength;", "", "varying vec2 outTexCoord;", "", "void main ()", "{", "    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);", "    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);", "", "    gl_FragColor = mix(frame1, frame2 * uStrength, 0.5);", "}", ""].join(`
`)
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                GenerateTexture: t(388),
                Palettes: t(889)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                ARNE16: t(389),
                C64: t(890),
                CGA: t(891),
                JMP: t(892),
                MSX: t(893)
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                0: "#000",
                1: "#fff",
                2: "#8b4131",
                3: "#7bbdc5",
                4: "#8b41ac",
                5: "#6aac41",
                6: "#3931a4",
                7: "#d5de73",
                8: "#945a20",
                9: "#5a4100",
                A: "#bd736a",
                B: "#525252",
                C: "#838383",
                D: "#acee8b",
                E: "#7b73de",
                F: "#acacac"
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                0: "#000",
                1: "#2234d1",
                2: "#0c7e45",
                3: "#44aacc",
                4: "#8a3622",
                5: "#5c2e78",
                6: "#aa5c3d",
                7: "#b5b5b5",
                8: "#5e606e",
                9: "#4c81fb",
                A: "#6cd947",
                B: "#7be2f9",
                C: "#eb8a60",
                D: "#e23d69",
                E: "#ffd93f",
                F: "#fff"
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                0: "#000",
                1: "#191028",
                2: "#46af45",
                3: "#a1d685",
                4: "#453e78",
                5: "#7664fe",
                6: "#833129",
                7: "#9ec2e8",
                8: "#dc534b",
                9: "#e18d79",
                A: "#d6b97b",
                B: "#e9d8a1",
                C: "#216c4b",
                D: "#d365c8",
                E: "#afaab9",
                F: "#f5f4eb"
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                0: "#000",
                1: "#191028",
                2: "#46af45",
                3: "#a1d685",
                4: "#453e78",
                5: "#7664fe",
                6: "#833129",
                7: "#9ec2e8",
                8: "#dc534b",
                9: "#e18d79",
                A: "#d6b97b",
                B: "#e9d8a1",
                C: "#216c4b",
                D: "#d365c8",
                E: "#afaab9",
                F: "#fff"
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Path: t(895),
                MoveTo: t(393),
                CubicBezier: t(390),
                Curve: t(94),
                Ellipse: t(391),
                Line: t(392),
                QuadraticBezier: t(394),
                Spline: t(395)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(390)
              , r = t(391)
              , o = t(5)
              , a = t(392)
              , n = t(393)
              , s = t(394)
              , l = t(10)
              , i = t(395)
              , h = t(3)
              , u = t(14)
              , d = new e({
                initialize: function(p, g) {
                    p === void 0 && (p = 0),
                    g === void 0 && (g = 0),
                    this.name = "",
                    this.curves = [],
                    this.cacheLengths = [],
                    this.autoClose = !1,
                    this.startPoint = new h,
                    this._tmpVec2A = new h,
                    this._tmpVec2B = new h,
                    typeof p == "object" ? this.fromJSON(p) : this.startPoint.set(p, g)
                },
                add: function(v) {
                    return this.curves.push(v),
                    this
                },
                circleTo: function(v, p, g) {
                    return p === void 0 && (p = !1),
                    this.ellipseTo(v, v, 0, 360, p, g)
                },
                closePath: function() {
                    var v = this.curves[0].getPoint(0)
                      , p = this.curves[this.curves.length - 1].getPoint(1);
                    return v.equals(p) || this.curves.push(new a(p,v)),
                    this
                },
                cubicBezierTo: function(v, p, g, m, x, T) {
                    var E = this.getEndPoint(), P, M, L;
                    return v instanceof h ? (P = v,
                    M = p,
                    L = g) : (P = new h(g,m),
                    M = new h(x,T),
                    L = new h(v,p)),
                    this.add(new f(E,P,M,L))
                },
                quadraticBezierTo: function(v, p, g, m) {
                    var x = this.getEndPoint(), T, E;
                    return v instanceof h ? (T = v,
                    E = p) : (T = new h(g,m),
                    E = new h(v,p)),
                    this.add(new s(x,T,E))
                },
                draw: function(v, p) {
                    for (var g = 0; g < this.curves.length; g++) {
                        var m = this.curves[g];
                        m.active && m.draw(v, p)
                    }
                    return v
                },
                ellipseTo: function(v, p, g, m, x, T) {
                    var E = new r(0,0,v,p,g,m,x,T)
                      , P = this.getEndPoint(this._tmpVec2A)
                      , M = E.getStartPoint(this._tmpVec2B);
                    return P.subtract(M),
                    E.x = P.x,
                    E.y = P.y,
                    this.add(E)
                },
                fromJSON: function(v) {
                    this.curves = [],
                    this.cacheLengths = [],
                    this.startPoint.set(v.x, v.y),
                    this.autoClose = v.autoClose;
                    for (var p = 0; p < v.curves.length; p++) {
                        var g = v.curves[p];
                        switch (g.type) {
                        case "LineCurve":
                            this.add(a.fromJSON(g));
                            break;
                        case "EllipseCurve":
                            this.add(r.fromJSON(g));
                            break;
                        case "SplineCurve":
                            this.add(i.fromJSON(g));
                            break;
                        case "CubicBezierCurve":
                            this.add(f.fromJSON(g));
                            break;
                        case "QuadraticBezierCurve":
                            this.add(s.fromJSON(g));
                            break
                        }
                    }
                    return this
                },
                getBounds: function(v, p) {
                    v === void 0 && (v = new l),
                    p === void 0 && (p = 16),
                    v.x = Number.MAX_VALUE,
                    v.y = Number.MAX_VALUE;
                    for (var g = new l, m = u.MIN_SAFE_INTEGER, x = u.MIN_SAFE_INTEGER, T = 0; T < this.curves.length; T++) {
                        var E = this.curves[T];
                        E.active && (E.getBounds(g, p),
                        v.x = Math.min(v.x, g.x),
                        v.y = Math.min(v.y, g.y),
                        m = Math.max(m, g.right),
                        x = Math.max(x, g.bottom))
                    }
                    return v.right = m,
                    v.bottom = x,
                    v
                },
                getCurveLengths: function() {
                    if (this.cacheLengths.length === this.curves.length)
                        return this.cacheLengths;
                    for (var v = [], p = 0, g = 0; g < this.curves.length; g++)
                        p += this.curves[g].getLength(),
                        v.push(p);
                    return this.cacheLengths = v,
                    v
                },
                getEndPoint: function(v) {
                    return v === void 0 && (v = new h),
                    this.curves.length > 0 ? this.curves[this.curves.length - 1].getPoint(1, v) : v.copy(this.startPoint),
                    v
                },
                getLength: function() {
                    var v = this.getCurveLengths();
                    return v[v.length - 1]
                },
                getPoint: function(v, p) {
                    p === void 0 && (p = new h);
                    for (var g = v * this.getLength(), m = this.getCurveLengths(), x = 0; x < m.length; ) {
                        if (m[x] >= g) {
                            var T = m[x] - g
                              , E = this.curves[x]
                              , P = E.getLength()
                              , M = P === 0 ? 0 : 1 - T / P;
                            return E.getPointAt(M, p)
                        }
                        x++
                    }
                    return null
                },
                getPoints: function(v) {
                    v === void 0 && (v = 12);
                    for (var p = [], g, m = 0; m < this.curves.length; m++) {
                        var x = this.curves[m];
                        if (x.active)
                            for (var T = x.getResolution(v), E = x.getPoints(T), P = 0; P < E.length; P++) {
                                var M = E[P];
                                g && g.equals(M) || (p.push(M),
                                g = M)
                            }
                    }
                    return this.autoClose && p.length > 1 && !p[p.length - 1].equals(p[0]) && p.push(p[0]),
                    p
                },
                getRandomPoint: function(v) {
                    return v === void 0 && (v = new h),
                    this.getPoint(Math.random(), v)
                },
                getSpacedPoints: function(v) {
                    v === void 0 && (v = 40);
                    for (var p = [], g = 0; g <= v; g++)
                        p.push(this.getPoint(g / v));
                    return this.autoClose && p.push(p[0]),
                    p
                },
                getStartPoint: function(v) {
                    return v === void 0 && (v = new h),
                    v.copy(this.startPoint)
                },
                getTangent: function(v, p) {
                    p === void 0 && (p = new h);
                    for (var g = v * this.getLength(), m = this.getCurveLengths(), x = 0; x < m.length; ) {
                        if (m[x] >= g) {
                            var T = m[x] - g
                              , E = this.curves[x]
                              , P = E.getLength()
                              , M = P === 0 ? 0 : 1 - T / P;
                            return E.getTangentAt(M, p)
                        }
                        x++
                    }
                    return null
                },
                lineTo: function(v, p) {
                    v instanceof h ? this._tmpVec2B.copy(v) : this._tmpVec2B.set(v, p);
                    var g = this.getEndPoint(this._tmpVec2A);
                    return this.add(new a([g.x, g.y, this._tmpVec2B.x, this._tmpVec2B.y]))
                },
                splineTo: function(v) {
                    return v.unshift(this.getEndPoint()),
                    this.add(new i(v))
                },
                moveTo: function(v, p) {
                    return v instanceof h ? this.add(new n(v.x,v.y)) : this.add(new n(v,p))
                },
                toJSON: function() {
                    for (var v = [], p = 0; p < this.curves.length; p++)
                        v.push(this.curves[p].toJSON());
                    return {
                        type: "Path",
                        x: this.startPoint.x,
                        y: this.startPoint.y,
                        autoClose: this.autoClose,
                        curves: v
                    }
                },
                updateArcLengths: function() {
                    this.cacheLengths = [],
                    this.getCurveLengths()
                },
                destroy: function() {
                    this.curves.length = 0,
                    this.cacheLengths.length = 0,
                    this.startPoint = void 0
                }
            });
            o.register("path", function(v, p) {
                return new d(v,p)
            }),
            c.exports = d
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                DataManager: t(101),
                DataManagerPlugin: t(897),
                Events: t(315)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(101)
              , r = t(24)
              , o = t(20)
              , a = new e({
                Extends: f,
                initialize: function(s) {
                    f.call(this, s, s.sys.events),
                    this.scene = s,
                    this.systems = s.sys,
                    s.sys.events.once(o.BOOT, this.boot, this),
                    s.sys.events.on(o.START, this.start, this)
                },
                boot: function() {
                    this.events = this.systems.events,
                    this.events.once(o.DESTROY, this.destroy, this)
                },
                start: function() {
                    this.events.once(o.SHUTDOWN, this.shutdown, this)
                },
                shutdown: function() {
                    this.systems.events.off(o.SHUTDOWN, this.shutdown, this)
                },
                destroy: function() {
                    f.prototype.destroy.call(this),
                    this.events.off(o.START, this.start, this),
                    this.scene = null,
                    this.systems = null
                }
            });
            r.register("DataManagerPlugin", a, "data"),
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Align: t(899),
                BaseShader: t(396),
                Bounds: t(902),
                Canvas: t(906),
                Color: t(397),
                ColorMatrix: t(198),
                Masks: t(916),
                RGB: t(200)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(123)
              , f = t(17)
              , r = {
                In: t(900),
                To: t(901)
            };
            r = f(!1, r, e),
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                BottomCenter: t(290),
                BottomLeft: t(291),
                BottomRight: t(292),
                Center: t(293),
                LeftCenter: t(295),
                QuickSet: t(289),
                RightCenter: t(296),
                TopCenter: t(297),
                TopLeft: t(298),
                TopRight: t(299)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                BottomCenter: t(277),
                BottomLeft: t(278),
                BottomRight: t(279),
                LeftBottom: t(280),
                LeftCenter: t(281),
                LeftTop: t(282),
                QuickSet: t(276),
                RightBottom: t(283),
                RightCenter: t(284),
                RightTop: t(285),
                TopCenter: t(286),
                TopLeft: t(287),
                TopRight: t(288)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                CenterOn: t(294),
                GetBottom: t(42),
                GetBounds: t(903),
                GetCenterX: t(87),
                GetCenterY: t(89),
                GetLeft: t(43),
                GetOffsetX: t(904),
                GetOffsetY: t(905),
                GetRight: t(44),
                GetTop: t(45),
                SetBottom: t(55),
                SetCenterX: t(88),
                SetCenterY: t(90),
                SetLeft: t(53),
                SetRight: t(54),
                SetTop: t(52)
            }
        }
        , function(c, S, t) {
            /**
 * @author       samme
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(42)
              , f = t(43)
              , r = t(44)
              , o = t(45)
              , a = function(n, s) {
                s === void 0 && (s = {});
                var l = f(n)
                  , i = o(n);
                return s.x = l,
                s.y = i,
                s.width = r(n) - l,
                s.height = e(n) - i,
                s
            };
            c.exports = a
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e.width * e.originX
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e.height * e.originY
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                CanvasInterpolation: t(367),
                CanvasPool: t(31),
                Smoothing: t(192),
                TouchAction: t(907),
                UserSelect: t(908)
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return f === void 0 && (f = "none"),
                e.style.msTouchAction = f,
                e.style["ms-touch-action"] = f,
                e.style["touch-action"] = f,
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                f === void 0 && (f = "none");
                var r = ["-webkit-", "-khtml-", "-moz-", "-ms-", ""];
                return r.forEach(function(o) {
                    e.style[o + "user-select"] = f
                }),
                e.style["-webkit-touch-callout"] = f,
                e.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)",
                e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(103)
              , f = function(r) {
                r === void 0 && (r = 1024);
                var o = [], a = 255, n, s = 255, l = 0, i = 0;
                for (n = 0; n <= a; n++)
                    o.push({
                        r: s,
                        g: n,
                        b: i,
                        color: e(s, n, i)
                    });
                for (l = 255,
                n = a; n >= 0; n--)
                    o.push({
                        r: n,
                        g: l,
                        b: i,
                        color: e(n, l, i)
                    });
                for (s = 0,
                n = 0; n <= a; n++,
                l--)
                    o.push({
                        r: s,
                        g: l,
                        b: n,
                        color: e(s, l, n)
                    });
                for (l = 0,
                i = 255,
                n = 0; n <= a; n++,
                i--,
                s++)
                    o.push({
                        r: s,
                        g: l,
                        b: i,
                        color: e(s, l, i)
                    });
                if (r === 1024)
                    return o;
                var h = []
                  , u = 0
                  , d = 1024 / r;
                for (n = 0; n < r; n++)
                    h.push(o[Math.floor(u)]),
                    u += d;
                return h
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                var f = {
                    r: e >> 16 & 255,
                    g: e >> 8 & 255,
                    b: e & 255,
                    a: 255
                };
                return e > 16777215 && (f.a = e >>> 24),
                f
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(38)
              , f = t(399)
              , r = function(o, a, n) {
                var s = n
                  , l = n
                  , i = n;
                if (a !== 0) {
                    var h = n < .5 ? n * (1 + a) : n + a - n * a
                      , u = 2 * n - h;
                    s = f(u, h, o + 1 / 3),
                    l = f(u, h, o),
                    i = f(u, h, o - 1 / 3)
                }
                var d = new e;
                return d.setGLTo(s, l, i, 1)
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(188)
              , f = function(r, o) {
                r === void 0 && (r = 1),
                o === void 0 && (o = 1);
                for (var a = [], n = 0; n <= 359; n++)
                    a.push(e(n / 359, r, o));
                return a
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(135)
              , f = function(a, n, s, l, i, h, u, d) {
                u === void 0 && (u = 100),
                d === void 0 && (d = 0);
                var v = d / u;
                return {
                    r: e(a, l, v),
                    g: e(n, i, v),
                    b: e(s, h, v)
                }
            }
              , r = function(a, n, s, l) {
                return s === void 0 && (s = 100),
                l === void 0 && (l = 0),
                f(a.r, a.g, a.b, n.r, n.g, n.b, s, l)
            }
              , o = function(a, n, s, l, i, h) {
                return i === void 0 && (i = 100),
                h === void 0 && (h = 0),
                f(a.r, a.g, a.b, n, s, l, i, h)
            };
            c.exports = {
                RGBWithRGB: f,
                ColorWithRGB: o,
                ColorWithColor: r
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(195)
              , f = t(38)
              , r = function(o, a) {
                return o === void 0 && (o = 0),
                a === void 0 && (a = 255),
                new f(e(o, a),e(o, a),e(o, a))
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(398)
              , f = function(r, o, a, n, s) {
                return n === void 0 && (n = 255),
                s === void 0 && (s = "#"),
                s === "#" ? "#" + ((1 << 24) + (r << 16) + (o << 8) + a).toString(16).slice(1, 7) : "0x" + e(n) + e(r) + e(o) + e(a)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                BitmapMask: t(310),
                GeometryMask: t(311)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = {
                AddToDOM: t(142),
                DOMContentLoaded: t(400),
                GetInnerHeight: t(401),
                GetScreenOrientation: t(402),
                GetTarget: t(407),
                ParseXML: t(408),
                RemoveFromDOM: t(202),
                RequestAnimationFrame: t(386)
            };
            c.exports = e
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                EventEmitter: t(919)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(9)
              , r = t(24)
              , o = new e({
                Extends: f,
                initialize: function() {
                    f.call(this)
                },
                shutdown: function() {
                    this.removeAllListeners()
                },
                destroy: function() {
                    this.removeAllListeners()
                }
            });
            r.register("EventEmitter", o, "events"),
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(142)
              , f = t(321)
              , r = t(325)
              , o = t(31)
              , a = t(0)
              , n = t(346)
              , s = t(921)
              , l = t(366)
              , i = t(101)
              , h = t(384)
              , u = t(347)
              , d = t(400)
              , v = t(9)
              , p = t(22)
              , g = t(409)
              , m = t(24)
              , x = t(414)
              , T = t(415)
              , E = t(417)
              , P = t(106)
              , M = t(422)
              , L = t(385)
              , R = t(387)
              , O = t(426)
              , F = new a({
                initialize: function(N) {
                    this.config = new n(N),
                    this.renderer = null,
                    this.domContainer = null,
                    this.canvas = null,
                    this.context = null,
                    this.isBooted = !1,
                    this.isRunning = !1,
                    this.events = new v,
                    this.anims = new f(this),
                    this.textures = new M(this),
                    this.cache = new r(this),
                    this.registry = new i(this),
                    this.input = new g(this,this.config),
                    this.scene = new E(this,this.config.sceneConfig),
                    this.device = u,
                    this.scale = new T(this,this.config),
                    this.sound = null,
                    this.sound = O.create(this),
                    this.loop = new L(this,this.config.fps),
                    this.plugins = new x(this,this.config),
                    this.pendingDestroy = !1,
                    this.removeCanvas = !1,
                    this.noReturn = !1,
                    this.hasFocus = !1,
                    d(this.boot.bind(this))
                },
                boot: function() {
                    if (!m.hasCore("EventEmitter")) {
                        console.warn("Aborting. Core Plugins missing.");
                        return
                    }
                    this.isBooted = !0,
                    this.config.preBoot(this),
                    this.scale.preBoot(),
                    l(this),
                    s(this),
                    h(this),
                    e(this.canvas, this.config.parent),
                    this.textures.once(P.READY, this.texturesReady, this),
                    this.events.emit(p.BOOT)
                },
                texturesReady: function() {
                    this.events.emit(p.READY),
                    this.start()
                },
                start: function() {
                    this.isRunning = !0,
                    this.config.postBoot(this),
                    this.renderer ? this.loop.start(this.step.bind(this)) : this.loop.start(this.headlessStep.bind(this)),
                    R(this);
                    var B = this.events;
                    B.on(p.HIDDEN, this.onHidden, this),
                    B.on(p.VISIBLE, this.onVisible, this),
                    B.on(p.BLUR, this.onBlur, this),
                    B.on(p.FOCUS, this.onFocus, this)
                },
                step: function(B, N) {
                    if (this.pendingDestroy)
                        return this.runDestroy();
                    var Y = this.events;
                    Y.emit(p.PRE_STEP, B, N),
                    Y.emit(p.STEP, B, N),
                    this.scene.update(B, N),
                    Y.emit(p.POST_STEP, B, N);
                    var z = this.renderer;
                    z.preRender(),
                    Y.emit(p.PRE_RENDER, z, B, N),
                    this.scene.render(z),
                    z.postRender(),
                    Y.emit(p.POST_RENDER, z, B, N)
                },
                headlessStep: function(B, N) {
                    if (this.pendingDestroy)
                        return this.runDestroy();
                    var Y = this.events;
                    Y.emit(p.PRE_STEP, B, N),
                    Y.emit(p.STEP, B, N),
                    this.scene.update(B, N),
                    Y.emit(p.POST_STEP, B, N),
                    Y.emit(p.PRE_RENDER),
                    Y.emit(p.POST_RENDER)
                },
                onHidden: function() {
                    this.loop.pause(),
                    this.events.emit(p.PAUSE)
                },
                onVisible: function() {
                    this.loop.resume(),
                    this.events.emit(p.RESUME)
                },
                onBlur: function() {
                    this.hasFocus = !1,
                    this.loop.blur()
                },
                onFocus: function() {
                    this.hasFocus = !0,
                    this.loop.focus()
                },
                getFrame: function() {
                    return this.loop.frame
                },
                getTime: function() {
                    return this.loop.now
                },
                destroy: function(B, N) {
                    N === void 0 && (N = !1),
                    this.pendingDestroy = !0,
                    this.removeCanvas = B,
                    this.noReturn = N
                },
                runDestroy: function() {
                    this.scene.destroy(),
                    this.events.emit(p.DESTROY),
                    this.events.removeAllListeners(),
                    this.renderer && this.renderer.destroy(),
                    this.removeCanvas && this.canvas && (o.remove(this.canvas),
                    this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas)),
                    this.domContainer && this.domContainer.parentNode.removeChild(this.domContainer),
                    this.loop.destroy(),
                    this.pendingDestroy = !1
                }
            });
            c.exports = F
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(142)
              , f = function(r) {
                var o = r.config;
                if (!(!o.parent || !o.domCreateContainer)) {
                    var a = document.createElement("div");
                    a.style.cssText = ["display: block;", "width: " + r.scale.width + "px;", "height: " + r.scale.height + "px;", "padding: 0; margin: 0;", "position: absolute;", "overflow: hidden;", "pointer-events: " + o.domPointerEvents + ";", "transform: scale(1);", "transform-origin: left top;"].join(" "),
                    r.domContainer = a,
                    e(a, o.parent)
                }
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "boot"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "destroy"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "dragend"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "dragenter"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "drag"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "dragleave"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "dragover"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "dragstart"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "drop"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "gameout"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "gameover"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "gameobjectdown"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "dragend"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "dragenter"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "drag"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "dragleave"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "dragover"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "dragstart"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "drop"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "gameobjectmove"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "gameobjectout"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "gameobjectover"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pointerdown"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pointermove"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pointerout"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pointerover"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pointerup"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "wheel"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "gameobjectup"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "gameobjectwheel"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "boot"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "process"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "update"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pointerdown"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pointerdownoutside"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pointermove"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pointerout"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pointerover"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pointerup"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pointerupoutside"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "wheel"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pointerlockchange"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "preupdate"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "shutdown"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "start"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "update"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "addfile"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "complete"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "filecomplete"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "filecomplete-"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "loaderror"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "load"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "fileprogress"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "postprocess"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "progress"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "start"
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = {
                game: "game",
                renderer: "renderer",
                anims: "anims",
                cache: "cache",
                plugins: "plugins",
                registry: "registry",
                scale: "scale",
                sound: "sound",
                textures: "textures",
                events: "events",
                cameras: "cameras",
                add: "add",
                make: "make",
                scenePlugin: "scene",
                displayList: "children",
                lights: "lights",
                data: "data",
                input: "input",
                load: "load",
                time: "time",
                tweens: "tweens",
                arcadePhysics: "physics",
                impactPhysics: "impact",
                matterPhysics: "matter"
            };
            c.exports = e
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                if (!r.getElementsByTagName("TextureAtlas")) {
                    console.warn("Invalid Texture Atlas XML given");
                    return
                }
                var o = e.source[f];
                e.add("__BASE", f, 0, 0, o.width, o.height);
                for (var a = r.getElementsByTagName("SubTexture"), n, s = 0; s < a.length; s++) {
                    var l = a[s].attributes
                      , i = l.name.value
                      , h = parseInt(l.x.value, 10)
                      , u = parseInt(l.y.value, 10)
                      , d = parseInt(l.width.value, 10)
                      , v = parseInt(l.height.value, 10);
                    if (n = e.add(i, f, h, u, d, v),
                    l.frameX) {
                        var p = Math.abs(parseInt(l.frameX.value, 10))
                          , g = Math.abs(parseInt(l.frameY.value, 10))
                          , m = parseInt(l.frameWidth.value, 10)
                          , x = parseInt(l.frameHeight.value, 10);
                        n.setTrim(d, v, p, g, m, x)
                    }
                }
                return e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                var r = e.source[f];
                return e.add("__BASE", f, 0, 0, r.width, r.height),
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                var r = e.source[f];
                return e.add("__BASE", f, 0, 0, r.width, r.height),
                e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(77)
              , f = function(r, o, a) {
                if (!a.frames && !a.textures) {
                    console.warn("Invalid Texture Atlas JSON Array");
                    return
                }
                var n = r.source[o];
                r.add("__BASE", o, 0, 0, n.width, n.height);
                for (var s = Array.isArray(a.textures) ? a.textures[o].frames : a.frames, l, i = 0; i < s.length; i++) {
                    var h = s[i];
                    l = r.add(h.filename, o, h.frame.x, h.frame.y, h.frame.w, h.frame.h),
                    h.trimmed && l.setTrim(h.sourceSize.w, h.sourceSize.h, h.spriteSourceSize.x, h.spriteSourceSize.y, h.spriteSourceSize.w, h.spriteSourceSize.h),
                    h.rotated && (l.rotated = !0,
                    l.updateUVsInverted());
                    var u = h.anchor || h.pivot;
                    u && (l.customPivot = !0,
                    l.pivotX = u.x,
                    l.pivotY = u.y),
                    l.customData = e(h)
                }
                for (var d in a)
                    d !== "frames" && (Array.isArray(a[d]) ? r.customData[d] = a[d].slice(0) : r.customData[d] = a[d]);
                return r
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(77)
              , f = function(r, o, a) {
                if (!a.frames) {
                    console.warn("Invalid Texture Atlas JSON Hash given, missing 'frames' Object");
                    return
                }
                var n = r.source[o];
                r.add("__BASE", o, 0, 0, n.width, n.height);
                var s = a.frames, l;
                for (var i in s)
                    if (s.hasOwnProperty(i)) {
                        var h = s[i];
                        l = r.add(i, o, h.frame.x, h.frame.y, h.frame.w, h.frame.h),
                        h.trimmed && l.setTrim(h.sourceSize.w, h.sourceSize.h, h.spriteSourceSize.x, h.spriteSourceSize.y, h.spriteSourceSize.w, h.spriteSourceSize.h),
                        h.rotated && (l.rotated = !0,
                        l.updateUVsInverted());
                        var u = h.anchor || h.pivot;
                        u && (l.customPivot = !0,
                        l.pivotX = u.x,
                        l.pivotY = u.y),
                        l.customData = e(h)
                    }
                for (var d in a)
                    d !== "frames" && (Array.isArray(a[d]) ? r.customData[d] = a[d].slice(0) : r.customData[d] = a[d]);
                return r
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(2)
              , f = function(r, o, a, n, s, l, i) {
                var h = e(i, "frameWidth", null)
                  , u = e(i, "frameHeight", h);
                if (h === null)
                    throw new Error("TextureManager.SpriteSheet: Invalid frameWidth given.");
                var d = r.source[o];
                r.add("__BASE", o, 0, 0, d.width, d.height);
                var v = e(i, "startFrame", 0)
                  , p = e(i, "endFrame", -1)
                  , g = e(i, "margin", 0)
                  , m = e(i, "spacing", 0)
                  , x = Math.floor((s - g + m) / (h + m))
                  , T = Math.floor((l - g + m) / (u + m))
                  , E = x * T;
                E === 0 && console.warn("SpriteSheet frame dimensions will result in zero frames for texture:", r.key),
                (v > E || v < -E) && (v = 0),
                v < 0 && (v = E + v),
                p !== -1 && (E = v + (p + 1));
                for (var P = g, M = g, L = 0, R = 0, O = 0; O < E; O++) {
                    L = 0,
                    R = 0;
                    var F = P + h
                      , B = M + u;
                    F > s && (L = F - s),
                    B > l && (R = B - l),
                    r.add(O, o, a + P, n + M, h - L, u - R),
                    P += h + m,
                    P + h > s && (P = g,
                    M += u + m)
                }
                return r
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(2)
              , f = function(r, o, a) {
                var n = e(a, "frameWidth", null)
                  , s = e(a, "frameHeight", n);
                if (!n)
                    throw new Error("TextureManager.SpriteSheetFromAtlas: Invalid frameWidth given.");
                var l = r.source[0];
                r.add("__BASE", 0, 0, 0, l.width, l.height),
                e(a, "startFrame", 0),
                e(a, "endFrame", -1);
                for (var i = e(a, "margin", 0), h = e(a, "spacing", 0), u = o.cutX, d = o.cutY, v = o.cutWidth, p = o.cutHeight, g = o.realWidth, m = o.realHeight, x = Math.floor((g - i + h) / (n + h)), T = Math.floor((m - i + h) / (s + h)), E = o.x, P = n - E, M = n - (g - v - E), L = o.y, R = s - L, O = s - (m - p - L), F, B = i, N = i, Y = 0, z = o.sourceIndex, W = 0; W < T; W++) {
                    for (var b = W === 0, D = W === T - 1, I = 0; I < x; I++) {
                        var G = I === 0
                          , w = I === x - 1;
                        if (F = r.add(Y, z, u + B, d + N, n, s),
                        G || b || w || D) {
                            var U = G ? E : 0
                              , X = b ? L : 0
                              , V = 0
                              , H = 0;
                            G && (V += n - P),
                            w && (V += n - M),
                            b && (H += s - R),
                            D && (H += s - O);
                            var J = n - V
                              , $ = s - H;
                            F.cutWidth = J,
                            F.cutHeight = $,
                            F.setTrim(n, s, U, X, J, $)
                        }
                        B += h,
                        G ? B += P : w ? B += M : B += n,
                        Y++
                    }
                    B = i,
                    N += h,
                    b ? N += R : D ? N += O : N += s
                }
                return r
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = 0
              , e = function(r, o, a, n) {
                var s = t - n.y - n.height;
                r.add(a, o, n.x, s, n.width, n.height)
            }
              , f = function(r, o, a) {
                var n = r.source[o];
                r.add("__BASE", o, 0, 0, n.width, n.height),
                t = n.height;
                for (var s = a.split(`
`), l = /^[ ]*(- )*(\w+)+[: ]+(.*)/, i = "", h = "", u = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                }, d = 0; d < s.length; d++) {
                    var v = s[d].match(l);
                    if (v) {
                        var p = v[1] === "- "
                          , g = v[2]
                          , m = v[3];
                        if (p && (h !== i && (e(r, o, h, u),
                        i = h),
                        u = {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        }),
                        g === "name") {
                            h = m;
                            continue
                        }
                        switch (g) {
                        case "x":
                        case "y":
                        case "width":
                        case "height":
                            u[g] = parseInt(m, 10);
                            break
                        }
                    }
                }
                return h !== i && e(r, o, h, u),
                r
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "complete"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "decoded"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "decodedall"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "destroy"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "detune"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "detune"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "mute"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "rate"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "volume"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "loop"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "looped"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "mute"
        }
        , function(c, S) {
            /**
 * @author       pi-kei
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pan"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pauseall"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pause"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "play"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "rate"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "resumeall"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "resume"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "seek"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "stopall"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "stop"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "unlocked"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "volume"
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = {
                Events: t(75),
                DisplayList: t(1012),
                GameObjectCreator: t(16),
                GameObjectFactory: t(5),
                UpdateList: t(1040),
                Components: t(11),
                GetCalcMatrix: t(19),
                BuildGameObject: t(28),
                BuildGameObjectAnimation: t(439),
                GameObject: t(15),
                BitmapText: t(148),
                Blitter: t(213),
                Bob: t(440),
                Container: t(214),
                DOMElement: t(442),
                DynamicBitmapText: t(215),
                Extern: t(444),
                Graphics: t(216),
                Group: t(113),
                Image: t(125),
                Layer: t(219),
                Particles: t(1074),
                PathFollower: t(457),
                RenderTexture: t(221),
                RetroFont: t(1082),
                Rope: t(223),
                Sprite: t(73),
                Text: t(224),
                GetTextSize: t(458),
                MeasureText: t(460),
                TextStyle: t(459),
                TileSprite: t(225),
                Zone: t(129),
                Video: t(226),
                Shape: t(34),
                Arc: t(461),
                Curve: t(462),
                Ellipse: t(463),
                Grid: t(464),
                IsoBox: t(465),
                IsoTriangle: t(466),
                Line: t(467),
                Polygon: t(468),
                Rectangle: t(473),
                Star: t(474),
                Triangle: t(475),
                Factories: {
                    Blitter: t(1130),
                    Container: t(1131),
                    DOMElement: t(1132),
                    DynamicBitmapText: t(1133),
                    Extern: t(1134),
                    Graphics: t(1135),
                    Group: t(1136),
                    Image: t(1137),
                    Layer: t(1138),
                    Particles: t(1139),
                    PathFollower: t(1140),
                    RenderTexture: t(1141),
                    Rope: t(1142),
                    Sprite: t(1143),
                    StaticBitmapText: t(1144),
                    Text: t(1145),
                    TileSprite: t(1146),
                    Zone: t(1147),
                    Video: t(1148),
                    Arc: t(1149),
                    Curve: t(1150),
                    Ellipse: t(1151),
                    Grid: t(1152),
                    IsoBox: t(1153),
                    IsoTriangle: t(1154),
                    Line: t(1155),
                    Polygon: t(1156),
                    Rectangle: t(1157),
                    Star: t(1158),
                    Triangle: t(1159)
                },
                Creators: {
                    Blitter: t(1160),
                    Container: t(1161),
                    DynamicBitmapText: t(1162),
                    Graphics: t(1163),
                    Group: t(1164),
                    Image: t(1165),
                    Layer: t(1166),
                    Particles: t(1167),
                    RenderTexture: t(1168),
                    Rope: t(1169),
                    Sprite: t(1170),
                    StaticBitmapText: t(1171),
                    Text: t(1172),
                    TileSprite: t(1173),
                    Zone: t(1174),
                    Video: t(1175)
                }
            };
            e.Shader = t(229),
            e.Mesh = t(230),
            e.PointLight = t(150),
            e.Factories.Shader = t(1184),
            e.Factories.Mesh = t(1185),
            e.Factories.PointLight = t(1186),
            e.Creators.Shader = t(1187),
            e.Creators.Mesh = t(1188),
            e.Creators.PointLight = t(1189),
            e.Light = t(481),
            e.LightsManager = t(482),
            e.LightsPlugin = t(1190),
            c.exports = e
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(110)
              , r = t(24)
              , o = t(75)
              , a = t(20)
              , n = t(79)
              , s = new e({
                Extends: f,
                initialize: function(i) {
                    f.call(this, i),
                    this.sortChildrenFlag = !1,
                    this.scene = i,
                    this.systems = i.sys,
                    this.events = i.sys.events,
                    this.addCallback = this.addChildCallback,
                    this.removeCallback = this.removeChildCallback,
                    this.events.once(a.BOOT, this.boot, this),
                    this.events.on(a.START, this.start, this)
                },
                boot: function() {
                    this.events.once(a.DESTROY, this.destroy, this)
                },
                addChildCallback: function(l) {
                    l.displayList && l.displayList !== this && l.removeFromDisplayList(),
                    l.displayList || (this.queueDepthSort(),
                    l.displayList = this,
                    l.emit(o.ADDED_TO_SCENE, l, this.scene),
                    this.events.emit(a.ADDED_TO_SCENE, l, this.scene))
                },
                removeChildCallback: function(l) {
                    this.queueDepthSort(),
                    l.displayList = null,
                    l.emit(o.REMOVED_FROM_SCENE, l, this.scene),
                    this.events.emit(a.REMOVED_FROM_SCENE, l, this.scene)
                },
                start: function() {
                    this.events.once(a.SHUTDOWN, this.shutdown, this)
                },
                queueDepthSort: function() {
                    this.sortChildrenFlag = !0
                },
                depthSort: function() {
                    this.sortChildrenFlag && (n(this.list, this.sortByDepth),
                    this.sortChildrenFlag = !1)
                },
                sortByDepth: function(l, i) {
                    return l._depth - i._depth
                },
                getChildren: function() {
                    return this.list
                },
                shutdown: function() {
                    for (var l = this.list, i = l.length; i--; )
                        l[i].destroy(!0);
                    l.length = 0,
                    this.events.off(a.SHUTDOWN, this.shutdown, this)
                },
                destroy: function() {
                    this.shutdown(),
                    this.events.off(a.START, this.start, this),
                    this.scene = null,
                    this.systems = null,
                    this.events = null
                }
            });
            r.register("DisplayList", s, "displayList"),
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                CheckMatrix: t(209),
                MatrixToString: t(1014),
                ReverseColumns: t(1015),
                ReverseRows: t(1016),
                Rotate180: t(1017),
                RotateLeft: t(1018),
                RotateMatrix: t(147),
                RotateRight: t(1019),
                Translate: t(1020),
                TransposeMatrix: t(435)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(186)
              , f = t(209)
              , r = function(o) {
                var a = "";
                if (!f(o))
                    return a;
                for (var n = 0; n < o.length; n++) {
                    for (var s = 0; s < o[n].length; s++) {
                        var l = o[n][s].toString();
                        l !== "undefined" ? a += e(l, 2) : a += "?",
                        s < o[n].length - 1 && (a += " |")
                    }
                    if (n < o.length - 1) {
                        a += `
`;
                        for (var i = 0; i < o[n].length; i++)
                            a += "---",
                            i < o[n].length - 1 && (a += "+");
                        a += `
`
                    }
                }
                return a
            };
            c.exports = r
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e.reverse()
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                for (var f = 0; f < e.length; f++)
                    e[f].reverse();
                return e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(147)
              , f = function(r) {
                return e(r, 180)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(147)
              , f = function(r) {
                return e(r, 90)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(147)
              , f = function(r) {
                return e(r, -90)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(178)
              , f = t(179)
              , r = function(o, a, n) {
                if (a === void 0 && (a = 0),
                n === void 0 && (n = 0),
                n !== 0 && (n < 0 ? e(o, Math.abs(n)) : f(o, n)),
                a !== 0)
                    for (var s = 0; s < o.length; s++) {
                        var l = o[s];
                        a < 0 ? e(l, Math.abs(a)) : f(l, a)
                    }
                return o
            };
            c.exports = r
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o, a) {
                if (a === void 0 && (a = e),
                r > 0) {
                    var n = r - e.length;
                    if (n <= 0)
                        return null
                }
                if (!Array.isArray(f))
                    return e.indexOf(f) === -1 ? (e.push(f),
                    o && o.call(a, f),
                    f) : null;
                for (var s = f.length - 1; s >= 0; )
                    e.indexOf(f[s]) !== -1 && f.splice(s, 1),
                    s--;
                if (s = f.length,
                s === 0)
                    return null;
                r > 0 && s > n && (f.splice(n),
                s = n);
                for (var l = 0; l < s; l++) {
                    var i = f[l];
                    e.push(i),
                    o && o.call(a, i)
                }
                return f
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o, a, n) {
                if (r === void 0 && (r = 0),
                n === void 0 && (n = e),
                o > 0) {
                    var s = o - e.length;
                    if (s <= 0)
                        return null
                }
                if (!Array.isArray(f))
                    return e.indexOf(f) === -1 ? (e.splice(r, 0, f),
                    a && a.call(n, f),
                    f) : null;
                for (var l = f.length - 1; l >= 0; )
                    e.indexOf(f[l]) !== -1 && f.pop(),
                    l--;
                if (l = f.length,
                l === 0)
                    return null;
                o > 0 && l > s && (f.splice(s),
                l = s);
                for (var i = l - 1; i >= 0; i--) {
                    var h = f[i];
                    e.splice(r, 0, h),
                    a && a.call(n, h)
                }
                return f
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                var r = e.indexOf(f);
                return r !== -1 && r < e.length && (e.splice(r, 1),
                e.push(f)),
                f
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(78)
              , f = function(r, o, a, n, s) {
                n === void 0 && (n = 0),
                s === void 0 && (s = r.length);
                var l = 0;
                if (e(r, n, s))
                    for (var i = n; i < s; i++) {
                        var h = r[i];
                        h[o] === a && l++
                    }
                return l
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                var o, a = [null];
                for (o = 3; o < arguments.length; o++)
                    a.push(arguments[o]);
                for (o = 0; o < e.length; o++)
                    a[0] = e[o],
                    f.apply(r, a);
                return e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(78)
              , f = function(r, o, a, n, s) {
                if (n === void 0 && (n = 0),
                s === void 0 && (s = r.length),
                e(r, n, s)) {
                    var l, i = [null];
                    for (l = 5; l < arguments.length; l++)
                        i.push(arguments[l]);
                    for (l = n; l < s; l++)
                        i[0] = r[l],
                        o.apply(a, i)
                }
                return r
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                var r = e.indexOf(f);
                if (r > 0) {
                    var o = e[r - 1]
                      , a = e.indexOf(o);
                    e[r] = o,
                    e[a] = f
                }
                return e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                var o = e.indexOf(f);
                if (o === -1 || r < 0 || r >= e.length)
                    throw new Error("Supplied index out of bounds");
                return o !== r && (e.splice(o, 1),
                e.splice(r, 0, f)),
                f
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                var r = e.indexOf(f);
                if (r !== -1 && r < e.length - 1) {
                    var o = e[r + 1]
                      , a = e.indexOf(o);
                    e[r] = o,
                    e[a] = f
                }
                return e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                if (f === r)
                    return e;
                var o = e.indexOf(f)
                  , a = e.indexOf(r);
                if (o < 0 || a < 0)
                    throw new Error("Supplied items must be elements of the same array");
                return o > a || (e.splice(o, 1),
                a === e.length - 1 ? e.push(f) : e.splice(a, 0, f)),
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                if (f === r)
                    return e;
                var o = e.indexOf(f)
                  , a = e.indexOf(r);
                if (o < 0 || a < 0)
                    throw new Error("Supplied items must be elements of the same array");
                return o < a || (e.splice(o, 1),
                a === 0 ? e.unshift(f) : e.splice(a, 0, f)),
                e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(363)
              , f = function(r, o, a) {
                r === void 0 && (r = 0),
                o === void 0 && (o = null),
                a === void 0 && (a = 1),
                o === null && (o = r,
                r = 0);
                for (var n = [], s = Math.max(e((o - r) / (a || 1)), 0), l = 0; l < s; l++)
                    n.push(r),
                    r += a;
                return n
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(74)
              , f = function(r, o, a, n) {
                if (n === void 0 && (n = r),
                o < 0 || o > r.length - 1)
                    throw new Error("Index out of bounds");
                var s = e(r, o);
                return a && a.call(n, s),
                s
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(78)
              , f = function(r, o, a, n, s) {
                if (o === void 0 && (o = 0),
                a === void 0 && (a = r.length),
                s === void 0 && (s = r),
                e(r, o, a)) {
                    var l = a - o
                      , i = r.splice(o, l);
                    if (n)
                        for (var h = 0; h < i.length; h++) {
                            var u = i[h];
                            n.call(s, u)
                        }
                    return i
                } else
                    return []
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(74)
              , f = function(r, o, a) {
                o === void 0 && (o = 0),
                a === void 0 && (a = r.length);
                var n = o + Math.floor(Math.random() * a);
                return e(r, n)
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                var o = e.indexOf(f)
                  , a = e.indexOf(r);
                return o !== -1 && a === -1 ? (e[o] = r,
                !0) : !1
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                var r = e.indexOf(f);
                return r !== -1 && r > 0 && (e.splice(r, 1),
                e.unshift(f)),
                f
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(78)
              , f = function(r, o, a, n, s) {
                if (n === void 0 && (n = 0),
                s === void 0 && (s = r.length),
                e(r, n, s))
                    for (var l = n; l < s; l++) {
                        var i = r[l];
                        i.hasOwnProperty(o) && (i[o] = a)
                    }
                return r
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                if (f === r)
                    return e;
                var o = e.indexOf(f)
                  , a = e.indexOf(r);
                if (o < 0 || a < 0)
                    throw new Error("Supplied items must be elements of the same array");
                return e[o] = r,
                e[a] = f,
                e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(211)
              , r = t(24)
              , o = t(20)
              , a = new e({
                Extends: f,
                initialize: function(s) {
                    f.call(this),
                    this.checkQueue = !0,
                    this.scene = s,
                    this.systems = s.sys,
                    s.sys.events.once(o.BOOT, this.boot, this),
                    s.sys.events.on(o.START, this.start, this)
                },
                boot: function() {
                    this.systems.events.once(o.DESTROY, this.destroy, this)
                },
                start: function() {
                    var n = this.systems.events;
                    n.on(o.PRE_UPDATE, this.update, this),
                    n.on(o.UPDATE, this.sceneUpdate, this),
                    n.once(o.SHUTDOWN, this.shutdown, this)
                },
                sceneUpdate: function(n, s) {
                    for (var l = this._active, i = l.length, h = 0; h < i; h++) {
                        var u = l[h];
                        u.active && u.preUpdate.call(u, n, s)
                    }
                },
                shutdown: function() {
                    for (var n = this._active.length; n--; )
                        this._active[n].destroy(!0);
                    for (n = this._pending.length; n--; )
                        this._pending[n].destroy(!0);
                    for (n = this._destroy.length; n--; )
                        this._destroy[n].destroy(!0);
                    this._toProcess = 0,
                    this._pending = [],
                    this._active = [],
                    this._destroy = [],
                    this.removeAllListeners();
                    var s = this.systems.events;
                    s.off(o.PRE_UPDATE, this.update, this),
                    s.off(o.UPDATE, this.sceneUpdate, this),
                    s.off(o.SHUTDOWN, this.shutdown, this)
                },
                destroy: function() {
                    this.shutdown(),
                    this.systems.events.off(o.START, this.start, this),
                    this.scene = null,
                    this.systems = null
                }
            });
            r.register("UpdateList", a, "updateList"),
            c.exports = a
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "add"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "remove"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                if (r === void 0 && (r = !1),
                o === void 0)
                    return o = {
                        local: {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        },
                        global: {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        },
                        lines: {
                            shortest: 0,
                            longest: 0,
                            lengths: null,
                            height: 0
                        },
                        wrappedText: "",
                        words: [],
                        characters: [],
                        scaleX: 0,
                        scaleY: 0
                    },
                    o;
                var a = e.text, n = a.length, s = e.maxWidth, l = e.wordWrapCharCode, i = Number.MAX_VALUE, h = Number.MAX_VALUE, u = 0, d = 0, v = e.fontData.chars, p = e.fontData.lineHeight, g = e.letterSpacing, m = 0, x = 0, T = 0, E = null, P = e._align, M = 0, L = 0, R = e.fontSize / e.fontData.size, O = R * e.scaleX, F = R * e.scaleY, B = null, N = 0, Y = [], z = Number.MAX_VALUE, W = 0, b = 0, D = 0, I, G = [], w = [], U = null;
                if (s > 0) {
                    for (I = 0; I < n; I++) {
                        if (T = a.charCodeAt(I),
                        T === 10) {
                            U !== null && (G.push({
                                word: U.word,
                                i: U.i,
                                x: U.x * O,
                                y: U.y * F,
                                w: U.w * O,
                                h: U.h * F,
                                cr: !0
                            }),
                            U = null),
                            m = 0,
                            x += p,
                            B = null;
                            continue
                        }
                        if (E = v[T],
                        !!E) {
                            if (B !== null)
                                var X = E.kerning[N];
                            T === l ? U !== null && (G.push({
                                word: U.word,
                                i: U.i,
                                x: U.x * O,
                                y: U.y * F,
                                w: U.w * O,
                                h: U.h * F,
                                cr: !1
                            }),
                            U = null) : (U === null && (U = {
                                word: "",
                                i: I,
                                x: m,
                                y: x,
                                w: 0,
                                h: p,
                                cr: !1
                            }),
                            U.word = U.word.concat(a[I]),
                            U.w += E.xOffset + E.xAdvance + (X !== void 0 ? X : 0)),
                            m += E.xAdvance + g,
                            B = E,
                            N = T
                        }
                    }
                    U !== null && G.push({
                        word: U.word,
                        i: U.i,
                        x: U.x * O,
                        y: U.y * F,
                        w: U.w * O,
                        h: U.h * F,
                        cr: !1
                    }),
                    m = 0,
                    x = 0,
                    B = null,
                    N = 0;
                    var V, H = 0, J = [];
                    for (I = 0; I < G.length; I++) {
                        var $ = G[I]
                          , _ = $.x
                          , nt = $.x + $.w;
                        if (V) {
                            var K = _ - (V.x + V.w);
                            H = _ - (K + V.w),
                            V = null
                        }
                        var Z = _ - H
                          , j = nt - H;
                        Z > s || j > s ? (J.push($.i - 1),
                        $.cr ? (J.push($.i + $.word.length),
                        H = 0,
                        V = null) : V = $) : $.cr && (J.push($.i + $.word.length),
                        H = 0,
                        V = null)
                    }
                    var Q = function(ut, ft, mt) {
                        return ut.substr(0, ft) + mt + ut.substr(ft + 1)
                    };
                    for (I = J.length - 1; I >= 0; I--)
                        a = Q(a, J[I], `
`);
                    o.wrappedText = a,
                    n = a.length,
                    G = [],
                    U = null
                }
                var tt = 0;
                for (I = 0; I < n; I++) {
                    if (T = a.charCodeAt(I),
                    T === 10) {
                        U !== null && (G.push({
                            word: U.word,
                            i: U.i,
                            x: U.x * O,
                            y: U.y * F,
                            w: U.w * O,
                            h: U.h * F
                        }),
                        U = null),
                        m = 0,
                        x += p,
                        B = null,
                        Y[b] = D,
                        D > W && (W = D),
                        D < z && (z = D),
                        b++,
                        D = 0;
                        continue
                    }
                    if (E = v[T],
                    !!E) {
                        if (M = m,
                        L = x,
                        B !== null) {
                            var et = E.kerning[N];
                            M += et !== void 0 ? et : 0
                        }
                        i > M && (i = M),
                        h > L && (h = L);
                        var it = M + E.xAdvance
                          , k = L + p;
                        u < it && (u = it),
                        d < k && (d = k);
                        var st = E.xOffset + E.xAdvance + (et !== void 0 ? et : 0);
                        T === l ? U !== null && (G.push({
                            word: U.word,
                            i: U.i,
                            x: U.x * O,
                            y: U.y * F,
                            w: U.w * O,
                            h: U.h * F
                        }),
                        U = null) : (U === null && (U = {
                            word: "",
                            i: tt,
                            x: m,
                            y: x,
                            w: 0,
                            h: p
                        }),
                        U.word = U.word.concat(a[I]),
                        U.w += st),
                        w.push({
                            i: tt,
                            char: a[I],
                            code: T,
                            x: (E.xOffset + m) * R,
                            y: (E.yOffset + x) * R,
                            w: E.width * R,
                            h: E.height * R,
                            t: x * R,
                            r: it * R,
                            b: p * R,
                            line: b,
                            glyph: E
                        }),
                        m += E.xAdvance + g,
                        B = E,
                        N = T,
                        D = it * R,
                        tt++
                    }
                }
                if (U !== null && G.push({
                    word: U.word,
                    i: U.i,
                    x: U.x * O,
                    y: U.y * F,
                    w: U.w * O,
                    h: U.h * F
                }),
                Y[b] = D,
                D > W && (W = D),
                D < z && (z = D),
                P > 0)
                    for (var q = 0; q < w.length; q++) {
                        var rt = w[q];
                        if (P === 1) {
                            var ot = (W - Y[rt.line]) / 2;
                            rt.x += ot,
                            rt.r += ot
                        } else if (P === 2) {
                            var lt = W - Y[rt.line];
                            rt.x += lt,
                            rt.r += lt
                        }
                    }
                var at = o.local
                  , ht = o.global
                  , dt = o.lines;
                return at.x = i * R,
                at.y = h * R,
                at.width = u * R,
                at.height = d * R,
                ht.x = e.x - e._displayOriginX + i * O,
                ht.y = e.y - e._displayOriginY + h * F,
                ht.width = u * O,
                ht.height = d * F,
                dt.shortest = z,
                dt.longest = W,
                dt.lengths = Y,
                f && (at.x = Math.ceil(at.x),
                at.y = Math.ceil(at.y),
                at.width = Math.ceil(at.width),
                at.height = Math.ceil(at.height),
                ht.x = Math.ceil(ht.x),
                ht.y = Math.ceil(ht.y),
                ht.width = Math.ceil(ht.width),
                ht.height = Math.ceil(ht.height),
                dt.shortest = Math.ceil(z),
                dt.longest = Math.ceil(W)),
                r && (e._displayOriginX = e.originX * at.width,
                e._displayOriginY = e.originY * at.height,
                ht.x = e.x - e._displayOriginX * e.scaleX,
                ht.y = e.y - e._displayOriginY * e.scaleY,
                f && (ht.x = Math.ceil(ht.x),
                ht.y = Math.ceil(ht.y))),
                o.words = G,
                o.characters = w,
                o.lines.height = p,
                o.scale = R,
                o.scaleX = e.scaleX,
                o.scaleY = e.scaleY,
                o
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(212)
              , f = function(r, o, a, n, s, l, i) {
                var h = r.sys.textures.get(a)
                  , u = h.get(n)
                  , d = r.sys.cache.xml.get(s);
                if (u && d) {
                    var v = e(d, u, l, i, h);
                    return r.sys.cache.bitmapFont.add(o, {
                        data: v,
                        texture: a,
                        frame: n,
                        fromAtlas: !0
                    }),
                    !0
                } else
                    return !1
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1046),
            f = t(1048),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1047)
              , f = t(19)
              , r = t(12)
              , o = function(a, n, s, l) {
                var i = n._text
                  , h = i.length;
                if (h !== 0) {
                    s.addToRenderList(n);
                    var u = a.pipelines.set(n.pipeline, n), d = f(n, s, l).calc, v = s.roundPixels, p = s.alpha, g = n.charColors, m = n.tintFill, x = r.getTintAppendFloatAlpha, T = x(n.tintTopLeft, p * n._alphaTL), E = x(n.tintTopRight, p * n._alphaTR), P = x(n.tintBottomLeft, p * n._alphaBL), M = x(n.tintBottomRight, p * n._alphaBR), L = n.frame.glTexture, R = u.setGameObject(n), O = n.getTextBounds(!1), F, B, N, Y = O.characters, z = n.dropShadowX, W = n.dropShadowY, b = z !== 0 || W !== 0;
                    if (a.pipelines.preBatch(n),
                    b) {
                        var D = n.dropShadowColor
                          , I = n.dropShadowAlpha
                          , G = x(D, p * I * n._alphaTL)
                          , w = x(D, p * I * n._alphaTR)
                          , U = x(D, p * I * n._alphaBL)
                          , X = x(D, p * I * n._alphaBR);
                        for (F = 0; F < Y.length; F++)
                            B = Y[F],
                            N = B.glyph,
                            !(B.code === 32 || N.width === 0 || N.height === 0) && e(u, n, B, N, z, W, d, v, G, w, U, X, 1, L, R)
                    }
                    for (F = 0; F < Y.length; F++)
                        if (B = Y[F],
                        N = B.glyph,
                        !(B.code === 32 || N.width === 0 || N.height === 0))
                            if (g[B.i]) {
                                var V = g[B.i]
                                  , H = V.tintEffect
                                  , J = x(V.tintTL, p * n._alphaTL)
                                  , $ = x(V.tintTR, p * n._alphaTR)
                                  , _ = x(V.tintBL, p * n._alphaBL)
                                  , nt = x(V.tintBR, p * n._alphaBR);
                                e(u, n, B, N, 0, 0, d, v, J, $, _, nt, H, L, R)
                            } else
                                e(u, n, B, N, 0, 0, d, v, T, E, P, M, m, L, R);
                    a.pipelines.postBatch(n)
                }
            };
            c.exports = o
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o, a, n, s, l, i, h, u, d, v, p, g) {
                var m = r.x - f.displayOriginX + a
                  , x = r.y - f.displayOriginY + n
                  , T = m + r.w
                  , E = x + r.h
                  , P = s.getXRound(m, x, l)
                  , M = s.getYRound(m, x, l)
                  , L = s.getXRound(m, E, l)
                  , R = s.getYRound(m, E, l)
                  , O = s.getXRound(T, E, l)
                  , F = s.getYRound(T, E, l)
                  , B = s.getXRound(T, x, l)
                  , N = s.getYRound(T, x, l);
                e.batchQuad(f, P, M, L, R, O, F, B, N, o.u0, o.v0, o.u1, o.v1, i, h, u, d, v, p, g)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(30)
              , f = function(r, o, a, n) {
                var s = o._text
                  , l = s.length
                  , i = r.currentContext;
                if (!(l === 0 || !e(r, i, o, a, n))) {
                    a.addToRenderList(o);
                    var h = o.fromAtlas ? o.frame : o.texture.frames.__BASE
                      , u = o.fontData.chars
                      , d = o.fontData.lineHeight
                      , v = o._letterSpacing
                      , p = 0
                      , g = 0
                      , m = 0
                      , x = null
                      , T = 0
                      , E = 0
                      , P = 0
                      , M = 0
                      , L = 0
                      , R = 0
                      , O = null
                      , F = 0
                      , B = h.source.image
                      , N = h.cutX
                      , Y = h.cutY
                      , z = o._fontSize / o.fontData.size
                      , W = o._align
                      , b = 0
                      , D = 0
                      , I = o.getTextBounds(!1);
                    o.maxWidth > 0 && (s = I.wrappedText,
                    l = s.length);
                    var G = o._bounds.lines;
                    W === 1 ? D = (G.longest - G.lengths[0]) / 2 : W === 2 && (D = G.longest - G.lengths[0]),
                    i.translate(-o.displayOriginX, -o.displayOriginY);
                    for (var w = a.roundPixels, U = 0; U < l; U++) {
                        if (m = s.charCodeAt(U),
                        m === 10) {
                            b++,
                            W === 1 ? D = (G.longest - G.lengths[b]) / 2 : W === 2 && (D = G.longest - G.lengths[b]),
                            p = 0,
                            g += d,
                            O = null;
                            continue
                        }
                        if (x = u[m],
                        !!x) {
                            if (T = N + x.x,
                            E = Y + x.y,
                            P = x.width,
                            M = x.height,
                            L = x.xOffset + p,
                            R = x.yOffset + g,
                            O !== null) {
                                var X = x.kerning[F];
                                L += X !== void 0 ? X : 0
                            }
                            L *= z,
                            R *= z,
                            L += D,
                            p += x.xAdvance + v,
                            O = x,
                            F = m,
                            !(P === 0 || M === 0 || m === 32) && (w && (L = Math.round(L),
                            R = Math.round(R)),
                            i.save(),
                            i.translate(L, R),
                            i.scale(z, z),
                            i.drawImage(B, T, E, P, M, 0, 0, P, M),
                            i.restore())
                        }
                    }
                    i.restore()
                }
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1050),
            f = t(1051),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(25)
              , f = t(12)
              , r = new e
              , o = function(a, n, s, l) {
                var i = n.getRenderList();
                if (i.length !== 0) {
                    var h = s.alpha * n.alpha;
                    if (h !== 0) {
                        s.addToRenderList(n);
                        var u = a.pipelines.set(this.pipeline, n)
                          , d = s.scrollX * n.scrollFactorX
                          , v = s.scrollY * n.scrollFactorY
                          , p = r.copyFrom(s.matrix);
                        l && (p.multiplyWithOffset(l, -d, -v),
                        d = 0,
                        v = 0);
                        var g = n.x - d
                          , m = n.y - v
                          , x = -1
                          , T = !1
                          , E = s.roundPixels;
                        a.pipelines.preBatch(n);
                        for (var P = 0; P < i.length; P++) {
                            var M = i[P]
                              , L = M.frame
                              , R = M.alpha * h;
                            if (R !== 0) {
                                var O = L.width
                                  , F = L.height
                                  , B = g + M.x + L.x
                                  , N = m + M.y + L.y;
                                M.flipX && (O *= -1,
                                B += L.width),
                                M.flipY && (F *= -1,
                                N += L.height);
                                var Y = B + O
                                  , z = N + F
                                  , W = p.getX(B, N)
                                  , b = p.getY(B, N)
                                  , D = p.getX(Y, z)
                                  , I = p.getY(Y, z)
                                  , G = f.getTintAppendFloatAlpha(M.tint, R);
                                if (L.sourceIndex !== x) {
                                    var w = u.setGameObject(n, L);
                                    x = L.sourceIndex
                                }
                                E && (W = Math.round(W),
                                b = Math.round(b),
                                D = Math.round(D),
                                I = Math.round(I)),
                                u.batchQuad(n, W, b, W, I, D, I, D, b, L.u0, L.v0, L.u1, L.v1, G, G, G, G, T, L.glTexture, w) && (x = -1)
                            }
                        }
                        a.pipelines.postBatch(n)
                    }
                }
            };
            c.exports = o
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                var a = f.getRenderList();
                if (a.length !== 0) {
                    var n = e.currentContext
                      , s = r.alpha * f.alpha;
                    if (s !== 0) {
                        r.addToRenderList(f),
                        n.globalCompositeOperation = e.blendModes[f.blendMode],
                        n.imageSmoothingEnabled = !(!e.antialias || f.frame.source.scaleMode);
                        var l = f.x - r.scrollX * f.scrollFactorX
                          , i = f.y - r.scrollY * f.scrollFactorY;
                        n.save(),
                        o && o.copyToContext(n);
                        for (var h = r.roundPixels, u = 0; u < a.length; u++) {
                            var d = a[u]
                              , v = d.flipX || d.flipY
                              , p = d.frame
                              , g = p.canvasData
                              , m = p.x
                              , x = p.y
                              , T = 1
                              , E = 1
                              , P = d.alpha * s;
                            P !== 0 && (n.globalAlpha = P,
                            v ? (d.flipX && (T = -1,
                            m -= g.width),
                            d.flipY && (E = -1,
                            x -= g.height),
                            n.save(),
                            n.translate(d.x + l, d.y + i),
                            n.scale(T, E),
                            n.drawImage(p.source.image, g.x, g.y, g.width, g.height, m, x, g.width, g.height),
                            n.restore()) : (h && (m = Math.round(m),
                            x = Math.round(x)),
                            n.drawImage(p.source.image, g.x, g.y, g.width, g.height, m + d.x + l, x + d.y + i, g.width, g.height)))
                        }
                        n.restore()
                    }
                }
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1053),
            f = t(1054),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                r.addToRenderList(f);
                var a = f.list
                  , n = a.length;
                if (n !== 0) {
                    var s = f.localTransform;
                    o ? (s.loadIdentity(),
                    s.multiply(o),
                    s.translate(f.x, f.y),
                    s.rotate(f.rotation),
                    s.scale(f.scaleX, f.scaleY)) : s.applyITRS(f.x, f.y, f.rotation, f.scaleX, f.scaleY),
                    e.pipelines.preBatch(f);
                    var l = f.blendMode !== -1;
                    l || e.setBlendMode(0);
                    for (var i = f.alpha, h = f.scrollFactorX, u = f.scrollFactorY, d = 0; d < n; d++) {
                        var v = a[d];
                        if (v.willRender(r)) {
                            var p, g, m, x;
                            if (v.alphaTopLeft !== void 0)
                                p = v.alphaTopLeft,
                                g = v.alphaTopRight,
                                m = v.alphaBottomLeft,
                                x = v.alphaBottomRight;
                            else {
                                var T = v.alpha;
                                p = T,
                                g = T,
                                m = T,
                                x = T
                            }
                            var E = v.scrollFactorX
                              , P = v.scrollFactorY;
                            !l && v.blendMode !== e.currentBlendMode && e.setBlendMode(v.blendMode);
                            var M = v.mask;
                            M && M.preRenderWebGL(e, v, r);
                            var L = v.type;
                            L !== e.currentType && (e.newType = !0,
                            e.currentType = L),
                            e.nextTypeMatch = d < n - 1 ? a[d + 1].type === e.currentType : !1,
                            v.setScrollFactor(E * h, P * u),
                            v.setAlpha(p * i, g * i, m * i, x * i),
                            v.renderWebGL(e, v, r, s),
                            v.setAlpha(p, g, m, x),
                            v.setScrollFactor(E, P),
                            M && M.postRenderWebGL(e, r),
                            e.newType = !1
                        }
                    }
                    e.pipelines.postBatch(f)
                }
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                r.addToRenderList(f);
                var a = f.list;
                if (a.length !== 0) {
                    var n = f.localTransform;
                    o ? (n.loadIdentity(),
                    n.multiply(o),
                    n.translate(f.x, f.y),
                    n.rotate(f.rotation),
                    n.scale(f.scaleX, f.scaleY)) : n.applyITRS(f.x, f.y, f.rotation, f.scaleX, f.scaleY);
                    var s = f.blendMode !== -1;
                    s || e.setBlendMode(0);
                    var l = f._alpha
                      , i = f.scrollFactorX
                      , h = f.scrollFactorY;
                    f.mask && f.mask.preRenderCanvas(e, null, r);
                    for (var u = 0; u < a.length; u++) {
                        var d = a[u];
                        if (d.willRender(r)) {
                            var v = d.alpha
                              , p = d.scrollFactorX
                              , g = d.scrollFactorY;
                            !s && d.blendMode !== e.currentBlendMode && e.setBlendMode(d.blendMode),
                            d.setScrollFactor(p * i, g * h),
                            d.setAlpha(v * l),
                            d.renderCanvas(e, d, r, n),
                            d.setAlpha(v),
                            d.setScrollFactor(p, g)
                        }
                    }
                    f.mask && f.mask.postRenderCanvas(e)
                }
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(443),
            f = t(443),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = ["normal", "multiply", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"]
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1058),
            f = t(1059),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(19)
              , f = t(25)
              , r = t(12)
              , o = new f
              , a = function(n, s, l, i) {
                var h = s.text
                  , u = h.length;
                if (u !== 0) {
                    l.addToRenderList(s);
                    var d = n.pipelines.set(s.pipeline, s)
                      , v = e(s, l, i)
                      , p = v.sprite
                      , g = v.calc
                      , m = o
                      , x = s.cropWidth > 0 || s.cropHeight > 0;
                    x && (d.flush(),
                    n.pushScissor(g.tx, g.ty, s.cropWidth * g.scaleX, s.cropHeight * g.scaleY));
                    var T = s.frame, E = T.glTexture, P = s.tintFill, M = r.getTintAppendFloatAlpha(s.tintTopLeft, l.alpha * s._alphaTL), L = r.getTintAppendFloatAlpha(s.tintTopRight, l.alpha * s._alphaTR), R = r.getTintAppendFloatAlpha(s.tintBottomLeft, l.alpha * s._alphaBL), O = r.getTintAppendFloatAlpha(s.tintBottomRight, l.alpha * s._alphaBR), F = d.setGameObject(s), B = 0, N = 0, Y = 0, z = 0, W = s.letterSpacing, b, D = 0, I = 0, G, w = s.scrollX, U = s.scrollY, X = s.fontData, V = X.chars, H = X.lineHeight, J = s.fontSize / X.size, $ = 0, _ = s._align, nt = 0, K = 0, Z = s.getTextBounds(!1);
                    s.maxWidth > 0 && (h = Z.wrappedText,
                    u = h.length);
                    var j = s._bounds.lines;
                    _ === 1 ? K = (j.longest - j.lengths[0]) / 2 : _ === 2 && (K = j.longest - j.lengths[0]);
                    var Q = l.roundPixels
                      , tt = s.displayCallback
                      , et = s.callbackData;
                    n.pipelines.preBatch(s);
                    for (var it = 0; it < u; it++) {
                        if (Y = h.charCodeAt(it),
                        Y === 10) {
                            nt++,
                            _ === 1 ? K = (j.longest - j.lengths[nt]) / 2 : _ === 2 && (K = j.longest - j.lengths[nt]),
                            B = 0,
                            N += H,
                            G = null;
                            continue
                        }
                        if (b = V[Y],
                        !!b) {
                            D = b.width,
                            I = b.height;
                            var k = b.xOffset + B - w
                              , st = b.yOffset + N - U;
                            if (G !== null) {
                                var q = b.kerning[z];
                                k += q !== void 0 ? q : 0
                            }
                            if (B += b.xAdvance + W,
                            G = b,
                            z = Y,
                            !(D === 0 || I === 0 || Y === 32)) {
                                if (J = s.fontSize / s.fontData.size,
                                $ = 0,
                                tt) {
                                    et.color = 0,
                                    et.tint.topLeft = M,
                                    et.tint.topRight = L,
                                    et.tint.bottomLeft = R,
                                    et.tint.bottomRight = O,
                                    et.index = it,
                                    et.charCode = Y,
                                    et.x = k,
                                    et.y = st,
                                    et.scale = J,
                                    et.rotation = $,
                                    et.data = b.data;
                                    var rt = tt(et);
                                    k = rt.x,
                                    st = rt.y,
                                    J = rt.scale,
                                    $ = rt.rotation,
                                    rt.color ? (M = rt.color,
                                    L = rt.color,
                                    R = rt.color,
                                    O = rt.color) : (M = rt.tint.topLeft,
                                    L = rt.tint.topRight,
                                    R = rt.tint.bottomLeft,
                                    O = rt.tint.bottomRight),
                                    M = r.getTintAppendFloatAlpha(M, l.alpha * s._alphaTL),
                                    L = r.getTintAppendFloatAlpha(L, l.alpha * s._alphaTR),
                                    R = r.getTintAppendFloatAlpha(R, l.alpha * s._alphaBL),
                                    O = r.getTintAppendFloatAlpha(O, l.alpha * s._alphaBR)
                                }
                                k *= J,
                                st *= J,
                                k -= s.displayOriginX,
                                st -= s.displayOriginY,
                                k += K,
                                m.applyITRS(k, st, $, J, J),
                                g.multiply(m, p);
                                var ot = b.u0
                                  , lt = b.v0
                                  , at = b.u1
                                  , ht = b.v1
                                  , dt = D
                                  , ut = I
                                  , ft = p.e
                                  , mt = p.f
                                  , Gt = ut * p.c + p.e
                                  , jt = ut * p.d + p.f
                                  , Yt = dt * p.a + ut * p.c + p.e
                                  , $t = dt * p.b + ut * p.d + p.f
                                  , Ct = dt * p.a + p.e
                                  , Rt = dt * p.b + p.f;
                                Q && (ft = Math.round(ft),
                                mt = Math.round(mt),
                                Gt = Math.round(Gt),
                                jt = Math.round(jt),
                                Yt = Math.round(Yt),
                                $t = Math.round($t),
                                Ct = Math.round(Ct),
                                Rt = Math.round(Rt)),
                                d.batchQuad(s, ft, mt, Gt, jt, Yt, $t, Ct, Rt, ot, lt, at, ht, M, L, R, O, P, E, F)
                            }
                        }
                    }
                    x && (d.flush(),
                    n.popScissor()),
                    n.pipelines.postBatch(s)
                }
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(30)
              , f = function(r, o, a, n) {
                var s = o._text
                  , l = s.length
                  , i = r.currentContext;
                if (!(l === 0 || !e(r, i, o, a, n))) {
                    a.addToRenderList(o);
                    var h = o.fromAtlas ? o.frame : o.texture.frames.__BASE
                      , u = o.displayCallback
                      , d = o.callbackData
                      , v = o.fontData.chars
                      , p = o.fontData.lineHeight
                      , g = o._letterSpacing
                      , m = 0
                      , x = 0
                      , T = 0
                      , E = null
                      , P = 0
                      , M = 0
                      , L = 0
                      , R = 0
                      , O = 0
                      , F = 0
                      , B = null
                      , N = 0
                      , Y = o.frame.source.image
                      , z = h.cutX
                      , W = h.cutY
                      , b = 0
                      , D = 0
                      , I = o._fontSize / o.fontData.size
                      , G = o._align
                      , w = 0
                      , U = 0;
                    o.getTextBounds(!1);
                    var X = o._bounds.lines;
                    G === 1 ? U = (X.longest - X.lengths[0]) / 2 : G === 2 && (U = X.longest - X.lengths[0]),
                    i.translate(-o.displayOriginX, -o.displayOriginY);
                    var V = a.roundPixels;
                    o.cropWidth > 0 && o.cropHeight > 0 && (i.beginPath(),
                    i.rect(0, 0, o.cropWidth, o.cropHeight),
                    i.clip());
                    for (var H = 0; H < l; H++) {
                        if (D = I,
                        b = 0,
                        T = s.charCodeAt(H),
                        T === 10) {
                            w++,
                            G === 1 ? U = (X.longest - X.lengths[w]) / 2 : G === 2 && (U = X.longest - X.lengths[w]),
                            m = 0,
                            x += p,
                            B = null;
                            continue
                        }
                        if (E = v[T],
                        !!E) {
                            if (P = z + E.x,
                            M = W + E.y,
                            L = E.width,
                            R = E.height,
                            O = E.xOffset + m - o.scrollX,
                            F = E.yOffset + x - o.scrollY,
                            B !== null) {
                                var J = E.kerning[N];
                                O += J !== void 0 ? J : 0
                            }
                            if (u) {
                                d.index = H,
                                d.charCode = T,
                                d.x = O,
                                d.y = F,
                                d.scale = D,
                                d.rotation = b,
                                d.data = E.data;
                                var $ = u(d);
                                O = $.x,
                                F = $.y,
                                D = $.scale,
                                b = $.rotation
                            }
                            O *= D,
                            F *= D,
                            O += U,
                            m += E.xAdvance + g,
                            B = E,
                            N = T,
                            !(L === 0 || R === 0 || T === 32) && (V && (O = Math.round(O),
                            F = Math.round(F)),
                            i.save(),
                            i.translate(O, F),
                            i.rotate(b),
                            i.scale(D, D),
                            i.drawImage(Y, P, M, L, R, 0, 0, L, R),
                            i.restore())
                        }
                    }
                    i.restore()
                }
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1061),
            f = t(1062),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(19)
              , f = function(r, o, a, n) {
                r.pipelines.clear();
                var s = e(o, a, n).calc;
                o.render.call(o, r, a, s),
                r.pipelines.rebind()
            };
            c.exports = f
        }
        , function(c, S) {}
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1064),
            f = t(448),
            f = t(448),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(217)
              , f = t(19)
              , r = t(25)
              , o = t(12)
              , a = function(h, u, d) {
                this.x = h,
                this.y = u,
                this.width = d
            }
              , n = function(h, u, d) {
                this.points = [],
                this.pointsLength = 1,
                this.points[0] = new a(h,u,d)
            }
              , s = []
              , l = new r
              , i = function(h, u, d, v) {
                if (u.commandBuffer.length !== 0) {
                    d.addToRenderList(u);
                    var p = h.pipelines.set(u.pipeline, u);
                    h.pipelines.preBatch(u);
                    for (var g = f(u, d, v).calc, m = l.loadIdentity(), x = u.commandBuffer, T = d.alpha * u.alpha, E = 1, P = p.fillTint, M = p.strokeTint, L = 0, R = 0, O = 0, F = .01, B = Math.PI * 2, N, Y = [], z = 0, W = !0, b = null, D = o.getTintAppendFloatAlpha, I = 0; I < x.length; I++)
                        switch (N = x[I],
                        N) {
                        case e.BEGIN_PATH:
                            {
                                Y.length = 0,
                                b = null,
                                W = !0;
                                break
                            }
                        case e.CLOSE_PATH:
                            {
                                W = !1,
                                b && b.points.length && b.points.push(b.points[0]);
                                break
                            }
                        case e.FILL_PATH:
                            {
                                for (z = 0; z < Y.length; z++)
                                    p.batchFillPath(Y[z].points, m, g);
                                break
                            }
                        case e.STROKE_PATH:
                            {
                                for (z = 0; z < Y.length; z++)
                                    p.batchStrokePath(Y[z].points, E, W, m, g);
                                break
                            }
                        case e.LINE_STYLE:
                            {
                                E = x[++I];
                                var G = x[++I]
                                  , w = x[++I] * T
                                  , U = D(G, w);
                                M.TL = U,
                                M.TR = U,
                                M.BL = U,
                                M.BR = U;
                                break
                            }
                        case e.FILL_STYLE:
                            {
                                var X = x[++I]
                                  , V = x[++I] * T
                                  , H = D(X, V);
                                P.TL = H,
                                P.TR = H,
                                P.BL = H,
                                P.BR = H;
                                break
                            }
                        case e.GRADIENT_FILL_STYLE:
                            {
                                var J = x[++I] * T
                                  , $ = x[++I] * T
                                  , _ = x[++I] * T
                                  , nt = x[++I] * T;
                                P.TL = D(x[++I], J),
                                P.TR = D(x[++I], $),
                                P.BL = D(x[++I], _),
                                P.BR = D(x[++I], nt);
                                break
                            }
                        case e.GRADIENT_LINE_STYLE:
                            {
                                E = x[++I];
                                var K = x[++I] * T;
                                M.TL = D(x[++I], K),
                                M.TR = D(x[++I], K),
                                M.BL = D(x[++I], K),
                                M.BR = D(x[++I], K);
                                break
                            }
                        case e.ARC:
                            {
                                var Z = 0
                                  , j = x[++I]
                                  , Q = x[++I]
                                  , tt = x[++I]
                                  , et = x[++I]
                                  , it = x[++I]
                                  , k = x[++I]
                                  , st = x[++I];
                                for (it -= et,
                                k ? it < -B ? it = -B : it > 0 && (it = -B + it % B) : it > B ? it = B : it < 0 && (it = B + it % B),
                                b === null && (b = new n(j + Math.cos(et) * tt,Q + Math.sin(et) * tt,E),
                                Y.push(b),
                                Z += F); Z < 1 + st; )
                                    O = it * Z + et,
                                    L = j + Math.cos(O) * tt,
                                    R = Q + Math.sin(O) * tt,
                                    b.points.push(new a(L,R,E)),
                                    Z += F;
                                O = it + et,
                                L = j + Math.cos(O) * tt,
                                R = Q + Math.sin(O) * tt,
                                b.points.push(new a(L,R,E));
                                break
                            }
                        case e.FILL_RECT:
                            {
                                p.batchFillRect(x[++I], x[++I], x[++I], x[++I], m, g);
                                break
                            }
                        case e.FILL_TRIANGLE:
                            {
                                p.batchFillTriangle(x[++I], x[++I], x[++I], x[++I], x[++I], x[++I], m, g);
                                break
                            }
                        case e.STROKE_TRIANGLE:
                            {
                                p.batchStrokeTriangle(x[++I], x[++I], x[++I], x[++I], x[++I], x[++I], E, m, g);
                                break
                            }
                        case e.LINE_TO:
                            {
                                b !== null ? b.points.push(new a(x[++I],x[++I],E)) : (b = new n(x[++I],x[++I],E),
                                Y.push(b));
                                break
                            }
                        case e.MOVE_TO:
                            {
                                b = new n(x[++I],x[++I],E),
                                Y.push(b);
                                break
                            }
                        case e.SAVE:
                            {
                                s.push(m.copyToArray());
                                break
                            }
                        case e.RESTORE:
                            {
                                m.copyFromArray(s.pop());
                                break
                            }
                        case e.TRANSLATE:
                            {
                                j = x[++I],
                                Q = x[++I],
                                m.translate(j, Q);
                                break
                            }
                        case e.SCALE:
                            {
                                j = x[++I],
                                Q = x[++I],
                                m.scale(j, Q);
                                break
                            }
                        case e.ROTATE:
                            {
                                m.rotate(x[++I]);
                                break
                            }
                        }
                    h.pipelines.postBatch(u)
                }
            };
            c.exports = i
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1066),
            f = t(1067),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                r.addToRenderList(f),
                f.pipeline.batchSprite(f, r, o)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                r.addToRenderList(f),
                e.batchSprite(f, f.frame, r, o)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1069),
            f = t(1070),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                r.addToRenderList(f),
                this.pipeline.batchSprite(f, r, o)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                r.addToRenderList(f),
                e.batchSprite(f, f.frame, r, o)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1072),
            f = t(1073),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                var o = f.list
                  , a = o.length;
                if (a !== 0) {
                    f.depthSort(),
                    e.pipelines.preBatch(f);
                    var n = f.blendMode !== -1;
                    n || e.setBlendMode(0);
                    for (var s = f.alpha, l = 0; l < a; l++) {
                        var i = o[l];
                        if (i.willRender(r)) {
                            var h, u, d, v;
                            if (i.alphaTopLeft !== void 0)
                                h = i.alphaTopLeft,
                                u = i.alphaTopRight,
                                d = i.alphaBottomLeft,
                                v = i.alphaBottomRight;
                            else {
                                var p = i.alpha;
                                h = p,
                                u = p,
                                d = p,
                                v = p
                            }
                            !n && i.blendMode !== e.currentBlendMode && e.setBlendMode(i.blendMode);
                            var g = i.mask;
                            g && g.preRenderWebGL(e, i, r);
                            var m = i.type;
                            m !== e.currentType && (e.newType = !0,
                            e.currentType = m),
                            e.nextTypeMatch = l < a - 1 ? o[l + 1].type === e.currentType : !1,
                            i.setAlpha(h * s, u * s, d * s, v * s),
                            i.renderWebGL(e, i, r),
                            i.setAlpha(h, u, d, v),
                            g && g.postRenderWebGL(e, r),
                            e.newType = !1
                        }
                    }
                    e.pipelines.postBatch(f)
                }
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                var o = f.list;
                if (o.length !== 0) {
                    f.depthSort();
                    var a = f.blendMode !== -1;
                    a || e.setBlendMode(0);
                    var n = f._alpha;
                    f.mask && f.mask.preRenderCanvas(e, null, r);
                    for (var s = 0; s < o.length; s++) {
                        var l = o[s];
                        if (l.willRender(r)) {
                            var i = l.alpha;
                            !a && l.blendMode !== e.currentBlendMode && e.setBlendMode(l.blendMode),
                            l.setAlpha(i * n),
                            l.renderCanvas(e, l, r),
                            l.setAlpha(i)
                        }
                    }
                    f.mask && f.mask.postRenderCanvas(e)
                }
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                EmitterOp: t(449),
                GravityWell: t(450),
                Particle: t(451),
                ParticleEmitter: t(452),
                ParticleEmitterManager: t(220),
                Zones: t(1078)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1076),
            f = t(1077),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(25)
              , f = t(12)
              , r = new e
              , o = new e
              , a = new e
              , n = new e
              , s = function(l, i, h, u) {
                var d = i.emitters.list
                  , v = d.length;
                if (v !== 0) {
                    var p = l.pipelines.set(i.pipeline)
                      , g = r
                      , m = o
                      , x = a
                      , T = n;
                    u ? (T.loadIdentity(),
                    T.multiply(u),
                    T.translate(i.x, i.y),
                    T.rotate(i.rotation),
                    T.scale(i.scaleX, i.scaleY)) : T.applyITRS(i.x, i.y, i.rotation, i.scaleX, i.scaleY);
                    var E = h.roundPixels
                      , P = i.defaultFrame.glTexture
                      , M = f.getTintAppendFloatAlpha
                      , L = p.setGameObject(i, i.defaultFrame);
                    l.pipelines.preBatch(i);
                    for (var R = 0; R < v; R++) {
                        var O = d[R]
                          , F = O.alive
                          , B = F.length;
                        if (!(!O.visible || B === 0)) {
                            h.addToRenderList(O);
                            var N = O.scrollFactorX
                              , Y = O.scrollFactorY;
                            l.setBlendMode(O.blendMode),
                            O.mask && (O.mask.preRenderWebGL(l, O, h),
                            l.pipelines.set(i.pipeline));
                            for (var z = 0, W = 0; W < B; W++) {
                                var b = F[W]
                                  , D = b.alpha * h.alpha;
                                if (!(D <= 0)) {
                                    x.applyITRS(b.x, b.y, b.rotation, b.scaleX, b.scaleY),
                                    g.copyFrom(h.matrix),
                                    g.multiplyWithOffset(T, -h.scrollX * N, -h.scrollY * Y),
                                    x.e = b.x,
                                    x.f = b.y,
                                    g.multiply(x, m);
                                    var I = b.frame
                                      , G = -I.halfWidth
                                      , w = -I.halfHeight
                                      , U = G + I.width
                                      , X = w + I.height
                                      , V = m.getXRound(G, w, E)
                                      , H = m.getYRound(G, w, E)
                                      , J = m.getXRound(G, X, E)
                                      , $ = m.getYRound(G, X, E)
                                      , _ = m.getXRound(U, X, E)
                                      , nt = m.getYRound(U, X, E)
                                      , K = m.getXRound(U, w, E)
                                      , Z = m.getYRound(U, w, E)
                                      , j = M(b.tint, D);
                                    p.batchQuad(O, V, H, J, $, _, nt, K, Z, I.u0, I.v0, I.u1, I.v1, j, j, j, j, z, P, L)
                                }
                            }
                            O.mask && O.mask.postRenderWebGL(l, h)
                        }
                    }
                    l.pipelines.postBatch(i)
                }
            };
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(25)
              , f = new e
              , r = new e
              , o = new e
              , a = new e
              , n = function(s, l, i, h) {
                var u = l.emitters.list
                  , d = u.length;
                if (d !== 0) {
                    var v = f.copyFrom(i.matrix)
                      , p = r
                      , g = o
                      , m = a;
                    h ? (m.loadIdentity(),
                    m.multiply(h),
                    m.translate(l.x, l.y),
                    m.rotate(l.rotation),
                    m.scale(l.scaleX, l.scaleY)) : m.applyITRS(l.x, l.y, l.rotation, l.scaleX, l.scaleY);
                    for (var x = s.currentContext, T = i.roundPixels, E = 0; E < d; E++) {
                        var P = u[E]
                          , M = P.alive
                          , L = M.length;
                        if (!(!P.visible || L === 0)) {
                            i.addToRenderList(P);
                            var R = P.scrollFactorX
                              , O = P.scrollFactorY;
                            x.save(),
                            x.globalCompositeOperation = s.blendModes[P.blendMode];
                            for (var F = 0; F < L; F++) {
                                var B = M[F]
                                  , N = B.alpha * i.alpha;
                                if (!(N <= 0)) {
                                    g.applyITRS(B.x, B.y, B.rotation, B.scaleX, B.scaleY),
                                    v.copyFrom(i.matrix),
                                    v.multiplyWithOffset(m, -i.scrollX * R, -i.scrollY * O),
                                    g.e = B.x,
                                    g.f = B.y,
                                    v.multiply(g, p);
                                    var Y = B.frame
                                      , z = Y.canvasData
                                      , W = -Y.halfWidth
                                      , b = -Y.halfHeight;
                                    x.globalAlpha = N,
                                    x.save(),
                                    p.setToContext(x),
                                    T && (W = Math.round(W),
                                    b = Math.round(b)),
                                    x.imageSmoothingEnabled = !(!s.antialias || Y.source.scaleMode),
                                    x.drawImage(Y.source.image, z.x, z.y, z.width, z.height, W, b, z.width, z.height),
                                    x.restore()
                                }
                            }
                            x.restore()
                        }
                    }
                }
            };
            c.exports = n
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                DeathZone: t(453),
                EdgeZone: t(454),
                RandomZone: t(456)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1080),
            f = t(1081),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(12)
              , f = function(r, o, a, n) {
                a.addToRenderList(o);
                var s = a.alpha
                  , l = o.renderTarget
                  , i = l.width
                  , h = l.height
                  , u = e.getTintAppendFloatAlpha
                  , d = r.pipelines.set(o.pipeline)
                  , v = d.setTexture2D(l.texture);
                r.pipelines.preBatch(o),
                d.batchTexture(o, l.texture, i, h, o.x, o.y, i, h, o.scaleX, o.scaleY, o.rotation, o.flipX, !o.flipY, o.scrollFactorX, o.scrollFactorY, o.displayOriginX, o.displayOriginY, 0, 0, i, h, u(o.tintTopLeft, s * o._alphaTL), u(o.tintTopRight, s * o._alphaTR), u(o.tintBottomLeft, s * o._alphaBL), u(o.tintBottomRight, s * o._alphaBR), o.tintFill, 0, 0, a, n, !0, v),
                r.resetTextures(),
                r.pipelines.postBatch(o)
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                r.addToRenderList(f),
                e.batchSprite(f, f.frame, r, o)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1083)
              , f = t(17)
              , r = {
                Parse: t(1084)
            };
            r = f(!1, r, e),
            c.exports = r
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                TEXT_SET1: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",
                TEXT_SET2: ` !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ`,
                TEXT_SET3: "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ",
                TEXT_SET4: "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789",
                TEXT_SET5: "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789",
                TEXT_SET6: `ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789"(),-.' `,
                TEXT_SET7: `AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW")28FLRX-'39`,
                TEXT_SET8: "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ",
                TEXT_SET9: `ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'"?!`,
                TEXT_SET10: "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
                TEXT_SET11: `ABCDEFGHIJKLMNOPQRSTUVWXYZ.,"-+!?()':;0123456789`
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(6)
              , f = function(r, o) {
                var a = o.width
                  , n = o.height
                  , s = Math.floor(a / 2)
                  , l = Math.floor(n / 2)
                  , i = e(o, "chars", "");
                if (i !== "") {
                    var h = e(o, "image", "")
                      , u = r.sys.textures.getFrame(h)
                      , d = u.cutX
                      , v = u.cutY
                      , p = u.source.width
                      , g = u.source.height
                      , m = e(o, "offset.x", 0)
                      , x = e(o, "offset.y", 0)
                      , T = e(o, "spacing.x", 0)
                      , E = e(o, "spacing.y", 0)
                      , P = e(o, "lineSpacing", 0)
                      , M = e(o, "charsPerRow", null);
                    M === null && (M = p / a,
                    M > i.length && (M = i.length));
                    for (var L = m, R = x, O = {
                        retroFont: !0,
                        font: h,
                        size: a,
                        lineHeight: n + P,
                        chars: {}
                    }, F = 0, B = 0; B < i.length; B++) {
                        var N = i.charCodeAt(B)
                          , Y = (d + L) / p
                          , z = (v + R) / g
                          , W = (d + L + a) / p
                          , b = (v + R + n) / g;
                        O.chars[N] = {
                            x: L,
                            y: R,
                            width: a,
                            height: n,
                            centerX: s,
                            centerY: l,
                            xOffset: 0,
                            yOffset: 0,
                            xAdvance: a,
                            data: {},
                            kerning: {},
                            u0: Y,
                            v0: z,
                            u1: W,
                            v1: b
                        },
                        F++,
                        F === M ? (F = 0,
                        L = m,
                        R += n + E) : L += a + T
                    }
                    var D = {
                        data: O,
                        frame: null,
                        texture: h
                    };
                    return D
                }
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1086),
            f = t(1087),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(19)
              , f = t(12)
              , r = function(o, a, n, s) {
                n.addToRenderList(a);
                var l = o.pipelines.set(a.pipeline, a)
                  , i = e(a, n, s).calc
                  , h = a.vertices
                  , u = a.uv
                  , d = a.colors
                  , v = a.alphas
                  , p = a.alpha
                  , g = f.getTintAppendFloatAlpha
                  , m = n.roundPixels
                  , x = h.length
                  , T = Math.floor(x * .5);
                l.flush(),
                o.pipelines.preBatch(a);
                var E = l.setGameObject(a)
                  , P = l.vertexViewF32
                  , M = l.vertexViewU32
                  , L = l.vertexCount * l.currentShader.vertexComponentCount - 1
                  , R = 0
                  , O = a.tintFill;
                a.dirty && a.updateVertices();
                for (var F = a.debugCallback, B = [], N = 0; N < x; N += 2) {
                    var Y = h[N + 0]
                      , z = h[N + 1]
                      , W = Y * i.a + z * i.c + i.e
                      , b = Y * i.b + z * i.d + i.f;
                    m && (W = Math.round(W),
                    b = Math.round(b)),
                    P[++L] = W,
                    P[++L] = b,
                    P[++L] = u[N + 0],
                    P[++L] = u[N + 1],
                    P[++L] = E,
                    P[++L] = O,
                    M[++L] = g(d[R], n.alpha * (v[R] * p)),
                    R++,
                    F && (B[N + 0] = W,
                    B[N + 1] = b)
                }
                F && F.call(a, a, x, B),
                l.vertexCount += T,
                o.pipelines.postBatch(a)
            };
            c.exports = r
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function() {};
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1089),
            f = t(1090),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(12)
              , f = function(r, o, a, n) {
                if (!(o.width === 0 || o.height === 0)) {
                    a.addToRenderList(o);
                    var s = o.frame
                      , l = s.width
                      , i = s.height
                      , h = e.getTintAppendFloatAlpha
                      , u = r.pipelines.set(o.pipeline, o)
                      , d = u.setTexture2D(s.glTexture, o);
                    r.pipelines.preBatch(o),
                    u.batchTexture(o, s.glTexture, l, i, o.x, o.y, l / o.style.resolution, i / o.style.resolution, o.scaleX, o.scaleY, o.rotation, o.flipX, o.flipY, o.scrollFactorX, o.scrollFactorY, o.displayOriginX, o.displayOriginY, 0, 0, l, i, h(o.tintTopLeft, a.alpha * o._alphaTL), h(o.tintTopRight, a.alpha * o._alphaTR), h(o.tintBottomLeft, a.alpha * o._alphaBL), h(o.tintBottomRight, a.alpha * o._alphaBR), o.tintFill, 0, 0, a, n, !1, d),
                    r.pipelines.postBatch(o)
                }
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                f.width === 0 || f.height === 0 || (r.addToRenderList(f),
                e.batchSprite(f, f.frame, r, o))
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1092),
            f = t(1093),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(12)
              , f = function(r, o, a, n) {
                o.updateCanvas();
                var s = o.width
                  , l = o.height;
                if (!(s === 0 || l === 0)) {
                    a.addToRenderList(o),
                    r.pipelines.preBatch(o);
                    var i = e.getTintAppendFloatAlpha
                      , h = r.pipelines.set(o.pipeline, o)
                      , u = h.setTexture2D(o.fillPattern, o);
                    h.batchTexture(o, o.fillPattern, o.displayFrame.width * o.tileScaleX, o.displayFrame.height * o.tileScaleY, o.x, o.y, s, l, o.scaleX, o.scaleY, o.rotation, o.flipX, o.flipY, o.scrollFactorX, o.scrollFactorY, o.originX * s, o.originY * l, 0, 0, s, l, i(o.tintTopLeft, a.alpha * o._alphaTL), i(o.tintTopRight, a.alpha * o._alphaTR), i(o.tintBottomLeft, a.alpha * o._alphaBL), i(o.tintBottomRight, a.alpha * o._alphaBR), o.tintFill, o.tilePositionX % o.displayFrame.width / o.displayFrame.width, o.tilePositionY % o.displayFrame.height / o.displayFrame.height, a, n, !1, u),
                    r.pipelines.postBatch(o)
                }
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                f.updateCanvas(),
                r.addToRenderList(f),
                e.batchSprite(f, f.frame, r, o)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1095),
            f = t(1096),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                f.videoTexture && (r.addToRenderList(f),
                f.pipeline.batchSprite(f, r, o))
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                f.videoTexture && (r.addToRenderList(f),
                e.batchSprite(f, f.frame, r, o))
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1098),
            f = t(1099),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(19)
              , f = t(114)
              , r = t(81)
              , o = function(a, n, s, l) {
                s.addToRenderList(n);
                var i = a.pipelines.set(n.pipeline)
                  , h = e(n, s, l)
                  , u = i.calcMatrix.copyFrom(h.calc)
                  , d = n._displayOriginX
                  , v = n._displayOriginY
                  , p = s.alpha * n.alpha;
                a.pipelines.preBatch(n),
                n.isFilled && f(i, u, n, p, d, v),
                n.isStroked && r(i, n, p, d, v),
                a.pipelines.postBatch(n)
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(36)
              , f = t(48)
              , r = t(60)
              , o = t(30)
              , a = function(n, s, l, i) {
                l.addToRenderList(s);
                var h = n.currentContext;
                if (o(n, h, s, l, i)) {
                    var u = s.radius;
                    h.beginPath(),
                    h.arc(u - s.originX * (u * 2), u - s.originY * (u * 2), u, e(s._startAngle), e(s._endAngle), s.anticlockwise),
                    s.closePath && h.closePath(),
                    s.isFilled && (f(h, s),
                    h.fill()),
                    s.isStroked && (r(h, s),
                    h.stroke()),
                    h.restore()
                }
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1101),
            f = t(1102),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(114)
              , f = t(19)
              , r = t(81)
              , o = function(a, n, s, l) {
                s.addToRenderList(n);
                var i = a.pipelines.set(n.pipeline)
                  , h = f(n, s, l)
                  , u = i.calcMatrix.copyFrom(h.calc)
                  , d = n._displayOriginX + n._curveBounds.x
                  , v = n._displayOriginY + n._curveBounds.y
                  , p = s.alpha * n.alpha;
                a.pipelines.preBatch(n),
                n.isFilled && e(i, u, n, p, d, v),
                n.isStroked && r(i, n, p, d, v),
                a.pipelines.postBatch(n)
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(48)
              , f = t(60)
              , r = t(30)
              , o = function(a, n, s, l) {
                s.addToRenderList(n);
                var i = a.currentContext;
                if (r(a, i, n, s, l)) {
                    var h = n._displayOriginX + n._curveBounds.x
                      , u = n._displayOriginY + n._curveBounds.y
                      , d = n.pathData
                      , v = d.length - 1
                      , p = d[0] - h
                      , g = d[1] - u;
                    i.beginPath(),
                    i.moveTo(p, g),
                    n.closePath || (v -= 2);
                    for (var m = 2; m < v; m += 2) {
                        var x = d[m] - h
                          , T = d[m + 1] - u;
                        i.lineTo(x, T)
                    }
                    n.closePath && i.closePath(),
                    n.isFilled && (e(i, n),
                    i.fill()),
                    n.isStroked && (f(i, n),
                    i.stroke()),
                    i.restore()
                }
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1104),
            f = t(1105),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(114)
              , f = t(19)
              , r = t(81)
              , o = function(a, n, s, l) {
                s.addToRenderList(n);
                var i = a.pipelines.set(n.pipeline)
                  , h = f(n, s, l)
                  , u = i.calcMatrix.copyFrom(h.calc)
                  , d = n._displayOriginX
                  , v = n._displayOriginY
                  , p = s.alpha * n.alpha;
                a.pipelines.preBatch(n),
                n.isFilled && e(i, u, n, p, d, v),
                n.isStroked && r(i, n, p, d, v),
                a.pipelines.postBatch(n)
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(48)
              , f = t(60)
              , r = t(30)
              , o = function(a, n, s, l) {
                s.addToRenderList(n);
                var i = a.currentContext;
                if (r(a, i, n, s, l)) {
                    var h = n._displayOriginX
                      , u = n._displayOriginY
                      , d = n.pathData
                      , v = d.length - 1
                      , p = d[0] - h
                      , g = d[1] - u;
                    i.beginPath(),
                    i.moveTo(p, g),
                    n.closePath || (v -= 2);
                    for (var m = 2; m < v; m += 2) {
                        var x = d[m] - h
                          , T = d[m + 1] - u;
                        i.lineTo(x, T)
                    }
                    i.closePath(),
                    n.isFilled && (e(i, n),
                    i.fill()),
                    n.isStroked && (f(i, n),
                    i.stroke()),
                    i.restore()
                }
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1107),
            f = t(1108),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(19)
              , f = t(12)
              , r = function(o, a, n, s) {
                n.addToRenderList(a);
                var l = o.pipelines.set(a.pipeline)
                  , i = e(a, n, s)
                  , h = l.calcMatrix.copyFrom(i.calc);
                h.translate(-a._displayOriginX, -a._displayOriginY);
                var u = n.alpha * a.alpha, d = a.width, v = a.height, p = a.cellWidth, g = a.cellHeight, m = Math.ceil(d / p), x = Math.ceil(v / g), T = p, E = g, P = p - (m * p - d), M = g - (x * g - v), L, R, O = a.showCells, F = a.showAltCells, B = a.showOutline, N = 0, Y = 0, z = 0, W = 0, b = 0;
                if (B && (T--,
                E--,
                P === p && P--,
                M === g && M--),
                o.pipelines.preBatch(a),
                O && a.fillAlpha > 0)
                    for (L = l.fillTint,
                    R = f.getTintAppendFloatAlpha(a.fillColor, a.fillAlpha * u),
                    L.TL = R,
                    L.TR = R,
                    L.BL = R,
                    L.BR = R,
                    Y = 0; Y < x; Y++)
                        for (F && (z = Y % 2),
                        N = 0; N < m; N++) {
                            if (F && z) {
                                z = 0;
                                continue
                            }
                            z++,
                            W = N < m - 1 ? T : P,
                            b = Y < x - 1 ? E : M,
                            l.batchFillRect(N * p, Y * g, W, b)
                        }
                if (F && a.altFillAlpha > 0)
                    for (L = l.fillTint,
                    R = f.getTintAppendFloatAlpha(a.altFillColor, a.altFillAlpha * u),
                    L.TL = R,
                    L.TR = R,
                    L.BL = R,
                    L.BR = R,
                    Y = 0; Y < x; Y++)
                        for (F && (z = Y % 2),
                        N = 0; N < m; N++) {
                            if (F && !z) {
                                z = 1;
                                continue
                            }
                            z = 0,
                            W = N < m - 1 ? T : P,
                            b = Y < x - 1 ? E : M,
                            l.batchFillRect(N * p, Y * g, W, b)
                        }
                if (B && a.outlineFillAlpha > 0) {
                    var D = l.strokeTint
                      , I = f.getTintAppendFloatAlpha(a.outlineFillColor, a.outlineFillAlpha * u);
                    for (D.TL = I,
                    D.TR = I,
                    D.BL = I,
                    D.BR = I,
                    N = 1; N < m; N++) {
                        var G = N * p;
                        l.batchLine(G, 0, G, v, 1, 1, 1, 0, !1)
                    }
                    for (Y = 1; Y < x; Y++) {
                        var w = Y * g;
                        l.batchLine(0, w, d, w, 1, 1, 1, 0, !1)
                    }
                }
                o.pipelines.postBatch(a)
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(48)
              , f = t(60)
              , r = t(30)
              , o = function(a, n, s, l) {
                s.addToRenderList(n);
                var i = a.currentContext;
                if (r(a, i, n, s, l)) {
                    var h = -n._displayOriginX
                      , u = -n._displayOriginY
                      , d = s.alpha * n.alpha
                      , v = n.width
                      , p = n.height
                      , g = n.cellWidth
                      , m = n.cellHeight
                      , x = Math.ceil(v / g)
                      , T = Math.ceil(p / m)
                      , E = g
                      , P = m
                      , M = g - (x * g - v)
                      , L = m - (T * m - p)
                      , R = n.showCells
                      , O = n.showAltCells
                      , F = n.showOutline
                      , B = 0
                      , N = 0
                      , Y = 0
                      , z = 0
                      , W = 0;
                    if (F && (E--,
                    P--,
                    M === g && M--,
                    L === m && L--),
                    R && n.fillAlpha > 0)
                        for (e(i, n),
                        N = 0; N < T; N++)
                            for (O && (Y = N % 2),
                            B = 0; B < x; B++) {
                                if (O && Y) {
                                    Y = 0;
                                    continue
                                }
                                Y++,
                                z = B < x - 1 ? E : M,
                                W = N < T - 1 ? P : L,
                                i.fillRect(h + B * g, u + N * m, z, W)
                            }
                    if (O && n.altFillAlpha > 0)
                        for (e(i, n, n.altFillColor, n.altFillAlpha * d),
                        N = 0; N < T; N++)
                            for (O && (Y = N % 2),
                            B = 0; B < x; B++) {
                                if (O && !Y) {
                                    Y = 1;
                                    continue
                                }
                                Y = 0,
                                z = B < x - 1 ? E : M,
                                W = N < T - 1 ? P : L,
                                i.fillRect(h + B * g, u + N * m, z, W)
                            }
                    if (F && n.outlineFillAlpha > 0) {
                        for (f(i, n, n.outlineFillColor, n.outlineFillAlpha * d),
                        B = 1; B < x; B++) {
                            var b = B * g;
                            i.beginPath(),
                            i.moveTo(b + h, u),
                            i.lineTo(b + h, p + u),
                            i.stroke()
                        }
                        for (N = 1; N < T; N++) {
                            var D = N * m;
                            i.beginPath(),
                            i.moveTo(h, D + u),
                            i.lineTo(h + v, D + u),
                            i.stroke()
                        }
                    }
                    i.restore()
                }
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1110),
            f = t(1111),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(19)
              , f = t(12)
              , r = function(o, a, n, s) {
                n.addToRenderList(a);
                var l = o.pipelines.set(a.pipeline)
                  , i = e(a, n, s)
                  , h = l.calcMatrix.copyFrom(i.calc)
                  , u = a.width
                  , d = a.height
                  , v = u / 2
                  , p = u / a.projection
                  , g = n.alpha * a.alpha;
                if (a.isFilled) {
                    var m, x, T, E, P, M, L, R, O;
                    o.pipelines.preBatch(a),
                    a.showTop && (m = f.getTintAppendFloatAlpha(a.fillTop, g),
                    x = h.getX(-v, -d),
                    T = h.getY(-v, -d),
                    E = h.getX(0, -p - d),
                    P = h.getY(0, -p - d),
                    M = h.getX(v, -d),
                    L = h.getY(v, -d),
                    R = h.getX(0, p - d),
                    O = h.getY(0, p - d),
                    l.batchQuad(a, x, T, E, P, M, L, R, O, 0, 0, 1, 1, m, m, m, m, 2)),
                    a.showLeft && (m = f.getTintAppendFloatAlpha(a.fillLeft, g),
                    x = h.getX(-v, 0),
                    T = h.getY(-v, 0),
                    E = h.getX(0, p),
                    P = h.getY(0, p),
                    M = h.getX(0, p - d),
                    L = h.getY(0, p - d),
                    R = h.getX(-v, -d),
                    O = h.getY(-v, -d),
                    l.batchQuad(a, x, T, E, P, M, L, R, O, 0, 0, 1, 1, m, m, m, m, 2)),
                    a.showRight && (m = f.getTintAppendFloatAlpha(a.fillRight, g),
                    x = h.getX(v, 0),
                    T = h.getY(v, 0),
                    E = h.getX(0, p),
                    P = h.getY(0, p),
                    M = h.getX(0, p - d),
                    L = h.getY(0, p - d),
                    R = h.getX(v, -d),
                    O = h.getY(v, -d),
                    l.batchQuad(a, x, T, E, P, M, L, R, O, 0, 0, 1, 1, m, m, m, m, 2)),
                    o.pipelines.postBatch(a)
                }
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(48)
              , f = t(30)
              , r = function(o, a, n, s) {
                n.addToRenderList(a);
                var l = o.currentContext;
                if (f(o, l, a, n, s) && a.isFilled) {
                    var i = a.width
                      , h = a.height
                      , u = i / 2
                      , d = i / a.projection;
                    a.showTop && (e(l, a, a.fillTop),
                    l.beginPath(),
                    l.moveTo(-u, -h),
                    l.lineTo(0, -d - h),
                    l.lineTo(u, -h),
                    l.lineTo(u, -1),
                    l.lineTo(0, d - 1),
                    l.lineTo(-u, -1),
                    l.lineTo(-u, -h),
                    l.fill()),
                    a.showLeft && (e(l, a, a.fillLeft),
                    l.beginPath(),
                    l.moveTo(-u, 0),
                    l.lineTo(0, d),
                    l.lineTo(0, d - h),
                    l.lineTo(-u, -h),
                    l.lineTo(-u, 0),
                    l.fill()),
                    a.showRight && (e(l, a, a.fillRight),
                    l.beginPath(),
                    l.moveTo(u, 0),
                    l.lineTo(0, d),
                    l.lineTo(0, d - h),
                    l.lineTo(u, -h),
                    l.lineTo(u, 0),
                    l.fill()),
                    l.restore()
                }
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1113),
            f = t(1114),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(19)
              , f = t(12)
              , r = function(o, a, n, s) {
                n.addToRenderList(a);
                var l = o.pipelines.set(a.pipeline)
                  , i = e(a, n, s)
                  , h = l.calcMatrix.copyFrom(i.calc)
                  , u = a.width
                  , d = a.height
                  , v = u / 2
                  , p = u / a.projection
                  , g = a.isReversed
                  , m = n.alpha * a.alpha;
                if (a.isFilled) {
                    o.pipelines.preBatch(a);
                    var x, T, E, P, M, L, R;
                    if (a.showTop && g) {
                        x = f.getTintAppendFloatAlpha(a.fillTop, m),
                        T = h.getX(-v, -d),
                        E = h.getY(-v, -d),
                        P = h.getX(0, -p - d),
                        M = h.getY(0, -p - d),
                        L = h.getX(v, -d),
                        R = h.getY(v, -d);
                        var O = h.getX(0, p - d)
                          , F = h.getY(0, p - d);
                        l.batchQuad(a, T, E, P, M, L, R, O, F, 0, 0, 1, 1, x, x, x, x, 2)
                    }
                    a.showLeft && (x = f.getTintAppendFloatAlpha(a.fillLeft, m),
                    g ? (T = h.getX(-v, -d),
                    E = h.getY(-v, -d),
                    P = h.getX(0, p),
                    M = h.getY(0, p),
                    L = h.getX(0, p - d),
                    R = h.getY(0, p - d)) : (T = h.getX(-v, 0),
                    E = h.getY(-v, 0),
                    P = h.getX(0, p),
                    M = h.getY(0, p),
                    L = h.getX(0, p - d),
                    R = h.getY(0, p - d)),
                    l.batchTri(a, T, E, P, M, L, R, 0, 0, 1, 1, x, x, x, 2)),
                    a.showRight && (x = f.getTintAppendFloatAlpha(a.fillRight, m),
                    g ? (T = h.getX(v, -d),
                    E = h.getY(v, -d),
                    P = h.getX(0, p),
                    M = h.getY(0, p),
                    L = h.getX(0, p - d),
                    R = h.getY(0, p - d)) : (T = h.getX(v, 0),
                    E = h.getY(v, 0),
                    P = h.getX(0, p),
                    M = h.getY(0, p),
                    L = h.getX(0, p - d),
                    R = h.getY(0, p - d)),
                    l.batchTri(a, T, E, P, M, L, R, 0, 0, 1, 1, x, x, x, 2)),
                    o.pipelines.postBatch(a)
                }
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(48)
              , f = t(30)
              , r = function(o, a, n, s) {
                n.addToRenderList(a);
                var l = o.currentContext;
                if (f(o, l, a, n, s) && a.isFilled) {
                    var i = a.width
                      , h = a.height
                      , u = i / 2
                      , d = i / a.projection
                      , v = a.isReversed;
                    a.showTop && v && (e(l, a, a.fillTop),
                    l.beginPath(),
                    l.moveTo(-u, -h),
                    l.lineTo(0, -d - h),
                    l.lineTo(u, -h),
                    l.lineTo(0, d - h),
                    l.fill()),
                    a.showLeft && (e(l, a, a.fillLeft),
                    l.beginPath(),
                    v ? (l.moveTo(-u, -h),
                    l.lineTo(0, d),
                    l.lineTo(0, d - h)) : (l.moveTo(-u, 0),
                    l.lineTo(0, d),
                    l.lineTo(0, d - h)),
                    l.fill()),
                    a.showRight && (e(l, a, a.fillRight),
                    l.beginPath(),
                    v ? (l.moveTo(u, -h),
                    l.lineTo(0, d),
                    l.lineTo(0, d - h)) : (l.moveTo(u, 0),
                    l.lineTo(0, d),
                    l.lineTo(0, d - h)),
                    l.fill()),
                    l.restore()
                }
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1116),
            f = t(1117),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(19)
              , f = t(12)
              , r = function(o, a, n, s) {
                n.addToRenderList(a);
                var l = o.pipelines.set(a.pipeline)
                  , i = e(a, n, s);
                l.calcMatrix.copyFrom(i.calc);
                var h = a._displayOriginX
                  , u = a._displayOriginY
                  , d = n.alpha * a.alpha;
                if (o.pipelines.preBatch(a),
                a.isStroked) {
                    var v = l.strokeTint
                      , p = f.getTintAppendFloatAlpha(a.strokeColor, a.strokeAlpha * d);
                    v.TL = p,
                    v.TR = p,
                    v.BL = p,
                    v.BR = p;
                    var g = a._startWidth
                      , m = a._endWidth;
                    l.batchLine(a.geom.x1 - h, a.geom.y1 - u, a.geom.x2 - h, a.geom.y2 - u, g, m, 1, 0, !1, i.sprite, i.camera)
                }
                o.pipelines.postBatch(a)
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(60)
              , f = t(30)
              , r = function(o, a, n, s) {
                n.addToRenderList(a);
                var l = o.currentContext;
                if (f(o, l, a, n, s)) {
                    var i = a._displayOriginX
                      , h = a._displayOriginY;
                    a.isStroked && (e(l, a),
                    l.beginPath(),
                    l.moveTo(a.geom.x1 - i, a.geom.y1 - h),
                    l.lineTo(a.geom.x2 - i, a.geom.y2 - h),
                    l.stroke()),
                    l.restore()
                }
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1119),
            f = t(1120),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(114)
              , f = t(19)
              , r = t(81)
              , o = function(a, n, s, l) {
                s.addToRenderList(n);
                var i = a.pipelines.set(n.pipeline)
                  , h = f(n, s, l)
                  , u = i.calcMatrix.copyFrom(h.calc)
                  , d = n._displayOriginX
                  , v = n._displayOriginY
                  , p = s.alpha * n.alpha;
                a.pipelines.preBatch(n),
                n.isFilled && e(i, u, n, p, d, v),
                n.isStroked && r(i, n, p, d, v),
                a.pipelines.postBatch(n)
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(48)
              , f = t(60)
              , r = t(30)
              , o = function(a, n, s, l) {
                s.addToRenderList(n);
                var i = a.currentContext;
                if (r(a, i, n, s, l)) {
                    var h = n._displayOriginX
                      , u = n._displayOriginY
                      , d = n.pathData
                      , v = d.length - 1
                      , p = d[0] - h
                      , g = d[1] - u;
                    i.beginPath(),
                    i.moveTo(p, g),
                    n.closePath || (v -= 2);
                    for (var m = 2; m < v; m += 2) {
                        var x = d[m] - h
                          , T = d[m + 1] - u;
                        i.lineTo(x, T)
                    }
                    i.closePath(),
                    n.isFilled && (e(i, n),
                    i.fill()),
                    n.isStroked && (f(i, n),
                    i.stroke()),
                    i.restore()
                }
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1122),
            f = t(1123),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(19)
              , f = t(81)
              , r = t(12)
              , o = function(a, n, s, l) {
                s.addToRenderList(n);
                var i = a.pipelines.set(n.pipeline)
                  , h = e(n, s, l);
                i.calcMatrix.copyFrom(h.calc);
                var u = n._displayOriginX
                  , d = n._displayOriginY
                  , v = s.alpha * n.alpha;
                if (a.pipelines.preBatch(n),
                n.isFilled) {
                    var p = i.fillTint
                      , g = r.getTintAppendFloatAlpha(n.fillColor, n.fillAlpha * v);
                    p.TL = g,
                    p.TR = g,
                    p.BL = g,
                    p.BR = g,
                    i.batchFillRect(-u, -d, n.width, n.height)
                }
                n.isStroked && f(i, n, v, u, d),
                a.pipelines.postBatch(n)
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(48)
              , f = t(60)
              , r = t(30)
              , o = function(a, n, s, l) {
                s.addToRenderList(n);
                var i = a.currentContext;
                if (r(a, i, n, s, l)) {
                    var h = n._displayOriginX
                      , u = n._displayOriginY;
                    n.isFilled && (e(i, n),
                    i.fillRect(-h, -u, n.width, n.height)),
                    n.isStroked && (f(i, n),
                    i.beginPath(),
                    i.rect(-h, -u, n.width, n.height),
                    i.stroke()),
                    i.restore()
                }
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1125),
            f = t(1126),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(114)
              , f = t(19)
              , r = t(81)
              , o = function(a, n, s, l) {
                s.addToRenderList(n);
                var i = a.pipelines.set(n.pipeline)
                  , h = f(n, s, l)
                  , u = i.calcMatrix.copyFrom(h.calc)
                  , d = n._displayOriginX
                  , v = n._displayOriginY
                  , p = s.alpha * n.alpha;
                a.pipelines.preBatch(n),
                n.isFilled && e(i, u, n, p, d, v),
                n.isStroked && r(i, n, p, d, v),
                a.pipelines.postBatch(n)
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(48)
              , f = t(60)
              , r = t(30)
              , o = function(a, n, s, l) {
                s.addToRenderList(n);
                var i = a.currentContext;
                if (r(a, i, n, s, l)) {
                    var h = n._displayOriginX
                      , u = n._displayOriginY
                      , d = n.pathData
                      , v = d.length - 1
                      , p = d[0] - h
                      , g = d[1] - u;
                    i.beginPath(),
                    i.moveTo(p, g),
                    n.closePath || (v -= 2);
                    for (var m = 2; m < v; m += 2) {
                        var x = d[m] - h
                          , T = d[m + 1] - u;
                        i.lineTo(x, T)
                    }
                    i.closePath(),
                    n.isFilled && (e(i, n),
                    i.fill()),
                    n.isStroked && (f(i, n),
                    i.stroke()),
                    i.restore()
                }
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1128),
            f = t(1129),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(19)
              , f = t(81)
              , r = t(12)
              , o = function(a, n, s, l) {
                s.addToRenderList(n);
                var i = a.pipelines.set(n.pipeline)
                  , h = e(n, s, l);
                i.calcMatrix.copyFrom(h.calc);
                var u = n._displayOriginX
                  , d = n._displayOriginY
                  , v = s.alpha * n.alpha;
                if (a.pipelines.preBatch(n),
                n.isFilled) {
                    var p = i.fillTint
                      , g = r.getTintAppendFloatAlpha(n.fillColor, n.fillAlpha * v);
                    p.TL = g,
                    p.TR = g,
                    p.BL = g,
                    p.BR = g;
                    var m = n.geom.x1 - u
                      , x = n.geom.y1 - d
                      , T = n.geom.x2 - u
                      , E = n.geom.y2 - d
                      , P = n.geom.x3 - u
                      , M = n.geom.y3 - d;
                    i.batchFillTriangle(m, x, T, E, P, M, h.sprite, h.camera)
                }
                n.isStroked && f(i, n, v, u, d),
                a.pipelines.postBatch(n)
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(48)
              , f = t(60)
              , r = t(30)
              , o = function(a, n, s, l) {
                s.addToRenderList(n);
                var i = a.currentContext;
                if (r(a, i, n, s, l)) {
                    var h = n._displayOriginX
                      , u = n._displayOriginY
                      , d = n.geom.x1 - h
                      , v = n.geom.y1 - u
                      , p = n.geom.x2 - h
                      , g = n.geom.y2 - u
                      , m = n.geom.x3 - h
                      , x = n.geom.y3 - u;
                    i.beginPath(),
                    i.moveTo(d, v),
                    i.lineTo(p, g),
                    i.lineTo(m, x),
                    i.closePath(),
                    n.isFilled && (e(i, n),
                    i.fill()),
                    n.isStroked && (f(i, n),
                    i.stroke()),
                    i.restore()
                }
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(213)
              , f = t(5);
            f.register("blitter", function(r, o, a, n) {
                return this.displayList.add(new e(this.scene,r,o,a,n))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(214)
              , f = t(5);
            f.register("container", function(r, o, a) {
                return this.displayList.add(new e(this.scene,r,o,a))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(442)
              , f = t(5);
            f.register("dom", function(r, o, a, n, s) {
                var l = new e(this.scene,r,o,a,n,s);
                return this.displayList.add(l),
                l
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(215)
              , f = t(5);
            f.register("dynamicBitmapText", function(r, o, a, n, s) {
                return this.displayList.add(new e(this.scene,r,o,a,n,s))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(444)
              , f = t(5);
            f.register("extern", function() {
                var r = new e(this.scene);
                return this.displayList.add(r),
                r
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(216)
              , f = t(5);
            f.register("graphics", function(r) {
                return this.displayList.add(new e(this.scene,r))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(113)
              , f = t(5);
            f.register("group", function(r, o) {
                return this.updateList.add(new e(this.scene,r,o))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(125)
              , f = t(5);
            f.register("image", function(r, o, a, n) {
                return this.displayList.add(new e(this.scene,r,o,a,n))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(219)
              , f = t(5);
            f.register("layer", function(r) {
                return this.displayList.add(new e(this.scene,r))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(5)
              , f = t(220);
            e.register("particles", function(r, o, a) {
                return this.displayList.add(new f(this.scene,r,o,a))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(5)
              , f = t(457);
            e.register("follower", function(r, o, a, n, s) {
                var l = new f(this.scene,r,o,a,n,s);
                return this.displayList.add(l),
                this.updateList.add(l),
                l
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(5)
              , f = t(221);
            e.register("renderTexture", function(r, o, a, n, s, l) {
                return this.displayList.add(new f(this.scene,r,o,a,n,s,l))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(223)
              , f = t(5);
            f.register("rope", function(r, o, a, n, s, l, i, h) {
                return this.displayList.add(new e(this.scene,r,o,a,n,s,l,i,h))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(5)
              , f = t(73);
            e.register("sprite", function(r, o, a, n) {
                var s = new f(this.scene,r,o,a,n);
                return this.displayList.add(s),
                s
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(148)
              , f = t(5);
            f.register("bitmapText", function(r, o, a, n, s, l) {
                return this.displayList.add(new e(this.scene,r,o,a,n,s,l))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(224)
              , f = t(5);
            f.register("text", function(r, o, a, n) {
                return this.displayList.add(new e(this.scene,r,o,a,n))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(225)
              , f = t(5);
            f.register("tileSprite", function(r, o, a, n, s, l) {
                return this.displayList.add(new e(this.scene,r,o,a,n,s,l))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(129)
              , f = t(5);
            f.register("zone", function(r, o, a, n) {
                return this.displayList.add(new e(this.scene,r,o,a,n))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(226)
              , f = t(5);
            f.register("video", function(r, o, a) {
                return this.displayList.add(new e(this.scene,r,o,a))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(461)
              , f = t(5);
            f.register("arc", function(r, o, a, n, s, l, i, h) {
                return this.displayList.add(new e(this.scene,r,o,a,n,s,l,i,h))
            }),
            f.register("circle", function(r, o, a, n, s) {
                return this.displayList.add(new e(this.scene,r,o,a,0,360,!1,n,s))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(5)
              , f = t(462);
            e.register("curve", function(r, o, a, n, s) {
                return this.displayList.add(new f(this.scene,r,o,a,n,s))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(463)
              , f = t(5);
            f.register("ellipse", function(r, o, a, n, s, l) {
                return this.displayList.add(new e(this.scene,r,o,a,n,s,l))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(5)
              , f = t(464);
            e.register("grid", function(r, o, a, n, s, l, i, h, u, d) {
                return this.displayList.add(new f(this.scene,r,o,a,n,s,l,i,h,u,d))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(5)
              , f = t(465);
            e.register("isobox", function(r, o, a, n, s, l, i) {
                return this.displayList.add(new f(this.scene,r,o,a,n,s,l,i))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(5)
              , f = t(466);
            e.register("isotriangle", function(r, o, a, n, s, l, i, h) {
                return this.displayList.add(new f(this.scene,r,o,a,n,s,l,i,h))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(5)
              , f = t(467);
            e.register("line", function(r, o, a, n, s, l, i, h) {
                return this.displayList.add(new f(this.scene,r,o,a,n,s,l,i,h))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(5)
              , f = t(468);
            e.register("polygon", function(r, o, a, n, s) {
                return this.displayList.add(new f(this.scene,r,o,a,n,s))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(5)
              , f = t(473);
            e.register("rectangle", function(r, o, a, n, s, l) {
                return this.displayList.add(new f(this.scene,r,o,a,n,s,l))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(474)
              , f = t(5);
            f.register("star", function(r, o, a, n, s, l, i) {
                return this.displayList.add(new e(this.scene,r,o,a,n,s,l,i))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(5)
              , f = t(475);
            e.register("triangle", function(r, o, a, n, s, l, i, h, u, d) {
                return this.displayList.add(new f(this.scene,r,o,a,n,s,l,i,h,u,d))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(213)
              , f = t(28)
              , r = t(16)
              , o = t(13);
            r.register("blitter", function(a, n) {
                a === void 0 && (a = {});
                var s = o(a, "key", null)
                  , l = o(a, "frame", null)
                  , i = new e(this.scene,0,0,s,l);
                return n !== void 0 && (a.add = n),
                f(this.scene, i, a),
                i
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(28)
              , f = t(214)
              , r = t(16)
              , o = t(13);
            r.register("container", function(a, n) {
                a === void 0 && (a = {});
                var s = o(a, "x", 0)
                  , l = o(a, "y", 0)
                  , i = o(a, "children", null)
                  , h = new f(this.scene,s,l,i);
                return n !== void 0 && (a.add = n),
                e(this.scene, h, a),
                h
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(215)
              , f = t(28)
              , r = t(16)
              , o = t(13);
            r.register("dynamicBitmapText", function(a, n) {
                a === void 0 && (a = {});
                var s = o(a, "font", "")
                  , l = o(a, "text", "")
                  , i = o(a, "size", !1)
                  , h = new e(this.scene,0,0,s,l,i);
                return n !== void 0 && (a.add = n),
                f(this.scene, h, a),
                h
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(16)
              , f = t(216);
            e.register("graphics", function(r, o) {
                r === void 0 && (r = {}),
                o !== void 0 && (r.add = o);
                var a = new f(this.scene,r);
                return r.add && this.scene.sys.displayList.add(a),
                a
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(16)
              , f = t(113);
            e.register("group", function(r) {
                return new f(this.scene,null,r)
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(28)
              , f = t(16)
              , r = t(13)
              , o = t(125);
            f.register("image", function(a, n) {
                a === void 0 && (a = {});
                var s = r(a, "key", null)
                  , l = r(a, "frame", null)
                  , i = new o(this.scene,0,0,s,l);
                return n !== void 0 && (a.add = n),
                e(this.scene, i, a),
                i
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(28)
              , f = t(219)
              , r = t(16)
              , o = t(13);
            r.register("layer", function(a, n) {
                a === void 0 && (a = {});
                var s = o(a, "children", null)
                  , l = new f(this.scene,s);
                return n !== void 0 && (a.add = n),
                e(this.scene, l, a),
                l
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(16)
              , f = t(13)
              , r = t(2)
              , o = t(220);
            e.register("particles", function(a, n) {
                a === void 0 && (a = {});
                var s = f(a, "key", null)
                  , l = f(a, "frame", null)
                  , i = r(a, "emitters", null)
                  , h = new o(this.scene,s,l,i);
                n !== void 0 && (a.add = n);
                var u = r(a, "add", !1);
                return u ? this.displayList.add(h) : this.updateList.add(h),
                h
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(28)
              , f = t(16)
              , r = t(13)
              , o = t(221);
            f.register("renderTexture", function(a, n) {
                a === void 0 && (a = {});
                var s = r(a, "x", 0)
                  , l = r(a, "y", 0)
                  , i = r(a, "width", 32)
                  , h = r(a, "height", 32)
                  , u = r(a, "key", void 0)
                  , d = r(a, "frame", void 0)
                  , v = new o(this.scene,s,l,i,h,u,d);
                return n !== void 0 && (a.add = n),
                e(this.scene, v, a),
                v
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(28)
              , f = t(16)
              , r = t(13)
              , o = t(6)
              , a = t(223);
            f.register("rope", function(n, s) {
                n === void 0 && (n = {});
                var l = r(n, "key", null)
                  , i = r(n, "frame", null)
                  , h = r(n, "horizontal", !0)
                  , u = o(n, "points", void 0)
                  , d = o(n, "colors", void 0)
                  , v = o(n, "alphas", void 0)
                  , p = new a(this.scene,0,0,l,i,u,h,d,v);
                return s !== void 0 && (n.add = s),
                e(this.scene, p, n),
                n.add || this.updateList.add(p),
                p
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(28)
              , f = t(439)
              , r = t(16)
              , o = t(13)
              , a = t(73);
            r.register("sprite", function(n, s) {
                n === void 0 && (n = {});
                var l = o(n, "key", null)
                  , i = o(n, "frame", null)
                  , h = new a(this.scene,0,0,l,i);
                return s !== void 0 && (n.add = s),
                e(this.scene, h, n),
                f(h, n),
                h
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(148)
              , f = t(28)
              , r = t(16)
              , o = t(13)
              , a = t(6);
            r.register("bitmapText", function(n, s) {
                n === void 0 && (n = {});
                var l = a(n, "font", "")
                  , i = o(n, "text", "")
                  , h = o(n, "size", !1)
                  , u = a(n, "align", 0)
                  , d = new e(this.scene,0,0,l,i,h,u);
                return s !== void 0 && (n.add = s),
                f(this.scene, d, n),
                d
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(28)
              , f = t(16)
              , r = t(13)
              , o = t(224);
            f.register("text", function(a, n) {
                a === void 0 && (a = {});
                var s = r(a, "text", "")
                  , l = r(a, "style", null)
                  , i = r(a, "padding", null);
                i !== null && (l.padding = i);
                var h = new o(this.scene,0,0,s,l);
                return n !== void 0 && (a.add = n),
                e(this.scene, h, a),
                h.autoRound = r(a, "autoRound", !0),
                h.resolution = r(a, "resolution", 1),
                h
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(28)
              , f = t(16)
              , r = t(13)
              , o = t(225);
            f.register("tileSprite", function(a, n) {
                a === void 0 && (a = {});
                var s = r(a, "x", 0)
                  , l = r(a, "y", 0)
                  , i = r(a, "width", 512)
                  , h = r(a, "height", 512)
                  , u = r(a, "key", "")
                  , d = r(a, "frame", "")
                  , v = new o(this.scene,s,l,i,h,u,d);
                return n !== void 0 && (a.add = n),
                e(this.scene, v, a),
                v
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(16)
              , f = t(13)
              , r = t(129);
            e.register("zone", function(o) {
                var a = f(o, "x", 0)
                  , n = f(o, "y", 0)
                  , s = f(o, "width", 1)
                  , l = f(o, "height", s);
                return new r(this.scene,a,n,s,l)
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(28)
              , f = t(16)
              , r = t(13)
              , o = t(226);
            f.register("video", function(a, n) {
                a === void 0 && (a = {});
                var s = r(a, "key", null)
                  , l = new o(this.scene,0,0,s);
                return n !== void 0 && (a.add = n),
                e(this.scene, l, a),
                a.add || this.updateList.add(l),
                l
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1177),
            f = t(1178),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(19)
              , f = function(r, o, a, n) {
                if (o.shader) {
                    if (a.addToRenderList(o),
                    r.pipelines.clear(),
                    o.renderToTexture)
                        o.load(),
                        o.flush();
                    else {
                        var s = e(o, a, n).calc;
                        (r.width !== o._rendererWidth || r.height !== o._rendererHeight) && o.projOrtho(0, r.width, r.height, 0),
                        o.load(s.matrix),
                        o.flush()
                    }
                    r.pipelines.rebind()
                }
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function() {};
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1180),
            f = t(1181),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(19)
              , f = function(r, o, a, n) {
                var s = o.faces
                  , l = s.length;
                if (l !== 0) {
                    a.addToRenderList(o);
                    var i = r.pipelines.set(o.pipeline, o)
                      , h = e(o, a, n).calc
                      , u = i.setGameObject(o)
                      , d = i.vertexViewF32
                      , v = i.vertexViewU32
                      , p = i.vertexCount * i.currentShader.vertexComponentCount - 1
                      , g = o.tintFill
                      , m = []
                      , x = o.debugCallback
                      , T = h.a
                      , E = h.b
                      , P = h.c
                      , M = h.d
                      , L = h.e
                      , R = h.f
                      , O = o.viewPosition.z
                      , F = o.hideCCW
                      , B = a.roundPixels
                      , N = a.alpha * o.alpha
                      , Y = 0;
                    r.pipelines.preBatch(o);
                    for (var z = 0; z < l; z++) {
                        var W = s[z];
                        W.isInView(a, F, O, N, T, E, P, M, L, R, B) && (i.shouldFlush(3) && (i.flush(),
                        p = 0),
                        p = W.load(d, v, p, u, g),
                        Y++,
                        i.vertexCount += 3,
                        x && m.push(W))
                    }
                    o.totalFrame += Y,
                    x && x.call(o, o, m),
                    r.pipelines.postBatch(o)
                }
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function() {};
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1183),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(19)
              , f = function(r, o, a, n) {
                a.addToRenderList(o);
                var s = r.pipelines.set(o.pipeline)
                  , l = e(o, a, n).calc
                  , i = o.width
                  , h = o.height
                  , u = -o._radius
                  , d = -o._radius
                  , v = u + i
                  , p = d + h
                  , g = l.getX(0, 0)
                  , m = l.getY(0, 0)
                  , x = l.getX(u, d)
                  , T = l.getY(u, d)
                  , E = l.getX(u, p)
                  , P = l.getY(u, p)
                  , M = l.getX(v, p)
                  , L = l.getY(v, p)
                  , R = l.getX(v, d)
                  , O = l.getY(v, d);
                r.pipelines.preBatch(o),
                s.batchPointLight(o, a, x, T, E, P, M, L, R, O, g, m),
                r.pipelines.postBatch(o)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(229)
              , f = t(5);
            f.register("shader", function(r, o, a, n, s, l, i) {
                return this.displayList.add(new e(this.scene,r,o,a,n,s,l,i))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(230)
              , f = t(5);
            f.register("mesh", function(r, o, a, n, s, l, i, h, u, d, v) {
                return this.displayList.add(new e(this.scene,r,o,a,n,s,l,i,h,u,d,v))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(5)
              , f = t(150);
            e.register("pointlight", function(r, o, a, n, s, l) {
                return this.displayList.add(new f(this.scene,r,o,a,n,s,l))
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(28)
              , f = t(16)
              , r = t(13)
              , o = t(229);
            f.register("shader", function(a, n) {
                a === void 0 && (a = {});
                var s = r(a, "key", null)
                  , l = r(a, "x", 0)
                  , i = r(a, "y", 0)
                  , h = r(a, "width", 128)
                  , u = r(a, "height", 128)
                  , d = new o(this.scene,s,l,i,h,u);
                return n !== void 0 && (a.add = n),
                e(this.scene, d, a),
                d
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(28)
              , f = t(16)
              , r = t(13)
              , o = t(6)
              , a = t(230);
            f.register("mesh", function(n, s) {
                n === void 0 && (n = {});
                var l = r(n, "key", null)
                  , i = r(n, "frame", null)
                  , h = o(n, "vertices", [])
                  , u = o(n, "uvs", [])
                  , d = o(n, "indicies", [])
                  , v = o(n, "containsZ", !1)
                  , p = o(n, "normals", [])
                  , g = o(n, "colors", 16777215)
                  , m = o(n, "alphas", 1)
                  , x = new a(this.scene,0,0,l,i,h,u,d,v,p,g,m);
                return s !== void 0 && (n.add = s),
                e(this.scene, x, n),
                x
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(28)
              , f = t(16)
              , r = t(13)
              , o = t(150);
            f.register("pointlight", function(a, n) {
                a === void 0 && (a = {});
                var s = r(a, "color", 16777215)
                  , l = r(a, "radius", 128)
                  , i = r(a, "intensity", 1)
                  , h = r(a, "attenuation", .1)
                  , u = new o(this.scene,0,0,s,l,i,h);
                return n !== void 0 && (a.add = n),
                e(this.scene, u, a),
                u
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(482)
              , r = t(24)
              , o = t(20)
              , a = new e({
                Extends: f,
                initialize: function(s) {
                    this.scene = s,
                    this.systems = s.sys,
                    s.sys.settings.isBooted || s.sys.events.once(o.BOOT, this.boot, this),
                    f.call(this)
                },
                boot: function() {
                    var n = this.systems.events;
                    n.on(o.SHUTDOWN, this.shutdown, this),
                    n.on(o.DESTROY, this.destroy, this)
                },
                destroy: function() {
                    this.shutdown(),
                    this.scene = void 0,
                    this.systems = void 0
                }
            });
            r.register("LightsPlugin", a, "lights"),
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(65);
            e.Area = t(1192),
            e.Circumference = t(302),
            e.CircumferencePoint = t(169),
            e.Clone = t(1193),
            e.Contains = t(66),
            e.ContainsPoint = t(1194),
            e.ContainsRect = t(1195),
            e.CopyFrom = t(1196),
            e.Equals = t(1197),
            e.GetBounds = t(1198),
            e.GetPoint = t(300),
            e.GetPoints = t(301),
            e.Offset = t(1199),
            e.OffsetPoint = t(1200),
            e.Random = t(170),
            c.exports = e
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e.radius > 0 ? Math.PI * e.radius * e.radius : 0
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(65)
              , f = function(r) {
                return new e(r.x,r.y,r.radius)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(66)
              , f = function(r, o) {
                return e(r, o.x, o.y)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(66)
              , f = function(r, o) {
                return e(r, o.x, o.y) && e(r, o.right, o.y) && e(r, o.x, o.bottom) && e(r, o.right, o.bottom)
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return f.setTo(e.x, e.y, e.radius)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return e.x === f.x && e.y === f.y && e.radius === f.radius
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(10)
              , f = function(r, o) {
                return o === void 0 && (o = new e),
                o.x = r.left,
                o.y = r.top,
                o.width = r.diameter,
                o.height = r.diameter,
                o
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                return e.x += f,
                e.y += r,
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return e.x += f.x,
                e.y += f.y,
                e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(111);
            e.Area = t(1202),
            e.Circumference = t(447),
            e.CircumferencePoint = t(218),
            e.Clone = t(1203),
            e.Contains = t(112),
            e.ContainsPoint = t(1204),
            e.ContainsRect = t(1205),
            e.CopyFrom = t(1206),
            e.Equals = t(1207),
            e.GetBounds = t(1208),
            e.GetPoint = t(445),
            e.GetPoints = t(446),
            e.Offset = t(1209),
            e.OffsetPoint = t(1210),
            e.Random = t(180),
            c.exports = e
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e.isEmpty() ? 0 : e.getMajorRadius() * e.getMinorRadius() * Math.PI
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(111)
              , f = function(r) {
                return new e(r.x,r.y,r.width,r.height)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(112)
              , f = function(r, o) {
                return e(r, o.x, o.y)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(112)
              , f = function(r, o) {
                return e(r, o.x, o.y) && e(r, o.right, o.y) && e(r, o.x, o.bottom) && e(r, o.right, o.bottom)
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return f.setTo(e.x, e.y, e.width, e.height)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return e.x === f.x && e.y === f.y && e.width === f.width && e.height === f.height
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(10)
              , f = function(r, o) {
                return o === void 0 && (o = new e),
                o.x = r.left,
                o.y = r.top,
                o.width = r.width,
                o.height = r.height,
                o
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                return e.x += f,
                e.y += r,
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return e.x += f.x,
                e.y += f.y,
                e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4)
              , f = t(231)
              , r = function(o, a, n) {
                if (n === void 0 && (n = []),
                f(o, a)) {
                    var s = o.x, l = o.y, i = o.radius, h = a.x, u = a.y, d = a.radius, v, p, g, m, x;
                    if (l === u)
                        x = (d * d - i * i - h * h + s * s) / (2 * (s - h)),
                        v = 1,
                        p = -2 * u,
                        g = h * h + x * x - 2 * h * x + u * u - d * d,
                        m = p * p - 4 * v * g,
                        m === 0 ? n.push(new e(x,-p / (2 * v))) : m > 0 && (n.push(new e(x,(-p + Math.sqrt(m)) / (2 * v))),
                        n.push(new e(x,(-p - Math.sqrt(m)) / (2 * v))));
                    else {
                        var T = (s - h) / (l - u)
                          , E = (d * d - i * i - h * h + s * s - u * u + l * l) / (2 * (l - u));
                        v = T * T + 1,
                        p = 2 * l * T - 2 * E * T - 2 * s,
                        g = s * s + l * l + E * E - i * i - 2 * l * E,
                        m = p * p - 4 * v * g,
                        m === 0 ? (x = -p / (2 * v),
                        n.push(new e(x,E - x * T))) : m > 0 && (x = (-p + Math.sqrt(m)) / (2 * v),
                        n.push(new e(x,E - x * T)),
                        x = (-p - Math.sqrt(m)) / (2 * v),
                        n.push(new e(x,E - x * T)))
                    }
                }
                return n
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(232)
              , f = t(151)
              , r = function(o, a, n) {
                if (n === void 0 && (n = []),
                f(o, a)) {
                    var s = a.getLineA()
                      , l = a.getLineB()
                      , i = a.getLineC()
                      , h = a.getLineD();
                    e(s, o, n),
                    e(l, o, n),
                    e(i, o, n),
                    e(h, o, n)
                }
                return n
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(140)
              , f = t(487)
              , r = t(47)
              , o = new r;
            function a(l, i, h, u, d) {
                var v = Math.cos(l)
                  , p = Math.sin(l);
                o.setTo(i, h, i + v, h + p);
                var g = f(o, u);
                g && d.push(new e(g.x,g.y,l,g.w))
            }
            function n(l, i) {
                return l.z - i.z
            }
            var s = function(l, i, h) {
                Array.isArray(h) || (h = [h]);
                for (var u = [], d = [], v = 0; v < h.length; v++)
                    for (var p = h[v].points, g = 0; g < p.length; g++) {
                        var m = Math.atan2(p[g].y - i, p[g].x - l);
                        d.indexOf(m) === -1 && (a(m, l, i, h, u),
                        a(m - 1e-5, l, i, h, u),
                        a(m + 1e-5, l, i, h, u),
                        d.push(m))
                    }
                return u.sort(n)
            };
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(10)
              , f = t(152)
              , r = function(o, a, n) {
                return n === void 0 && (n = new e),
                f(o, a) && (n.x = Math.max(o.x, a.x),
                n.y = Math.max(o.y, a.y),
                n.width = Math.min(o.right, a.right) - n.x,
                n.height = Math.min(o.bottom, a.bottom) - n.y),
                n
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(234)
              , f = t(152)
              , r = function(o, a, n) {
                if (n === void 0 && (n = []),
                f(o, a)) {
                    var s = o.getLineA()
                      , l = o.getLineB()
                      , i = o.getLineC()
                      , h = o.getLineD();
                    e(s, a, n),
                    e(l, a, n),
                    e(i, a, n),
                    e(h, a, n)
                }
                return n
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(489)
              , f = t(234)
              , r = function(o, a, n) {
                if (n === void 0 && (n = []),
                e(o, a)) {
                    var s = a.getLineA()
                      , l = a.getLineB()
                      , i = a.getLineC();
                    f(s, o, n),
                    f(l, o, n),
                    f(i, o, n)
                }
                return n
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(232)
              , f = t(491)
              , r = function(o, a, n) {
                if (n === void 0 && (n = []),
                f(o, a)) {
                    var s = o.getLineA()
                      , l = o.getLineB()
                      , i = o.getLineC();
                    e(s, a, n),
                    e(l, a, n),
                    e(i, a, n)
                }
                return n
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(494)
              , f = t(492)
              , r = function(o, a, n) {
                if (n === void 0 && (n = []),
                e(o, a)) {
                    var s = a.getLineA()
                      , l = a.getLineB()
                      , i = a.getLineC();
                    f(o, s, n),
                    f(o, l, n),
                    f(o, i, n)
                }
                return n
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(496)
              , f = function(r, o) {
                if (!e(r, o))
                    return !1;
                var a = Math.min(o.x1, o.x2)
                  , n = Math.max(o.x1, o.x2)
                  , s = Math.min(o.y1, o.y2)
                  , l = Math.max(o.y1, o.y2);
                return r.x >= a && r.x <= n && r.y >= s && r.y <= l
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o, a, n) {
                return n === void 0 && (n = 0),
                !(f > e.right + n || r < e.left - n || o > e.bottom + n || a < e.top - n)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(47);
            e.Angle = t(97),
            e.BresenhamPoints = t(317),
            e.CenterOn = t(1222),
            e.Clone = t(1223),
            e.CopyFrom = t(1224),
            e.Equals = t(1225),
            e.Extend = t(1226),
            e.GetEasedPoints = t(1227),
            e.GetMidPoint = t(1228),
            e.GetNearestPoint = t(1229),
            e.GetNormal = t(1230),
            e.GetPoint = t(307),
            e.GetPoints = t(172),
            e.GetShortestDistance = t(1231),
            e.Height = t(1232),
            e.Length = t(67),
            e.NormalAngle = t(497),
            e.NormalX = t(1233),
            e.NormalY = t(1234),
            e.Offset = t(1235),
            e.PerpSlope = t(1236),
            e.Random = t(173),
            e.ReflectAngle = t(1237),
            e.Rotate = t(1238),
            e.RotateAroundPoint = t(1239),
            e.RotateAroundXY = t(236),
            e.SetToAngle = t(1240),
            e.Slope = t(1241),
            e.Width = t(1242),
            c.exports = e
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                var o = f - (e.x1 + e.x2) / 2
                  , a = r - (e.y1 + e.y2) / 2;
                return e.x1 += o,
                e.y1 += a,
                e.x2 += o,
                e.y2 += a,
                e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(47)
              , f = function(r) {
                return new e(r.x1,r.y1,r.x2,r.y2)
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return f.setTo(e.x1, e.y1, e.x2, e.y2)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return e.x1 === f.x1 && e.y1 === f.y1 && e.x2 === f.x2 && e.y2 === f.y2
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(67)
              , f = function(r, o, a) {
                a === void 0 && (a = o);
                var n = e(r)
                  , s = r.x2 - r.x1
                  , l = r.y2 - r.y1;
                return o && (r.x1 = r.x1 - s / n * o,
                r.y1 = r.y1 - l / n * o),
                a && (r.x2 = r.x2 + s / n * a,
                r.y2 = r.y2 + l / n * a),
                r
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(352)
              , f = t(80)
              , r = t(4)
              , o = function(a, n, s, l, i) {
                l === void 0 && (l = 0),
                i === void 0 && (i = []);
                var h = [], u = a.x1, d = a.y1, v = a.x2 - u, p = a.y2 - d, g = f(n, i), m, x, T = s - 1;
                for (m = 0; m < T; m++)
                    x = g(m / T),
                    h.push(new r(u + v * x,d + p * x));
                if (x = g(1),
                h.push(new r(u + v * x,d + p * x)),
                l > 0) {
                    var E = h[0]
                      , P = [E];
                    for (m = 1; m < h.length - 1; m++) {
                        var M = h[m];
                        e(E, M) >= l && (P.push(M),
                        E = M)
                    }
                    var L = h[h.length - 1];
                    return e(E, L) < l && P.pop(),
                    P.push(L),
                    P
                } else
                    return h
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4)
              , f = function(r, o) {
                return o === void 0 && (o = new e),
                o.x = (r.x1 + r.x2) / 2,
                o.y = (r.y1 + r.y2) / 2,
                o
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Florian Mertens
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4)
              , f = function(r, o, a) {
                a === void 0 && (a = new e);
                var n = r.x1
                  , s = r.y1
                  , l = r.x2
                  , i = r.y2
                  , h = (l - n) * (l - n) + (i - s) * (i - s);
                if (h === 0)
                    return a;
                var u = ((o.x - n) * (l - n) + (o.y - s) * (i - s)) / h;
                return a.x = n + u * (l - n),
                a.y = s + u * (i - s),
                a
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(14)
              , f = t(97)
              , r = t(4)
              , o = function(a, n) {
                n === void 0 && (n = new r);
                var s = f(a) - e.TAU;
                return n.x = Math.cos(s),
                n.y = Math.sin(s),
                n
            };
            c.exports = o
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Florian Mertens
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                var r = e.x1
                  , o = e.y1
                  , a = e.x2
                  , n = e.y2
                  , s = (a - r) * (a - r) + (n - o) * (n - o);
                if (s === 0)
                    return !1;
                var l = ((o - f.y) * (a - r) - (r - f.x) * (n - o)) / s;
                return Math.abs(l) * Math.sqrt(s)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return Math.abs(e.y1 - e.y2)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(14)
              , f = t(97)
              , r = function(o) {
                return Math.cos(f(o) - e.TAU)
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(14)
              , f = t(97)
              , r = function(o) {
                return Math.sin(f(o) - e.TAU)
            };
            c.exports = r
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                return e.x1 += f,
                e.y1 += r,
                e.x2 += f,
                e.y2 += r,
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return -((e.x2 - e.x1) / (e.y2 - e.y1))
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(97)
              , f = t(497)
              , r = function(o, a) {
                return 2 * f(a) - Math.PI - e(o)
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(236)
              , f = function(r, o) {
                var a = (r.x1 + r.x2) / 2
                  , n = (r.y1 + r.y2) / 2;
                return e(r, a, n, o)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(236)
              , f = function(r, o, a) {
                return e(r, o.x, o.y, a)
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o, a) {
                return e.x1 = f,
                e.y1 = r,
                e.x2 = f + Math.cos(o) * a,
                e.y2 = r + Math.sin(o) * a,
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return (e.y2 - e.y1) / (e.x2 - e.x1)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return Math.abs(e.x1 - e.x2)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = {
                Face: t(116),
                GenerateGridVerts: t(1244),
                GenerateObjVerts: t(480),
                GenerateVerts: t(479),
                ParseObj: t(498),
                ParseObjMaterial: t(499),
                RotateFace: t(1245),
                Vertex: t(117)
            };
            c.exports = e
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(116)
              , f = t(2)
              , r = t(69)
              , o = t(39)
              , a = t(117)
              , n = new o
              , s = new o
              , l = new r
              , i = function(h) {
                var u = f(h, "mesh")
                  , d = f(h, "texture", null)
                  , v = f(h, "frame")
                  , p = f(h, "width", 1)
                  , g = f(h, "height", p)
                  , m = f(h, "widthSegments", 1)
                  , x = f(h, "heightSegments", m)
                  , T = f(h, "x", 0)
                  , E = f(h, "y", 0)
                  , P = f(h, "z", 0)
                  , M = f(h, "rotateX", 0)
                  , L = f(h, "rotateY", 0)
                  , R = f(h, "rotateZ", 0)
                  , O = f(h, "zIsUp", !0)
                  , F = f(h, "isOrtho", u ? u.dirtyCache[11] : !1)
                  , B = f(h, "colors", [16777215])
                  , N = f(h, "alphas", [1])
                  , Y = f(h, "tile", !1)
                  , z = f(h, "flipY", !1)
                  , W = f(h, "width", null)
                  , b = {
                    faces: [],
                    verts: []
                };
                if (n.set(T, E, P),
                s.set(M, L, R),
                l.fromRotationXYTranslation(s, n, O),
                !d && u)
                    d = u.texture;
                else if (u && typeof d == "string")
                    d = u.scene.sys.textures.get(d);
                else
                    return b;
                var D = d.get(v);
                !W && F && d && u && (p = D.width / u.height,
                g = D.height / u.height);
                var I = p / 2, G = g / 2, w = Math.floor(m), U = Math.floor(x), X = w + 1, V = U + 1, H = p / w, J = g / U, $ = [], _ = [], nt, K, Z = 0, j = 1, Q = 0, tt = 1;
                D && (Z = D.u0,
                j = D.u1,
                z ? (Q = D.v1,
                tt = D.v0) : (Q = D.v0,
                tt = D.v1));
                var et = j - Z
                  , it = tt - Q;
                for (K = 0; K < V; K++) {
                    var k = K * J - G;
                    for (nt = 0; nt < X; nt++) {
                        var st = nt * H - I;
                        _.push(st, -k);
                        var q = Z + et * (nt / w)
                          , rt = Q + it * (K / U);
                        $.push(q, rt)
                    }
                }
                Array.isArray(B) || (B = [B]),
                Array.isArray(N) || (N = [N]);
                var ot = 0
                  , lt = 0;
                for (K = 0; K < U; K++)
                    for (nt = 0; nt < w; nt++) {
                        var at = (nt + X * K) * 2
                          , ht = (nt + X * (K + 1)) * 2
                          , dt = (nt + 1 + X * (K + 1)) * 2
                          , ut = (nt + 1 + X * K) * 2
                          , ft = B[lt]
                          , mt = N[ot]
                          , Gt = new a(_[at],_[at + 1],0,$[at],$[at + 1],ft,mt).transformMat4(l)
                          , jt = new a(_[ht],_[ht + 1],0,$[ht],$[ht + 1],ft,mt).transformMat4(l)
                          , Yt = new a(_[ut],_[ut + 1],0,$[ut],$[ut + 1],ft,mt).transformMat4(l)
                          , $t = new a(_[ht],_[ht + 1],0,$[ht],$[ht + 1],ft,mt).transformMat4(l)
                          , Ct = new a(_[dt],_[dt + 1],0,$[dt],$[dt + 1],ft,mt).transformMat4(l)
                          , Rt = new a(_[ut],_[ut + 1],0,$[ut],$[ut + 1],ft,mt).transformMat4(l);
                        Y && (Gt.setUVs(Z, tt),
                        jt.setUVs(Z, Q),
                        Yt.setUVs(j, tt),
                        $t.setUVs(Z, Q),
                        Ct.setUVs(j, Q),
                        Rt.setUVs(j, tt)),
                        lt++,
                        lt === B.length && (lt = 0),
                        ot++,
                        ot === N.length && (ot = 0),
                        b.verts.push(Gt, jt, Yt, $t, Ct, Rt),
                        b.faces.push(new e(Gt,jt,Yt), new e($t,Ct,Rt))
                    }
                return u && (u.faces = u.faces.concat(b.faces),
                u.vertices = u.vertices.concat(b.verts)),
                b
            };
            c.exports = i
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                var a, n;
                if (r === void 0 && o === void 0) {
                    var s = e.getInCenter();
                    a = s.x,
                    n = s.y
                }
                var l = Math.cos(f)
                  , i = Math.sin(f)
                  , h = e.vertex1
                  , u = e.vertex2
                  , d = e.vertex3
                  , v = h.x - a
                  , p = h.y - n;
                h.set(v * l - p * i + a, v * i + p * l + n),
                v = u.x - a,
                p = u.y - n,
                u.set(v * l - p * i + a, v * i + p * l + n),
                v = d.x - a,
                p = d.y - n,
                d.set(v * l - p * i + a, v * i + p * l + n)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4);
            e.Ceil = t(1247),
            e.Clone = t(1248),
            e.CopyFrom = t(1249),
            e.Equals = t(1250),
            e.Floor = t(1251),
            e.GetCentroid = t(1252),
            e.GetMagnitude = t(500),
            e.GetMagnitudeSq = t(501),
            e.GetRectangleFromPoints = t(1253),
            e.Interpolate = t(1254),
            e.Invert = t(1255),
            e.Negative = t(1256),
            e.Project = t(1257),
            e.ProjectUnit = t(1258),
            e.SetMagnitude = t(1259),
            c.exports = e
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e.setTo(Math.ceil(e.x), Math.ceil(e.y))
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4)
              , f = function(r) {
                return new e(r.x,r.y)
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return f.setTo(e.x, e.y)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return e.x === f.x && e.y === f.y
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e.setTo(Math.floor(e.x), Math.floor(e.y))
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4)
              , f = function(r, o) {
                if (o === void 0 && (o = new e),
                !Array.isArray(r))
                    throw new Error("GetCentroid points argument must be an array");
                var a = r.length;
                if (a < 1)
                    throw new Error("GetCentroid points array must not be empty");
                if (a === 1)
                    o.x = r[0].x,
                    o.y = r[0].y;
                else {
                    for (var n = 0; n < a; n++)
                        o.x += r[n].x,
                        o.y += r[n].y;
                    o.x /= a,
                    o.y /= a
                }
                return o
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(10)
              , f = function(r, o) {
                o === void 0 && (o = new e);
                for (var a = Number.NEGATIVE_INFINITY, n = Number.POSITIVE_INFINITY, s = Number.NEGATIVE_INFINITY, l = Number.POSITIVE_INFINITY, i = 0; i < r.length; i++) {
                    var h = r[i];
                    h.x > a && (a = h.x),
                    h.x < n && (n = h.x),
                    h.y > s && (s = h.y),
                    h.y < l && (l = h.y)
                }
                return o.x = n,
                o.y = l,
                o.width = a - n,
                o.height = s - l,
                o
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4)
              , f = function(r, o, a, n) {
                return a === void 0 && (a = 0),
                n === void 0 && (n = new e),
                n.x = r.x + (o.x - r.x) * a,
                n.y = r.y + (o.y - r.y) * a,
                n
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e.setTo(e.y, e.x)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4)
              , f = function(r, o) {
                return o === void 0 && (o = new e),
                o.setTo(-r.x, -r.y)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4)
              , f = t(501)
              , r = function(o, a, n) {
                n === void 0 && (n = new e);
                var s = o.x * a.x + o.y * a.y
                  , l = s / f(a);
                return l !== 0 && (n.x = l * a.x,
                n.y = l * a.y),
                n
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4)
              , f = function(r, o, a) {
                a === void 0 && (a = new e);
                var n = r.x * o.x + r.y * o.y;
                return n !== 0 && (a.x = n * o.x,
                a.y = n * o.y),
                a
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(500)
              , f = function(r, o) {
                if (r.x !== 0 || r.y !== 0) {
                    var a = e(r);
                    r.x /= a,
                    r.y /= a
                }
                return r.x *= o,
                r.y *= o,
                r
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(227);
            e.Clone = t(1261),
            e.Contains = t(228),
            e.ContainsPoint = t(1262),
            e.Earcut = t(59),
            e.GetAABB = t(469),
            e.GetNumberArray = t(1263),
            e.GetPoints = t(470),
            e.Perimeter = t(471),
            e.Reverse = t(1264),
            e.Simplify = t(1265),
            e.Smooth = t(472),
            e.Translate = t(1266),
            c.exports = e
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(227)
              , f = function(r) {
                return new e(r.points)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(228)
              , f = function(r, o) {
                return e(r, o.x, o.y)
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                f === void 0 && (f = []);
                for (var r = 0; r < e.points.length; r++)
                    f.push(e.points[r].x),
                    f.push(e.points[r].y);
                return f
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e.points.reverse(),
                e
            };
            c.exports = t
        }
        , function(c, S) {
            function t(n, s) {
                var l = n.x - s.x
                  , i = n.y - s.y;
                return l * l + i * i
            }
            function e(n, s, l) {
                var i = s.x
                  , h = s.y
                  , u = l.x - i
                  , d = l.y - h;
                if (u !== 0 || d !== 0) {
                    var v = ((n.x - i) * u + (n.y - h) * d) / (u * u + d * d);
                    v > 1 ? (i = l.x,
                    h = l.y) : v > 0 && (i += u * v,
                    h += d * v)
                }
                return u = n.x - i,
                d = n.y - h,
                u * u + d * d
            }
            function f(n, s) {
                for (var l = n[0], i = [l], h, u = 1, d = n.length; u < d; u++)
                    h = n[u],
                    t(h, l) > s && (i.push(h),
                    l = h);
                return l !== h && i.push(h),
                i
            }
            function r(n, s, l, i, h) {
                for (var u = i, d, v = s + 1; v < l; v++) {
                    var p = e(n[v], n[s], n[l]);
                    p > u && (d = v,
                    u = p)
                }
                u > i && (d - s > 1 && r(n, s, d, i, h),
                h.push(n[d]),
                l - d > 1 && r(n, d, l, i, h))
            }
            function o(n, s) {
                var l = n.length - 1
                  , i = [n[0]];
                return r(n, 0, l, s, i),
                i.push(n[l]),
                i
            }
            var a = function(n, s, l) {
                s === void 0 && (s = 1),
                l === void 0 && (l = !1);
                var i = n.points;
                if (i.length > 2) {
                    var h = s * s;
                    l || (i = f(i, h)),
                    n.setTo(o(i, h))
                }
                return n
            };
            c.exports = a
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                for (var o = e.points, a = 0; a < o.length; a++)
                    o[a].x += f,
                    o[a].y += r;
                return e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e.width * e.height
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e.x = Math.ceil(e.x),
                e.y = Math.ceil(e.y),
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e.x = Math.ceil(e.x),
                e.y = Math.ceil(e.y),
                e.width = Math.ceil(e.width),
                e.height = Math.ceil(e.height),
                e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(10)
              , f = function(r) {
                return new e(r.x,r.y,r.width,r.height)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(57)
              , f = function(r, o) {
                return e(r, o.x, o.y)
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return f.setTo(e.x, e.y, e.width, e.height)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return e.x === f.x && e.y === f.y && e.width === f.width && e.height === f.height
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(237)
              , f = function(r, o) {
                var a = e(r);
                return a < e(o) ? r.setSize(o.height * a, o.height) : r.setSize(o.width, o.width / a),
                r.setPosition(o.centerX - r.width / 2, o.centerY - r.height / 2)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(237)
              , f = function(r, o) {
                var a = e(r);
                return a > e(o) ? r.setSize(o.height * a, o.height) : r.setSize(o.width, o.width / a),
                r.setPosition(o.centerX - r.width / 2, o.centerY - r.height / 2)
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e.x = Math.floor(e.x),
                e.y = Math.floor(e.y),
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e.x = Math.floor(e.x),
                e.y = Math.floor(e.y),
                e.width = Math.floor(e.width),
                e.height = Math.floor(e.height),
                e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       samme
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(10)
              , f = function(r, o, a, n, s) {
                return s === void 0 && (s = new e),
                s.setTo(Math.min(r, a), Math.min(o, n), Math.abs(r - a), Math.abs(o - n))
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4)
              , f = function(r, o) {
                return o === void 0 && (o = new e),
                o.x = r.centerX,
                o.y = r.centerY,
                o
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4)
              , f = function(r, o) {
                return o === void 0 && (o = new e),
                o.x = r.width,
                o.y = r.height,
                o
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(190)
              , f = function(r, o, a) {
                var n = r.centerX
                  , s = r.centerY;
                return r.setSize(r.width + o * 2, r.height + a * 2),
                e(r, n, s)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(10)
              , f = t(152)
              , r = function(o, a, n) {
                return n === void 0 && (n = new e),
                f(o, a) ? (n.x = Math.max(o.x, a.x),
                n.y = Math.max(o.y, a.y),
                n.width = Math.min(o.right, a.right) - n.x,
                n.height = Math.min(o.bottom, a.bottom) - n.y) : n.setEmpty(),
                n
            };
            c.exports = r
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                for (var r = e.x, o = e.right, a = e.y, n = e.bottom, s = 0; s < f.length; s++)
                    r = Math.min(r, f[s].x),
                    o = Math.max(o, f[s].x),
                    a = Math.min(a, f[s].y),
                    n = Math.max(n, f[s].y);
                return e.x = r,
                e.y = a,
                e.width = o - r,
                e.height = n - a,
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                var r = Math.min(e.x, f.x)
                  , o = Math.max(e.right, f.right);
                e.x = r,
                e.width = o - r;
                var a = Math.min(e.y, f.y)
                  , n = Math.max(e.bottom, f.bottom);
                return e.y = a,
                e.height = n - a,
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                var o = Math.min(e.x, f)
                  , a = Math.max(e.right, f);
                e.x = o,
                e.width = a - o;
                var n = Math.min(e.y, r)
                  , s = Math.max(e.bottom, r);
                return e.y = n,
                e.height = s - n,
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                return e.x += f,
                e.y += r,
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return e.x += f.x,
                e.y += f.y,
                e
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return e.x < f.right && e.right > f.x && e.y < f.bottom && e.bottom > f.y
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(4)
              , f = t(36)
              , r = function(o, a, n) {
                n === void 0 && (n = new e),
                a = f(a);
                var s = Math.sin(a)
                  , l = Math.cos(a)
                  , i = l > 0 ? o.width / 2 : o.width / -2
                  , h = s > 0 ? o.height / 2 : o.height / -2;
                return Math.abs(i * s) < Math.abs(h * l) ? h = i * s / l : i = h * l / s,
                n.x = i + o.centerX,
                n.y = h + o.centerY,
                n
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(195)
              , f = t(503)
              , r = t(4)
              , o = function(a, n, s) {
                if (s === void 0 && (s = new r),
                f(a, n))
                    switch (e(0, 3)) {
                    case 0:
                        s.x = a.x + Math.random() * (n.right - a.x),
                        s.y = a.y + Math.random() * (n.top - a.y);
                        break;
                    case 1:
                        s.x = n.x + Math.random() * (a.right - n.x),
                        s.y = n.bottom + Math.random() * (a.bottom - n.bottom);
                        break;
                    case 2:
                        s.x = a.x + Math.random() * (n.x - a.x),
                        s.y = n.y + Math.random() * (a.bottom - n.y);
                        break;
                    case 3:
                        s.x = n.right + Math.random() * (a.right - n.right),
                        s.y = a.y + Math.random() * (n.bottom - a.y);
                        break
                    }
                return s
            };
            c.exports = o
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return e.width === f.width && e.height === f.height
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r) {
                return r === void 0 && (r = f),
                e.width *= f,
                e.height *= r,
                e
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(82);
            e.Area = t(1294),
            e.BuildEquilateral = t(1295),
            e.BuildFromPolygon = t(1296),
            e.BuildRight = t(1297),
            e.CenterOn = t(1298),
            e.Centroid = t(504),
            e.CircumCenter = t(1299),
            e.CircumCircle = t(1300),
            e.Clone = t(1301),
            e.Contains = t(115),
            e.ContainsArray = t(235),
            e.ContainsPoint = t(1302),
            e.CopyFrom = t(1303),
            e.Decompose = t(495),
            e.Equals = t(1304),
            e.GetPoint = t(476),
            e.GetPoints = t(477),
            e.InCenter = t(506),
            e.Perimeter = t(1305),
            e.Offset = t(505),
            e.Random = t(181),
            e.Rotate = t(1306),
            e.RotateAroundPoint = t(1307),
            e.RotateAroundXY = t(238),
            c.exports = e
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                var f = e.x1
                  , r = e.y1
                  , o = e.x2
                  , a = e.y2
                  , n = e.x3
                  , s = e.y3;
                return Math.abs(((n - f) * (a - r) - (o - f) * (s - r)) / 2)
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(82)
              , f = function(r, o, a) {
                var n = a * (Math.sqrt(3) / 2)
                  , s = r
                  , l = o
                  , i = r + a / 2
                  , h = o + n
                  , u = r - a / 2
                  , d = o + n;
                return new e(s,l,i,h,u,d)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(59)
              , f = t(82)
              , r = function(o, a, n, s, l) {
                a === void 0 && (a = null),
                n === void 0 && (n = 1),
                s === void 0 && (s = 1),
                l === void 0 && (l = []);
                for (var i = e(o, a), h, u, d, v, p, g, m, x, T, E = 0; E < i.length; E += 3)
                    h = i[E],
                    u = i[E + 1],
                    d = i[E + 2],
                    v = o[h * 2] * n,
                    p = o[h * 2 + 1] * s,
                    g = o[u * 2] * n,
                    m = o[u * 2 + 1] * s,
                    x = o[d * 2] * n,
                    T = o[d * 2 + 1] * s,
                    l.push(new f(v,p,g,m,x,T));
                return l
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(82)
              , f = function(r, o, a, n) {
                n === void 0 && (n = a);
                var s = r
                  , l = o
                  , i = r
                  , h = o - n
                  , u = r + a
                  , d = o;
                return new e(s,l,i,h,u,d)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(504)
              , f = t(505)
              , r = function(o, a, n, s) {
                s === void 0 && (s = e);
                var l = s(o)
                  , i = a - l.x
                  , h = n - l.y;
                return f(o, i, h)
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(3);
            function f(o, a, n, s) {
                return o * s - a * n
            }
            var r = function(o, a) {
                a === void 0 && (a = new e);
                var n = o.x3
                  , s = o.y3
                  , l = o.x1 - n
                  , i = o.y1 - s
                  , h = o.x2 - n
                  , u = o.y2 - s
                  , d = 2 * f(l, i, h, u)
                  , v = f(i, l * l + i * i, u, h * h + u * u)
                  , p = f(l, l * l + i * i, h, h * h + u * u);
                return a.x = n - v / d,
                a.y = s + p / d,
                a
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(65)
              , f = function(r, o) {
                o === void 0 && (o = new e);
                var a = r.x1, n = r.y1, s = r.x2, l = r.y2, i = r.x3, h = r.y3, u = s - a, d = l - n, v = i - a, p = h - n, g = u * (a + s) + d * (n + l), m = v * (a + i) + p * (n + h), x = 2 * (u * (h - l) - d * (i - s)), T, E;
                if (Math.abs(x) < 1e-6) {
                    var P = Math.min(a, s, i)
                      , M = Math.min(n, l, h);
                    T = (Math.max(a, s, i) - P) * .5,
                    E = (Math.max(n, l, h) - M) * .5,
                    o.x = P + T,
                    o.y = M + E,
                    o.radius = Math.sqrt(T * T + E * E)
                } else
                    o.x = (p * g - d * m) / x,
                    o.y = (u * m - v * g) / x,
                    T = o.x - a,
                    E = o.y - n,
                    o.radius = Math.sqrt(T * T + E * E);
                return o
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(82)
              , f = function(r) {
                return new e(r.x1,r.y1,r.x2,r.y2,r.x3,r.y3)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(115)
              , f = function(r, o) {
                return e(r, o.x, o.y)
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return f.setTo(e.x1, e.y1, e.x2, e.y2, e.x3, e.y3)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return e.x1 === f.x1 && e.y1 === f.y1 && e.x2 === f.x2 && e.y2 === f.y2 && e.x3 === f.x3 && e.y3 === f.y3
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(67)
              , f = function(r) {
                var o = r.getLineA()
                  , a = r.getLineB()
                  , n = r.getLineC();
                return e(o) + e(a) + e(n)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(238)
              , f = t(506)
              , r = function(o, a) {
                var n = f(o);
                return e(o, n.x, n.y, a)
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(238)
              , f = function(r, o, a) {
                return e(r, o.x, o.y, a)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(203)
              , f = t(17)
              , r = {
                CreatePixelPerfectHandler: t(507),
                CreateInteractiveObject: t(508),
                Events: t(51),
                Gamepad: t(1309),
                InputManager: t(409),
                InputPlugin: t(1321),
                InputPluginCache: t(153),
                Keyboard: t(1322),
                Mouse: t(1336),
                Pointer: t(412),
                Touch: t(1337)
            };
            r = f(!1, r, e),
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Axis: t(509),
                Button: t(510),
                Events: t(239),
                Gamepad: t(511),
                GamepadPlugin: t(1316),
                Configs: t(1317)
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "down"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "up"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "connected"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "disconnected"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "down"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "up"
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(9)
              , r = t(239)
              , o = t(511)
              , a = t(6)
              , n = t(153)
              , s = t(51)
              , l = new e({
                Extends: f,
                initialize: function(h) {
                    f.call(this),
                    this.scene = h.scene,
                    this.settings = this.scene.sys.settings,
                    this.sceneInputPlugin = h,
                    this.enabled = !0,
                    this.target,
                    this.gamepads = [],
                    this.queue = [],
                    this.onGamepadHandler,
                    this._pad1,
                    this._pad2,
                    this._pad3,
                    this._pad4,
                    h.pluginEvents.once(s.BOOT, this.boot, this),
                    h.pluginEvents.on(s.START, this.start, this)
                },
                boot: function() {
                    var i = this.scene.sys.game
                      , h = this.settings.input
                      , u = i.config;
                    this.enabled = a(h, "gamepad", u.inputGamepad) && i.device.input.gamepads,
                    this.target = a(h, "gamepad.target", u.inputGamepadEventTarget),
                    this.sceneInputPlugin.pluginEvents.once(s.DESTROY, this.destroy, this)
                },
                start: function() {
                    this.enabled && (this.startListeners(),
                    this.refreshPads()),
                    this.sceneInputPlugin.pluginEvents.once(s.SHUTDOWN, this.shutdown, this)
                },
                isActive: function() {
                    return this.enabled && this.scene.sys.isActive()
                },
                startListeners: function() {
                    var i = this
                      , h = this.target
                      , u = function(d) {
                        d.defaultPrevented || !i.isActive() || (i.refreshPads(),
                        i.queue.push(d))
                    };
                    this.onGamepadHandler = u,
                    h.addEventListener("gamepadconnected", u, !1),
                    h.addEventListener("gamepaddisconnected", u, !1),
                    this.sceneInputPlugin.pluginEvents.on(s.UPDATE, this.update, this)
                },
                stopListeners: function() {
                    this.target.removeEventListener("gamepadconnected", this.onGamepadHandler),
                    this.target.removeEventListener("gamepaddisconnected", this.onGamepadHandler),
                    this.sceneInputPlugin.pluginEvents.off(s.UPDATE, this.update);
                    for (var i = 0; i < this.gamepads.length; i++)
                        this.gamepads[i].removeAllListeners()
                },
                disconnectAll: function() {
                    for (var i = 0; i < this.gamepads.length; i++)
                        this.gamepads[i].pad.connected = !1
                },
                refreshPads: function() {
                    var i = navigator.getGamepads();
                    if (!i)
                        this.disconnectAll();
                    else
                        for (var h = this.gamepads, u = 0; u < i.length; u++) {
                            var d = i[u];
                            if (d) {
                                var v = d.id
                                  , p = d.index
                                  , g = h[p];
                                if (g)
                                    g.id !== v ? (g.destroy(),
                                    h[p] = new o(this,d)) : g.update(d);
                                else {
                                    var m = new o(this,d);
                                    h[p] = m,
                                    this._pad1 ? this._pad2 ? this._pad3 ? this._pad4 || (this._pad4 = m) : this._pad3 = m : this._pad2 = m : this._pad1 = m
                                }
                            }
                        }
                },
                getAll: function() {
                    for (var i = [], h = this.gamepads, u = 0; u < h.length; u++)
                        h[u] && i.push(h[u]);
                    return i
                },
                getPad: function(i) {
                    for (var h = this.gamepads, u = 0; u < h.length; u++)
                        if (h[u] && h[u].index === i)
                            return h[u]
                },
                update: function() {
                    if (this.enabled) {
                        this.refreshPads();
                        var i = this.queue.length;
                        if (i !== 0)
                            for (var h = this.queue.splice(0, i), u = 0; u < i; u++) {
                                var d = h[u]
                                  , v = this.getPad(d.gamepad.index);
                                d.type === "gamepadconnected" ? this.emit(r.CONNECTED, v, d) : d.type === "gamepaddisconnected" && this.emit(r.DISCONNECTED, v, d)
                            }
                    }
                },
                shutdown: function() {
                    this.stopListeners(),
                    this.removeAllListeners()
                },
                destroy: function() {
                    this.shutdown();
                    for (var i = 0; i < this.gamepads.length; i++)
                        this.gamepads[i] && this.gamepads[i].destroy();
                    this.gamepads = [],
                    this.scene = null,
                    this.settings = null,
                    this.sceneInputPlugin = null,
                    this.target = null
                },
                total: {
                    get: function() {
                        return this.gamepads.length
                    }
                },
                pad1: {
                    get: function() {
                        return this._pad1
                    }
                },
                pad2: {
                    get: function() {
                        return this._pad2
                    }
                },
                pad3: {
                    get: function() {
                        return this._pad3
                    }
                },
                pad4: {
                    get: function() {
                        return this._pad4
                    }
                }
            });
            n.register("GamepadPlugin", l, "gamepad", "gamepad", "inputGamepad"),
            c.exports = l
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                DUALSHOCK_4: t(1318),
                SNES_USB: t(1319),
                XBOX_360: t(1320)
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                UP: 12,
                DOWN: 13,
                LEFT: 14,
                RIGHT: 15,
                SHARE: 8,
                OPTIONS: 9,
                PS: 16,
                TOUCHBAR: 17,
                X: 0,
                CIRCLE: 1,
                SQUARE: 2,
                TRIANGLE: 3,
                L1: 4,
                R1: 5,
                L2: 6,
                R2: 7,
                L3: 10,
                R3: 11,
                LEFT_STICK_H: 0,
                LEFT_STICK_V: 1,
                RIGHT_STICK_H: 2,
                RIGHT_STICK_V: 3
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                UP: 12,
                DOWN: 13,
                LEFT: 14,
                RIGHT: 15,
                SELECT: 8,
                START: 9,
                B: 0,
                A: 1,
                Y: 2,
                X: 3,
                LEFT_SHOULDER: 4,
                RIGHT_SHOULDER: 5
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                UP: 12,
                DOWN: 13,
                LEFT: 14,
                RIGHT: 15,
                MENU: 16,
                A: 0,
                B: 1,
                X: 2,
                Y: 3,
                LB: 4,
                RB: 5,
                LT: 6,
                RT: 7,
                BACK: 8,
                START: 9,
                LS: 10,
                RS: 11,
                LEFT_STICK_H: 0,
                LEFT_STICK_V: 1,
                RIGHT_STICK_H: 2,
                RIGHT_STICK_V: 3
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(65)
              , f = t(66)
              , r = t(0)
              , o = t(203)
              , a = t(508)
              , n = t(507)
              , s = t(50)
              , l = t(111)
              , i = t(112)
              , h = t(51)
              , u = t(9)
              , d = t(2)
              , v = t(56)
              , p = t(153)
              , g = t(7)
              , m = t(24)
              , x = t(10)
              , T = t(57)
              , E = t(20)
              , P = t(82)
              , M = t(115)
              , L = new r({
                Extends: u,
                initialize: function(O) {
                    u.call(this),
                    this.scene = O,
                    this.systems = O.sys,
                    this.settings = O.sys.settings,
                    this.manager = O.sys.game.input,
                    this.pluginEvents = new u,
                    this.enabled = !0,
                    this.displayList,
                    this.cameras,
                    p.install(this),
                    this.mouse = this.manager.mouse,
                    this.topOnly = !0,
                    this.pollRate = -1,
                    this._pollTimer = 0;
                    var F = {
                        cancelled: !1
                    };
                    this._eventContainer = {
                        stopPropagation: function() {
                            F.cancelled = !0
                        }
                    },
                    this._eventData = F,
                    this.dragDistanceThreshold = 0,
                    this.dragTimeThreshold = 0,
                    this._temp = [],
                    this._tempZones = [],
                    this._list = [],
                    this._pendingInsertion = [],
                    this._pendingRemoval = [],
                    this._draggable = [],
                    this._drag = {
                        0: [],
                        1: [],
                        2: [],
                        3: [],
                        4: [],
                        5: [],
                        6: [],
                        7: [],
                        8: [],
                        9: [],
                        10: []
                    },
                    this._dragState = [],
                    this._over = {
                        0: [],
                        1: [],
                        2: [],
                        3: [],
                        4: [],
                        5: [],
                        6: [],
                        7: [],
                        8: [],
                        9: [],
                        10: []
                    },
                    this._validTypes = ["onDown", "onUp", "onOver", "onOut", "onMove", "onDragStart", "onDrag", "onDragEnd", "onDragEnter", "onDragLeave", "onDragOver", "onDrop"],
                    this._updatedThisFrame = !1,
                    O.sys.events.once(E.BOOT, this.boot, this),
                    O.sys.events.on(E.START, this.start, this)
                },
                boot: function() {
                    this.cameras = this.systems.cameras,
                    this.displayList = this.systems.displayList,
                    this.systems.events.once(E.DESTROY, this.destroy, this),
                    this.pluginEvents.emit(h.BOOT)
                },
                start: function() {
                    var R = this.systems.events;
                    R.on(E.TRANSITION_START, this.transitionIn, this),
                    R.on(E.TRANSITION_OUT, this.transitionOut, this),
                    R.on(E.TRANSITION_COMPLETE, this.transitionComplete, this),
                    R.on(E.PRE_UPDATE, this.preUpdate, this),
                    R.once(E.SHUTDOWN, this.shutdown, this),
                    this.manager.events.on(h.GAME_OUT, this.onGameOut, this),
                    this.manager.events.on(h.GAME_OVER, this.onGameOver, this),
                    this.enabled = !0,
                    this._dragState = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    this.pluginEvents.emit(h.START)
                },
                onGameOver: function(R) {
                    this.isActive() && this.emit(h.GAME_OVER, R.timeStamp, R)
                },
                onGameOut: function(R) {
                    this.isActive() && this.emit(h.GAME_OUT, R.timeStamp, R)
                },
                preUpdate: function() {
                    this.pluginEvents.emit(h.PRE_UPDATE);
                    var R = this._pendingRemoval
                      , O = this._pendingInsertion
                      , F = R.length
                      , B = O.length;
                    if (!(F === 0 && B === 0)) {
                        for (var N = this._list, Y = 0; Y < F; Y++) {
                            var z = R[Y]
                              , W = N.indexOf(z);
                            W > -1 && (N.splice(W, 1),
                            this.clear(z, !0))
                        }
                        R.length = 0,
                        this._pendingRemoval.length = 0,
                        this._list = N.concat(O.splice(0))
                    }
                },
                isActive: function() {
                    return this.enabled && this.scene.sys.isActive()
                },
                updatePoll: function(R, O) {
                    if (!this.isActive())
                        return !1;
                    if (this.pluginEvents.emit(h.UPDATE, R, O),
                    this._updatedThisFrame)
                        return this._updatedThisFrame = !1,
                        !1;
                    var F, B = this.manager, N = B.pointers, Y = B.pointersTotal;
                    for (F = 0; F < Y; F++)
                        N[F].updateMotion();
                    if (this._list.length === 0)
                        return !1;
                    var z = this.pollRate;
                    if (z === -1)
                        return !1;
                    if (z > 0)
                        if (this._pollTimer -= O,
                        this._pollTimer < 0)
                            this._pollTimer = this.pollRate;
                        else
                            return !1;
                    var W = !1;
                    for (F = 0; F < Y; F++) {
                        var b = 0
                          , D = N[F];
                        this._tempZones = [],
                        this._temp = this.hitTestPointer(D),
                        this.sortGameObjects(this._temp, D),
                        this.sortDropZones(this._tempZones),
                        this.topOnly && (this._temp.length && this._temp.splice(1),
                        this._tempZones.length && this._tempZones.splice(1)),
                        b += this.processOverOutEvents(D),
                        this.getDragState(D) === 2 && this.processDragThresholdEvent(D, R),
                        b > 0 && (W = !0)
                    }
                    return W
                },
                update: function(R, O) {
                    if (!this.isActive())
                        return !1;
                    for (var F = O.length, B = !1, N = 0; N < F; N++) {
                        var Y = 0
                          , z = O[N];
                        switch (this._tempZones = [],
                        this._temp = this.hitTestPointer(z),
                        this.sortGameObjects(this._temp, z),
                        this.sortDropZones(this._tempZones),
                        this.topOnly && (this._temp.length && this._temp.splice(1),
                        this._tempZones.length && this._tempZones.splice(1)),
                        R) {
                        case o.MOUSE_DOWN:
                            Y += this.processDragDownEvent(z),
                            Y += this.processDownEvents(z),
                            Y += this.processOverOutEvents(z);
                            break;
                        case o.MOUSE_UP:
                            Y += this.processDragUpEvent(z),
                            Y += this.processUpEvents(z),
                            Y += this.processOverOutEvents(z);
                            break;
                        case o.TOUCH_START:
                            Y += this.processDragDownEvent(z),
                            Y += this.processDownEvents(z),
                            Y += this.processOverEvents(z);
                            break;
                        case o.TOUCH_END:
                        case o.TOUCH_CANCEL:
                            Y += this.processDragUpEvent(z),
                            Y += this.processUpEvents(z),
                            Y += this.processOutEvents(z);
                            break;
                        case o.MOUSE_MOVE:
                        case o.TOUCH_MOVE:
                            Y += this.processDragMoveEvent(z),
                            Y += this.processMoveEvents(z),
                            Y += this.processOverOutEvents(z);
                            break;
                        case o.MOUSE_WHEEL:
                            Y += this.processWheelEvent(z);
                            break
                        }
                        Y > 0 && (B = !0)
                    }
                    return this._updatedThisFrame = !0,
                    B
                },
                clear: function(R, O) {
                    O === void 0 && (O = !1);
                    var F = R.input;
                    if (F) {
                        O || this.queueForRemoval(R),
                        F.gameObject = void 0,
                        F.target = void 0,
                        F.hitArea = void 0,
                        F.hitAreaCallback = void 0,
                        F.callbackContext = void 0,
                        R.input = null;
                        var B = this._draggable.indexOf(R);
                        return B > -1 && this._draggable.splice(B, 1),
                        B = this._drag[0].indexOf(R),
                        B > -1 && this._drag[0].splice(B, 1),
                        B = this._over[0].indexOf(R),
                        B > -1 && (this._over[0].splice(B, 1),
                        this.manager.resetCursor(F)),
                        R
                    }
                },
                disable: function(R) {
                    R.input.enabled = !1
                },
                enable: function(R, O, F, B) {
                    return B === void 0 && (B = !1),
                    R.input ? R.input.enabled = !0 : this.setHitArea(R, O, F),
                    R.input && B && !R.input.dropZone && (R.input.dropZone = B),
                    this
                },
                hitTestPointer: function(R) {
                    for (var O = this.cameras.getCamerasBelowPointer(R), F = 0; F < O.length; F++) {
                        for (var B = O[F], N = this.manager.hitTest(R, this._list, B), Y = 0; Y < N.length; Y++) {
                            var z = N[Y];
                            z.input.dropZone && this._tempZones.push(z)
                        }
                        if (N.length > 0)
                            return R.camera = B,
                            N
                    }
                    return R.camera = O[0],
                    []
                },
                processDownEvents: function(R) {
                    var O = 0
                      , F = this._temp
                      , B = this._eventData
                      , N = this._eventContainer;
                    B.cancelled = !1;
                    for (var Y = !1, z = 0; z < F.length; z++) {
                        var W = F[z];
                        if (W.input) {
                            if (O++,
                            W.emit(h.GAMEOBJECT_POINTER_DOWN, R, W.input.localX, W.input.localY, N),
                            B.cancelled || !W.input) {
                                Y = !0;
                                break
                            }
                            if (this.emit(h.GAMEOBJECT_DOWN, R, W, N),
                            B.cancelled || !W.input) {
                                Y = !0;
                                break
                            }
                        }
                    }
                    return !Y && this.manager && (R.downElement === this.manager.game.canvas ? this.emit(h.POINTER_DOWN, R, F) : this.emit(h.POINTER_DOWN_OUTSIDE, R)),
                    O
                },
                getDragState: function(R) {
                    return this._dragState[R.id]
                },
                setDragState: function(R, O) {
                    this._dragState[R.id] = O
                },
                processDragThresholdEvent: function(R, O) {
                    var F = !1
                      , B = this.dragTimeThreshold
                      , N = this.dragDistanceThreshold;
                    if ((N > 0 && s(R.x, R.y, R.downX, R.downY) >= N || B > 0 && O >= R.downTime + B) && (F = !0),
                    F)
                        return this.setDragState(R, 3),
                        this.processDragStartList(R)
                },
                processDragStartList: function(R) {
                    if (this.getDragState(R) !== 3)
                        return 0;
                    for (var O = this._drag[R.id], F = 0; F < O.length; F++) {
                        var B = O[F]
                          , N = B.input;
                        N.dragState = 2,
                        N.dragStartX = B.x,
                        N.dragStartY = B.y,
                        N.dragStartXGlobal = R.worldX,
                        N.dragStartYGlobal = R.worldY,
                        N.dragX = N.dragStartXGlobal - N.dragStartX,
                        N.dragY = N.dragStartYGlobal - N.dragStartY,
                        B.emit(h.GAMEOBJECT_DRAG_START, R, N.dragX, N.dragY),
                        this.emit(h.DRAG_START, R, B)
                    }
                    return this.setDragState(R, 4),
                    O.length
                },
                processDragDownEvent: function(R) {
                    var O = this._temp;
                    if (this._draggable.length === 0 || O.length === 0 || !R.primaryDown || this.getDragState(R) !== 0)
                        return 0;
                    this.setDragState(R, 1);
                    for (var F = [], B = 0; B < O.length; B++) {
                        var N = O[B];
                        N.input.draggable && N.input.dragState === 0 && F.push(N)
                    }
                    return F.length === 0 ? (this.setDragState(R, 0),
                    0) : (F.length > 1 && (this.sortGameObjects(F, R),
                    this.topOnly && F.splice(1)),
                    this._drag[R.id] = F,
                    this.dragDistanceThreshold === 0 && this.dragTimeThreshold === 0 ? (this.setDragState(R, 3),
                    this.processDragStartList(R)) : (this.setDragState(R, 2),
                    0))
                },
                processDragMoveEvent: function(R) {
                    if (this.getDragState(R) === 2 && this.processDragThresholdEvent(R, this.manager.game.loop.now),
                    this.getDragState(R) !== 4)
                        return 0;
                    for (var O = this._tempZones, F = this._drag[R.id], B = 0; B < F.length; B++) {
                        var N = F[B]
                          , Y = N.input
                          , z = Y.target;
                        if (z) {
                            var W = O.indexOf(z);
                            W === 0 ? (N.emit(h.GAMEOBJECT_DRAG_OVER, R, z),
                            this.emit(h.DRAG_OVER, R, N, z)) : W > 0 ? (N.emit(h.GAMEOBJECT_DRAG_LEAVE, R, z),
                            this.emit(h.DRAG_LEAVE, R, N, z),
                            Y.target = O[0],
                            z = Y.target,
                            N.emit(h.GAMEOBJECT_DRAG_ENTER, R, z),
                            this.emit(h.DRAG_ENTER, R, N, z)) : (N.emit(h.GAMEOBJECT_DRAG_LEAVE, R, z),
                            this.emit(h.DRAG_LEAVE, R, N, z),
                            O[0] ? (Y.target = O[0],
                            z = Y.target,
                            N.emit(h.GAMEOBJECT_DRAG_ENTER, R, z),
                            this.emit(h.DRAG_ENTER, R, N, z)) : Y.target = null)
                        } else
                            !z && O[0] && (Y.target = O[0],
                            z = Y.target,
                            N.emit(h.GAMEOBJECT_DRAG_ENTER, R, z),
                            this.emit(h.DRAG_ENTER, R, N, z));
                        var b, D;
                        if (!N.parentContainer)
                            b = R.worldX - Y.dragX,
                            D = R.worldY - Y.dragY;
                        else {
                            var I = R.worldX - Y.dragStartXGlobal
                              , G = R.worldY - Y.dragStartYGlobal
                              , w = N.getParentRotation()
                              , U = I * Math.cos(w) + G * Math.sin(w)
                              , X = G * Math.cos(w) - I * Math.sin(w);
                            U *= 1 / N.parentContainer.scaleX,
                            X *= 1 / N.parentContainer.scaleY,
                            b = U + Y.dragStartX,
                            D = X + Y.dragStartY
                        }
                        N.emit(h.GAMEOBJECT_DRAG, R, b, D),
                        this.emit(h.DRAG, R, N, b, D)
                    }
                    return F.length
                },
                processDragUpEvent: function(R) {
                    for (var O = this._drag[R.id], F = 0; F < O.length; F++) {
                        var B = O[F]
                          , N = B.input;
                        if (N && N.dragState === 2) {
                            N.dragState = 0,
                            N.dragX = N.localX - B.displayOriginX,
                            N.dragY = N.localY - B.displayOriginY;
                            var Y = !1
                              , z = N.target;
                            z && (B.emit(h.GAMEOBJECT_DROP, R, z),
                            this.emit(h.DROP, R, B, z),
                            N.target = null,
                            Y = !0),
                            B.input && (B.emit(h.GAMEOBJECT_DRAG_END, R, N.dragX, N.dragY, Y),
                            this.emit(h.DRAG_END, R, B, Y))
                        }
                    }
                    return this.setDragState(R, 0),
                    O.splice(0),
                    0
                },
                processMoveEvents: function(R) {
                    var O = 0
                      , F = this._temp
                      , B = this._eventData
                      , N = this._eventContainer;
                    B.cancelled = !1;
                    for (var Y = !1, z = 0; z < F.length; z++) {
                        var W = F[z];
                        if (W.input) {
                            if (O++,
                            W.emit(h.GAMEOBJECT_POINTER_MOVE, R, W.input.localX, W.input.localY, N),
                            B.cancelled || !W.input) {
                                Y = !0;
                                break
                            }
                            if (this.emit(h.GAMEOBJECT_MOVE, R, W, N),
                            B.cancelled || !W.input) {
                                Y = !0;
                                break
                            }
                            if (this.topOnly)
                                break
                        }
                    }
                    return Y || this.emit(h.POINTER_MOVE, R, F),
                    O
                },
                processWheelEvent: function(R) {
                    var O = 0
                      , F = this._temp
                      , B = this._eventData
                      , N = this._eventContainer;
                    B.cancelled = !1;
                    for (var Y = !1, z = R.deltaX, W = R.deltaY, b = R.deltaZ, D = 0; D < F.length; D++) {
                        var I = F[D];
                        if (I.input) {
                            if (O++,
                            I.emit(h.GAMEOBJECT_POINTER_WHEEL, R, z, W, b, N),
                            B.cancelled || !I.input) {
                                Y = !0;
                                break
                            }
                            if (this.emit(h.GAMEOBJECT_WHEEL, R, I, z, W, b, N),
                            B.cancelled || !I.input) {
                                Y = !0;
                                break
                            }
                        }
                    }
                    return Y || this.emit(h.POINTER_WHEEL, R, F, z, W, b),
                    O
                },
                processOverEvents: function(R) {
                    var O = this._temp
                      , F = 0
                      , B = O.length
                      , N = [];
                    if (B > 0) {
                        var Y = this.manager
                          , z = this._eventData
                          , W = this._eventContainer;
                        z.cancelled = !1;
                        for (var b = !1, D = 0; D < B; D++) {
                            var I = O[D];
                            if (I.input) {
                                if (N.push(I),
                                Y.setCursor(I.input),
                                I.emit(h.GAMEOBJECT_POINTER_OVER, R, I.input.localX, I.input.localY, W),
                                F++,
                                z.cancelled || !I.input) {
                                    b = !0;
                                    break
                                }
                                if (this.emit(h.GAMEOBJECT_OVER, R, I, W),
                                z.cancelled || !I.input) {
                                    b = !0;
                                    break
                                }
                            }
                        }
                        b || this.emit(h.POINTER_OVER, R, N)
                    }
                    return this._over[R.id] = N,
                    F
                },
                processOutEvents: function(R) {
                    var O = this._over[R.id]
                      , F = 0
                      , B = O.length;
                    if (B > 0) {
                        var N = this.manager
                          , Y = this._eventData
                          , z = this._eventContainer;
                        Y.cancelled = !1;
                        var W = !1;
                        this.sortGameObjects(O, R);
                        for (var b = 0; b < B; b++) {
                            var D = O[b];
                            if (D = O[b],
                            !!D.input) {
                                if (N.resetCursor(D.input),
                                D.emit(h.GAMEOBJECT_POINTER_OUT, R, z),
                                F++,
                                Y.cancelled || !D.input) {
                                    W = !0;
                                    break
                                }
                                if (this.emit(h.GAMEOBJECT_OUT, R, D, z),
                                Y.cancelled || !D.input) {
                                    W = !0;
                                    break
                                }
                                W || this.emit(h.POINTER_OUT, R, O)
                            }
                        }
                        this._over[R.id] = []
                    }
                    return F
                },
                processOverOutEvents: function(R) {
                    var O = this._temp, F, B, N = [], Y = [], z = [], W = this._over[R.id], b = this._drag[R.id], D = this.manager;
                    for (F = 0; F < W.length; F++)
                        B = W[F],
                        O.indexOf(B) === -1 && b.indexOf(B) === -1 ? N.push(B) : z.push(B);
                    for (F = 0; F < O.length; F++)
                        B = O[F],
                        W.indexOf(B) === -1 && Y.push(B);
                    var I = N.length
                      , G = 0
                      , w = this._eventData
                      , U = this._eventContainer;
                    w.cancelled = !1;
                    var X = !1;
                    if (I > 0) {
                        for (this.sortGameObjects(N, R),
                        F = 0; F < I; F++)
                            if (B = N[F],
                            !!B.input) {
                                if (D.resetCursor(B.input),
                                B.emit(h.GAMEOBJECT_POINTER_OUT, R, U),
                                G++,
                                w.cancelled || !B.input) {
                                    X = !0;
                                    break
                                }
                                if (this.emit(h.GAMEOBJECT_OUT, R, B, U),
                                w.cancelled || !B.input) {
                                    X = !0;
                                    break
                                }
                            }
                        X || this.emit(h.POINTER_OUT, R, N)
                    }
                    if (I = Y.length,
                    w.cancelled = !1,
                    X = !1,
                    I > 0) {
                        for (this.sortGameObjects(Y, R),
                        F = 0; F < I; F++)
                            if (B = Y[F],
                            !!B.input) {
                                if (D.setCursor(B.input),
                                B.emit(h.GAMEOBJECT_POINTER_OVER, R, B.input.localX, B.input.localY, U),
                                G++,
                                w.cancelled || !B.input) {
                                    X = !0;
                                    break
                                }
                                if (this.emit(h.GAMEOBJECT_OVER, R, B, U),
                                w.cancelled || !B.input) {
                                    X = !0;
                                    break
                                }
                            }
                        X || this.emit(h.POINTER_OVER, R, Y)
                    }
                    return W = z.concat(Y),
                    this._over[R.id] = this.sortGameObjects(W, R),
                    G
                },
                processUpEvents: function(R) {
                    var O = this._temp
                      , F = this._eventData
                      , B = this._eventContainer;
                    F.cancelled = !1;
                    for (var N = !1, Y = 0; Y < O.length; Y++) {
                        var z = O[Y];
                        if (z.input) {
                            if (z.emit(h.GAMEOBJECT_POINTER_UP, R, z.input.localX, z.input.localY, B),
                            F.cancelled || !z.input) {
                                N = !0;
                                break
                            }
                            if (this.emit(h.GAMEOBJECT_UP, R, z, B),
                            F.cancelled || !z.input) {
                                N = !0;
                                break
                            }
                        }
                    }
                    return !N && this.manager && (R.upElement === this.manager.game.canvas ? this.emit(h.POINTER_UP, R, O) : this.emit(h.POINTER_UP_OUTSIDE, R)),
                    O.length
                },
                queueForInsertion: function(R) {
                    return this._pendingInsertion.indexOf(R) === -1 && this._list.indexOf(R) === -1 && this._pendingInsertion.push(R),
                    this
                },
                queueForRemoval: function(R) {
                    return this._pendingRemoval.push(R),
                    this
                },
                setDraggable: function(R, O) {
                    O === void 0 && (O = !0),
                    Array.isArray(R) || (R = [R]);
                    for (var F = 0; F < R.length; F++) {
                        var B = R[F];
                        B.input.draggable = O;
                        var N = this._draggable.indexOf(B);
                        O && N === -1 ? this._draggable.push(B) : !O && N > -1 && this._draggable.splice(N, 1)
                    }
                    return this
                },
                makePixelPerfect: function(R) {
                    R === void 0 && (R = 1);
                    var O = this.systems.textures;
                    return n(O, R)
                },
                setHitArea: function(R, O, F) {
                    if (O === void 0)
                        return this.setHitAreaFromTexture(R);
                    Array.isArray(R) || (R = [R]);
                    var B = !1
                      , N = !1
                      , Y = !1
                      , z = !1
                      , W = !1
                      , b = !0;
                    if (g(O)) {
                        var D = O;
                        O = d(D, "hitArea", null),
                        F = d(D, "hitAreaCallback", null),
                        B = d(D, "draggable", !1),
                        N = d(D, "dropZone", !1),
                        Y = d(D, "cursor", !1),
                        z = d(D, "useHandCursor", !1),
                        W = d(D, "pixelPerfect", !1);
                        var I = d(D, "alphaTolerance", 1);
                        W && (O = {},
                        F = this.makePixelPerfect(I)),
                        (!O || !F) && (this.setHitAreaFromTexture(R),
                        b = !1)
                    } else
                        typeof O == "function" && !F && (F = O,
                        O = {});
                    for (var G = 0; G < R.length; G++) {
                        var w = R[G];
                        if (W && w.type === "Container") {
                            console.warn("Cannot pixelPerfect test a Container. Use a custom callback.");
                            continue
                        }
                        var U = w.input ? w.input : a(w, O, F);
                        U.customHitArea = b,
                        U.dropZone = N,
                        U.cursor = z ? "pointer" : Y,
                        w.input = U,
                        B && this.setDraggable(w),
                        this.queueForInsertion(w)
                    }
                    return this
                },
                setHitAreaCircle: function(R, O, F, B, N) {
                    N === void 0 && (N = f);
                    var Y = new e(O,F,B);
                    return this.setHitArea(R, Y, N)
                },
                setHitAreaEllipse: function(R, O, F, B, N, Y) {
                    Y === void 0 && (Y = i);
                    var z = new l(O,F,B,N);
                    return this.setHitArea(R, z, Y)
                },
                setHitAreaFromTexture: function(R, O) {
                    O === void 0 && (O = T),
                    Array.isArray(R) || (R = [R]);
                    for (var F = 0; F < R.length; F++) {
                        var B = R[F]
                          , N = B.frame
                          , Y = 0
                          , z = 0;
                        if (B.width ? (Y = B.width,
                        z = B.height) : N && (Y = N.realWidth,
                        z = N.realHeight),
                        B.type === "Container" && (Y === 0 || z === 0)) {
                            console.warn("Container.setInteractive must specify a Shape or call setSize() first");
                            continue
                        }
                        Y !== 0 && z !== 0 && (B.input = a(B, new x(0,0,Y,z), O),
                        this.queueForInsertion(B))
                    }
                    return this
                },
                setHitAreaRectangle: function(R, O, F, B, N, Y) {
                    Y === void 0 && (Y = T);
                    var z = new x(O,F,B,N);
                    return this.setHitArea(R, z, Y)
                },
                setHitAreaTriangle: function(R, O, F, B, N, Y, z, W) {
                    W === void 0 && (W = M);
                    var b = new P(O,F,B,N,Y,z);
                    return this.setHitArea(R, b, W)
                },
                enableDebug: function(R, O) {
                    O === void 0 && (O = 65280);
                    var F = R.input;
                    if (!F || !F.hitArea)
                        return this;
                    var B = F.hitArea
                      , N = B.type
                      , Y = F.hitAreaDebug
                      , z = this.systems.add
                      , W = this.systems.updateList;
                    Y && (W.remove(Y),
                    Y.destroy(),
                    Y = null);
                    var b = 0
                      , D = 0;
                    switch (N) {
                    case v.CIRCLE:
                        Y = z.arc(0, 0, B.radius),
                        b = B.x - B.radius,
                        D = B.y - B.radius;
                        break;
                    case v.ELLIPSE:
                        Y = z.ellipse(0, 0, B.width, B.height),
                        b = B.x - B.width / 2,
                        D = B.y - B.height / 2;
                        break;
                    case v.LINE:
                        Y = z.line(0, 0, B.x1, B.y1, B.x2, B.y2);
                        break;
                    case v.POLYGON:
                        Y = z.polygon(0, 0, B.points);
                        break;
                    case v.RECTANGLE:
                        Y = z.rectangle(0, 0, B.width, B.height),
                        b = B.x,
                        D = B.y;
                        break;
                    case v.TRIANGLE:
                        Y = z.triangle(0, 0, B.x1, B.y1, B.x2, B.y2, B.x3, B.y3);
                        break
                    }
                    return Y && (Y.isFilled = !1,
                    Y.preUpdate = function() {
                        Y.setStrokeStyle(1 / R.scale, O),
                        Y.setDisplayOrigin(R.displayOriginX, R.displayOriginY);
                        var I = R.x
                          , G = R.y
                          , w = R.rotation
                          , U = R.scaleX
                          , X = R.scaleY;
                        if (R.parentContainer) {
                            var V = R.getWorldTransformMatrix();
                            I = V.tx,
                            G = V.ty,
                            w = V.rotation,
                            U = V.scaleX,
                            X = V.scaleY
                        }
                        Y.setRotation(w),
                        Y.setScale(U, X),
                        Y.setPosition(I + b, G + D),
                        Y.setScrollFactor(R.scrollFactorX, R.scrollFactorY),
                        Y.setDepth(R.depth)
                    }
                    ,
                    W.add(Y),
                    F.hitAreaDebug = Y),
                    this
                },
                removeDebug: function(R) {
                    var O = R.input;
                    if (O && O.hitAreaDebug) {
                        var F = O.hitAreaDebug;
                        this.systems.updateList.remove(F),
                        F.destroy(),
                        O.hitAreaDebug = null
                    }
                    return this
                },
                setPollAlways: function() {
                    return this.setPollRate(0)
                },
                setPollOnMove: function() {
                    return this.setPollRate(-1)
                },
                setPollRate: function(R) {
                    return this.pollRate = R,
                    this._pollTimer = 0,
                    this
                },
                setGlobalTopOnly: function(R) {
                    return this.manager.globalTopOnly = R,
                    this
                },
                setTopOnly: function(R) {
                    return this.topOnly = R,
                    this
                },
                sortGameObjects: function(R, O) {
                    if (R.length < 2)
                        return R;
                    var F = O.camera.renderList;
                    return R.sort(function(B, N) {
                        return F.indexOf(N) - F.indexOf(B)
                    })
                },
                sortDropZones: function(R) {
                    return R.length < 2 ? R : (this.scene.sys.depthSort(),
                    R.sort(this.sortDropZoneHandler.bind(this)))
                },
                sortDropZoneHandler: function(R, O) {
                    if (!R.parentContainer && !O.parentContainer)
                        return this.displayList.getIndex(O) - this.displayList.getIndex(R);
                    if (R.parentContainer === O.parentContainer)
                        return O.parentContainer.getIndex(O) - R.parentContainer.getIndex(R);
                    if (R.parentContainer === O)
                        return -1;
                    if (O.parentContainer === R)
                        return 1;
                    for (var F = R.getIndexList(), B = O.getIndexList(), N = Math.min(F.length, B.length), Y = 0; Y < N; Y++) {
                        var z = F[Y]
                          , W = B[Y];
                        if (z !== W)
                            return W - z
                    }
                    return B.length - F.length
                },
                stopPropagation: function() {
                    return this.manager._tempSkip = !0,
                    this
                },
                addPointer: function(R) {
                    return this.manager.addPointer(R)
                },
                setDefaultCursor: function(R) {
                    return this.manager.setDefaultCursor(R),
                    this
                },
                transitionIn: function() {
                    this.enabled = this.settings.transitionAllowInput
                },
                transitionComplete: function() {
                    this.settings.transitionAllowInput || (this.enabled = !0)
                },
                transitionOut: function() {
                    this.enabled = this.settings.transitionAllowInput
                },
                shutdown: function() {
                    this.pluginEvents.emit(h.SHUTDOWN),
                    this._temp.length = 0,
                    this._list.length = 0,
                    this._draggable.length = 0,
                    this._pendingRemoval.length = 0,
                    this._pendingInsertion.length = 0,
                    this._dragState.length = 0;
                    for (var R = 0; R < 10; R++)
                        this._drag[R] = [],
                        this._over[R] = [];
                    this.removeAllListeners();
                    var O = this.manager;
                    O.canvas.style.cursor = O.defaultCursor;
                    var F = this.systems.events;
                    F.off(E.TRANSITION_START, this.transitionIn, this),
                    F.off(E.TRANSITION_OUT, this.transitionOut, this),
                    F.off(E.TRANSITION_COMPLETE, this.transitionComplete, this),
                    F.off(E.PRE_UPDATE, this.preUpdate, this),
                    O.events.off(h.GAME_OUT, this.onGameOut, this),
                    O.events.off(h.GAME_OVER, this.onGameOver, this),
                    F.off(E.SHUTDOWN, this.shutdown, this)
                },
                destroy: function() {
                    this.shutdown(),
                    this.pluginEvents.emit(h.DESTROY),
                    this.pluginEvents.removeAllListeners(),
                    this.scene.sys.events.off(E.START, this.start, this),
                    this.scene = null,
                    this.cameras = null,
                    this.manager = null,
                    this.events = null,
                    this.mouse = null
                },
                x: {
                    get: function() {
                        return this.manager.activePointer.x
                    }
                },
                y: {
                    get: function() {
                        return this.manager.activePointer.y
                    }
                },
                isOver: {
                    get: function() {
                        return this.manager.isOver
                    }
                },
                mousePointer: {
                    get: function() {
                        return this.manager.mousePointer
                    }
                },
                activePointer: {
                    get: function() {
                        return this.manager.activePointer
                    }
                },
                pointer1: {
                    get: function() {
                        return this.manager.pointers[1]
                    }
                },
                pointer2: {
                    get: function() {
                        return this.manager.pointers[2]
                    }
                },
                pointer3: {
                    get: function() {
                        return this.manager.pointers[3]
                    }
                },
                pointer4: {
                    get: function() {
                        return this.manager.pointers[4]
                    }
                },
                pointer5: {
                    get: function() {
                        return this.manager.pointers[5]
                    }
                },
                pointer6: {
                    get: function() {
                        return this.manager.pointers[6]
                    }
                },
                pointer7: {
                    get: function() {
                        return this.manager.pointers[7]
                    }
                },
                pointer8: {
                    get: function() {
                        return this.manager.pointers[8]
                    }
                },
                pointer9: {
                    get: function() {
                        return this.manager.pointers[9]
                    }
                },
                pointer10: {
                    get: function() {
                        return this.manager.pointers[10]
                    }
                }
            });
            m.register("InputPlugin", L, "input"),
            c.exports = L
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Events: t(154),
                KeyboardManager: t(410),
                KeyboardPlugin: t(1330),
                Key: t(512),
                KeyCodes: t(143),
                KeyCombo: t(513),
                AdvanceKeyCombo: t(515),
                ProcessKeyCombo: t(514),
                ResetKeyCombo: t(516),
                JustDown: t(1332),
                JustUp: t(1333),
                DownDuration: t(1334),
                UpDuration: t(1335)
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "keydown"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "keyup"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "keycombomatch"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "down"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "keydown-"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "keyup-"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "up"
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(9)
              , r = t(154)
              , o = t(22)
              , a = t(6)
              , n = t(51)
              , s = t(153)
              , l = t(512)
              , i = t(143)
              , h = t(513)
              , u = t(1331)
              , d = t(20)
              , v = t(76)
              , p = new e({
                Extends: f,
                initialize: function(m) {
                    f.call(this),
                    this.game = m.systems.game,
                    this.scene = m.scene,
                    this.settings = this.scene.sys.settings,
                    this.sceneInputPlugin = m,
                    this.manager = m.manager.keyboard,
                    this.enabled = !0,
                    this.keys = [],
                    this.combos = [],
                    this.prevCode = null,
                    this.prevTime = 0,
                    this.prevType = null,
                    m.pluginEvents.once(n.BOOT, this.boot, this),
                    m.pluginEvents.on(n.START, this.start, this)
                },
                boot: function() {
                    var g = this.settings.input;
                    this.enabled = a(g, "keyboard", !0);
                    var m = a(g, "keyboard.capture", null);
                    m && this.addCaptures(m),
                    this.sceneInputPlugin.pluginEvents.once(n.DESTROY, this.destroy, this)
                },
                start: function() {
                    this.sceneInputPlugin.manager.events.on(n.MANAGER_PROCESS, this.update, this),
                    this.sceneInputPlugin.pluginEvents.once(n.SHUTDOWN, this.shutdown, this),
                    this.game.events.on(o.BLUR, this.resetKeys, this),
                    this.scene.sys.events.on(d.PAUSE, this.resetKeys, this),
                    this.scene.sys.events.on(d.SLEEP, this.resetKeys, this)
                },
                isActive: function() {
                    return this.enabled && this.scene.sys.isActive()
                },
                addCapture: function(g) {
                    return this.manager.addCapture(g),
                    this
                },
                removeCapture: function(g) {
                    return this.manager.removeCapture(g),
                    this
                },
                getCaptures: function() {
                    return this.manager.captures
                },
                enableGlobalCapture: function() {
                    return this.manager.preventDefault = !0,
                    this
                },
                disableGlobalCapture: function() {
                    return this.manager.preventDefault = !1,
                    this
                },
                clearCaptures: function() {
                    return this.manager.clearCaptures(),
                    this
                },
                createCursorKeys: function() {
                    return this.addKeys({
                        up: i.UP,
                        down: i.DOWN,
                        left: i.LEFT,
                        right: i.RIGHT,
                        space: i.SPACE,
                        shift: i.SHIFT
                    })
                },
                addKeys: function(g, m, x) {
                    m === void 0 && (m = !0),
                    x === void 0 && (x = !1);
                    var T = {};
                    if (typeof g == "string") {
                        g = g.split(",");
                        for (var E = 0; E < g.length; E++) {
                            var P = g[E].trim();
                            P && (T[P] = this.addKey(P, m, x))
                        }
                    } else
                        for (var M in g)
                            T[M] = this.addKey(g[M], m, x);
                    return T
                },
                addKey: function(g, m, x) {
                    m === void 0 && (m = !0),
                    x === void 0 && (x = !1);
                    var T = this.keys;
                    if (g instanceof l) {
                        var E = T.indexOf(g);
                        return E > -1 ? T[E] = g : T[g.keyCode] = g,
                        m && this.addCapture(g.keyCode),
                        g.setEmitOnRepeat(x),
                        g
                    }
                    return typeof g == "string" && (g = i[g.toUpperCase()]),
                    T[g] || (T[g] = new l(this,g),
                    m && this.addCapture(g),
                    T[g].setEmitOnRepeat(x)),
                    T[g]
                },
                removeKey: function(g, m) {
                    m === void 0 && (m = !1);
                    var x = this.keys, T;
                    if (g instanceof l) {
                        var E = x.indexOf(g);
                        E > -1 && (T = this.keys[E],
                        this.keys[E] = void 0)
                    } else
                        typeof g == "string" && (g = i[g.toUpperCase()]);
                    return x[g] && (T = x[g],
                    x[g] = void 0),
                    T && (T.plugin = null,
                    m && T.destroy()),
                    this
                },
                removeAllKeys: function(g) {
                    for (var m = this.keys, x = 0; x < m.length; x++) {
                        var T = m[x];
                        T && (m[x] = void 0,
                        g && T.destroy())
                    }
                    return this
                },
                createCombo: function(g, m) {
                    return new h(this,g,m)
                },
                checkDown: function(g, m) {
                    if (m === void 0 && (m = 0),
                    this.enabled && g.isDown) {
                        var x = v(this.time - g.timeDown, m);
                        if (x > g._tick)
                            return g._tick = x,
                            !0
                    }
                    return !1
                },
                update: function() {
                    var g = this.manager.queue
                      , m = g.length;
                    if (!(!this.isActive() || m === 0))
                        for (var x = this.keys, T = 0; T < m; T++) {
                            var E = g[T]
                              , P = E.keyCode
                              , M = x[P]
                              , L = !1;
                            E.cancelled === void 0 && (E.cancelled = 0,
                            E.stopImmediatePropagation = function() {
                                E.cancelled = 1
                            }
                            ,
                            E.stopPropagation = function() {
                                E.cancelled = -1
                            }
                            ),
                            E.cancelled !== -1 && (P === this.prevCode && E.timeStamp === this.prevTime && E.type === this.prevType || (this.prevCode = P,
                            this.prevTime = E.timeStamp,
                            this.prevType = E.type,
                            E.type === "keydown" ? (M && (L = M.isDown,
                            M.onDown(E)),
                            !E.cancelled && (!M || !L) && (u[P] && this.emit(r.KEY_DOWN + u[P], E),
                            E.cancelled || this.emit(r.ANY_KEY_DOWN, E))) : (M && M.onUp(E),
                            E.cancelled || (u[P] && this.emit(r.KEY_UP + u[P], E),
                            E.cancelled || this.emit(r.ANY_KEY_UP, E))),
                            E.cancelled === 1 && (E.cancelled = 0)))
                        }
                },
                resetKeys: function() {
                    for (var g = this.keys, m = 0; m < g.length; m++)
                        g[m] && g[m].reset();
                    return this
                },
                shutdown: function() {
                    this.removeAllKeys(!0),
                    this.removeAllListeners(),
                    this.sceneInputPlugin.manager.events.off(n.MANAGER_PROCESS, this.update, this),
                    this.game.events.off(o.BLUR, this.resetKeys),
                    this.scene.sys.events.off(d.PAUSE, this.resetKeys, this),
                    this.scene.sys.events.off(d.SLEEP, this.resetKeys, this),
                    this.queue = []
                },
                destroy: function() {
                    this.shutdown();
                    for (var g = this.keys, m = 0; m < g.length; m++)
                        g[m] && g[m].destroy();
                    this.keys = [],
                    this.combos = [],
                    this.queue = [],
                    this.scene = null,
                    this.settings = null,
                    this.sceneInputPlugin = null,
                    this.manager = null
                },
                time: {
                    get: function() {
                        return this.sceneInputPlugin.manager.time
                    }
                }
            });
            s.register("KeyboardPlugin", p, "keyboard", "keyboard", "inputKeyboard"),
            c.exports = p
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(143)
              , f = {};
            for (var r in e)
                f[e[r]] = r;
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e._justDown ? (e._justDown = !1,
                !0) : !1
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e._justUp ? (e._justUp = !1,
                !0) : !1
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                f === void 0 && (f = 50);
                var r = e.plugin.game.loop.time - e.timeDown;
                return e.isDown && r < f
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                f === void 0 && (f = 50);
                var r = e.plugin.game.loop.time - e.timeUp;
                return e.isUp && r < f
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                MouseManager: t(411)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                TouchManager: t(413)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(21)
              , f = t(17)
              , r = {
                Events: t(95),
                FileTypes: t(1339),
                File: t(23),
                FileTypesManager: t(8),
                GetURL: t(155),
                LoaderPlugin: t(1365),
                MergeXHRSettings: t(240),
                MultiFile: t(49),
                XHRLoader: t(517),
                XHRSettings: t(156)
            };
            r = f(!1, r, e),
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                AnimationJSONFile: t(1340),
                AsepriteFile: t(1341),
                AtlasJSONFile: t(1342),
                AtlasXMLFile: t(1343),
                AudioFile: t(518),
                AudioSpriteFile: t(1344),
                BinaryFile: t(1345),
                BitmapFontFile: t(1346),
                CSSFile: t(1347),
                GLSLFile: t(1348),
                HTML5AudioFile: t(519),
                HTMLFile: t(1349),
                HTMLTextureFile: t(1350),
                ImageFile: t(71),
                JSONFile: t(61),
                MultiAtlasFile: t(1351),
                MultiScriptFile: t(1352),
                OBJFile: t(1353),
                PackFile: t(1354),
                PluginFile: t(1355),
                SceneFile: t(1356),
                ScenePluginFile: t(1357),
                ScriptFile: t(520),
                SpriteSheetFile: t(1358),
                SVGFile: t(1359),
                TextFile: t(242),
                TilemapCSVFile: t(1360),
                TilemapImpactFile: t(1361),
                TilemapJSONFile: t(1362),
                UnityAtlasFile: t(1363),
                VideoFile: t(1364),
                XMLFile: t(241)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(8)
              , r = t(61)
              , o = t(95)
              , a = new e({
                Extends: r,
                initialize: function(s, l, i, h, u) {
                    r.call(this, s, l, i, h, u),
                    this.type = "animationJSON"
                },
                onProcess: function() {
                    this.loader.once(o.POST_PROCESS, this.onLoadComplete, this),
                    r.prototype.onProcess.call(this)
                },
                onLoadComplete: function() {
                    this.loader.systems.anims.fromJSON(this.data)
                }
            });
            f.register("animation", function(n, s, l, i) {
                if (Array.isArray(n))
                    for (var h = 0; h < n.length; h++)
                        this.addFile(new a(this,n[h]));
                else
                    this.addFile(new a(this,n,s,i,l));
                return this
            }),
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(8)
              , r = t(2)
              , o = t(71)
              , a = t(7)
              , n = t(61)
              , s = t(49)
              , l = new e({
                Extends: s,
                initialize: function(h, u, d, v, p, g) {
                    var m, x;
                    if (a(u)) {
                        var T = u;
                        u = r(T, "key"),
                        m = new o(h,{
                            key: u,
                            url: r(T, "textureURL"),
                            extension: r(T, "textureExtension", "png"),
                            normalMap: r(T, "normalMap"),
                            xhrSettings: r(T, "textureXhrSettings")
                        }),
                        x = new n(h,{
                            key: u,
                            url: r(T, "atlasURL"),
                            extension: r(T, "atlasExtension", "json"),
                            xhrSettings: r(T, "atlasXhrSettings")
                        })
                    } else
                        m = new o(h,u,d,p),
                        x = new n(h,u,v,g);
                    m.linkFile ? s.call(this, h, "atlasjson", u, [m, x, m.linkFile]) : s.call(this, h, "atlasjson", u, [m, x])
                },
                addToCache: function() {
                    if (this.isReadyToProcess()) {
                        var i = this.files[0]
                          , h = this.files[1]
                          , u = this.files[2] ? this.files[2].data : null;
                        this.loader.textureManager.addAtlas(i.key, i.data, h.data, u),
                        h.addToCache(),
                        this.complete = !0
                    }
                }
            });
            f.register("aseprite", function(i, h, u, d, v) {
                var p;
                if (Array.isArray(i))
                    for (var g = 0; g < i.length; g++)
                        p = new l(this,i[g]),
                        this.addFile(p.files);
                else
                    p = new l(this,i,h,u,d,v),
                    this.addFile(p.files);
                return this
            }),
            c.exports = l
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(8)
              , r = t(2)
              , o = t(71)
              , a = t(7)
              , n = t(61)
              , s = t(49)
              , l = new e({
                Extends: s,
                initialize: function(h, u, d, v, p, g) {
                    var m, x;
                    if (a(u)) {
                        var T = u;
                        u = r(T, "key"),
                        m = new o(h,{
                            key: u,
                            url: r(T, "textureURL"),
                            extension: r(T, "textureExtension", "png"),
                            normalMap: r(T, "normalMap"),
                            xhrSettings: r(T, "textureXhrSettings")
                        }),
                        x = new n(h,{
                            key: u,
                            url: r(T, "atlasURL"),
                            extension: r(T, "atlasExtension", "json"),
                            xhrSettings: r(T, "atlasXhrSettings")
                        })
                    } else
                        m = new o(h,u,d,p),
                        x = new n(h,u,v,g);
                    m.linkFile ? s.call(this, h, "atlasjson", u, [m, x, m.linkFile]) : s.call(this, h, "atlasjson", u, [m, x])
                },
                addToCache: function() {
                    if (this.isReadyToProcess()) {
                        var i = this.files[0]
                          , h = this.files[1]
                          , u = this.files[2] ? this.files[2].data : null;
                        this.loader.textureManager.addAtlas(i.key, i.data, h.data, u),
                        h.pendingDestroy(),
                        this.complete = !0
                    }
                }
            });
            f.register("atlas", function(i, h, u, d, v) {
                var p;
                if (Array.isArray(i))
                    for (var g = 0; g < i.length; g++)
                        p = new l(this,i[g]),
                        this.addFile(p.files);
                else
                    p = new l(this,i,h,u,d,v),
                    this.addFile(p.files);
                return this
            }),
            c.exports = l
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(8)
              , r = t(2)
              , o = t(71)
              , a = t(7)
              , n = t(49)
              , s = t(241)
              , l = new e({
                Extends: n,
                initialize: function(h, u, d, v, p, g) {
                    var m, x;
                    if (a(u)) {
                        var T = u;
                        u = r(T, "key"),
                        m = new o(h,{
                            key: u,
                            url: r(T, "textureURL"),
                            extension: r(T, "textureExtension", "png"),
                            normalMap: r(T, "normalMap"),
                            xhrSettings: r(T, "textureXhrSettings")
                        }),
                        x = new s(h,{
                            key: u,
                            url: r(T, "atlasURL"),
                            extension: r(T, "atlasExtension", "xml"),
                            xhrSettings: r(T, "atlasXhrSettings")
                        })
                    } else
                        m = new o(h,u,d,p),
                        x = new s(h,u,v,g);
                    m.linkFile ? n.call(this, h, "atlasxml", u, [m, x, m.linkFile]) : n.call(this, h, "atlasxml", u, [m, x])
                },
                addToCache: function() {
                    if (this.isReadyToProcess()) {
                        var i = this.files[0]
                          , h = this.files[1]
                          , u = this.files[2] ? this.files[2].data : null;
                        this.loader.textureManager.addAtlasXML(i.key, i.data, h.data, u),
                        h.pendingDestroy(),
                        this.complete = !0
                    }
                }
            });
            f.register("atlasXML", function(i, h, u, d, v) {
                var p;
                if (Array.isArray(i))
                    for (var g = 0; g < i.length; g++)
                        p = new l(this,i[g]),
                        this.addFile(p.files);
                else
                    p = new l(this,i,h,u,d,v),
                    this.addFile(p.files);
                return this
            }),
            c.exports = l
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(518)
              , f = t(0)
              , r = t(8)
              , o = t(2)
              , a = t(7)
              , n = t(61)
              , s = t(49)
              , l = new f({
                Extends: s,
                initialize: function(h, u, d, v, p, g, m) {
                    if (a(u)) {
                        var x = u;
                        u = o(x, "key"),
                        d = o(x, "jsonURL"),
                        v = o(x, "audioURL"),
                        p = o(x, "audioConfig"),
                        g = o(x, "audioXhrSettings"),
                        m = o(x, "jsonXhrSettings")
                    }
                    var T;
                    if (!v)
                        T = new n(h,u,d,m),
                        s.call(this, h, "audiosprite", u, [T]),
                        this.config.resourceLoad = !0,
                        this.config.audioConfig = p,
                        this.config.audioXhrSettings = g;
                    else {
                        var E = e.create(h, u, v, p, g);
                        E && (T = new n(h,u,d,m),
                        s.call(this, h, "audiosprite", u, [E, T]),
                        this.config.resourceLoad = !1)
                    }
                },
                onFileComplete: function(i) {
                    var h = this.files.indexOf(i);
                    if (h !== -1 && (this.pending--,
                    this.config.resourceLoad && i.type === "json" && i.data.hasOwnProperty("resources"))) {
                        var u = i.data.resources
                          , d = o(this.config, "audioConfig")
                          , v = o(this.config, "audioXhrSettings")
                          , p = e.create(this.loader, i.key, u, d, v);
                        p && (this.addToMultiFile(p),
                        this.loader.addFile(p))
                    }
                },
                addToCache: function() {
                    if (this.isReadyToProcess()) {
                        var i = this.files[0]
                          , h = this.files[1];
                        i.addToCache(),
                        h.addToCache(),
                        this.complete = !0
                    }
                }
            });
            r.register("audioSprite", function(i, h, u, d, v, p) {
                var g = this.systems.game
                  , m = g.config.audio
                  , x = g.device.audio;
                if (m && m.noAudio || !x.webAudio && !x.audioData)
                    return this;
                var T;
                if (Array.isArray(i))
                    for (var E = 0; E < i.length; E++)
                        T = new l(this,i[E]),
                        T.files && this.addFile(T.files);
                else
                    T = new l(this,i,h,u,d,v,p),
                    T.files && this.addFile(T.files);
                return this
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(21)
              , r = t(23)
              , o = t(8)
              , a = t(2)
              , n = t(7)
              , s = new e({
                Extends: r,
                initialize: function(i, h, u, d, v) {
                    var p = "bin";
                    if (n(h)) {
                        var g = h;
                        h = a(g, "key"),
                        u = a(g, "url"),
                        d = a(g, "xhrSettings"),
                        p = a(g, "extension", p),
                        v = a(g, "dataType", v)
                    }
                    var m = {
                        type: "binary",
                        cache: i.cacheManager.binary,
                        extension: p,
                        responseType: "arraybuffer",
                        key: h,
                        url: u,
                        xhrSettings: d,
                        config: {
                            dataType: v
                        }
                    };
                    r.call(this, i, m)
                },
                onProcess: function() {
                    this.state = f.FILE_PROCESSING;
                    var l = this.config.dataType;
                    this.data = l ? new l(this.xhrLoader.response) : this.xhrLoader.response,
                    this.onProcessComplete()
                }
            });
            o.register("binary", function(l, i, h, u) {
                if (Array.isArray(l))
                    for (var d = 0; d < l.length; d++)
                        this.addFile(new s(this,l[d]));
                else
                    this.addFile(new s(this,l,i,u,h));
                return this
            }),
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(8)
              , r = t(2)
              , o = t(71)
              , a = t(7)
              , n = t(49)
              , s = t(212)
              , l = t(241)
              , i = new e({
                Extends: n,
                initialize: function(u, d, v, p, g, m) {
                    var x, T;
                    if (a(d)) {
                        var E = d;
                        d = r(E, "key"),
                        x = new o(u,{
                            key: d,
                            url: r(E, "textureURL"),
                            extension: r(E, "textureExtension", "png"),
                            normalMap: r(E, "normalMap"),
                            xhrSettings: r(E, "textureXhrSettings")
                        }),
                        T = new l(u,{
                            key: d,
                            url: r(E, "fontDataURL"),
                            extension: r(E, "fontDataExtension", "xml"),
                            xhrSettings: r(E, "fontDataXhrSettings")
                        })
                    } else
                        x = new o(u,d,v,g),
                        T = new l(u,d,p,m);
                    x.linkFile ? n.call(this, u, "bitmapfont", d, [x, T, x.linkFile]) : n.call(this, u, "bitmapfont", d, [x, T])
                },
                addToCache: function() {
                    if (this.isReadyToProcess()) {
                        var h = this.files[0]
                          , u = this.files[1];
                        h.addToCache(),
                        u.pendingDestroy();
                        var d = h.cache.get(h.key)
                          , v = s(u.data, h.cache.getFrame(h.key), 0, 0, d);
                        this.loader.cacheManager.bitmapFont.add(h.key, {
                            data: v,
                            texture: h.key,
                            frame: null
                        }),
                        this.complete = !0
                    }
                }
            });
            f.register("bitmapFont", function(h, u, d, v, p) {
                var g;
                if (Array.isArray(h))
                    for (var m = 0; m < h.length; m++)
                        g = new i(this,h[m]),
                        this.addFile(g.files);
                else
                    g = new i(this,h,u,d,v,p),
                    this.addFile(g.files);
                return this
            }),
            c.exports = i
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(21)
              , r = t(23)
              , o = t(8)
              , a = t(2)
              , n = t(7)
              , s = new e({
                Extends: r,
                initialize: function(i, h, u, d) {
                    var v = "css";
                    if (n(h)) {
                        var p = h;
                        h = a(p, "key"),
                        u = a(p, "url"),
                        d = a(p, "xhrSettings"),
                        v = a(p, "extension", v)
                    }
                    var g = {
                        type: "script",
                        cache: !1,
                        extension: v,
                        responseType: "text",
                        key: h,
                        url: u,
                        xhrSettings: d
                    };
                    r.call(this, i, g)
                },
                onProcess: function() {
                    this.state = f.FILE_PROCESSING,
                    this.data = document.createElement("style"),
                    this.data.defer = !1,
                    this.data.innerHTML = this.xhrLoader.responseText,
                    document.head.appendChild(this.data),
                    this.onProcessComplete()
                }
            });
            o.register("css", function(l, i, h) {
                if (Array.isArray(l))
                    for (var u = 0; u < l.length; u++)
                        this.addFile(new s(this,l[u]));
                else
                    this.addFile(new s(this,l,i,h));
                return this
            }),
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(21)
              , r = t(23)
              , o = t(8)
              , a = t(2)
              , n = t(7)
              , s = t(396)
              , l = new e({
                Extends: r,
                initialize: function(h, u, d, v, p) {
                    var g = "glsl";
                    if (n(u)) {
                        var m = u;
                        u = a(m, "key"),
                        d = a(m, "url"),
                        v = a(m, "shaderType", "fragment"),
                        p = a(m, "xhrSettings"),
                        g = a(m, "extension", g)
                    } else
                        v === void 0 && (v = "fragment");
                    var x = {
                        type: "glsl",
                        cache: h.cacheManager.shader,
                        extension: g,
                        responseType: "text",
                        key: u,
                        url: d,
                        config: {
                            shaderType: v
                        },
                        xhrSettings: p
                    };
                    r.call(this, h, x)
                },
                onProcess: function() {
                    this.state = f.FILE_PROCESSING,
                    this.data = this.xhrLoader.responseText,
                    this.onProcessComplete()
                },
                addToCache: function() {
                    var i = this.data.split(`
`)
                      , h = this.extractBlock(i, 0);
                    if (h)
                        for (; h; ) {
                            var u = this.getShaderName(h.header)
                              , d = this.getShaderType(h.header)
                              , v = this.getShaderUniforms(h.header)
                              , p = h.shader;
                            if (this.cache.has(u)) {
                                var g = this.cache.get(u);
                                d === "fragment" ? g.fragmentSrc = p : g.vertexSrc = p,
                                g.uniforms || (g.uniforms = v)
                            } else
                                d === "fragment" ? this.cache.add(u, new s(u,p,"",v)) : this.cache.add(u, new s(u,"",p,v));
                            h = this.extractBlock(i, h.offset)
                        }
                    else
                        this.config.shaderType === "fragment" ? this.cache.add(this.key, new s(this.key,this.data)) : this.cache.add(this.key, new s(this.key,"",this.data));
                    this.pendingDestroy()
                },
                getShaderName: function(i) {
                    for (var h = 0; h < i.length; h++) {
                        var u = i[h].trim();
                        if (u.substring(0, 5) === "name:")
                            return u.substring(5).trim()
                    }
                    return this.key
                },
                getShaderType: function(i) {
                    for (var h = 0; h < i.length; h++) {
                        var u = i[h].trim();
                        if (u.substring(0, 5) === "type:")
                            return u.substring(5).trim()
                    }
                    return this.config.shaderType
                },
                getShaderUniforms: function(i) {
                    for (var h = {}, u = 0; u < i.length; u++) {
                        var d = i[u].trim();
                        if (d.substring(0, 8) === "uniform.") {
                            var v = d.indexOf(":");
                            if (v) {
                                var p = d.substring(8, v);
                                try {
                                    h[p] = JSON.parse(d.substring(v + 1))
                                } catch {
                                    console.warn("Invalid uniform JSON: " + p)
                                }
                            }
                        }
                    }
                    return h
                },
                extractBlock: function(i, h) {
                    for (var u = -1, d = -1, v = -1, p = !1, g = !1, m = [], x = [], T = h; T < i.length; T++) {
                        var E = i[T].trim();
                        if (E === "---")
                            if (u === -1)
                                u = T,
                                p = !0;
                            else if (p)
                                d = T,
                                p = !1,
                                g = !0;
                            else {
                                g = !1;
                                break
                            }
                        else
                            p ? m.push(E) : g && (x.push(E),
                            v = T)
                    }
                    return !p && d !== -1 ? {
                        header: m,
                        shader: x.join(`
`),
                        offset: v
                    } : null
                }
            });
            o.register("glsl", function(i, h, u, d) {
                if (Array.isArray(i))
                    for (var v = 0; v < i.length; v++)
                        this.addFile(new l(this,i[v]));
                else
                    this.addFile(new l(this,i,h,u,d));
                return this
            }),
            c.exports = l
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(21)
              , r = t(23)
              , o = t(8)
              , a = t(2)
              , n = t(7)
              , s = new e({
                Extends: r,
                initialize: function(i, h, u, d) {
                    var v = "html";
                    if (n(h)) {
                        var p = h;
                        h = a(p, "key"),
                        u = a(p, "url"),
                        d = a(p, "xhrSettings"),
                        v = a(p, "extension", v)
                    }
                    var g = {
                        type: "text",
                        cache: i.cacheManager.html,
                        extension: v,
                        responseType: "text",
                        key: h,
                        url: u,
                        xhrSettings: d
                    };
                    r.call(this, i, g)
                },
                onProcess: function() {
                    this.state = f.FILE_PROCESSING,
                    this.data = this.xhrLoader.responseText,
                    this.onProcessComplete()
                }
            });
            o.register("html", function(l, i, h) {
                if (Array.isArray(l))
                    for (var u = 0; u < l.length; u++)
                        this.addFile(new s(this,l[u]));
                else
                    this.addFile(new s(this,l,i,h));
                return this
            }),
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(21)
              , r = t(23)
              , o = t(8)
              , a = t(2)
              , n = t(7)
              , s = new e({
                Extends: r,
                initialize: function(i, h, u, d, v, p) {
                    d === void 0 && (d = 512),
                    v === void 0 && (v = 512);
                    var g = "html";
                    if (n(h)) {
                        var m = h;
                        h = a(m, "key"),
                        u = a(m, "url"),
                        p = a(m, "xhrSettings"),
                        g = a(m, "extension", g),
                        d = a(m, "width", d),
                        v = a(m, "height", v)
                    }
                    var x = {
                        type: "html",
                        cache: i.textureManager,
                        extension: g,
                        responseType: "text",
                        key: h,
                        url: u,
                        xhrSettings: p,
                        config: {
                            width: d,
                            height: v
                        }
                    };
                    r.call(this, i, x)
                },
                onProcess: function() {
                    this.state = f.FILE_PROCESSING;
                    var l = this.config.width
                      , i = this.config.height
                      , h = [];
                    h.push('<svg width="' + l + 'px" height="' + i + 'px" viewBox="0 0 ' + l + " " + i + '" xmlns="http://www.w3.org/2000/svg">'),
                    h.push('<foreignObject width="100%" height="100%">'),
                    h.push('<body xmlns="http://www.w3.org/1999/xhtml">'),
                    h.push(this.xhrLoader.responseText),
                    h.push("</body>"),
                    h.push("</foreignObject>"),
                    h.push("</svg>");
                    var u = [h.join(`
`)]
                      , d = this;
                    try {
                        var v = new window.Blob(u,{
                            type: "image/svg+xml;charset=utf-8"
                        })
                    } catch {
                        d.state = f.FILE_ERRORED,
                        d.onProcessComplete();
                        return
                    }
                    this.data = new Image,
                    this.data.crossOrigin = this.crossOrigin,
                    this.data.onload = function() {
                        r.revokeObjectURL(d.data),
                        d.onProcessComplete()
                    }
                    ,
                    this.data.onerror = function() {
                        r.revokeObjectURL(d.data),
                        d.onProcessError()
                    }
                    ,
                    r.createObjectURL(this.data, v, "image/svg+xml")
                },
                addToCache: function() {
                    var l = this.cache.addImage(this.key, this.data);
                    this.pendingDestroy(l)
                }
            });
            o.register("htmlTexture", function(l, i, h, u, d) {
                if (Array.isArray(l))
                    for (var v = 0; v < l.length; v++)
                        this.addFile(new s(this,l[v]));
                else
                    this.addFile(new s(this,l,i,h,u,d));
                return this
            }),
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(8)
              , r = t(2)
              , o = t(71)
              , a = t(7)
              , n = t(61)
              , s = t(49)
              , l = new e({
                Extends: s,
                initialize: function(h, u, d, v, p, g, m) {
                    if (a(u)) {
                        var x = u;
                        u = r(x, "key"),
                        r(x, "url", !1) ? d = r(x, "url") : d = r(x, "atlasURL"),
                        g = r(x, "xhrSettings"),
                        v = r(x, "path"),
                        p = r(x, "baseURL"),
                        m = r(x, "textureXhrSettings")
                    }
                    var T = new n(h,u,d,g);
                    s.call(this, h, "multiatlas", u, [T]),
                    this.config.path = v,
                    this.config.baseURL = p,
                    this.config.textureXhrSettings = m
                },
                onFileComplete: function(i) {
                    var h = this.files.indexOf(i);
                    if (h !== -1 && (this.pending--,
                    i.type === "json" && i.data.hasOwnProperty("textures"))) {
                        var u = i.data.textures
                          , d = this.config
                          , v = this.loader
                          , p = v.baseURL
                          , g = v.path
                          , m = v.prefix
                          , x = r(d, "baseURL", this.baseURL)
                          , T = r(d, "path", this.path)
                          , E = r(d, "prefix", this.prefix)
                          , P = r(d, "textureXhrSettings");
                        v.setBaseURL(x),
                        v.setPath(T),
                        v.setPrefix(E);
                        for (var M = 0; M < u.length; M++) {
                            var L = u[M].image
                              , R = "MA" + this.multiKeyIndex + "_" + L
                              , O = new o(v,R,L,P);
                            if (this.addToMultiFile(O),
                            v.addFile(O),
                            u[M].normalMap) {
                                var F = new o(v,R,u[M].normalMap,P);
                                F.type = "normalMap",
                                O.setLink(F),
                                this.addToMultiFile(F),
                                v.addFile(F)
                            }
                        }
                        v.setBaseURL(p),
                        v.setPath(g),
                        v.setPrefix(m)
                    }
                },
                addToCache: function() {
                    if (this.isReadyToProcess()) {
                        for (var i = this.files[0], h = [], u = [], d = [], v = 1; v < this.files.length; v++) {
                            var p = this.files[v];
                            if (p.type !== "normalMap")
                                for (var g = p.key.indexOf("_"), m = p.key.substr(g + 1), x = p.data, T = 0; T < i.data.textures.length; T++) {
                                    var E = i.data.textures[T];
                                    if (E.image === m) {
                                        u.push(x),
                                        h.push(E),
                                        p.linkFile && d.push(p.linkFile.data);
                                        break
                                    }
                                }
                        }
                        for (d.length === 0 && (d = void 0),
                        this.loader.textureManager.addAtlasJSONArray(this.key, u, h, d),
                        this.complete = !0,
                        v = 0; v < this.files.length; v++)
                            this.files[v].pendingDestroy()
                    }
                }
            });
            f.register("multiatlas", function(i, h, u, d, v) {
                var p;
                if (Array.isArray(i))
                    for (var g = 0; g < i.length; g++)
                        p = new l(this,i[g]),
                        this.addFile(p.files);
                else
                    p = new l(this,i,h,u,d,v),
                    this.addFile(p.files);
                return this
            }),
            c.exports = l
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(8)
              , r = t(2)
              , o = t(7)
              , a = t(49)
              , n = t(520)
              , s = new e({
                Extends: a,
                initialize: function(i, h, u, d) {
                    var v = "js"
                      , p = [];
                    if (o(h)) {
                        var g = h;
                        h = r(g, "key"),
                        u = r(g, "url"),
                        d = r(g, "xhrSettings"),
                        v = r(g, "extension", v)
                    }
                    Array.isArray(u) || (u = [u]);
                    for (var m = 0; m < u.length; m++) {
                        var x = new n(i,{
                            key: h + "_" + m.toString(),
                            url: u[m],
                            extension: v,
                            xhrSettings: d
                        });
                        x.onProcess = function() {
                            this.onProcessComplete()
                        }
                        ,
                        p.push(x)
                    }
                    a.call(this, i, "scripts", h, p)
                },
                addToCache: function() {
                    if (this.isReadyToProcess()) {
                        for (var l = 0; l < this.files.length; l++) {
                            var i = this.files[l];
                            i.data = document.createElement("script"),
                            i.data.language = "javascript",
                            i.data.type = "text/javascript",
                            i.data.defer = !1,
                            i.data.text = i.xhrLoader.responseText,
                            document.head.appendChild(i.data)
                        }
                        this.complete = !0
                    }
                }
            });
            f.register("scripts", function(l, i, h) {
                var u;
                if (Array.isArray(l))
                    for (var d = 0; d < l.length; d++)
                        u = new s(this,l[d]),
                        this.addFile(u.files);
                else
                    u = new s(this,l,i,h),
                    this.addFile(u.files);
                return this
            }),
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(8)
              , r = t(2)
              , o = t(7)
              , a = t(49)
              , n = t(498)
              , s = t(499)
              , l = t(242)
              , i = new e({
                Extends: a,
                initialize: function(u, d, v, p, g, m) {
                    var x, T, E = u.cacheManager.obj;
                    if (o(d)) {
                        var P = d;
                        d = r(P, "key"),
                        x = new l(u,{
                            key: d,
                            type: "obj",
                            cache: E,
                            url: r(P, "url"),
                            extension: r(P, "extension", "obj"),
                            xhrSettings: r(P, "xhrSettings"),
                            config: {
                                flipUV: r(P, "flipUV", g)
                            }
                        }),
                        p = r(P, "matURL"),
                        p && (T = new l(u,{
                            key: d,
                            type: "mat",
                            cache: E,
                            url: p,
                            extension: r(P, "matExtension", "mat"),
                            xhrSettings: r(P, "xhrSettings")
                        }))
                    } else
                        x = new l(u,{
                            key: d,
                            url: v,
                            type: "obj",
                            cache: E,
                            extension: "obj",
                            xhrSettings: m,
                            config: {
                                flipUV: g
                            }
                        }),
                        p && (T = new l(u,{
                            key: d,
                            url: p,
                            type: "mat",
                            cache: E,
                            extension: "mat",
                            xhrSettings: m
                        }));
                    a.call(this, u, "obj", d, [x, T])
                },
                addToCache: function() {
                    if (this.isReadyToProcess()) {
                        var h = this.files[0]
                          , u = this.files[1]
                          , d = n(h.data, h.config.flipUV);
                        u && (d.materials = s(u.data)),
                        h.cache.add(h.key, d),
                        this.complete = !0
                    }
                }
            });
            f.register("obj", function(h, u, d, v, p) {
                var g;
                if (Array.isArray(h))
                    for (var m = 0; m < h.length; m++)
                        g = new i(this,h[m]),
                        this.addFile(g.files);
                else
                    g = new i(this,h,u,d,v,p),
                    this.addFile(g.files);
                return this
            }),
            c.exports = i
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(21)
              , r = t(8)
              , o = t(61)
              , a = new e({
                Extends: o,
                initialize: function(s, l, i, h, u) {
                    o.call(this, s, l, i, h, u),
                    this.type = "packfile"
                },
                onProcess: function() {
                    this.state !== f.FILE_POPULATED && (this.state = f.FILE_PROCESSING,
                    this.data = JSON.parse(this.xhrLoader.responseText)),
                    this.loader.addPack(this.data, this.config),
                    this.onProcessComplete()
                }
            });
            r.register("pack", function(n, s, l, i) {
                if (Array.isArray(n))
                    for (var h = 0; h < n.length; h++)
                        this.addFile(new a(this,n[h]));
                else
                    this.addFile(new a(this,n,s,i,l));
                return this
            }),
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(21)
              , r = t(23)
              , o = t(8)
              , a = t(2)
              , n = t(7)
              , s = new e({
                Extends: r,
                initialize: function(i, h, u, d, v, p) {
                    var g = "js";
                    if (n(h)) {
                        var m = h;
                        h = a(m, "key"),
                        u = a(m, "url"),
                        p = a(m, "xhrSettings"),
                        g = a(m, "extension", g),
                        d = a(m, "start"),
                        v = a(m, "mapping")
                    }
                    var x = {
                        type: "plugin",
                        cache: !1,
                        extension: g,
                        responseType: "text",
                        key: h,
                        url: u,
                        xhrSettings: p,
                        config: {
                            start: d,
                            mapping: v
                        }
                    };
                    r.call(this, i, x),
                    typeof u == "function" && (this.data = u,
                    this.state = f.FILE_POPULATED)
                },
                onProcess: function() {
                    var l = this.loader.systems.plugins
                      , i = this.config
                      , h = a(i, "start", !1)
                      , u = a(i, "mapping", null);
                    if (this.state === f.FILE_POPULATED)
                        l.install(this.key, this.data, h, u);
                    else {
                        this.state = f.FILE_PROCESSING,
                        this.data = document.createElement("script"),
                        this.data.language = "javascript",
                        this.data.type = "text/javascript",
                        this.data.defer = !1,
                        this.data.text = this.xhrLoader.responseText,
                        document.head.appendChild(this.data);
                        var d = l.install(this.key, window[this.key], h, u);
                        (h || u) && (this.loader.systems[u] = d,
                        this.loader.scene[u] = d)
                    }
                    this.onProcessComplete()
                }
            });
            o.register("plugin", function(l, i, h, u, d) {
                if (Array.isArray(l))
                    for (var v = 0; v < l.length; v++)
                        this.addFile(new s(this,l[v]));
                else
                    this.addFile(new s(this,l,i,h,u,d));
                return this
            }),
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(21)
              , r = t(23)
              , o = t(8)
              , a = t(2)
              , n = t(7)
              , s = new e({
                Extends: r,
                initialize: function(i, h, u, d) {
                    var v = "js";
                    if (n(h)) {
                        var p = h;
                        h = a(p, "key"),
                        u = a(p, "url"),
                        d = a(p, "xhrSettings"),
                        v = a(p, "extension", v)
                    }
                    var g = {
                        type: "text",
                        extension: v,
                        responseType: "text",
                        key: h,
                        url: u,
                        xhrSettings: d
                    };
                    r.call(this, i, g)
                },
                onProcess: function() {
                    this.state = f.FILE_PROCESSING,
                    this.data = this.xhrLoader.responseText,
                    this.onProcessComplete()
                },
                addToCache: function() {
                    var l = this.data.concat(`(function(){
return new ` + this.key + `();
}).call(this);`)
                      , i = eval;
                    this.loader.sceneManager.add(this.key, i(l)),
                    this.complete = !0
                }
            });
            o.register("sceneFile", function(l, i, h) {
                if (Array.isArray(l))
                    for (var u = 0; u < l.length; u++)
                        this.addFile(new s(this,l[u]));
                else
                    this.addFile(new s(this,l,i,h));
                return this
            }),
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(21)
              , r = t(23)
              , o = t(8)
              , a = t(2)
              , n = t(7)
              , s = new e({
                Extends: r,
                initialize: function(i, h, u, d, v, p) {
                    var g = "js";
                    if (n(h)) {
                        var m = h;
                        h = a(m, "key"),
                        u = a(m, "url"),
                        p = a(m, "xhrSettings"),
                        g = a(m, "extension", g),
                        d = a(m, "systemKey"),
                        v = a(m, "sceneKey")
                    }
                    var x = {
                        type: "scenePlugin",
                        cache: !1,
                        extension: g,
                        responseType: "text",
                        key: h,
                        url: u,
                        xhrSettings: p,
                        config: {
                            systemKey: d,
                            sceneKey: v
                        }
                    };
                    r.call(this, i, x),
                    typeof u == "function" && (this.data = u,
                    this.state = f.FILE_POPULATED)
                },
                onProcess: function() {
                    var l = this.loader.systems.plugins
                      , i = this.config
                      , h = this.key
                      , u = a(i, "systemKey", h)
                      , d = a(i, "sceneKey", h);
                    this.state === f.FILE_POPULATED ? l.installScenePlugin(u, this.data, d, this.loader.scene, !0) : (this.state = f.FILE_PROCESSING,
                    this.data = document.createElement("script"),
                    this.data.language = "javascript",
                    this.data.type = "text/javascript",
                    this.data.defer = !1,
                    this.data.text = this.xhrLoader.responseText,
                    document.head.appendChild(this.data),
                    l.installScenePlugin(u, window[this.key], d, this.loader.scene, !0)),
                    this.onProcessComplete()
                }
            });
            o.register("scenePlugin", function(l, i, h, u, d) {
                if (Array.isArray(l))
                    for (var v = 0; v < l.length; v++)
                        this.addFile(new s(this,l[v]));
                else
                    this.addFile(new s(this,l,i,h,u,d));
                return this
            }),
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(8)
              , r = t(71)
              , o = new e({
                Extends: r,
                initialize: function(n, s, l, i, h) {
                    r.call(this, n, s, l, h, i),
                    this.type = "spritesheet"
                },
                addToCache: function() {
                    var a = this.cache.addSpriteSheet(this.key, this.data, this.config);
                    this.pendingDestroy(a)
                }
            });
            f.register("spritesheet", function(a, n, s, l) {
                if (Array.isArray(a))
                    for (var i = 0; i < a.length; i++)
                        this.addFile(new o(this,a[i]));
                else
                    this.addFile(new o(this,a,n,s,l));
                return this
            }),
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(21)
              , r = t(23)
              , o = t(8)
              , a = t(2)
              , n = t(7)
              , s = new e({
                Extends: r,
                initialize: function(i, h, u, d, v) {
                    var p = "svg";
                    if (n(h)) {
                        var g = h;
                        h = a(g, "key"),
                        u = a(g, "url"),
                        d = a(g, "svgConfig", {}),
                        v = a(g, "xhrSettings"),
                        p = a(g, "extension", p)
                    }
                    var m = {
                        type: "svg",
                        cache: i.textureManager,
                        extension: p,
                        responseType: "text",
                        key: h,
                        url: u,
                        xhrSettings: v,
                        config: {
                            width: a(d, "width"),
                            height: a(d, "height"),
                            scale: a(d, "scale")
                        }
                    };
                    r.call(this, i, m)
                },
                onProcess: function() {
                    this.state = f.FILE_PROCESSING;
                    var l = this.xhrLoader.responseText
                      , i = [l]
                      , h = this.config.width
                      , u = this.config.height
                      , d = this.config.scale;
                    t: if (h && u || d) {
                        var v = null
                          , p = new DOMParser;
                        v = p.parseFromString(l, "text/xml");
                        var g = v.getElementsByTagName("svg")[0]
                          , m = g.hasAttribute("viewBox")
                          , x = parseFloat(g.getAttribute("width"))
                          , T = parseFloat(g.getAttribute("height"));
                        if (!m && x && T)
                            g.setAttribute("viewBox", "0  0 " + x + " " + T);
                        else if (m && !x && !T) {
                            var E = g.getAttribute("viewBox").split(/\s+|,/);
                            x = E[2],
                            T = E[3]
                        }
                        if (d)
                            if (x && T)
                                h = x * d,
                                u = T * d;
                            else
                                break t;
                        g.setAttribute("width", h.toString() + "px"),
                        g.setAttribute("height", u.toString() + "px"),
                        i = [new XMLSerializer().serializeToString(g)]
                    }
                    try {
                        var P = new window.Blob(i,{
                            type: "image/svg+xml;charset=utf-8"
                        })
                    } catch {
                        this.onProcessError();
                        return
                    }
                    this.data = new Image,
                    this.data.crossOrigin = this.crossOrigin;
                    var M = this
                      , L = !1;
                    this.data.onload = function() {
                        L || r.revokeObjectURL(M.data),
                        M.onProcessComplete()
                    }
                    ,
                    this.data.onerror = function() {
                        L ? M.onProcessError() : (L = !0,
                        r.revokeObjectURL(M.data),
                        M.data.src = "data:image/svg+xml," + encodeURIComponent(i.join("")))
                    }
                    ,
                    r.createObjectURL(this.data, P, "image/svg+xml")
                },
                addToCache: function() {
                    var l = this.cache.addImage(this.key, this.data);
                    this.pendingDestroy(l)
                }
            });
            o.register("svg", function(l, i, h, u) {
                if (Array.isArray(l))
                    for (var d = 0; d < l.length; d++)
                        this.addFile(new s(this,l[d]));
                else
                    this.addFile(new s(this,l,i,h,u));
                return this
            }),
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(21)
              , r = t(23)
              , o = t(8)
              , a = t(2)
              , n = t(7)
              , s = t(40)
              , l = new e({
                Extends: r,
                initialize: function(h, u, d, v) {
                    var p = "csv";
                    if (n(u)) {
                        var g = u;
                        u = a(g, "key"),
                        d = a(g, "url"),
                        v = a(g, "xhrSettings"),
                        p = a(g, "extension", p)
                    }
                    var m = {
                        type: "tilemapCSV",
                        cache: h.cacheManager.tilemap,
                        extension: p,
                        responseType: "text",
                        key: u,
                        url: d,
                        xhrSettings: v
                    };
                    r.call(this, h, m),
                    this.tilemapFormat = s.CSV
                },
                onProcess: function() {
                    this.state = f.FILE_PROCESSING,
                    this.data = this.xhrLoader.responseText,
                    this.onProcessComplete()
                },
                addToCache: function() {
                    var i = {
                        format: this.tilemapFormat,
                        data: this.data
                    };
                    this.cache.add(this.key, i),
                    this.pendingDestroy(i)
                }
            });
            o.register("tilemapCSV", function(i, h, u) {
                if (Array.isArray(i))
                    for (var d = 0; d < i.length; d++)
                        this.addFile(new l(this,i[d]));
                else
                    this.addFile(new l(this,i,h,u));
                return this
            }),
            c.exports = l
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(8)
              , r = t(61)
              , o = t(40)
              , a = new e({
                Extends: r,
                initialize: function(s, l, i, h) {
                    r.call(this, s, l, i, h),
                    this.type = "tilemapJSON",
                    this.cache = s.cacheManager.tilemap
                },
                addToCache: function() {
                    var n = {
                        format: o.WELTMEISTER,
                        data: this.data
                    };
                    this.cache.add(this.key, n),
                    this.pendingDestroy(n)
                }
            });
            f.register("tilemapImpact", function(n, s, l) {
                if (Array.isArray(n))
                    for (var i = 0; i < n.length; i++)
                        this.addFile(new a(this,n[i]));
                else
                    this.addFile(new a(this,n,s,l));
                return this
            }),
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(8)
              , r = t(61)
              , o = t(40)
              , a = new e({
                Extends: r,
                initialize: function(s, l, i, h) {
                    r.call(this, s, l, i, h),
                    this.type = "tilemapJSON",
                    this.cache = s.cacheManager.tilemap
                },
                addToCache: function() {
                    var n = {
                        format: o.TILED_JSON,
                        data: this.data
                    };
                    this.cache.add(this.key, n),
                    this.pendingDestroy(n)
                }
            });
            f.register("tilemapTiledJSON", function(n, s, l) {
                if (Array.isArray(n))
                    for (var i = 0; i < n.length; i++)
                        this.addFile(new a(this,n[i]));
                else
                    this.addFile(new a(this,n,s,l));
                return this
            }),
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(8)
              , r = t(2)
              , o = t(71)
              , a = t(7)
              , n = t(49)
              , s = t(242)
              , l = new e({
                Extends: n,
                initialize: function(h, u, d, v, p, g) {
                    var m, x;
                    if (a(u)) {
                        var T = u;
                        u = r(T, "key"),
                        m = new o(h,{
                            key: u,
                            url: r(T, "textureURL"),
                            extension: r(T, "textureExtension", "png"),
                            normalMap: r(T, "normalMap"),
                            xhrSettings: r(T, "textureXhrSettings")
                        }),
                        x = new s(h,{
                            key: u,
                            url: r(T, "atlasURL"),
                            extension: r(T, "atlasExtension", "txt"),
                            xhrSettings: r(T, "atlasXhrSettings")
                        })
                    } else
                        m = new o(h,u,d,p),
                        x = new s(h,u,v,g);
                    m.linkFile ? n.call(this, h, "unityatlas", u, [m, x, m.linkFile]) : n.call(this, h, "unityatlas", u, [m, x])
                },
                addToCache: function() {
                    if (this.isReadyToProcess()) {
                        var i = this.files[0]
                          , h = this.files[1]
                          , u = this.files[2] ? this.files[2].data : null;
                        this.loader.textureManager.addUnityAtlas(i.key, i.data, h.data, u),
                        h.pendingDestroy(),
                        this.complete = !0
                    }
                }
            });
            f.register("unityAtlas", function(i, h, u, d, v) {
                var p;
                if (Array.isArray(i))
                    for (var g = 0; g < i.length; g++)
                        p = new l(this,i[g]),
                        this.addFile(p.files);
                else
                    p = new l(this,i,h,u,d,v),
                    this.addFile(p.files);
                return this
            }),
            c.exports = l
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(21)
              , r = t(23)
              , o = t(8)
              , a = t(155)
              , n = t(2)
              , s = t(7)
              , l = new e({
                Extends: r,
                initialize: function(h, u, d, v, p, g, m) {
                    v === void 0 && (v = "loadeddata"),
                    p === void 0 && (p = !1),
                    g === void 0 && (g = !1),
                    v !== "loadeddata" && v !== "canplay" && v !== "canplaythrough" && (v = "loadeddata");
                    var x = {
                        type: "video",
                        cache: h.cacheManager.video,
                        extension: d.type,
                        responseType: "blob",
                        key: u,
                        url: d.url,
                        xhrSettings: m,
                        config: {
                            loadEvent: v,
                            asBlob: p,
                            noAudio: g
                        }
                    };
                    this.onLoadCallback = this.onVideoLoadHandler.bind(this),
                    this.onErrorCallback = this.onVideoErrorHandler.bind(this),
                    r.call(this, h, x)
                },
                onProcess: function() {
                    if (this.state = f.FILE_PROCESSING,
                    !this.config.asBlob) {
                        this.onProcessComplete();
                        return
                    }
                    var i = this.createVideoElement();
                    this.data = i;
                    var h = this;
                    this.data.onloadeddata = function() {
                        h.onProcessComplete()
                    }
                    ,
                    this.data.onerror = function() {
                        r.revokeObjectURL(h.data),
                        h.onProcessError()
                    }
                    ,
                    r.createObjectURL(i, this.xhrLoader.response, ""),
                    i.load()
                },
                createVideoElement: function() {
                    var i = document.createElement("video");
                    return i.controls = !1,
                    i.crossOrigin = this.loader.crossOrigin,
                    this.config.noAudio && (i.muted = !0,
                    i.defaultMuted = !0,
                    i.setAttribute("autoplay", "autoplay")),
                    i.setAttribute("playsinline", "playsinline"),
                    i.setAttribute("preload", "auto"),
                    i
                },
                onVideoLoadHandler: function(i) {
                    var h = i.target;
                    h.removeEventListener(this.config.loadEvent, this.onLoadCallback, !0),
                    h.removeEventListener("error", this.onErrorCallback, !0),
                    this.data = h,
                    this.resetXHR(),
                    this.loader.nextFile(this, !0)
                },
                onVideoErrorHandler: function(i) {
                    var h = i.target;
                    h && (h.removeEventListener(this.config.loadEvent, this.onLoadCallback, !0),
                    h.removeEventListener("error", this.onErrorCallback, !0)),
                    this.resetXHR(),
                    this.loader.nextFile(this, !1)
                },
                load: function() {
                    var i = this.config.loadEvent;
                    if (this.config.asBlob)
                        r.prototype.load.call(this);
                    else {
                        this.percentComplete = 0;
                        var h = this.createVideoElement();
                        h.addEventListener(i, this.onLoadCallback, !0),
                        h.addEventListener("error", this.onErrorCallback, !0),
                        h.src = a(this, this.loader.baseURL),
                        h.load()
                    }
                }
            });
            l.create = function(i, h, u, d, v, p, g) {
                var m = i.systems.game;
                s(h) && (u = n(h, "url", []),
                d = n(h, "loadEvent", "loadeddata"),
                v = n(h, "asBlob", !1),
                p = n(h, "noAudio", !1),
                g = n(h, "xhrSettings"),
                h = n(h, "key"));
                var x = l.getVideoURL(m, u);
                if (x)
                    return new l(i,h,x,d,v,p,g)
            }
            ,
            l.getVideoURL = function(i, h) {
                Array.isArray(h) || (h = [h]);
                for (var u = 0; u < h.length; u++) {
                    var d = n(h[u], "url", h[u]);
                    if (d.indexOf("blob:") === 0)
                        return {
                            url: d,
                            type: ""
                        };
                    var v;
                    if (d.indexOf("data:") === 0 ? v = d.split(",")[0].match(/\/(.*?);/) : v = d.match(/\.([a-zA-Z0-9]+)($|\?)/),
                    v = n(h[u], "type", v ? v[1] : "").toLowerCase(),
                    i.device.video[v])
                        return {
                            url: d,
                            type: v
                        }
                }
                return null
            }
            ,
            o.register("video", function(i, h, u, d, v, p) {
                var g;
                if (Array.isArray(i))
                    for (var m = 0; m < i.length; m++)
                        g = l.create(this, i[m]),
                        g && this.addFile(g);
                else
                    g = l.create(this, i, h, u, d, v, p),
                    g && this.addFile(g);
                return this
            }),
            c.exports = l
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(21)
              , r = t(149)
              , o = t(9)
              , a = t(95)
              , n = t(8)
              , s = t(2)
              , l = t(24)
              , i = t(20)
              , h = t(156)
              , u = new e({
                Extends: o,
                initialize: function(v) {
                    o.call(this);
                    var p = v.sys.game.config
                      , g = v.sys.settings.loader;
                    this.scene = v,
                    this.systems = v.sys,
                    this.cacheManager = v.sys.cache,
                    this.textureManager = v.sys.textures,
                    this.sceneManager = v.sys.game.scene,
                    n.install(this),
                    this.prefix = "",
                    this.path = "",
                    this.baseURL = "",
                    this.setBaseURL(s(g, "baseURL", p.loaderBaseURL)),
                    this.setPath(s(g, "path", p.loaderPath)),
                    this.setPrefix(s(g, "prefix", p.loaderPrefix)),
                    this.maxParallelDownloads = s(g, "maxParallelDownloads", p.loaderMaxParallelDownloads),
                    this.xhr = h(s(g, "responseType", p.loaderResponseType), s(g, "async", p.loaderAsync), s(g, "user", p.loaderUser), s(g, "password", p.loaderPassword), s(g, "timeout", p.loaderTimeout), s(g, "withCredentials", p.loaderWithCredentials)),
                    this.crossOrigin = s(g, "crossOrigin", p.loaderCrossOrigin),
                    this.totalToLoad = 0,
                    this.progress = 0,
                    this.list = new r,
                    this.inflight = new r,
                    this.queue = new r,
                    this._deleteQueue = new r,
                    this.totalFailed = 0,
                    this.totalComplete = 0,
                    this.state = f.LOADER_IDLE,
                    this.multiKeyIndex = 0,
                    v.sys.events.once(i.BOOT, this.boot, this),
                    v.sys.events.on(i.START, this.pluginStart, this)
                },
                boot: function() {
                    this.systems.events.once(i.DESTROY, this.destroy, this)
                },
                pluginStart: function() {
                    this.systems.events.once(i.SHUTDOWN, this.shutdown, this)
                },
                setBaseURL: function(d) {
                    return d === void 0 && (d = ""),
                    d !== "" && d.substr(-1) !== "/" && (d = d.concat("/")),
                    this.baseURL = d,
                    this
                },
                setPath: function(d) {
                    return d === void 0 && (d = ""),
                    d !== "" && d.substr(-1) !== "/" && (d = d.concat("/")),
                    this.path = d,
                    this
                },
                setPrefix: function(d) {
                    return d === void 0 && (d = ""),
                    this.prefix = d,
                    this
                },
                setCORS: function(d) {
                    return this.crossOrigin = d,
                    this
                },
                addFile: function(d) {
                    Array.isArray(d) || (d = [d]);
                    for (var v = 0; v < d.length; v++) {
                        var p = d[v];
                        this.keyExists(p) || (this.list.set(p),
                        this.emit(a.ADD, p.key, p.type, this, p),
                        this.isLoading() && (this.totalToLoad++,
                        this.updateProgress()))
                    }
                },
                keyExists: function(d) {
                    var v = d.hasCacheConflict();
                    return v || this.list.iterate(function(p) {
                        if (p.type === d.type && p.key === d.key)
                            return v = !0,
                            !1
                    }),
                    !v && this.isLoading() && (this.inflight.iterate(function(p) {
                        if (p.type === d.type && p.key === d.key)
                            return v = !0,
                            !1
                    }),
                    this.queue.iterate(function(p) {
                        if (p.type === d.type && p.key === d.key)
                            return v = !0,
                            !1
                    })),
                    v
                },
                addPack: function(d, v) {
                    v && d.hasOwnProperty(v) && (d = {
                        packKey: d[v]
                    });
                    var p = 0
                      , g = this.baseURL
                      , m = this.path
                      , x = this.prefix;
                    for (var T in d)
                        if (Object.prototype.hasOwnProperty.call(d, T)) {
                            var E = d[T]
                              , P = s(E, "baseURL", g)
                              , M = s(E, "path", m)
                              , L = s(E, "prefix", x)
                              , R = s(E, "files", null)
                              , O = s(E, "defaultType", "void");
                            if (Array.isArray(R)) {
                                this.setBaseURL(P),
                                this.setPath(M),
                                this.setPrefix(L);
                                for (var F = 0; F < R.length; F++) {
                                    var B = R[F]
                                      , N = B.hasOwnProperty("type") ? B.type : O;
                                    this[N] && (this[N](B),
                                    p++)
                                }
                            }
                        }
                    return this.setBaseURL(g),
                    this.setPath(m),
                    this.setPrefix(x),
                    p > 0
                },
                isLoading: function() {
                    return this.state === f.LOADER_LOADING || this.state === f.LOADER_PROCESSING
                },
                isReady: function() {
                    return this.state === f.LOADER_IDLE || this.state === f.LOADER_COMPLETE
                },
                start: function() {
                    this.isReady() && (this.progress = 0,
                    this.totalFailed = 0,
                    this.totalComplete = 0,
                    this.totalToLoad = this.list.size,
                    this.emit(a.START, this),
                    this.list.size === 0 ? this.loadComplete() : (this.state = f.LOADER_LOADING,
                    this.inflight.clear(),
                    this.queue.clear(),
                    this.updateProgress(),
                    this.checkLoadQueue(),
                    this.systems.events.on(i.UPDATE, this.update, this)))
                },
                updateProgress: function() {
                    this.progress = 1 - (this.list.size + this.inflight.size) / this.totalToLoad,
                    this.emit(a.PROGRESS, this.progress)
                },
                update: function() {
                    this.state === f.LOADER_LOADING && this.list.size > 0 && this.inflight.size < this.maxParallelDownloads && this.checkLoadQueue()
                },
                checkLoadQueue: function() {
                    this.list.each(function(d) {
                        if ((d.state === f.FILE_POPULATED || d.state === f.FILE_PENDING && this.inflight.size < this.maxParallelDownloads) && (this.inflight.set(d),
                        this.list.delete(d),
                        d.crossOrigin || (d.crossOrigin = this.crossOrigin),
                        d.load()),
                        this.inflight.size === this.maxParallelDownloads)
                            return !1
                    }, this)
                },
                nextFile: function(d, v) {
                    this.inflight && (this.inflight.delete(d),
                    this.updateProgress(),
                    v ? (this.totalComplete++,
                    this.queue.set(d),
                    this.emit(a.FILE_LOAD, d),
                    d.onProcess()) : (this.totalFailed++,
                    this._deleteQueue.set(d),
                    this.emit(a.FILE_LOAD_ERROR, d),
                    this.fileProcessComplete(d)))
                },
                fileProcessComplete: function(d) {
                    !this.scene || !this.systems || !this.systems.game || this.systems.game.pendingDestroy || (d.state === f.FILE_ERRORED ? d.multiFile && d.multiFile.onFileFailed(d) : d.state === f.FILE_COMPLETE && (d.multiFile ? d.multiFile.isReadyToProcess() && d.multiFile.addToCache() : d.addToCache()),
                    this.queue.delete(d),
                    this.list.size === 0 && this.inflight.size === 0 && this.queue.size === 0 && this.loadComplete())
                },
                loadComplete: function() {
                    this.emit(a.POST_PROCESS, this),
                    this.list.clear(),
                    this.inflight.clear(),
                    this.queue.clear(),
                    this.progress = 1,
                    this.state = f.LOADER_COMPLETE,
                    this.systems.events.off(i.UPDATE, this.update, this),
                    this._deleteQueue.iterateLocal("destroy"),
                    this._deleteQueue.clear(),
                    this.emit(a.COMPLETE, this, this.totalComplete, this.totalFailed)
                },
                flagForRemoval: function(d) {
                    this._deleteQueue.set(d)
                },
                saveJSON: function(d, v) {
                    return this.save(JSON.stringify(d), v)
                },
                save: function(d, v, p) {
                    v === void 0 && (v = "file.json"),
                    p === void 0 && (p = "application/json");
                    var g = new Blob([d],{
                        type: p
                    })
                      , m = URL.createObjectURL(g)
                      , x = document.createElement("a");
                    return x.download = v,
                    x.textContent = "Download " + v,
                    x.href = m,
                    x.click(),
                    this
                },
                reset: function() {
                    this.list.clear(),
                    this.inflight.clear(),
                    this.queue.clear();
                    var d = this.systems.game.config
                      , v = this.systems.settings.loader;
                    this.setBaseURL(s(v, "baseURL", d.loaderBaseURL)),
                    this.setPath(s(v, "path", d.loaderPath)),
                    this.setPrefix(s(v, "prefix", d.loaderPrefix)),
                    this.state = f.LOADER_IDLE
                },
                shutdown: function() {
                    this.reset(),
                    this.state = f.LOADER_SHUTDOWN,
                    this.systems.events.off(i.UPDATE, this.update, this),
                    this.systems.events.off(i.SHUTDOWN, this.shutdown, this)
                },
                destroy: function() {
                    this.shutdown(),
                    this.state = f.LOADER_DESTROYED,
                    this.systems.events.off(i.UPDATE, this.update, this),
                    this.systems.events.off(i.START, this.pluginStart, this),
                    this.list = null,
                    this.inflight = null,
                    this.queue = null,
                    this.scene = null,
                    this.systems = null,
                    this.textureManager = null,
                    this.cacheManager = null,
                    this.sceneManager = null
                }
            });
            l.register("Loader", u, "load"),
            c.exports = u
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(62)
              , f = t(17)
              , r = {
                ArcadePhysics: t(1367),
                Body: t(527),
                Collider: t(528),
                Components: t(243),
                Events: t(245),
                Factory: t(521),
                GetOverlapX: t(246),
                GetOverlapY: t(247),
                SeparateX: t(537),
                SeparateY: t(538),
                Group: t(524),
                Image: t(522),
                Sprite: t(157),
                StaticBody: t(539),
                StaticGroup: t(525),
                Tilemap: t(1391),
                World: t(526)
            };
            r = f(!1, r, e),
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(36)
              , r = t(50)
              , o = t(353)
              , a = t(521)
              , n = t(2)
              , s = t(127)
              , l = t(523)
              , i = t(244)
              , h = t(24)
              , u = t(20)
              , d = t(3)
              , v = t(526)
              , p = new e({
                initialize: function(m) {
                    this.scene = m,
                    this.systems = m.sys,
                    this.config = this.getConfig(),
                    this.world,
                    this.add,
                    m.sys.events.once(u.BOOT, this.boot, this),
                    m.sys.events.on(u.START, this.start, this)
                },
                boot: function() {
                    this.world = new v(this.scene,this.config),
                    this.add = new a(this.world),
                    this.systems.events.once(u.DESTROY, this.destroy, this)
                },
                start: function() {
                    this.world || (this.world = new v(this.scene,this.config),
                    this.add = new a(this.world));
                    var g = this.systems.events;
                    n(this.config, "customUpdate", !1) || g.on(u.UPDATE, this.world.update, this.world),
                    g.on(u.POST_UPDATE, this.world.postUpdate, this.world),
                    g.once(u.SHUTDOWN, this.shutdown, this)
                },
                enableUpdate: function() {
                    this.systems.events.on(u.UPDATE, this.world.update, this.world)
                },
                disableUpdate: function() {
                    this.systems.events.off(u.UPDATE, this.world.update, this.world)
                },
                getConfig: function() {
                    var g = this.systems.game.config.physics
                      , m = this.systems.settings.physics
                      , x = s(n(m, "arcade", {}), n(g, "arcade", {}));
                    return x
                },
                overlap: function(g, m, x, T, E) {
                    return x === void 0 && (x = null),
                    T === void 0 && (T = null),
                    E === void 0 && (E = x),
                    this.world.collideObjects(g, m, x, T, E, !0)
                },
                collide: function(g, m, x, T, E) {
                    return x === void 0 && (x = null),
                    T === void 0 && (T = null),
                    E === void 0 && (E = x),
                    this.world.collideObjects(g, m, x, T, E, !1)
                },
                collideTiles: function(g, m, x, T, E) {
                    return this.world.collideTiles(g, m, x, T, E)
                },
                overlapTiles: function(g, m, x, T, E) {
                    return this.world.overlapTiles(g, m, x, T, E)
                },
                pause: function() {
                    return this.world.pause()
                },
                resume: function() {
                    return this.world.resume()
                },
                accelerateTo: function(g, m, x, T, E, P) {
                    T === void 0 && (T = 60);
                    var M = Math.atan2(x - g.y, m - g.x);
                    return g.body.acceleration.setToPolar(M, T),
                    E !== void 0 && P !== void 0 && g.body.maxVelocity.set(E, P),
                    M
                },
                accelerateToObject: function(g, m, x, T, E) {
                    return this.accelerateTo(g, m.x, m.y, x, T, E)
                },
                closest: function(g, m) {
                    m || (m = this.world.bodies.entries);
                    for (var x = Number.MAX_VALUE, T = null, E = g.x, P = g.y, M = m.length, L = 0; L < M; L++) {
                        var R = m[L]
                          , O = R.body || R;
                        if (!(g === R || g === O || g === O.gameObject || g === O.center)) {
                            var F = o(E, P, O.center.x, O.center.y);
                            F < x && (T = R,
                            x = F)
                        }
                    }
                    return T
                },
                furthest: function(g, m) {
                    m || (m = this.world.bodies.entries);
                    for (var x = -1, T = null, E = g.x, P = g.y, M = m.length, L = 0; L < M; L++) {
                        var R = m[L]
                          , O = R.body || R;
                        if (!(g === R || g === O || g === O.gameObject || g === O.center)) {
                            var F = o(E, P, O.center.x, O.center.y);
                            F > x && (T = R,
                            x = F)
                        }
                    }
                    return T
                },
                moveTo: function(g, m, x, T, E) {
                    T === void 0 && (T = 60),
                    E === void 0 && (E = 0);
                    var P = Math.atan2(x - g.y, m - g.x);
                    return E > 0 && (T = r(g.x, g.y, m, x) / (E / 1e3)),
                    g.body.velocity.setToPolar(P, T),
                    P
                },
                moveToObject: function(g, m, x, T) {
                    return this.moveTo(g, m.x, m.y, x, T)
                },
                velocityFromAngle: function(g, m, x) {
                    return m === void 0 && (m = 60),
                    x === void 0 && (x = new d),
                    x.setToPolar(f(g), m)
                },
                velocityFromRotation: function(g, m, x) {
                    return m === void 0 && (m = 60),
                    x === void 0 && (x = new d),
                    x.setToPolar(g, m)
                },
                overlapRect: function(g, m, x, T, E, P) {
                    return i(this.world, g, m, x, T, E, P)
                },
                overlapCirc: function(g, m, x, T, E) {
                    return l(this.world, g, m, x, T, E)
                },
                shutdown: function() {
                    if (this.world) {
                        var g = this.systems.events;
                        g.off(u.UPDATE, this.world.update, this.world),
                        g.off(u.POST_UPDATE, this.world.postUpdate, this.world),
                        g.off(u.SHUTDOWN, this.shutdown, this),
                        this.add.destroy(),
                        this.world.destroy(),
                        this.add = null,
                        this.world = null
                    }
                },
                destroy: function() {
                    this.shutdown(),
                    this.scene.sys.events.off(u.START, this.start, this),
                    this.scene = null,
                    this.systems = null
                }
            });
            h.register("ArcadePhysics", p, "arcadePhysics"),
            c.exports = p
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                setAcceleration: function(e, f) {
                    return this.body.acceleration.set(e, f),
                    this
                },
                setAccelerationX: function(e) {
                    return this.body.acceleration.x = e,
                    this
                },
                setAccelerationY: function(e) {
                    return this.body.acceleration.y = e,
                    this
                }
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                setAngularVelocity: function(e) {
                    return this.body.angularVelocity = e,
                    this
                },
                setAngularAcceleration: function(e) {
                    return this.body.angularAcceleration = e,
                    this
                },
                setAngularDrag: function(e) {
                    return this.body.angularDrag = e,
                    this
                }
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                setBounce: function(e, f) {
                    return this.body.bounce.set(e, f),
                    this
                },
                setBounceX: function(e) {
                    return this.body.bounce.x = e,
                    this
                },
                setBounceY: function(e) {
                    return this.body.bounce.y = e,
                    this
                },
                setCollideWorldBounds: function(e, f, r) {
                    return this.body.setCollideWorldBounds(e, f, r),
                    this
                }
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                setDebug: function(e, f, r) {
                    return this.debugShowBody = e,
                    this.debugShowVelocity = f,
                    this.debugBodyColor = r,
                    this
                },
                setDebugBodyColor: function(e) {
                    return this.body.debugBodyColor = e,
                    this
                },
                debugShowBody: {
                    get: function() {
                        return this.body.debugShowBody
                    },
                    set: function(e) {
                        this.body.debugShowBody = e
                    }
                },
                debugShowVelocity: {
                    get: function() {
                        return this.body.debugShowVelocity
                    },
                    set: function(e) {
                        this.body.debugShowVelocity = e
                    }
                },
                debugBodyColor: {
                    get: function() {
                        return this.body.debugBodyColor
                    },
                    set: function(e) {
                        this.body.debugBodyColor = e
                    }
                }
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                setDrag: function(e, f) {
                    return this.body.drag.set(e, f),
                    this
                },
                setDragX: function(e) {
                    return this.body.drag.x = e,
                    this
                },
                setDragY: function(e) {
                    return this.body.drag.y = e,
                    this
                },
                setDamping: function(e) {
                    return this.body.useDamping = e,
                    this
                }
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                enableBody: function(e, f, r, o, a) {
                    return e && this.body.reset(f, r),
                    o && (this.body.gameObject.active = !0),
                    a && (this.body.gameObject.visible = !0),
                    this.body.enable = !0,
                    this
                },
                disableBody: function(e, f) {
                    return e === void 0 && (e = !1),
                    f === void 0 && (f = !1),
                    this.body.stop(),
                    this.body.enable = !1,
                    e && (this.body.gameObject.active = !1),
                    f && (this.body.gameObject.visible = !1),
                    this
                },
                refreshBody: function() {
                    return this.body.updateFromGameObject(),
                    this
                }
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                setFriction: function(e, f) {
                    return this.body.friction.set(e, f),
                    this
                },
                setFrictionX: function(e) {
                    return this.body.friction.x = e,
                    this
                },
                setFrictionY: function(e) {
                    return this.body.friction.y = e,
                    this
                }
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                setGravity: function(e, f) {
                    return this.body.gravity.set(e, f),
                    this
                },
                setGravityX: function(e) {
                    return this.body.gravity.x = e,
                    this
                },
                setGravityY: function(e) {
                    return this.body.gravity.y = e,
                    this
                }
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                setImmovable: function(e) {
                    return e === void 0 && (e = !0),
                    this.body.immovable = e,
                    this
                }
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                setMass: function(e) {
                    return this.body.mass = e,
                    this
                }
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                setPushable: function(e) {
                    return e === void 0 && (e = !0),
                    this.body.pushable = e,
                    this
                }
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                setOffset: function(e, f) {
                    return this.body.setOffset(e, f),
                    this
                },
                setSize: function(e, f, r) {
                    return this.body.setSize(e, f, r),
                    this
                },
                setBodySize: function(e, f, r) {
                    return this.body.setSize(e, f, r),
                    this
                },
                setCircle: function(e, f, r) {
                    return this.body.setCircle(e, f, r),
                    this
                }
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                setVelocity: function(e, f) {
                    return this.body.setVelocity(e, f),
                    this
                },
                setVelocityX: function(e) {
                    return this.body.setVelocityX(e),
                    this
                },
                setVelocityY: function(e) {
                    return this.body.setVelocityY(e),
                    this
                },
                setMaxVelocity: function(e, f) {
                    return this.body.maxVelocity.set(e, f),
                    this
                }
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "collide"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "overlap"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pause"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "resume"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "tilecollide"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "tileoverlap"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "worldbounds"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "worldstep"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t, e, f, r, o, a, n, s, l, i, h, u, d, v, p, g, m, x = function(R, O, F) {
                t = R,
                e = O;
                var B = t.velocity.x
                  , N = e.velocity.x;
                return f = t.pushable,
                l = t._dx < 0,
                i = t._dx > 0,
                h = t._dx === 0,
                p = Math.abs(t.right - e.x) <= Math.abs(e.right - t.x),
                n = N - B * t.bounce.x,
                r = e.pushable,
                u = e._dx < 0,
                d = e._dx > 0,
                v = e._dx === 0,
                g = !p,
                s = B - N * e.bounce.x,
                m = Math.abs(F),
                T()
            }, T = function() {
                return i && p && e.blocked.right ? (t.processX(-m, n, !1, !0),
                1) : l && g && e.blocked.left ? (t.processX(m, n, !0),
                1) : d && g && t.blocked.right ? (e.processX(-m, s, !1, !0),
                2) : u && p && t.blocked.left ? (e.processX(m, s, !0),
                2) : 0
            }, E = function() {
                var R = t.velocity.x
                  , O = e.velocity.x
                  , F = Math.sqrt(O * O * e.mass / t.mass) * (O > 0 ? 1 : -1)
                  , B = Math.sqrt(R * R * t.mass / e.mass) * (R > 0 ? 1 : -1)
                  , N = (F + B) * .5;
                return F -= N,
                B -= N,
                o = N + F * t.bounce.x,
                a = N + B * e.bounce.x,
                l && g ? P(0) : u && p ? P(1) : i && p ? P(2) : d && g ? P(3) : !1
            }, P = function(R) {
                if (f && r)
                    m *= .5,
                    R === 0 || R === 3 ? (t.processX(m, o),
                    e.processX(-m, a)) : (t.processX(-m, o),
                    e.processX(m, a));
                else if (f && !r)
                    R === 0 || R === 3 ? t.processX(m, n, !0) : t.processX(-m, n, !1, !0);
                else if (!f && r)
                    R === 0 || R === 3 ? e.processX(-m, s, !1, !0) : e.processX(m, s, !0);
                else {
                    var O = m * .5;
                    R === 0 ? v ? (t.processX(m, 0, !0),
                    e.processX(0, null, !1, !0)) : d ? (t.processX(O, 0, !0),
                    e.processX(-O, 0, !1, !0)) : (t.processX(O, e.velocity.x, !0),
                    e.processX(-O, null, !1, !0)) : R === 1 ? h ? (t.processX(0, null, !1, !0),
                    e.processX(m, 0, !0)) : i ? (t.processX(-O, 0, !1, !0),
                    e.processX(O, 0, !0)) : (t.processX(-O, null, !1, !0),
                    e.processX(O, t.velocity.x, !0)) : R === 2 ? v ? (t.processX(-m, 0, !1, !0),
                    e.processX(0, null, !0)) : u ? (t.processX(-O, 0, !1, !0),
                    e.processX(O, 0, !0)) : (t.processX(-O, e.velocity.x, !1, !0),
                    e.processX(O, null, !0)) : R === 3 && (h ? (t.processX(0, null, !0),
                    e.processX(-m, 0, !1, !0)) : l ? (t.processX(O, 0, !0),
                    e.processX(-O, 0, !1, !0)) : (t.processX(O, e.velocity.y, !0),
                    e.processX(-O, null, !1, !0)))
                }
                return !0
            }, M = function(R) {
                R === 1 ? e.velocity.x = 0 : p ? e.processX(m, s, !0) : e.processX(-m, s, !1, !0),
                t.moves && (e.y += (t.y - t.prev.y) * t.friction.y,
                e._dy = e.y - e.prev.y)
            }, L = function(R) {
                R === 2 ? t.velocity.x = 0 : g ? t.processX(m, n, !0) : t.processX(-m, n, !1, !0),
                e.moves && (t.y += (e.y - e.prev.y) * e.friction.y,
                t._dy = t.y - t.prev.y)
            };
            c.exports = {
                BlockCheck: T,
                Check: E,
                Set: x,
                Run: P,
                RunImmovableBody1: M,
                RunImmovableBody2: L
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t, e, f, r, o, a, n, s, l, i, h, u, d, v, p, g, m, x = function(R, O, F) {
                t = R,
                e = O;
                var B = t.velocity.y
                  , N = e.velocity.y;
                return f = t.pushable,
                l = t._dy < 0,
                i = t._dy > 0,
                h = t._dy === 0,
                p = Math.abs(t.bottom - e.y) <= Math.abs(e.bottom - t.y),
                n = N - B * t.bounce.y,
                r = e.pushable,
                u = e._dy < 0,
                d = e._dy > 0,
                v = e._dy === 0,
                g = !p,
                s = B - N * e.bounce.y,
                m = Math.abs(F),
                T()
            }, T = function() {
                return i && p && e.blocked.down ? (t.processY(-m, n, !1, !0),
                1) : l && g && e.blocked.up ? (t.processY(m, n, !0),
                1) : d && g && t.blocked.down ? (e.processY(-m, s, !1, !0),
                2) : u && p && t.blocked.up ? (e.processY(m, s, !0),
                2) : 0
            }, E = function() {
                var R = t.velocity.y
                  , O = e.velocity.y
                  , F = Math.sqrt(O * O * e.mass / t.mass) * (O > 0 ? 1 : -1)
                  , B = Math.sqrt(R * R * t.mass / e.mass) * (R > 0 ? 1 : -1)
                  , N = (F + B) * .5;
                return F -= N,
                B -= N,
                o = N + F * t.bounce.y,
                a = N + B * e.bounce.y,
                l && g ? P(0) : u && p ? P(1) : i && p ? P(2) : d && g ? P(3) : !1
            }, P = function(R) {
                if (f && r)
                    m *= .5,
                    R === 0 || R === 3 ? (t.processY(m, o),
                    e.processY(-m, a)) : (t.processY(-m, o),
                    e.processY(m, a));
                else if (f && !r)
                    R === 0 || R === 3 ? t.processY(m, n, !0) : t.processY(-m, n, !1, !0);
                else if (!f && r)
                    R === 0 || R === 3 ? e.processY(-m, s, !1, !0) : e.processY(m, s, !0);
                else {
                    var O = m * .5;
                    R === 0 ? v ? (t.processY(m, 0, !0),
                    e.processY(0, null, !1, !0)) : d ? (t.processY(O, 0, !0),
                    e.processY(-O, 0, !1, !0)) : (t.processY(O, e.velocity.y, !0),
                    e.processY(-O, null, !1, !0)) : R === 1 ? h ? (t.processY(0, null, !1, !0),
                    e.processY(m, 0, !0)) : i ? (t.processY(-O, 0, !1, !0),
                    e.processY(O, 0, !0)) : (t.processY(-O, null, !1, !0),
                    e.processY(O, t.velocity.y, !0)) : R === 2 ? v ? (t.processY(-m, 0, !1, !0),
                    e.processY(0, null, !0)) : u ? (t.processY(-O, 0, !1, !0),
                    e.processY(O, 0, !0)) : (t.processY(-O, e.velocity.y, !1, !0),
                    e.processY(O, null, !0)) : R === 3 && (h ? (t.processY(0, null, !0),
                    e.processY(-m, 0, !1, !0)) : l ? (t.processY(O, 0, !0),
                    e.processY(-O, 0, !1, !0)) : (t.processY(O, e.velocity.y, !0),
                    e.processY(-O, null, !1, !0)))
                }
                return !0
            }, M = function(R) {
                R === 1 ? e.velocity.y = 0 : p ? e.processY(m, s, !0) : e.processY(-m, s, !1, !0),
                t.moves && (e.x += (t.x - t.prev.x) * t.friction.x,
                e._dx = e.x - e.prev.x)
            }, L = function(R) {
                R === 2 ? t.velocity.y = 0 : g ? t.processY(m, n, !0) : t.processY(-m, n, !1, !0),
                e.moves && (t.x += (e.x - e.prev.x) * e.friction.x,
                t._dx = t.x - t.prev.x)
            };
            c.exports = {
                BlockCheck: T,
                Check: E,
                Set: x,
                Run: P,
                RunImmovableBody1: M,
                RunImmovableBody2: L
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = {
                ProcessTileCallbacks: t(530),
                ProcessTileSeparationX: t(534),
                ProcessTileSeparationY: t(536),
                SeparateTile: t(532),
                TileCheckX: t(533),
                TileCheckY: t(535),
                TileIntersectsBody: t(248)
            };
            c.exports = e
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(3)
              , r = new e({
                initialize: function() {
                    this.boundsCenter = new f,
                    this.centerDiff = new f
                },
                parseBody: function(o) {
                    if (o = o.hasOwnProperty("body") ? o.body : o,
                    !o.hasOwnProperty("bounds") || !o.hasOwnProperty("centerOfMass"))
                        return !1;
                    var a = this.boundsCenter
                      , n = this.centerDiff
                      , s = o.bounds.max.x - o.bounds.min.x
                      , l = o.bounds.max.y - o.bounds.min.y
                      , i = s * o.centerOfMass.x
                      , h = l * o.centerOfMass.y;
                    return a.set(s / 2, l / 2),
                    n.set(i - a.x, h - a.y),
                    !0
                },
                getTopLeft: function(o, a, n) {
                    if (a === void 0 && (a = 0),
                    n === void 0 && (n = 0),
                    this.parseBody(o)) {
                        var s = this.boundsCenter
                          , l = this.centerDiff;
                        return new f(a + s.x + l.x,n + s.y + l.y)
                    }
                    return !1
                },
                getTopCenter: function(o, a, n) {
                    if (a === void 0 && (a = 0),
                    n === void 0 && (n = 0),
                    this.parseBody(o)) {
                        var s = this.boundsCenter
                          , l = this.centerDiff;
                        return new f(a + l.x,n + s.y + l.y)
                    }
                    return !1
                },
                getTopRight: function(o, a, n) {
                    if (a === void 0 && (a = 0),
                    n === void 0 && (n = 0),
                    this.parseBody(o)) {
                        var s = this.boundsCenter
                          , l = this.centerDiff;
                        return new f(a - (s.x - l.x),n + s.y + l.y)
                    }
                    return !1
                },
                getLeftCenter: function(o, a, n) {
                    if (a === void 0 && (a = 0),
                    n === void 0 && (n = 0),
                    this.parseBody(o)) {
                        var s = this.boundsCenter
                          , l = this.centerDiff;
                        return new f(a + s.x + l.x,n + l.y)
                    }
                    return !1
                },
                getCenter: function(o, a, n) {
                    if (a === void 0 && (a = 0),
                    n === void 0 && (n = 0),
                    this.parseBody(o)) {
                        var s = this.centerDiff;
                        return new f(a + s.x,n + s.y)
                    }
                    return !1
                },
                getRightCenter: function(o, a, n) {
                    if (a === void 0 && (a = 0),
                    n === void 0 && (n = 0),
                    this.parseBody(o)) {
                        var s = this.boundsCenter
                          , l = this.centerDiff;
                        return new f(a - (s.x - l.x),n + l.y)
                    }
                    return !1
                },
                getBottomLeft: function(o, a, n) {
                    if (a === void 0 && (a = 0),
                    n === void 0 && (n = 0),
                    this.parseBody(o)) {
                        var s = this.boundsCenter
                          , l = this.centerDiff;
                        return new f(a + s.x + l.x,n - (s.y - l.y))
                    }
                    return !1
                },
                getBottomCenter: function(o, a, n) {
                    if (a === void 0 && (a = 0),
                    n === void 0 && (n = 0),
                    this.parseBody(o)) {
                        var s = this.boundsCenter
                          , l = this.centerDiff;
                        return new f(a + l.x,n - (s.y - l.y))
                    }
                    return !1
                },
                getBottomRight: function(o, a, n) {
                    if (a === void 0 && (a = 0),
                    n === void 0 && (n = 0),
                    this.parseBody(o)) {
                        var s = this.boundsCenter
                          , l = this.centerDiff;
                        return new f(a - (s.x - l.x),n - (s.y - l.y))
                    }
                    return !1
                }
            });
            c.exports = r
        }
        , function(c, S) {
            /**
 * @author       Stefan Hedman <schteppe@gmail.com> (http://steffe.se)
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                decomp: R,
                quickDecomp: N,
                isSimple: F,
                removeCollinearPoints: Y,
                removeDuplicatePoints: z,
                makeCCW: p
            };
            function t(D, I, G) {
                G = G || 0;
                var w = [0, 0], U, X, V, H, J, $, _;
                return U = D[1][1] - D[0][1],
                X = D[0][0] - D[1][0],
                V = U * D[0][0] + X * D[0][1],
                H = I[1][1] - I[0][1],
                J = I[0][0] - I[1][0],
                $ = H * I[0][0] + J * I[0][1],
                _ = U * J - H * X,
                W(_, 0, G) || (w[0] = (J * V - X * $) / _,
                w[1] = (U * $ - H * V) / _),
                w
            }
            function e(D, I, G, w) {
                var U = I[0] - D[0]
                  , X = I[1] - D[1]
                  , V = w[0] - G[0]
                  , H = w[1] - G[1];
                if (V * X - H * U === 0)
                    return !1;
                var J = (U * (G[1] - D[1]) + X * (D[0] - G[0])) / (V * X - H * U)
                  , $ = (V * (D[1] - G[1]) + H * (G[0] - D[0])) / (H * U - V * X);
                return J >= 0 && J <= 1 && $ >= 0 && $ <= 1
            }
            function f(D, I, G) {
                return (I[0] - D[0]) * (G[1] - D[1]) - (G[0] - D[0]) * (I[1] - D[1])
            }
            function r(D, I, G) {
                return f(D, I, G) > 0
            }
            function o(D, I, G) {
                return f(D, I, G) >= 0
            }
            function a(D, I, G) {
                return f(D, I, G) < 0
            }
            function n(D, I, G) {
                return f(D, I, G) <= 0
            }
            var s = []
              , l = [];
            function i(D, I, G, w) {
                if (w) {
                    var U = s
                      , X = l;
                    U[0] = I[0] - D[0],
                    U[1] = I[1] - D[1],
                    X[0] = G[0] - I[0],
                    X[1] = G[1] - I[1];
                    var V = U[0] * X[0] + U[1] * X[1]
                      , H = Math.sqrt(U[0] * U[0] + U[1] * U[1])
                      , J = Math.sqrt(X[0] * X[0] + X[1] * X[1])
                      , $ = Math.acos(V / (H * J));
                    return $ < w
                } else
                    return f(D, I, G) === 0
            }
            function h(D, I) {
                var G = I[0] - D[0]
                  , w = I[1] - D[1];
                return G * G + w * w
            }
            function u(D, I) {
                var G = D.length;
                return D[I < 0 ? I % G + G : I % G]
            }
            function d(D) {
                D.length = 0
            }
            function v(D, I, G, w) {
                for (var U = G; U < w; U++)
                    D.push(I[U])
            }
            function p(D) {
                for (var I = 0, G = D, w = 1; w < D.length; ++w)
                    (G[w][1] < G[I][1] || G[w][1] === G[I][1] && G[w][0] > G[I][0]) && (I = w);
                return r(u(D, I - 1), u(D, I), u(D, I + 1)) ? !1 : (g(D),
                !0)
            }
            function g(D) {
                for (var I = [], G = D.length, w = 0; w !== G; w++)
                    I.push(D.pop());
                for (var w = 0; w !== G; w++)
                    D[w] = I[w]
            }
            function m(D, I) {
                return a(u(D, I - 1), u(D, I), u(D, I + 1))
            }
            var x = []
              , T = [];
            function E(D, I, G) {
                var w, U, X = x, V = T;
                if (o(u(D, I + 1), u(D, I), u(D, G)) && n(u(D, I - 1), u(D, I), u(D, G)))
                    return !1;
                U = h(u(D, I), u(D, G));
                for (var H = 0; H !== D.length; ++H)
                    if (!((H + 1) % D.length === I || H === I) && o(u(D, I), u(D, G), u(D, H + 1)) && n(u(D, I), u(D, G), u(D, H)) && (X[0] = u(D, I),
                    X[1] = u(D, G),
                    V[0] = u(D, H),
                    V[1] = u(D, H + 1),
                    w = t(X, V),
                    h(u(D, I), w) < U))
                        return !1;
                return !0
            }
            function P(D, I, G) {
                for (var w = 0; w !== D.length; ++w)
                    if (!(w === I || w === G || (w + 1) % D.length === I || (w + 1) % D.length === G) && e(u(D, I), u(D, G), u(D, w), u(D, w + 1)))
                        return !1;
                return !0
            }
            function M(D, I, G, w) {
                var U = w || [];
                if (d(U),
                I < G)
                    for (var X = I; X <= G; X++)
                        U.push(D[X]);
                else {
                    for (var X = 0; X <= G; X++)
                        U.push(D[X]);
                    for (var X = I; X < D.length; X++)
                        U.push(D[X])
                }
                return U
            }
            function L(D) {
                for (var I = [], G = [], w = [], U = [], X = Number.MAX_VALUE, V = 0; V < D.length; ++V)
                    if (m(D, V)) {
                        for (var H = 0; H < D.length; ++H)
                            if (E(D, V, H)) {
                                G = L(M(D, V, H, U)),
                                w = L(M(D, H, V, U));
                                for (var J = 0; J < w.length; J++)
                                    G.push(w[J]);
                                G.length < X && (I = G,
                                X = G.length,
                                I.push([u(D, V), u(D, H)]))
                            }
                    }
                return I
            }
            function R(D) {
                var I = L(D);
                return I.length > 0 ? O(D, I) : [D]
            }
            function O(D, I) {
                if (I.length === 0)
                    return [D];
                if (I instanceof Array && I.length && I[0]instanceof Array && I[0].length === 2 && I[0][0]instanceof Array) {
                    for (var G = [D], w = 0; w < I.length; w++)
                        for (var U = I[w], X = 0; X < G.length; X++) {
                            var V = G[X]
                              , H = O(V, U);
                            if (H) {
                                G.splice(X, 1),
                                G.push(H[0], H[1]);
                                break
                            }
                        }
                    return G
                } else {
                    var U = I
                      , w = D.indexOf(U[0])
                      , X = D.indexOf(U[1]);
                    return w !== -1 && X !== -1 ? [M(D, w, X), M(D, X, w)] : !1
                }
            }
            function F(D) {
                var I = D, G;
                for (G = 0; G < I.length - 1; G++)
                    for (var w = 0; w < G - 1; w++)
                        if (e(I[G], I[G + 1], I[w], I[w + 1]))
                            return !1;
                for (G = 1; G < I.length - 2; G++)
                    if (e(I[0], I[I.length - 1], I[G], I[G + 1]))
                        return !1;
                return !0
            }
            function B(D, I, G, w, U) {
                U = U || 0;
                var X = I[1] - D[1]
                  , V = D[0] - I[0]
                  , H = X * D[0] + V * D[1]
                  , J = w[1] - G[1]
                  , $ = G[0] - w[0]
                  , _ = J * G[0] + $ * G[1]
                  , nt = X * $ - J * V;
                return W(nt, 0, U) ? [0, 0] : [($ * H - V * _) / nt, (X * _ - J * H) / nt]
            }
            function N(D, I, G, w, U, X, V) {
                X = X || 100,
                V = V || 0,
                U = U || 25,
                I = typeof I < "u" ? I : [],
                G = G || [],
                w = w || [];
                var H = [0, 0]
                  , J = [0, 0]
                  , $ = [0, 0]
                  , _ = 0
                  , nt = 0
                  , K = 0
                  , Z = 0
                  , j = 0
                  , Q = 0
                  , tt = 0
                  , et = []
                  , it = []
                  , k = D
                  , st = D;
                if (st.length < 3)
                    return I;
                if (V++,
                V > X)
                    return console.warn("quickDecomp: max level (" + X + ") reached."),
                    I;
                for (var q = 0; q < D.length; ++q)
                    if (m(k, q)) {
                        G.push(k[q]),
                        _ = nt = Number.MAX_VALUE;
                        for (var rt = 0; rt < D.length; ++rt)
                            r(u(k, q - 1), u(k, q), u(k, rt)) && n(u(k, q - 1), u(k, q), u(k, rt - 1)) && ($ = B(u(k, q - 1), u(k, q), u(k, rt), u(k, rt - 1)),
                            a(u(k, q + 1), u(k, q), $) && (K = h(k[q], $),
                            K < nt && (nt = K,
                            J = $,
                            Q = rt))),
                            r(u(k, q + 1), u(k, q), u(k, rt + 1)) && n(u(k, q + 1), u(k, q), u(k, rt)) && ($ = B(u(k, q + 1), u(k, q), u(k, rt), u(k, rt + 1)),
                            r(u(k, q - 1), u(k, q), $) && (K = h(k[q], $),
                            K < _ && (_ = K,
                            H = $,
                            j = rt)));
                        if (Q === (j + 1) % D.length)
                            $[0] = (J[0] + H[0]) / 2,
                            $[1] = (J[1] + H[1]) / 2,
                            w.push($),
                            q < j ? (v(et, k, q, j + 1),
                            et.push($),
                            it.push($),
                            Q !== 0 && v(it, k, Q, k.length),
                            v(it, k, 0, q + 1)) : (q !== 0 && v(et, k, q, k.length),
                            v(et, k, 0, j + 1),
                            et.push($),
                            it.push($),
                            v(it, k, Q, q + 1));
                        else {
                            if (Q > j && (j += D.length),
                            Z = Number.MAX_VALUE,
                            j < Q)
                                return I;
                            for (var rt = Q; rt <= j; ++rt)
                                o(u(k, q - 1), u(k, q), u(k, rt)) && n(u(k, q + 1), u(k, q), u(k, rt)) && (K = h(u(k, q), u(k, rt)),
                                K < Z && P(k, q, rt) && (Z = K,
                                tt = rt % D.length));
                            q < tt ? (v(et, k, q, tt + 1),
                            tt !== 0 && v(it, k, tt, st.length),
                            v(it, k, 0, q + 1)) : (q !== 0 && v(et, k, q, st.length),
                            v(et, k, 0, tt + 1),
                            v(it, k, tt, q + 1))
                        }
                        return et.length < it.length ? (N(et, I, G, w, U, X, V),
                        N(it, I, G, w, U, X, V)) : (N(it, I, G, w, U, X, V),
                        N(et, I, G, w, U, X, V)),
                        I
                    }
                return I.push(D),
                I
            }
            function Y(D, I) {
                for (var G = 0, w = D.length - 1; D.length > 3 && w >= 0; --w)
                    i(u(D, w - 1), u(D, w), u(D, w + 1), I) && (D.splice(w % D.length, 1),
                    G++);
                return G
            }
            function z(D, I) {
                for (var G = D.length - 1; G >= 1; --G)
                    for (var w = D[G], U = G - 1; U >= 0; --U)
                        if (b(w, D[U], I)) {
                            D.splice(G, 1);
                            continue
                        }
            }
            function W(D, I, G) {
                return G = G || 0,
                Math.abs(D - I) <= G
            }
            function b(D, I, G) {
                return W(D[0], I[0], G) && W(D[1], I[1], G)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(86)
              , f = t(0)
              , r = t(591)
              , o = t(128)
              , a = t(592)
              , n = t(1395)
              , s = t(1396)
              , l = t(1397)
              , i = t(593)
              , h = t(589)
              , u = t(590)
              , d = t(1398)
              , v = t(64)
              , p = new f({
                initialize: function(m) {
                    this.world = m,
                    this.scene = m.scene,
                    this.sys = m.scene.sys
                },
                rectangle: function(g, m, x, T, E) {
                    var P = e.rectangle(g, m, x, T, E);
                    return this.world.add(P),
                    P
                },
                trapezoid: function(g, m, x, T, E, P) {
                    var M = e.trapezoid(g, m, x, T, E, P);
                    return this.world.add(M),
                    M
                },
                circle: function(g, m, x, T, E) {
                    var P = e.circle(g, m, x, T, E);
                    return this.world.add(P),
                    P
                },
                polygon: function(g, m, x, T, E) {
                    var P = e.polygon(g, m, x, T, E);
                    return this.world.add(P),
                    P
                },
                fromVertices: function(g, m, x, T, E, P, M) {
                    typeof x == "string" && (x = v.fromPath(x));
                    var L = e.fromVertices(g, m, x, T, E, P, M);
                    return this.world.add(L),
                    L
                },
                fromPhysicsEditor: function(g, m, x, T, E) {
                    E === void 0 && (E = !0);
                    var P = h.parseBody(g, m, x, T);
                    return E && !this.world.has(P) && this.world.add(P),
                    P
                },
                fromSVG: function(g, m, x, T, E, P) {
                    T === void 0 && (T = 1),
                    E === void 0 && (E = {}),
                    P === void 0 && (P = !0);
                    for (var M = x.getElementsByTagName("path"), L = [], R = 0; R < M.length; R++) {
                        var O = a.pathToVertices(M[R], 30);
                        T !== 1 && v.scale(O, T, T),
                        L.push(O)
                    }
                    var F = e.fromVertices(g, m, L, E);
                    return P && this.world.add(F),
                    F
                },
                fromJSON: function(g, m, x, T, E) {
                    T === void 0 && (T = {}),
                    E === void 0 && (E = !0);
                    var P = u.parseBody(g, m, x, T);
                    return P && E && this.world.add(P),
                    P
                },
                imageStack: function(g, m, x, T, E, P, M, L, R) {
                    M === void 0 && (M = 0),
                    L === void 0 && (L = 0),
                    R === void 0 && (R = {});
                    var O = this.world
                      , F = this.sys.displayList;
                    R.addToWorld = !1;
                    var B = r.stack(x, T, E, P, M, L, function(N, Y) {
                        var z = new s(O,N,Y,g,m,R);
                        return F.add(z),
                        z.body
                    });
                    return O.add(B),
                    B
                },
                stack: function(g, m, x, T, E, P, M) {
                    var L = r.stack(g, m, x, T, E, P, M);
                    return this.world.add(L),
                    L
                },
                pyramid: function(g, m, x, T, E, P, M) {
                    var L = r.pyramid(g, m, x, T, E, P, M);
                    return this.world.add(L),
                    L
                },
                chain: function(g, m, x, T, E, P) {
                    return r.chain(g, m, x, T, E, P)
                },
                mesh: function(g, m, x, T, E) {
                    return r.mesh(g, m, x, T, E)
                },
                newtonsCradle: function(g, m, x, T, E) {
                    var P = r.newtonsCradle(g, m, x, T, E);
                    return this.world.add(P),
                    P
                },
                car: function(g, m, x, T, E) {
                    var P = r.car(g, m, x, T, E);
                    return this.world.add(P),
                    P
                },
                softBody: function(g, m, x, T, E, P, M, L, R, O) {
                    var F = r.softBody(g, m, x, T, E, P, M, L, R, O);
                    return this.world.add(F),
                    F
                },
                joint: function(g, m, x, T, E) {
                    return this.constraint(g, m, x, T, E)
                },
                spring: function(g, m, x, T, E) {
                    return this.constraint(g, m, x, T, E)
                },
                constraint: function(g, m, x, T, E) {
                    T === void 0 && (T = 1),
                    E === void 0 && (E = {}),
                    E.bodyA = g.type === "body" ? g : g.body,
                    E.bodyB = m.type === "body" ? m : m.body,
                    isNaN(x) || (E.length = x),
                    E.stiffness = T;
                    var P = o.create(E);
                    return this.world.add(P),
                    P
                },
                worldConstraint: function(g, m, x, T) {
                    x === void 0 && (x = 1),
                    T === void 0 && (T = {}),
                    T.bodyB = g.type === "body" ? g : g.body,
                    isNaN(m) || (T.length = m),
                    T.stiffness = x;
                    var E = o.create(T);
                    return this.world.add(E),
                    E
                },
                mouseSpring: function(g) {
                    return this.pointerConstraint(g)
                },
                pointerConstraint: function(g) {
                    g === void 0 && (g = {}),
                    g.hasOwnProperty("render") || (g.render = {
                        visible: !1
                    });
                    var m = new d(this.scene,this.world,g);
                    return this.world.add(m.constraint),
                    m
                },
                image: function(g, m, x, T, E) {
                    var P = new s(this.world,g,m,x,T,E);
                    return this.sys.displayList.add(P),
                    P
                },
                tileBody: function(g, m) {
                    return new i(this.world,g,m)
                },
                sprite: function(g, m, x, T, E) {
                    var P = new l(this.world,g,m,x,T,E);
                    return this.sys.displayList.add(P),
                    this.sys.updateList.add(P),
                    P
                },
                gameObject: function(g, m, x) {
                    return n(this.world, g, m, x)
                },
                destroy: function() {
                    this.world = null,
                    this.scene = null,
                    this.sys = null
                }
            });
            c.exports = p
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(249)
              , f = t(2)
              , r = t(3);
            function o(n) {
                return !!n.get && typeof n.get == "function" || !!n.set && typeof n.set == "function"
            }
            var a = function(n, s, l, i) {
                l === void 0 && (l = {}),
                i === void 0 && (i = !0);
                var h = s.x
                  , u = s.y;
                s.body = {
                    temp: !0,
                    position: {
                        x: h,
                        y: u
                    }
                };
                var d = [e.Bounce, e.Collision, e.Force, e.Friction, e.Gravity, e.Mass, e.Sensor, e.SetBody, e.Sleep, e.Static, e.Transform, e.Velocity];
                if (d.forEach(function(p) {
                    for (var g in p)
                        o(p[g]) ? Object.defineProperty(s, g, {
                            get: p[g].get,
                            set: p[g].set
                        }) : Object.defineProperty(s, g, {
                            value: p[g]
                        })
                }),
                s.world = n,
                s._tempVec2 = new r(h,u),
                l.hasOwnProperty("type") && l.type === "body")
                    s.setExistingBody(l, i);
                else {
                    var v = f(l, "shape", null);
                    v || (v = "rectangle"),
                    l.addToWorld = i,
                    s.setBody(v, l)
                }
                return s
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(249)
              , r = t(15)
              , o = t(2)
              , a = t(125)
              , n = t(167)
              , s = t(3)
              , l = new e({
                Extends: a,
                Mixins: [f.Bounce, f.Collision, f.Force, f.Friction, f.Gravity, f.Mass, f.Sensor, f.SetBody, f.Sleep, f.Static, f.Transform, f.Velocity, n],
                initialize: function(h, u, d, v, p, g) {
                    r.call(this, h.scene, "Image"),
                    this._crop = this.resetCropObject(),
                    this.setTexture(v, p),
                    this.setSizeToFrame(),
                    this.setOrigin(),
                    this.world = h,
                    this._tempVec2 = new s(u,d);
                    var m = o(g, "shape", null);
                    m ? this.setBody(m, g) : this.setRectangle(this.width, this.height, g),
                    this.setPosition(u, d),
                    this.initPipeline()
                }
            });
            c.exports = l
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(164)
              , f = t(0)
              , r = t(249)
              , o = t(15)
              , a = t(2)
              , n = t(167)
              , s = t(73)
              , l = t(3)
              , i = new f({
                Extends: s,
                Mixins: [r.Bounce, r.Collision, r.Force, r.Friction, r.Gravity, r.Mass, r.Sensor, r.SetBody, r.Sleep, r.Static, r.Transform, r.Velocity, n],
                initialize: function(u, d, v, p, g, m) {
                    o.call(this, u.scene, "Sprite"),
                    this._crop = this.resetCropObject(),
                    this.anims = new e(this),
                    this.setTexture(p, g),
                    this.setSizeToFrame(),
                    this.setOrigin(),
                    this.world = u,
                    this._tempVec2 = new l(d,v);
                    var x = a(m, "shape", null);
                    x ? this.setBody(x, m) : this.setRectangle(this.width, this.height, m),
                    this.setPosition(d, v),
                    this.initPipeline()
                }
            });
            c.exports = i
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(84)
              , f = t(0)
              , r = t(118)
              , o = t(128)
              , a = t(273)
              , n = t(272)
              , s = t(51)
              , l = t(127)
              , i = t(165)
              , h = t(3)
              , u = t(64)
              , d = new f({
                initialize: function(p, g, m) {
                    m === void 0 && (m = {});
                    var x = {
                        label: "Pointer Constraint",
                        pointA: {
                            x: 0,
                            y: 0
                        },
                        pointB: {
                            x: 0,
                            y: 0
                        },
                        length: .01,
                        stiffness: .1,
                        angularStiffness: 1,
                        collisionFilter: {
                            category: 1,
                            mask: 4294967295,
                            group: 0
                        }
                    };
                    this.scene = p,
                    this.world = g,
                    this.camera = null,
                    this.pointer = null,
                    this.active = !0,
                    this.position = new h,
                    this.body = null,
                    this.part = null,
                    this.constraint = o.create(l(m, x)),
                    this.world.on(n.BEFORE_UPDATE, this.update, this),
                    p.sys.input.on(s.POINTER_DOWN, this.onDown, this),
                    p.sys.input.on(s.POINTER_UP, this.onUp, this)
                },
                onDown: function(v) {
                    this.pointer || (this.pointer = v,
                    this.camera = v.camera)
                },
                onUp: function(v) {
                    v === this.pointer && (this.pointer = null)
                },
                getBody: function(v) {
                    var p = this.position
                      , g = this.constraint;
                    this.camera.getWorldPoint(v.x, v.y, p);
                    for (var m = r.allBodies(this.world.localWorld), x = 0; x < m.length; x++) {
                        var T = m[x];
                        if (!T.ignorePointer && e.contains(T.bounds, p) && a.canCollide(T.collisionFilter, g.collisionFilter) && this.hitTestBody(T, p))
                            return this.world.emit(n.DRAG_START, T, this.part, this),
                            !0
                    }
                    return !1
                },
                hitTestBody: function(v, p) {
                    for (var g = this.constraint, m = v.parts.length, x = m > 1 ? 1 : 0, T = x; T < m; T++) {
                        var E = v.parts[T];
                        if (u.contains(E.vertices, p))
                            return g.pointA = p,
                            g.pointB = {
                                x: p.x - v.position.x,
                                y: p.y - v.position.y
                            },
                            g.bodyB = v,
                            g.angleB = v.angle,
                            i.set(v, !1),
                            this.part = E,
                            this.body = v,
                            !0
                    }
                    return !1
                },
                update: function() {
                    var v = this.pointer
                      , p = this.body;
                    if (!this.active || !v) {
                        p && this.stopDrag();
                        return
                    }
                    if (!v.isDown && p) {
                        this.stopDrag();
                        return
                    } else if (v.isDown) {
                        if (!p && !this.getBody(v))
                            return;
                        p = this.body;
                        var g = this.position
                          , m = this.constraint;
                        this.camera.getWorldPoint(v.x, v.y, g),
                        m.pointA.x = g.x,
                        m.pointA.y = g.y,
                        i.set(p, !1),
                        this.world.emit(n.DRAG, p, this)
                    }
                },
                stopDrag: function() {
                    var v = this.body
                      , p = this.constraint;
                    p.bodyB = null,
                    p.pointB = null,
                    this.pointer = null,
                    this.body = null,
                    this.part = null,
                    v && this.world.emit(n.DRAG_END, v, this)
                },
                destroy: function() {
                    this.world.removeConstraint(this.constraint),
                    this.pointer = null,
                    this.constraint = null,
                    this.body = null,
                    this.part = null,
                    this.world.off(n.BEFORE_UPDATE, this.update),
                    this.scene.sys.input.off(s.POINTER_DOWN, this.onDown, this),
                    this.scene.sys.input.off(s.POINTER_UP, this.onUp, this)
                }
            });
            c.exports = d
        }
        , function(c, S, t) {
            var e = {};
            c.exports = e;
            var f = t(595)
              , r = t(32);
            (function() {
                e.name = "matter-js",
                e.version = "0.14.2",
                e.uses = [],
                e.used = [],
                e.use = function() {
                    f.use(e, Array.prototype.slice.call(arguments))
                }
                ,
                e.before = function(o, a) {
                    return o = o.replace(/^Matter./, ""),
                    r.chainPathBefore(e, o, a)
                }
                ,
                e.after = function(o, a) {
                    return o = o.replace(/^Matter./, ""),
                    r.chainPathAfter(e, o, a)
                }
            }
            )()
        }
        , function(c, S, t) {
            var e = {};
            c.exports = e;
            var f = t(83)
              , r = t(274)
              , o = t(84)
              , a = t(86)
              , n = t(64);
            (function() {
                e.collides = function(s, l) {
                    for (var i = [], h = 0; h < l.length; h++) {
                        var u = l[h];
                        if (s !== u && o.overlaps(u.bounds, s.bounds))
                            for (var d = u.parts.length === 1 ? 0 : 1; d < u.parts.length; d++) {
                                var v = u.parts[d];
                                if (o.overlaps(v.bounds, s.bounds)) {
                                    var p = r.collides(v, s);
                                    if (p.collided) {
                                        i.push(p);
                                        break
                                    }
                                }
                            }
                    }
                    return i
                }
                ,
                e.ray = function(s, l, i, h) {
                    h = h || 1e-100;
                    for (var u = f.angle(l, i), d = f.magnitude(f.sub(l, i)), v = (i.x + l.x) * .5, p = (i.y + l.y) * .5, g = a.rectangle(v, p, d, h, {
                        angle: u
                    }), m = e.collides(g, s), x = 0; x < m.length; x += 1) {
                        var T = m[x];
                        T.body = T.bodyB = T.bodyA
                    }
                    return m
                }
                ,
                e.region = function(s, l, i) {
                    for (var h = [], u = 0; u < s.length; u++) {
                        var d = s[u]
                          , v = o.overlaps(d.bounds, l);
                        (v && !i || !v && i) && h.push(d)
                    }
                    return h
                }
                ,
                e.point = function(s, l) {
                    for (var i = [], h = 0; h < s.length; h++) {
                        var u = s[h];
                        if (o.contains(u.bounds, l))
                            for (var d = u.parts.length === 1 ? 0 : 1; d < u.parts.length; d++) {
                                var v = u.parts[d];
                                if (o.contains(v.bounds, l) && n.contains(v.vertices, l)) {
                                    i.push(u);
                                    break
                                }
                            }
                    }
                    return i
                }
            }
            )()
        }
        , function(c, S, t) {
            var e = {};
            c.exports = e;
            var f = t(596)
              , r = t(165)
              , o = t(599)
              , a = t(598)
              , n = t(1523)
              , s = t(597)
              , l = t(166)
              , i = t(118)
              , h = t(128)
              , u = t(32)
              , d = t(41);
            (function() {
                e.create = function(v, p) {
                    p = u.isElement(v) ? p : v,
                    v = u.isElement(v) ? v : null,
                    p = p || {},
                    (v || p.render) && u.warn("Engine.create: engine.render is deprecated (see docs)");
                    var g = {
                        positionIterations: 6,
                        velocityIterations: 4,
                        constraintIterations: 2,
                        enableSleeping: !1,
                        events: [],
                        plugin: {},
                        timing: {
                            timestamp: 0,
                            timeScale: 1
                        },
                        broadphase: {
                            controller: s
                        }
                    }
                      , m = u.extend(g, p);
                    return m.world = p.world || f.create(m.world),
                    m.pairs = a.create(),
                    m.broadphase = m.broadphase.controller.create(m.broadphase),
                    m.metrics = m.metrics || {
                        extended: !1
                    },
                    m.metrics = n.create(m.metrics),
                    m
                }
                ,
                e.update = function(v, p, g) {
                    p = p || 1e3 / 60,
                    g = g || 1;
                    var m = v.world, x = v.timing, T = v.broadphase, E = [], P;
                    x.timestamp += p * x.timeScale;
                    var M = {
                        timestamp: x.timestamp
                    };
                    l.trigger(v, "beforeUpdate", M);
                    var L = i.allBodies(m)
                      , R = i.allConstraints(m);
                    for (n.reset(v.metrics),
                    v.enableSleeping && r.update(L, x.timeScale),
                    e._bodiesApplyGravity(L, m.gravity),
                    e._bodiesUpdate(L, p, x.timeScale, g, m.bounds),
                    h.preSolveAll(L),
                    P = 0; P < v.constraintIterations; P++)
                        h.solveAll(R, x.timeScale);
                    h.postSolveAll(L),
                    T.controller ? (m.isModified && T.controller.clear(T),
                    T.controller.update(T, L, v, m.isModified),
                    E = T.pairsList) : E = L,
                    m.isModified && i.setModified(m, !1, !1, !0);
                    var O = T.detector(E, v)
                      , F = v.pairs
                      , B = x.timestamp;
                    for (a.update(F, O, B),
                    a.removeOld(F, B),
                    v.enableSleeping && r.afterCollisions(F.list, x.timeScale),
                    F.collisionStart.length > 0 && l.trigger(v, "collisionStart", {
                        pairs: F.collisionStart
                    }),
                    o.preSolvePosition(F.list),
                    P = 0; P < v.positionIterations; P++)
                        o.solvePosition(F.list, L, x.timeScale);
                    for (o.postSolvePosition(L),
                    h.preSolveAll(L),
                    P = 0; P < v.constraintIterations; P++)
                        h.solveAll(R, x.timeScale);
                    for (h.postSolveAll(L),
                    o.preSolveVelocity(F.list),
                    P = 0; P < v.velocityIterations; P++)
                        o.solveVelocity(F.list, x.timeScale);
                    return F.collisionActive.length > 0 && l.trigger(v, "collisionActive", {
                        pairs: F.collisionActive
                    }),
                    F.collisionEnd.length > 0 && l.trigger(v, "collisionEnd", {
                        pairs: F.collisionEnd
                    }),
                    n.update(v.metrics, v),
                    e._bodiesClearForces(L),
                    l.trigger(v, "afterUpdate", M),
                    v
                }
                ,
                e.merge = function(v, p) {
                    if (u.extend(v, p),
                    p.world) {
                        v.world = p.world,
                        e.clear(v);
                        for (var g = i.allBodies(v.world), m = 0; m < g.length; m++) {
                            var x = g[m];
                            r.set(x, !1),
                            x.id = u.nextId()
                        }
                    }
                }
                ,
                e.clear = function(v) {
                    var p = v.world;
                    a.clear(v.pairs);
                    var g = v.broadphase;
                    if (g.controller) {
                        var m = i.allBodies(p);
                        g.controller.clear(g),
                        g.controller.update(g, m, v, !0)
                    }
                }
                ,
                e._bodiesClearForces = function(v) {
                    for (var p = 0; p < v.length; p++) {
                        var g = v[p];
                        g.force.x = 0,
                        g.force.y = 0,
                        g.torque = 0
                    }
                }
                ,
                e._bodiesApplyGravity = function(v, p) {
                    var g = typeof p.scale < "u" ? p.scale : .001;
                    if (!(p.x === 0 && p.y === 0 || g === 0))
                        for (var m = 0; m < v.length; m++) {
                            var x = v[m];
                            x.ignoreGravity || x.isStatic || x.isSleeping || (x.force.x += x.mass * p.x * g * x.gravityScale.x,
                            x.force.y += x.mass * p.y * g * x.gravityScale.y)
                        }
                }
                ,
                e._bodiesUpdate = function(v, p, g, m, x) {
                    for (var T = 0; T < v.length; T++) {
                        var E = v[T];
                        E.isStatic || E.isSleeping || d.update(E, p, g, m)
                    }
                }
            }
            )()
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(86)
              , f = t(41)
              , r = t(0)
              , o = t(32)
              , a = t(118)
              , n = t(1401)
              , s = t(9)
              , l = t(272)
              , i = t(2)
              , h = t(6)
              , u = t(41)
              , d = t(166)
              , v = t(593)
              , p = t(596)
              , g = t(83)
              , m = new r({
                Extends: s,
                initialize: function(T, E) {
                    s.call(this),
                    this.scene = T,
                    this.engine = n.create(E),
                    this.localWorld = this.engine.world;
                    var P = h(E, "gravity", null);
                    P ? this.setGravity(P.x, P.y, P.scale) : P === !1 && this.setGravity(0, 0, 0),
                    this.walls = {
                        left: null,
                        right: null,
                        top: null,
                        bottom: null
                    },
                    this.enabled = h(E, "enabled", !0),
                    this.correction = h(E, "correction", 1),
                    this.getDelta = h(E, "getDelta", this.update60Hz);
                    var M = i(E, "runner", {})
                      , L = i(M, "fps", !1)
                      , R = i(M, "fps", 60)
                      , O = i(M, "delta", 1e3 / R)
                      , F = i(M, "deltaMin", 1e3 / R)
                      , B = i(M, "deltaMax", 1e3 / (R * .5));
                    L || (R = 1e3 / O),
                    this.runner = {
                        fps: R,
                        correction: i(M, "correction", 1),
                        deltaSampleSize: i(M, "deltaSampleSize", 60),
                        counterTimestamp: 0,
                        frameCounter: 0,
                        deltaHistory: [],
                        timePrev: null,
                        timeScalePrev: 1,
                        frameRequestId: null,
                        isFixed: i(M, "isFixed", !1),
                        delta: O,
                        deltaMin: F,
                        deltaMax: B
                    },
                    this.autoUpdate = h(E, "autoUpdate", !0);
                    var N = h(E, "debug", !1);
                    if (this.drawDebug = typeof N == "object" ? !0 : N,
                    this.debugGraphic,
                    this.debugConfig = {
                        showAxes: i(N, "showAxes", !1),
                        showAngleIndicator: i(N, "showAngleIndicator", !1),
                        angleColor: i(N, "angleColor", 15208787),
                        showBroadphase: i(N, "showBroadphase", !1),
                        broadphaseColor: i(N, "broadphaseColor", 16757760),
                        showBounds: i(N, "showBounds", !1),
                        boundsColor: i(N, "boundsColor", 16777215),
                        showVelocity: i(N, "showVelocity", !1),
                        velocityColor: i(N, "velocityColor", 44783),
                        showCollisions: i(N, "showCollisions", !1),
                        collisionColor: i(N, "collisionColor", 16094476),
                        showSeparations: i(N, "showSeparations", !1),
                        separationColor: i(N, "separationColor", 16753920),
                        showBody: i(N, "showBody", !0),
                        showStaticBody: i(N, "showStaticBody", !0),
                        showInternalEdges: i(N, "showInternalEdges", !1),
                        renderFill: i(N, "renderFill", !1),
                        renderLine: i(N, "renderLine", !0),
                        fillColor: i(N, "fillColor", 1075465),
                        fillOpacity: i(N, "fillOpacity", 1),
                        lineColor: i(N, "lineColor", 2678297),
                        lineOpacity: i(N, "lineOpacity", 1),
                        lineThickness: i(N, "lineThickness", 1),
                        staticFillColor: i(N, "staticFillColor", 857979),
                        staticLineColor: i(N, "staticLineColor", 1255396),
                        showSleeping: i(N, "showSleeping", !1),
                        staticBodySleepOpacity: i(N, "staticBodySleepOpacity", .7),
                        sleepFillColor: i(N, "sleepFillColor", 4605510),
                        sleepLineColor: i(N, "sleepLineColor", 10066585),
                        showSensors: i(N, "showSensors", !0),
                        sensorFillColor: i(N, "sensorFillColor", 857979),
                        sensorLineColor: i(N, "sensorLineColor", 1255396),
                        showPositions: i(N, "showPositions", !0),
                        positionSize: i(N, "positionSize", 4),
                        positionColor: i(N, "positionColor", 14697178),
                        showJoint: i(N, "showJoint", !0),
                        jointColor: i(N, "jointColor", 14737474),
                        jointLineOpacity: i(N, "jointLineOpacity", 1),
                        jointLineThickness: i(N, "jointLineThickness", 2),
                        pinSize: i(N, "pinSize", 4),
                        pinColor: i(N, "pinColor", 4382944),
                        springColor: i(N, "springColor", 14697184),
                        anchorColor: i(N, "anchorColor", 15724527),
                        anchorSize: i(N, "anchorSize", 4),
                        showConvexHulls: i(N, "showConvexHulls", !1),
                        hullColor: i(N, "hullColor", 14091216)
                    },
                    this.drawDebug && this.createDebugGraphic(),
                    this.setEventsProxy(),
                    i(E, "setBounds", !1)) {
                        var Y = E.setBounds;
                        if (typeof Y == "boolean")
                            this.setBounds();
                        else {
                            var z = i(Y, "x", 0)
                              , W = i(Y, "y", 0)
                              , b = i(Y, "width", T.sys.scale.width)
                              , D = i(Y, "height", T.sys.scale.height)
                              , I = i(Y, "thickness", 64)
                              , G = i(Y, "left", !0)
                              , w = i(Y, "right", !0)
                              , U = i(Y, "top", !0)
                              , X = i(Y, "bottom", !0);
                            this.setBounds(z, W, b, D, I, G, w, U, X)
                        }
                    }
                },
                setCompositeRenderStyle: function(x) {
                    var T = x.bodies, E = x.constraints, P = x.composites, M, L, R;
                    for (M = 0; M < T.length; M++)
                        L = T[M],
                        R = L.render,
                        this.setBodyRenderStyle(L, R.lineColor, R.lineOpacity, R.lineThickness, R.fillColor, R.fillOpacity);
                    for (M = 0; M < E.length; M++)
                        L = E[M],
                        R = L.render,
                        this.setConstraintRenderStyle(L, R.lineColor, R.lineOpacity, R.lineThickness, R.pinSize, R.anchorColor, R.anchorSize);
                    for (M = 0; M < P.length; M++)
                        L = P[M],
                        this.setCompositeRenderStyle(L);
                    return this
                },
                setBodyRenderStyle: function(x, T, E, P, M, L) {
                    var R = x.render
                      , O = this.debugConfig;
                    return R ? (T == null && (T = x.isStatic ? O.staticLineColor : O.lineColor),
                    E == null && (E = O.lineOpacity),
                    P == null && (P = O.lineThickness),
                    M == null && (M = x.isStatic ? O.staticFillColor : O.fillColor),
                    L == null && (L = O.fillOpacity),
                    T !== !1 && (R.lineColor = T),
                    E !== !1 && (R.lineOpacity = E),
                    P !== !1 && (R.lineThickness = P),
                    M !== !1 && (R.fillColor = M),
                    L !== !1 && (R.fillOpacity = L),
                    this) : this
                },
                setConstraintRenderStyle: function(x, T, E, P, M, L, R) {
                    var O = x.render
                      , F = this.debugConfig;
                    if (!O)
                        return this;
                    if (T == null) {
                        var B = O.type;
                        B === "line" ? T = F.jointColor : B === "pin" ? T = F.pinColor : B === "spring" && (T = F.springColor)
                    }
                    return E == null && (E = F.jointLineOpacity),
                    P == null && (P = F.jointLineThickness),
                    M == null && (M = F.pinSize),
                    L == null && (L = F.anchorColor),
                    R == null && (R = F.anchorSize),
                    T !== !1 && (O.lineColor = T),
                    E !== !1 && (O.lineOpacity = E),
                    P !== !1 && (O.lineThickness = P),
                    M !== !1 && (O.pinSize = M),
                    L !== !1 && (O.anchorColor = L),
                    R !== !1 && (O.anchorSize = R),
                    this
                },
                setEventsProxy: function() {
                    var x = this
                      , T = this.engine
                      , E = this.localWorld;
                    this.drawDebug && (d.on(E, "compositeModified", function(P) {
                        x.setCompositeRenderStyle(P)
                    }),
                    d.on(E, "beforeAdd", function(P) {
                        for (var M = [].concat(P.object), L = 0; L < M.length; L++) {
                            var R = M[L]
                              , O = R.render;
                            R.type === "body" ? x.setBodyRenderStyle(R, O.lineColor, O.lineOpacity, O.lineThickness, O.fillColor, O.fillOpacity) : R.type === "composite" ? x.setCompositeRenderStyle(R) : R.type === "constraint" && x.setConstraintRenderStyle(R, O.lineColor, O.lineOpacity, O.lineThickness, O.pinSize, O.anchorColor, O.anchorSize)
                        }
                    })),
                    d.on(E, "beforeAdd", function(P) {
                        x.emit(l.BEFORE_ADD, P)
                    }),
                    d.on(E, "afterAdd", function(P) {
                        x.emit(l.AFTER_ADD, P)
                    }),
                    d.on(E, "beforeRemove", function(P) {
                        x.emit(l.BEFORE_REMOVE, P)
                    }),
                    d.on(E, "afterRemove", function(P) {
                        x.emit(l.AFTER_REMOVE, P)
                    }),
                    d.on(T, "beforeUpdate", function(P) {
                        x.emit(l.BEFORE_UPDATE, P)
                    }),
                    d.on(T, "afterUpdate", function(P) {
                        x.emit(l.AFTER_UPDATE, P)
                    }),
                    d.on(T, "collisionStart", function(P) {
                        var M = P.pairs, L, R;
                        M.length > 0 && (L = M[0].bodyA,
                        R = M[0].bodyB),
                        x.emit(l.COLLISION_START, P, L, R)
                    }),
                    d.on(T, "collisionActive", function(P) {
                        var M = P.pairs, L, R;
                        M.length > 0 && (L = M[0].bodyA,
                        R = M[0].bodyB),
                        x.emit(l.COLLISION_ACTIVE, P, L, R)
                    }),
                    d.on(T, "collisionEnd", function(P) {
                        var M = P.pairs, L, R;
                        M.length > 0 && (L = M[0].bodyA,
                        R = M[0].bodyB),
                        x.emit(l.COLLISION_END, P, L, R)
                    })
                },
                setBounds: function(x, T, E, P, M, L, R, O, F) {
                    return x === void 0 && (x = 0),
                    T === void 0 && (T = 0),
                    E === void 0 && (E = this.scene.sys.scale.width),
                    P === void 0 && (P = this.scene.sys.scale.height),
                    M === void 0 && (M = 64),
                    L === void 0 && (L = !0),
                    R === void 0 && (R = !0),
                    O === void 0 && (O = !0),
                    F === void 0 && (F = !0),
                    this.updateWall(L, "left", x - M, T - M, M, P + M * 2),
                    this.updateWall(R, "right", x + E, T - M, M, P + M * 2),
                    this.updateWall(O, "top", x, T - M, E, M),
                    this.updateWall(F, "bottom", x, T + P, E, M),
                    this
                },
                updateWall: function(x, T, E, P, M, L) {
                    var R = this.walls[T];
                    x ? (R && p.remove(this.localWorld, R),
                    E += M / 2,
                    P += L / 2,
                    this.walls[T] = this.create(E, P, M, L, {
                        isStatic: !0,
                        friction: 0,
                        frictionStatic: 0
                    })) : (R && p.remove(this.localWorld, R),
                    this.walls[T] = null)
                },
                createDebugGraphic: function() {
                    var x = this.scene.sys.add.graphics({
                        x: 0,
                        y: 0
                    });
                    return x.setDepth(Number.MAX_VALUE),
                    this.debugGraphic = x,
                    this.drawDebug = !0,
                    x
                },
                disableGravity: function() {
                    return this.localWorld.gravity.x = 0,
                    this.localWorld.gravity.y = 0,
                    this.localWorld.gravity.scale = 0,
                    this
                },
                setGravity: function(x, T, E) {
                    return x === void 0 && (x = 0),
                    T === void 0 && (T = 1),
                    this.localWorld.gravity.x = x,
                    this.localWorld.gravity.y = T,
                    E !== void 0 && (this.localWorld.gravity.scale = E),
                    this
                },
                create: function(x, T, E, P, M) {
                    var L = e.rectangle(x, T, E, P, M);
                    return p.add(this.localWorld, L),
                    L
                },
                add: function(x) {
                    return p.add(this.localWorld, x),
                    this
                },
                remove: function(x, T) {
                    Array.isArray(x) || (x = [x]);
                    for (var E = 0; E < x.length; E++) {
                        var P = x[E]
                          , M = P.body ? P.body : P;
                        a.remove(this.localWorld, M, T)
                    }
                    return this
                },
                removeConstraint: function(x, T) {
                    return a.remove(this.localWorld, x, T),
                    this
                },
                convertTilemapLayer: function(x, T) {
                    var E = x.layer
                      , P = x.getTilesWithin(0, 0, E.width, E.height, {
                        isColliding: !0
                    });
                    return this.convertTiles(P, T),
                    this
                },
                convertTiles: function(x, T) {
                    if (x.length === 0)
                        return this;
                    for (var E = 0; E < x.length; E++)
                        new v(this,x[E],T);
                    return this
                },
                nextGroup: function(x) {
                    return u.nextGroup(x)
                },
                nextCategory: function() {
                    return u.nextCategory()
                },
                pause: function() {
                    return this.enabled = !1,
                    this.emit(l.PAUSE),
                    this
                },
                resume: function() {
                    return this.enabled = !0,
                    this.emit(l.RESUME),
                    this
                },
                update: function(x, T) {
                    if (!(!this.enabled || !this.autoUpdate)) {
                        var E = this.engine
                          , P = this.runner
                          , M = E.timing
                          , L = this.correction;
                        P.isFixed ? T = this.getDelta(x, T) : (T = x - P.timePrev || P.delta,
                        P.timePrev = x,
                        P.deltaHistory.push(T),
                        P.deltaHistory = P.deltaHistory.slice(-P.deltaSampleSize),
                        T = Math.min.apply(null, P.deltaHistory),
                        T = T < P.deltaMin ? P.deltaMin : T,
                        T = T > P.deltaMax ? P.deltaMax : T,
                        L = T / P.delta,
                        P.delta = T),
                        P.timeScalePrev !== 0 && (L *= M.timeScale / P.timeScalePrev),
                        M.timeScale === 0 && (L = 0),
                        P.timeScalePrev = M.timeScale,
                        P.correction = L,
                        P.frameCounter += 1,
                        x - P.counterTimestamp >= 1e3 && (P.fps = P.frameCounter * ((x - P.counterTimestamp) / 1e3),
                        P.counterTimestamp = x,
                        P.frameCounter = 0),
                        n.update(E, T, L)
                    }
                },
                step: function(x, T) {
                    n.update(this.engine, x, T)
                },
                update60Hz: function() {
                    return 1e3 / 60
                },
                update30Hz: function() {
                    return 1e3 / 30
                },
                has: function(x) {
                    var T = x.hasOwnProperty("body") ? x.body : x;
                    return a.get(this.localWorld, T.id, T.type) !== null
                },
                getAllBodies: function() {
                    return a.allBodies(this.localWorld)
                },
                getAllConstraints: function() {
                    return a.allConstraints(this.localWorld)
                },
                getAllComposites: function() {
                    return a.allComposites(this.localWorld)
                },
                postUpdate: function() {
                    if (this.drawDebug) {
                        var x = this.debugConfig
                          , T = this.engine
                          , E = this.debugGraphic
                          , P = a.allBodies(this.localWorld);
                        this.debugGraphic.clear(),
                        x.showBroadphase && T.broadphase.controller && this.renderGrid(T.broadphase, E, x.broadphaseColor, .5),
                        x.showBounds && this.renderBodyBounds(P, E, x.boundsColor, .5),
                        (x.showBody || x.showStaticBody) && this.renderBodies(P),
                        x.showJoint && this.renderJoints(),
                        (x.showAxes || x.showAngleIndicator) && this.renderBodyAxes(P, E, x.showAxes, x.angleColor, .5),
                        x.showVelocity && this.renderBodyVelocity(P, E, x.velocityColor, 1, 2),
                        x.showSeparations && this.renderSeparations(T.pairs.list, E, x.separationColor),
                        x.showCollisions && this.renderCollisions(T.pairs.list, E, x.collisionColor)
                    }
                },
                renderGrid: function(x, T, E, P) {
                    T.lineStyle(1, E, P);
                    for (var M = o.keys(x.buckets), L = 0; L < M.length; L++) {
                        var R = M[L];
                        if (!(x.buckets[R].length < 2)) {
                            var O = R.split(/C|R/);
                            T.strokeRect(parseInt(O[1], 10) * x.bucketWidth, parseInt(O[2], 10) * x.bucketHeight, x.bucketWidth, x.bucketHeight)
                        }
                    }
                    return this
                },
                renderSeparations: function(x, T, E) {
                    T.lineStyle(1, E, 1);
                    for (var P = 0; P < x.length; P++) {
                        var M = x[P];
                        if (M.isActive) {
                            var L = M.collision
                              , R = L.bodyA
                              , O = L.bodyB
                              , F = R.position
                              , B = O.position
                              , N = L.penetration
                              , Y = !R.isStatic && !O.isStatic ? 4 : 1;
                            O.isStatic && (Y = 0),
                            T.lineBetween(B.x, B.y, B.x - N.x * Y, B.y - N.y * Y),
                            Y = !R.isStatic && !O.isStatic ? 4 : 1,
                            R.isStatic && (Y = 0),
                            T.lineBetween(F.x, F.y, F.x - N.x * Y, F.y - N.y * Y)
                        }
                    }
                    return this
                },
                renderCollisions: function(x, T, E) {
                    T.lineStyle(1, E, .5),
                    T.fillStyle(E, 1);
                    var P, M;
                    for (P = 0; P < x.length; P++)
                        if (M = x[P],
                        !!M.isActive)
                            for (var L = 0; L < M.activeContacts.length; L++) {
                                var R = M.activeContacts[L]
                                  , O = R.vertex;
                                T.fillRect(O.x - 2, O.y - 2, 5, 5)
                            }
                    for (P = 0; P < x.length; P++)
                        if (M = x[P],
                        !!M.isActive) {
                            var F = M.collision
                              , B = M.activeContacts;
                            if (B.length > 0) {
                                var N = B[0].vertex.x
                                  , Y = B[0].vertex.y;
                                B.length === 2 && (N = (B[0].vertex.x + B[1].vertex.x) / 2,
                                Y = (B[0].vertex.y + B[1].vertex.y) / 2),
                                F.bodyB === F.supports[0].body || F.bodyA.isStatic ? T.lineBetween(N - F.normal.x * 8, Y - F.normal.y * 8, N, Y) : T.lineBetween(N + F.normal.x * 8, Y + F.normal.y * 8, N, Y)
                            }
                        }
                    return this
                },
                renderBodyBounds: function(x, T, E, P) {
                    T.lineStyle(1, E, P);
                    for (var M = 0; M < x.length; M++) {
                        var L = x[M];
                        if (L.render.visible) {
                            var R = L.bounds;
                            if (R)
                                T.strokeRect(R.min.x, R.min.y, R.max.x - R.min.x, R.max.y - R.min.y);
                            else
                                for (var O = L.parts, F = O.length > 1 ? 1 : 0; F < O.length; F++) {
                                    var B = O[F];
                                    T.strokeRect(B.bounds.min.x, B.bounds.min.y, B.bounds.max.x - B.bounds.min.x, B.bounds.max.y - B.bounds.min.y)
                                }
                        }
                    }
                    return this
                },
                renderBodyAxes: function(x, T, E, P, M) {
                    T.lineStyle(1, P, M);
                    for (var L = 0; L < x.length; L++) {
                        var R = x[L]
                          , O = R.parts;
                        if (R.render.visible) {
                            var F, B, N;
                            if (E)
                                for (B = O.length > 1 ? 1 : 0; B < O.length; B++)
                                    for (F = O[B],
                                    N = 0; N < F.axes.length; N++) {
                                        var Y = F.axes[N];
                                        T.lineBetween(F.position.x, F.position.y, F.position.x + Y.x * 20, F.position.y + Y.y * 20)
                                    }
                            else
                                for (B = O.length > 1 ? 1 : 0; B < O.length; B++)
                                    for (F = O[B],
                                    N = 0; N < F.axes.length; N++)
                                        T.lineBetween(F.position.x, F.position.y, (F.vertices[0].x + F.vertices[F.vertices.length - 1].x) / 2, (F.vertices[0].y + F.vertices[F.vertices.length - 1].y) / 2)
                        }
                    }
                    return this
                },
                renderBodyVelocity: function(x, T, E, P, M) {
                    T.lineStyle(M, E, P);
                    for (var L = 0; L < x.length; L++) {
                        var R = x[L];
                        R.render.visible && T.lineBetween(R.position.x, R.position.y, R.position.x + (R.position.x - R.positionPrev.x) * 2, R.position.y + (R.position.y - R.positionPrev.y) * 2)
                    }
                    return this
                },
                renderBodies: function(x) {
                    for (var T = this.debugGraphic, E = this.debugConfig, P = E.showBody, M = E.showStaticBody, L = E.showSleeping, R = E.showInternalEdges, O = E.showConvexHulls, F = E.renderFill, B = E.renderLine, N = E.staticBodySleepOpacity, Y = E.sleepFillColor, z = E.sleepLineColor, W = E.hullColor, b = 0; b < x.length; b++) {
                        var D = x[b];
                        if (D.render.visible && !(!M && D.isStatic || !P && !D.isStatic)) {
                            var I = D.render.lineColor
                              , G = D.render.lineOpacity
                              , w = D.render.lineThickness
                              , U = D.render.fillColor
                              , X = D.render.fillOpacity;
                            L && D.isSleeping && (D.isStatic ? (G *= N,
                            X *= N) : (I = z,
                            U = Y)),
                            F || (U = null),
                            B || (I = null),
                            this.renderBody(D, T, R, I, G, w, U, X);
                            var V = D.parts.length;
                            O && V > 1 && this.renderConvexHull(D, T, W, w)
                        }
                    }
                },
                renderBody: function(x, T, E, P, M, L, R, O) {
                    P === void 0 && (P = null),
                    M === void 0 && (M = null),
                    L === void 0 && (L = 1),
                    R === void 0 && (R = null),
                    O === void 0 && (O = null);
                    for (var F = this.debugConfig, B = F.sensorFillColor, N = F.sensorLineColor, Y = x.parts, z = Y.length, W = z > 1 ? 1 : 0; W < z; W++) {
                        var b = Y[W]
                          , D = b.render
                          , I = D.opacity;
                        if (!(!D.visible || I === 0 || b.isSensor && !F.showSensors)) {
                            var G = b.circleRadius;
                            if (T.beginPath(),
                            b.isSensor ? (R !== null && T.fillStyle(B, O * I),
                            P !== null && T.lineStyle(L, N, M * I)) : (R !== null && T.fillStyle(R, O * I),
                            P !== null && T.lineStyle(L, P, M * I)),
                            G)
                                T.arc(b.position.x, b.position.y, G, 0, 2 * Math.PI);
                            else {
                                var w = b.vertices
                                  , U = w.length;
                                T.moveTo(w[0].x, w[0].y);
                                for (var X = 1; X < U; X++) {
                                    var V = w[X];
                                    if (!w[X - 1].isInternal || E ? T.lineTo(V.x, V.y) : T.moveTo(V.x, V.y),
                                    X < U && V.isInternal && !E) {
                                        var H = (X + 1) % U;
                                        T.moveTo(w[H].x, w[H].y)
                                    }
                                }
                                T.closePath()
                            }
                            R !== null && T.fillPath(),
                            P !== null && T.strokePath()
                        }
                    }
                    if (F.showPositions && !x.isStatic) {
                        var J = x.position.x
                          , $ = x.position.y
                          , _ = Math.ceil(F.positionSize / 2);
                        T.fillStyle(F.positionColor, 1),
                        T.fillRect(J - _, $ - _, F.positionSize, F.positionSize)
                    }
                    return this
                },
                renderConvexHull: function(x, T, E, P) {
                    P === void 0 && (P = 1);
                    var M = x.parts
                      , L = M.length;
                    if (L > 1) {
                        var R = x.vertices;
                        T.lineStyle(P, E),
                        T.beginPath(),
                        T.moveTo(R[0].x, R[0].y);
                        for (var O = 1; O < R.length; O++)
                            T.lineTo(R[O].x, R[O].y);
                        T.lineTo(R[0].x, R[0].y),
                        T.strokePath()
                    }
                    return this
                },
                renderJoints: function() {
                    for (var x = this.debugGraphic, T = a.allConstraints(this.localWorld), E = 0; E < T.length; E++) {
                        var P = T[E].render
                          , M = P.lineColor
                          , L = P.lineOpacity
                          , R = P.lineThickness
                          , O = P.pinSize
                          , F = P.anchorColor
                          , B = P.anchorSize;
                        this.renderConstraint(T[E], x, M, L, R, O, F, B)
                    }
                },
                renderConstraint: function(x, T, E, P, M, L, R, O) {
                    var F = x.render;
                    if (!F.visible || !x.pointA || !x.pointB)
                        return this;
                    T.lineStyle(M, E, P);
                    var B = x.bodyA, N = x.bodyB, Y, z;
                    if (B ? Y = g.add(B.position, x.pointA) : Y = x.pointA,
                    F.type === "pin")
                        T.strokeCircle(Y.x, Y.y, L);
                    else {
                        if (N ? z = g.add(N.position, x.pointB) : z = x.pointB,
                        T.beginPath(),
                        T.moveTo(Y.x, Y.y),
                        F.type === "spring")
                            for (var W = g.sub(z, Y), b = g.perp(g.normalise(W)), D = Math.ceil(o.clamp(x.length / 5, 12, 20)), I, G = 1; G < D; G += 1)
                                I = G % 2 === 0 ? 1 : -1,
                                T.lineTo(Y.x + W.x * (G / D) + b.x * I * 4, Y.y + W.y * (G / D) + b.y * I * 4);
                        T.lineTo(z.x, z.y)
                    }
                    return T.strokePath(),
                    F.anchors && O > 0 && (T.fillStyle(R),
                    T.fillCircle(Y.x, Y.y, O),
                    T.fillCircle(z.x, z.y, O)),
                    this
                },
                resetCollisionIDs: function() {
                    return f._nextCollidingGroupId = 1,
                    f._nextNonCollidingGroupId = -1,
                    f._nextCategory = 1,
                    this
                },
                shutdown: function() {
                    d.off(this.engine),
                    this.removeAllListeners(),
                    p.clear(this.localWorld, !1),
                    n.clear(this.engine),
                    this.drawDebug && this.debugGraphic.destroy()
                },
                destroy: function() {
                    this.shutdown()
                }
            });
            c.exports = m
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                BasePlugin: t(540),
                DefaultPlugins: t(197),
                PluginCache: t(24),
                PluginManager: t(414),
                ScenePlugin: t(1404)
            }
        }
        , function(c, S, t) {
            /**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2020 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}
*/
            var e = t(540)
              , f = t(0)
              , r = t(20)
              , o = new f({
                Extends: e,
                initialize: function(n, s, l) {
                    e.call(this, s),
                    this.scene = n,
                    this.systems = n.sys,
                    this.pluginKey = l,
                    n.sys.events.once(r.BOOT, this.boot, this)
                },
                boot: function() {},
                destroy: function() {
                    this.pluginManager = null,
                    this.game = null,
                    this.scene = null,
                    this.systems = null
                }
            });
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Canvas: t(1406),
                Events: t(91),
                Snapshot: t(1407),
                WebGL: t(1408)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                CanvasRenderer: t(368),
                GetBlendModes: t(370),
                SetTransform: t(30)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Canvas: t(369),
                WebGL: t(383)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(107)
              , f = t(17)
              , r = {
                PipelineManager: t(372),
                Pipelines: t(1409),
                RenderTarget: t(141),
                Utils: t(12),
                WebGLPipeline: t(58),
                WebGLRenderer: t(371),
                WebGLShader: t(375)
            };
            r = f(!1, r, e),
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(92)
              , f = t(17)
              , r = {
                BitmapMaskPipeline: t(373),
                Events: t(374),
                GraphicsPipeline: t(376),
                LightPipeline: t(377),
                MultiPipeline: t(108),
                PointLightPipeline: t(378),
                PostFXPipeline: t(1410),
                RopePipeline: t(379),
                SinglePipeline: t(380),
                UtilityPipeline: t(381)
            };
            r = f(!1, r, e),
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(198)
              , r = t(2)
              , o = t(1411)
              , a = t(382)
              , n = t(58)
              , s = new e({
                Extends: n,
                initialize: function(i) {
                    i.renderTarget = r(i, "renderTarget", 1),
                    i.fragShader = r(i, "fragShader", o),
                    i.vertShader = r(i, "vertShader", a),
                    i.attributes = r(i, "attributes", [{
                        name: "inPosition",
                        size: 2
                    }, {
                        name: "inTexCoord",
                        size: 2
                    }]),
                    i.batchSize = 1,
                    i.vertices = [-1, -1, 0, 0, -1, 1, 0, 1, 1, 1, 1, 1, -1, -1, 0, 0, 1, 1, 1, 1, 1, -1, 1, 0],
                    n.call(this, i),
                    this.isPostFX = !0,
                    this.gameObject,
                    this.colorMatrix = new f,
                    this.fullFrame1,
                    this.fullFrame2,
                    this.halfFrame1,
                    this.halfFrame2,
                    this.renderer.isBooted && (this.manager = this.renderer.pipelines,
                    this.boot())
                },
                boot: function() {
                    n.prototype.boot.call(this);
                    var l = this.manager.UTILITY_PIPELINE;
                    this.fullFrame1 = l.fullFrame1,
                    this.fullFrame2 = l.fullFrame2,
                    this.halfFrame1 = l.halfFrame1,
                    this.halfFrame2 = l.halfFrame2,
                    this.set1i("uMainSampler", 0)
                },
                onDraw: function(l) {
                    this.bindAndDraw(l)
                },
                copyFrame: function(l, i, h, u, d) {
                    this.manager.copyFrame(l, i, h, u, d)
                },
                copyToGame: function(l) {
                    this.manager.copyToGame(l)
                },
                drawFrame: function(l, i, h) {
                    this.manager.drawFrame(l, i, h, this.colorMatrix)
                },
                blendFrames: function(l, i, h, u, d) {
                    this.manager.blendFrames(l, i, h, u, d)
                },
                blendFramesAdditive: function(l, i, h, u, d) {
                    this.manager.blendFramesAdditive(l, i, h, u, d)
                },
                clearFrame: function(l, i) {
                    this.manager.clearFrame(l, i)
                },
                blitFrame: function(l, i, h, u, d, v) {
                    this.manager.blitFrame(l, i, h, u, d, v)
                },
                copyFrameRect: function(l, i, h, u, d, v, p, g) {
                    this.manager.copyFrameRect(l, i, h, u, d, v, p, g)
                },
                bindAndDraw: function(l, i, h, u, d) {
                    h === void 0 && (h = !0),
                    u === void 0 && (u = !0);
                    var v = this.gl
                      , p = this.renderer;
                    this.bind(d),
                    this.set1i("uMainSampler", 0),
                    i ? (v.viewport(0, 0, i.width, i.height),
                    v.bindFramebuffer(v.FRAMEBUFFER, i.framebuffer),
                    v.framebufferTexture2D(v.FRAMEBUFFER, v.COLOR_ATTACHMENT0, v.TEXTURE_2D, i.texture, 0),
                    h && (u ? v.clearColor(0, 0, 0, 0) : v.clearColor(0, 0, 0, 1),
                    v.clear(v.COLOR_BUFFER_BIT))) : (p.popFramebuffer(!1, !1, !1),
                    p.currentFramebuffer || v.viewport(0, 0, p.width, p.height)),
                    v.activeTexture(v.TEXTURE0),
                    v.bindTexture(v.TEXTURE_2D, l.texture),
                    v.bufferData(v.ARRAY_BUFFER, this.vertexData, v.STATIC_DRAW),
                    v.drawArrays(v.TRIANGLES, 0, 6),
                    i ? (v.bindTexture(v.TEXTURE_2D, null),
                    v.bindFramebuffer(v.FRAMEBUFFER, null)) : p.resetTextures()
                }
            });
            c.exports = s
        }
        , function(c, S) {
            c.exports = ["#define SHADER_NAME PHASER_POSTFX_FS", "", "precision mediump float;", "", "uniform sampler2D uMainSampler;", "", "varying vec2 outTexCoord;", "", "void main ()", "{", "    gl_FragColor = texture2D(uMainSampler, outTexCoord);", "}", ""].join(`
`)
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(17)
              , f = t(201)
              , r = {
                Center: t(403),
                Events: t(104),
                Orientation: t(404),
                ScaleManager: t(415),
                ScaleModes: t(405),
                Zoom: t(406)
            };
            r = e(!1, r, f.CENTER),
            r = e(!1, r, f.ORIENTATION),
            r = e(!1, r, f.SCALE_MODE),
            r = e(!1, r, f.ZOOM),
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(144)
              , f = t(17)
              , r = {
                Events: t(20),
                GetPhysicsPlugins: t(419),
                GetScenePlugins: t(420),
                SceneManager: t(417),
                ScenePlugin: t(1414),
                Settings: t(421),
                Systems: t(204)
            };
            r = f(!1, r, e),
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(18)
              , f = t(0)
              , r = t(20)
              , o = t(2)
              , a = t(24)
              , n = new f({
                initialize: function(l) {
                    this.scene = l,
                    this.systems = l.sys,
                    this.settings = l.sys.settings,
                    this.key = l.sys.settings.key,
                    this.manager = l.sys.game.scene,
                    this.transitionProgress = 0,
                    this._elapsed = 0,
                    this._target = null,
                    this._duration = 0,
                    this._onUpdate,
                    this._onUpdateScope,
                    this._willSleep = !1,
                    this._willRemove = !1,
                    l.sys.events.once(r.BOOT, this.boot, this),
                    l.sys.events.on(r.START, this.pluginStart, this)
                },
                boot: function() {
                    this.systems.events.once(r.DESTROY, this.destroy, this)
                },
                pluginStart: function() {
                    this._target = null,
                    this.systems.events.once(r.SHUTDOWN, this.shutdown, this)
                },
                start: function(s, l) {
                    return s === void 0 && (s = this.key),
                    this.manager.queueOp("stop", this.key),
                    this.manager.queueOp("start", s, l),
                    this
                },
                restart: function(s) {
                    var l = this.key;
                    return this.manager.queueOp("stop", l),
                    this.manager.queueOp("start", l, s),
                    this
                },
                transition: function(s) {
                    s === void 0 && (s = {});
                    var l = o(s, "target", !1)
                      , i = this.manager.getScene(l);
                    if (!l || !this.checkValidTransition(i))
                        return !1;
                    var h = o(s, "duration", 1e3);
                    this._elapsed = 0,
                    this._target = i,
                    this._duration = h,
                    this._willSleep = o(s, "sleep", !1),
                    this._willRemove = o(s, "remove", !1);
                    var u = o(s, "onUpdate", null);
                    u && (this._onUpdate = u,
                    this._onUpdateScope = o(s, "onUpdateScope", this.scene));
                    var d = o(s, "allowInput", !1);
                    this.settings.transitionAllowInput = d;
                    var v = i.sys.settings;
                    return v.isTransition = !0,
                    v.transitionFrom = this.scene,
                    v.transitionDuration = h,
                    v.transitionAllowInput = d,
                    o(s, "moveAbove", !1) ? this.manager.moveAbove(this.key, l) : o(s, "moveBelow", !1) && this.manager.moveBelow(this.key, l),
                    i.sys.isSleeping() ? i.sys.wake(o(s, "data")) : this.manager.start(l, o(s, "data")),
                    this.systems.events.emit(r.TRANSITION_OUT, i, h),
                    this.systems.events.on(r.UPDATE, this.step, this),
                    !0
                },
                checkValidTransition: function(s) {
                    return !(!s || s.sys.isActive() || s.sys.isTransitioning() || s === this.scene || this.systems.isTransitioning())
                },
                step: function(s, l) {
                    this._elapsed += l,
                    this.transitionProgress = e(this._elapsed / this._duration, 0, 1),
                    this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.transitionProgress),
                    this._elapsed >= this._duration && this.transitionComplete()
                },
                transitionComplete: function() {
                    var s = this._target.sys
                      , l = this._target.sys.settings;
                    this.systems.events.off(r.UPDATE, this.step, this),
                    s.events.emit(r.TRANSITION_COMPLETE, this.scene),
                    l.isTransition = !1,
                    l.transitionFrom = null,
                    this._duration = 0,
                    this._target = null,
                    this._onUpdate = null,
                    this._onUpdateScope = null,
                    this._willRemove ? this.manager.remove(this.key) : this._willSleep ? this.systems.sleep() : this.manager.stop(this.key)
                },
                add: function(s, l, i, h) {
                    return this.manager.add(s, l, i, h)
                },
                launch: function(s, l) {
                    return s && s !== this.key && this.manager.queueOp("start", s, l),
                    this
                },
                run: function(s, l) {
                    return s && s !== this.key && this.manager.queueOp("run", s, l),
                    this
                },
                pause: function(s, l) {
                    return s === void 0 && (s = this.key),
                    this.manager.queueOp("pause", s, l),
                    this
                },
                resume: function(s, l) {
                    return s === void 0 && (s = this.key),
                    this.manager.queueOp("resume", s, l),
                    this
                },
                sleep: function(s, l) {
                    return s === void 0 && (s = this.key),
                    this.manager.queueOp("sleep", s, l),
                    this
                },
                wake: function(s, l) {
                    return s === void 0 && (s = this.key),
                    this.manager.queueOp("wake", s, l),
                    this
                },
                switch: function(s) {
                    return s !== this.key && this.manager.queueOp("switch", this.key, s),
                    this
                },
                stop: function(s, l) {
                    return s === void 0 && (s = this.key),
                    this.manager.queueOp("stop", s, l),
                    this
                },
                setActive: function(s, l, i) {
                    l === void 0 && (l = this.key);
                    var h = this.manager.getScene(l);
                    return h && h.sys.setActive(s, i),
                    this
                },
                setVisible: function(s, l) {
                    l === void 0 && (l = this.key);
                    var i = this.manager.getScene(l);
                    return i && i.sys.setVisible(s),
                    this
                },
                isSleeping: function(s) {
                    return s === void 0 && (s = this.key),
                    this.manager.isSleeping(s)
                },
                isActive: function(s) {
                    return s === void 0 && (s = this.key),
                    this.manager.isActive(s)
                },
                isPaused: function(s) {
                    return s === void 0 && (s = this.key),
                    this.manager.isPaused(s)
                },
                isVisible: function(s) {
                    return s === void 0 && (s = this.key),
                    this.manager.isVisible(s)
                },
                swapPosition: function(s, l) {
                    return l === void 0 && (l = this.key),
                    s !== l && this.manager.swapPosition(s, l),
                    this
                },
                moveAbove: function(s, l) {
                    return l === void 0 && (l = this.key),
                    s !== l && this.manager.moveAbove(s, l),
                    this
                },
                moveBelow: function(s, l) {
                    return l === void 0 && (l = this.key),
                    s !== l && this.manager.moveBelow(s, l),
                    this
                },
                remove: function(s) {
                    return s === void 0 && (s = this.key),
                    this.manager.remove(s),
                    this
                },
                moveUp: function(s) {
                    return s === void 0 && (s = this.key),
                    this.manager.moveUp(s),
                    this
                },
                moveDown: function(s) {
                    return s === void 0 && (s = this.key),
                    this.manager.moveDown(s),
                    this
                },
                bringToTop: function(s) {
                    return s === void 0 && (s = this.key),
                    this.manager.bringToTop(s),
                    this
                },
                sendToBack: function(s) {
                    return s === void 0 && (s = this.key),
                    this.manager.sendToBack(s),
                    this
                },
                get: function(s) {
                    return this.manager.getScene(s)
                },
                getIndex: function(s) {
                    return s === void 0 && (s = this.key),
                    this.manager.getIndex(s)
                },
                shutdown: function() {
                    var s = this.systems.events;
                    s.off(r.SHUTDOWN, this.shutdown, this),
                    s.off(r.POST_UPDATE, this.step, this),
                    s.off(r.TRANSITION_OUT)
                },
                destroy: function() {
                    this.shutdown(),
                    this.scene.sys.events.off(r.START, this.start, this),
                    this.scene = null,
                    this.systems = null,
                    this.settings = null,
                    this.manager = null
                }
            });
            a.register("ScenePlugin", n, "scenePlugin"),
            c.exports = n
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Events: t(438),
                List: t(110),
                Map: t(102),
                ProcessQueue: t(211),
                RTree: t(531),
                Set: t(149),
                Size: t(416)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(17)
              , f = t(1417)
              , r = {
                CanvasTexture: t(423),
                Events: t(106),
                FilterMode: f,
                Frame: t(109),
                Parsers: t(425),
                Texture: t(206),
                TextureManager: t(422),
                TextureSource: t(424)
            };
            r = e(!1, r, f),
            c.exports = r
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                LINEAR: 0,
                NEAREST: 1
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(17)
              , f = t(1419)
              , r = {
                Components: t(251),
                Parsers: t(1452),
                Formats: t(40),
                ImageCollection: t(576),
                ParseToTilemap: t(262),
                Tile: t(85),
                Tilemap: t(580),
                TilemapCreator: t(1459),
                TilemapFactory: t(1460),
                Tileset: t(122),
                TilemapLayer: t(581),
                Orientation: t(29),
                LayerData: t(120),
                MapData: t(121),
                ObjectLayer: t(572)
            };
            r = e(!1, r, f.ORIENTATION),
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = {
                ORIENTATION: t(29)
            };
            c.exports = e
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(26)
              , f = t(63)
              , r = function(o, a, n, s, l, i, h, u) {
                h === void 0 && (h = !0),
                o < 0 && (o = 0),
                a < 0 && (a = 0);
                for (var d = e(o, a, n, s, null, u), v = l - o, p = i - a, g = 0; g < d.length; g++) {
                    var m = d[g].x + v
                      , x = d[g].y + p;
                    m >= 0 && m < u.width && x >= 0 && x < u.height && u.data[x][m] && u.data[x][m].copy(d[g])
                }
                h && f(l - 1, i - 1, n + 2, s + 2, u)
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(26)
              , f = t(542)
              , r = function(o, a, n, s, l, i) {
                n || (n = {}),
                Array.isArray(o) || (o = [o]);
                var h = i.tilemapLayer;
                s || (s = h.scene),
                l || (l = s.cameras.main);
                var u = e(0, 0, i.width, i.height, null, i), d = [], v;
                for (v = 0; v < u.length; v++) {
                    var p = u[v];
                    if (o.indexOf(p.index) !== -1) {
                        var g = h.tileToWorldXY(p.x, p.y, void 0, l, i);
                        n.x = g.x,
                        n.y = g.y,
                        d.push(s.make.sprite(n))
                    }
                }
                if (typeof a == "number")
                    for (v = 0; v < o.length; v++)
                        f(o[v], a, 0, 0, i.width, i.height, i);
                else if (Array.isArray(a))
                    for (v = 0; v < o.length; v++)
                        f(o[v], a[v], 0, 0, i.width, i.height, i);
                return d
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(26)
              , f = t(63)
              , r = t(72)
              , o = function(a, n, s, l, i, h, u) {
                for (var d = u.collideIndexes.indexOf(a) !== -1, v = e(n, s, l, i, null, u), p = 0; p < v.length; p++)
                    v[p].index = a,
                    r(v[p], d);
                h && f(n - 1, s - 1, l + 2, i + 2, u)
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(26)
              , f = function(r, o, a, n, s, l, i, h) {
                var u = e(a, n, s, l, i, h);
                return u.filter(r, o)
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                f === void 0 && (f = 0),
                r === void 0 && (r = !1);
                var a = 0, n, s, l;
                if (r) {
                    for (s = o.height - 1; s >= 0; s--)
                        for (n = o.width - 1; n >= 0; n--)
                            if (l = o.data[s][n],
                            l && l.index === e) {
                                if (a === f)
                                    return l;
                                a += 1
                            }
                } else
                    for (s = 0; s < o.height; s++)
                        for (n = 0; n < o.width; n++)
                            if (l = o.data[s][n],
                            l && l.index === e) {
                                if (a === f)
                                    return l;
                                a += 1
                            }
                return null
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(26)
              , f = function(r, o, a, n, s, l, i, h) {
                var u = e(a, n, s, l, i, h);
                return u.find(r, o) || null
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(26)
              , f = function(r, o, a, n, s, l, i, h) {
                var u = e(a, n, s, l, i, h);
                u.forEach(r, o)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(29)
              , f = t(544)
              , r = t(545)
              , o = t(547)
              , a = t(1)
              , n = t(548)
              , s = function(l) {
                return l === e.ORTHOGONAL ? f : l === e.HEXAGONAL ? r : l === e.STAGGERED ? n : l === e.ISOMETRIC ? o : a
            };
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(158)
              , f = t(3)
              , r = new f
              , o = function(a, n, s, l, i) {
                return i.tilemapLayer.worldToTileXY(a, n, !0, r, l),
                e(r.x, r.y, s, i)
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(483)
              , f = t(26)
              , r = t(484)
              , o = t(1)
              , a = t(3)
              , n = function(u, d) {
                return r.RectangleToTriangle(d, u)
            }
              , s = new a
              , l = new a
              , i = new a
              , h = function(u, d, v, p) {
                if (u === void 0)
                    return [];
                var g = o;
                u instanceof e.Circle ? g = r.CircleToRectangle : u instanceof e.Rectangle ? g = r.RectangleToRectangle : u instanceof e.Triangle ? g = n : u instanceof e.Line && (g = r.LineToRectangle),
                p.tilemapLayer.worldToTileXY(u.left, u.top, !0, l, v);
                var m = l.x
                  , x = l.y;
                p.tilemapLayer.worldToTileXY(u.right, u.bottom, !0, i, v);
                var T = Math.ceil(i.x)
                  , E = Math.ceil(i.y)
                  , P = Math.max(T - m, 1)
                  , M = Math.max(E - x, 1)
                  , L = f(m, x, P, M, d, p)
                  , R = p.tileWidth
                  , O = p.tileHeight;
                p.tilemapLayer && (R *= p.tilemapLayer.scaleX,
                O *= p.tilemapLayer.scaleY);
                for (var F = [], B = new e.Rectangle(0,0,R,O), N = 0; N < L.length; N++) {
                    var Y = L[N];
                    p.tilemapLayer.tileToWorldXY(Y.x, Y.y, s, v),
                    B.x = s.x,
                    B.y = s.y,
                    g(u, B) && F.push(Y)
                }
                return F
            };
            c.exports = h
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(29)
              , f = t(1)
              , r = t(253)
              , o = function(a) {
                return a === e.ORTHOGONAL ? r : f
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(29)
              , f = t(550)
              , r = t(551)
              , o = t(1)
              , a = t(552)
              , n = t(553)
              , s = function(l) {
                return l === e.ORTHOGONAL ? n : l === e.ISOMETRIC ? r : l === e.HEXAGONAL ? f : l === e.STAGGERED ? a : o
            };
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(29)
              , f = t(554)
              , r = t(1)
              , o = t(555)
              , a = t(254)
              , n = function(s) {
                return s === e.ORTHOGONAL ? a : s === e.HEXAGONAL ? f : s === e.STAGGERED ? o : r
            };
            c.exports = n
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(29)
              , f = t(1)
              , r = t(255)
              , o = function(a) {
                return a === e.ORTHOGONAL ? r : f
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(29)
              , f = t(556)
              , r = t(557)
              , o = t(1)
              , a = t(558)
              , n = t(559)
              , s = function(l) {
                return l === e.ORTHOGONAL ? n : l === e.ISOMETRIC ? r : l === e.HEXAGONAL ? f : l === e.STAGGERED ? a : o
            };
            c.exports = s
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(29)
              , f = t(560)
              , r = t(1)
              , o = t(561)
              , a = t(256)
              , n = function(s) {
                return s === e.ORTHOGONAL ? a : s === e.HEXAGONAL ? f : s === e.STAGGERED ? o : r
            };
            c.exports = n
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(562)
              , f = t(3)
              , r = new f
              , o = function(a, n, s, l) {
                l.tilemapLayer.worldToTileXY(a, n, !0, r, s);
                var i = r.x
                  , h = r.y;
                return e(i, h, l)
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(257)
              , f = t(3)
              , r = new f
              , o = function(a, n, s, l, i, h) {
                return h.tilemapLayer.worldToTileXY(n, s, !0, r, i, h),
                e(a, r.x, r.y, l, h)
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(63)
              , f = t(257)
              , r = function(o, a, n, s, l) {
                if (s === void 0 && (s = !0),
                !Array.isArray(o))
                    return null;
                Array.isArray(o[0]) || (o = [o]);
                for (var i = o.length, h = o[0].length, u = 0; u < i; u++)
                    for (var d = 0; d < h; d++) {
                        var v = o[u][d];
                        f(v, a + d, n + u, !1, l)
                    }
                s && e(a - 1, n - 1, h + 2, i + 2, l)
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(26)
              , f = t(210)
              , r = function(o, a, n, s, l, i) {
                var h, u = e(o, a, n, s, {}, i);
                if (!l)
                    for (l = [],
                    h = 0; h < u.length; h++)
                        l.indexOf(u[h].index) === -1 && l.push(u[h].index);
                for (h = 0; h < u.length; h++)
                    u[h].index = f(l)
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(563)
              , f = t(3)
              , r = new f
              , o = function(a, n, s, l, i, h) {
                return h.tilemapLayer.worldToTileXY(a, n, !0, r, i, h),
                e(r.x, r.y, s, l, h)
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(26)
              , f = t(397)
              , r = new f(105,210,231,150)
              , o = new f(243,134,48,200)
              , a = new f(40,39,37,150)
              , n = function(s, l, i) {
                l === void 0 && (l = {});
                var h = l.tileColor !== void 0 ? l.tileColor : r
                  , u = l.collidingTileColor !== void 0 ? l.collidingTileColor : o
                  , d = l.faceColor !== void 0 ? l.faceColor : a
                  , v = e(0, 0, i.width, i.height, null, i);
                s.translateCanvas(i.tilemapLayer.x, i.tilemapLayer.y),
                s.scaleCanvas(i.tilemapLayer.scaleX, i.tilemapLayer.scaleY);
                for (var p = 0; p < v.length; p++) {
                    var g = v[p]
                      , m = g.width
                      , x = g.height
                      , T = g.pixelX
                      , E = g.pixelY
                      , P = g.collides ? u : h;
                    P !== null && (s.fillStyle(P.color, P.alpha / 255),
                    s.fillRect(T, E, m, x)),
                    T += 1,
                    E += 1,
                    m -= 2,
                    x -= 2,
                    d !== null && (s.lineStyle(1, d.color, d.alpha / 255),
                    g.faceTop && s.lineBetween(T, E, T + m, E),
                    g.faceRight && s.lineBetween(T + m, E, T + m, E + x),
                    g.faceBottom && s.lineBetween(T, E + x, T + m, E + x),
                    g.faceLeft && s.lineBetween(T, E, T, E + x))
                }
            };
            c.exports = n
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(72)
              , f = t(63)
              , r = t(160)
              , o = function(a, n, s, l, i) {
                n === void 0 && (n = !0),
                s === void 0 && (s = !0),
                i === void 0 && (i = !0),
                Array.isArray(a) || (a = [a]);
                for (var h = 0; h < a.length; h++)
                    r(a[h], n, l);
                if (i)
                    for (var u = 0; u < l.height; u++)
                        for (var d = 0; d < l.width; d++) {
                            var v = l.data[u][d];
                            v && a.indexOf(v.index) !== -1 && e(v, n)
                        }
                s && f(0, 0, l.width, l.height, l)
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(72)
              , f = t(63)
              , r = t(160)
              , o = function(a, n, s, l, i, h) {
                if (s === void 0 && (s = !0),
                l === void 0 && (l = !0),
                h === void 0 && (h = !0),
                !(a > n)) {
                    for (var u = a; u <= n; u++)
                        r(u, s, i);
                    if (h)
                        for (var d = 0; d < i.height; d++)
                            for (var v = 0; v < i.width; v++) {
                                var p = i.data[d][v];
                                p && p.index >= a && p.index <= n && e(p, s)
                            }
                    l && f(0, 0, i.width, i.height, i)
                }
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(72)
              , f = t(63)
              , r = t(160)
              , o = function(a, n, s, l) {
                n === void 0 && (n = !0),
                s === void 0 && (s = !0),
                Array.isArray(a) || (a = [a]);
                for (var i = 0; i < l.height; i++)
                    for (var h = 0; h < l.width; h++) {
                        var u = l.data[i][h];
                        u && a.indexOf(u.index) === -1 && (e(u, n),
                        r(u.index, n, l))
                    }
                s && f(0, 0, l.width, l.height, l)
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(72)
              , f = t(63)
              , r = t(126)
              , o = function(a, n, s, l) {
                n === void 0 && (n = !0),
                s === void 0 && (s = !0);
                for (var i = 0; i < l.height; i++)
                    for (var h = 0; h < l.width; h++) {
                        var u = l.data[i][h];
                        if (u) {
                            for (var d in a)
                                if (r(u.properties, d)) {
                                    var v = a[d];
                                    Array.isArray(v) || (v = [v]);
                                    for (var p = 0; p < v.length; p++)
                                        u.properties[d] === v[p] && e(u, n)
                                }
                        }
                    }
                s && f(0, 0, l.width, l.height, l)
            };
            c.exports = o
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(72)
              , f = t(63)
              , r = function(o, a, n) {
                o === void 0 && (o = !0),
                a === void 0 && (a = !0);
                for (var s = 0; s < n.height; s++)
                    for (var l = 0; l < n.width; l++) {
                        var i = n.data[s][l];
                        if (i) {
                            var h = i.getCollisionGroup();
                            h && h.objects && h.objects.length > 0 && e(i, o)
                        }
                    }
                a && f(0, 0, n.width, n.height, n)
            };
            c.exports = r
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f, r, o) {
                if (typeof e == "number")
                    o.callbacks[e] = f !== null ? {
                        callback: f,
                        callbackContext: r
                    } : void 0;
                else
                    for (var a = 0, n = e.length; a < n; a++)
                        o.callbacks[e[a]] = f !== null ? {
                            callback: f,
                            callbackContext: r
                        } : void 0
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(26)
              , f = function(r, o, a, n, s, l, i) {
                for (var h = e(r, o, a, n, null, i), u = 0; u < h.length; u++)
                    h[u].setCollisionCallback(s, l)
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(26)
              , f = t(131)
              , r = function(o, a, n, s, l) {
                var i = e(o, a, n, s, null, l)
                  , h = i.map(function(d) {
                    return d.index
                });
                f(h);
                for (var u = 0; u < i.length; u++)
                    i[u].index = h[u]
            };
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(26)
              , f = function(r, o, a, n, s, l, i) {
                for (var h = e(a, n, s, l, null, i), u = 0; u < h.length; u++)
                    h[u] && (h[u].index === r ? h[u].index = o : h[u].index === o && (h[u].index = r))
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(26)
              , f = function(r, o, a, n, s, l) {
                if (s) {
                    var i, h = e(r, o, a, n, null, l), u = 0;
                    for (i = 0; i < s.length; i++)
                        u += s[i].weight;
                    if (!(u <= 0))
                        for (i = 0; i < h.length; i++) {
                            for (var d = Math.random() * u, v = 0, p = -1, g = 0; g < s.length; g++)
                                if (v += s[g].weight,
                                d <= v) {
                                    var m = s[g].index;
                                    p = Array.isArray(m) ? m[Math.floor(Math.random() * m.length)] : m;
                                    break
                                }
                            h[i].index = p
                        }
                }
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                FromOrientationString: t(258),
                Parse: t(564),
                Parse2DArray: t(259),
                ParseCSV: t(565),
                Impact: t(1454),
                Tiled: t(1455)
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                for (var r = 0; r < e.length; r++) {
                    var o = e[r]
                      , a = r;
                    if (o.name && o.name !== "" && (a = o.name),
                    Array.isArray(o.wangtiles) && o.wangtiles.length > 0) {
                        var n = {}, s = {}, l, i, h;
                        if (Array.isArray(o.edgecolors))
                            for (l = 0; l < o.edgecolors.length; l++)
                                h = 1 + l,
                                i = o.edgecolors[l],
                                i.name !== "" && (n[h] = i.name);
                        if (Array.isArray(o.cornercolors))
                            for (l = 0; l < o.cornercolors.length; l++)
                                h = 1 + l,
                                i = o.cornercolors[l],
                                i.name !== "" && (s[h] = i.name);
                        if (Array.isArray(o.colors))
                            for (l = 0; l < o.colors.length; l++)
                                i = o.colors[l],
                                h = 1 + l,
                                i.name !== "" && (n[h] = s[h] = i.name);
                        for (var u = [n, s, n, s, n, s, n, s], d = 0; d < o.wangtiles.length; d++) {
                            var v = o.wangtiles[d]
                              , p = f[v.tileid] || (f[v.tileid] = {});
                            p = p.wangid || (p.wangid = {});
                            for (var g = [], m = 0; m < Math.min(u.length, v.wangid.length); m++) {
                                if (i = v.wangid[m],
                                i === 0) {
                                    g.push(void 0);
                                    continue
                                }
                                var x = u[m][i];
                                if (x !== void 0) {
                                    g.push(x);
                                    continue
                                }
                                g.push(i)
                            }
                            p[a] = g
                        }
                    }
                }
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                ParseTileLayers: t(578),
                ParseTilesets: t(579),
                ParseWeltmeister: t(577)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                AssignTileProperties: t(567),
                Base64Decode: t(574),
                BuildTilesetIndex: t(568),
                CreateGroupLayer: t(161),
                ParseGID: t(261),
                ParseImageLayers: t(569),
                ParseJSONTiled: t(566),
                ParseObject: t(260),
                ParseObjectLayers: t(570),
                ParseTileLayers: t(573),
                ParseTilesets: t(575)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(1)
              , f = t(1);
            e = t(1457),
            f = t(1458),
            c.exports = {
                renderWebGL: e,
                renderCanvas: f
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(12)
              , f = function(r, o, a) {
                var n = o.cull(a)
                  , s = n.length
                  , l = a.alpha * o.alpha;
                if (!(s === 0 || l <= 0)) {
                    var i = o.gidMap
                      , h = r.pipelines.set(o.pipeline, o)
                      , u = e.getTintAppendFloatAlpha
                      , d = o.scrollFactorX
                      , v = o.scrollFactorY
                      , p = o.x
                      , g = o.y
                      , m = o.scaleX
                      , x = o.scaleY;
                    r.pipelines.preBatch(o);
                    for (var T = 0; T < s; T++) {
                        var E = n[T]
                          , P = i[E.index];
                        if (P) {
                            var M = P.getTileTextureCoordinates(E.index);
                            if (M !== null) {
                                var L = P.glTexture
                                  , R = h.setTexture2D(L, o)
                                  , O = P.tileWidth
                                  , F = P.tileHeight
                                  , B = M.x
                                  , N = M.y
                                  , Y = P.tileWidth * .5
                                  , z = P.tileHeight * .5
                                  , W = u(E.tint, l * E.alpha);
                                h.batchTexture(o, L, L.width, L.height, p + (Y + E.pixelX) * m, g + (z + E.pixelY) * x, E.width, E.height, m, x, E.rotation, E.flipX, E.flipY, d, v, Y, z, B, N, O, F, W, W, W, W, !1, 0, 0, a, null, !0, R)
                            }
                        }
                    }
                    r.pipelines.postBatch(o)
                }
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(25)
              , f = new e
              , r = new e
              , o = new e
              , a = function(n, s, l, i) {
                var h = s.cull(l)
                  , u = h.length
                  , d = l.alpha * s.alpha;
                if (!(u === 0 || d <= 0)) {
                    var v = f
                      , p = r
                      , g = o;
                    p.applyITRS(s.x, s.y, s.rotation, s.scaleX, s.scaleY),
                    v.copyFrom(l.matrix);
                    var m = n.currentContext
                      , x = s.gidMap;
                    m.save(),
                    i ? (v.multiplyWithOffset(i, -l.scrollX * s.scrollFactorX, -l.scrollY * s.scrollFactorY),
                    p.e = s.x,
                    p.f = s.y,
                    v.multiply(p, g),
                    g.copyToContext(m)) : (p.e -= l.scrollX * s.scrollFactorX,
                    p.f -= l.scrollY * s.scrollFactorY,
                    p.copyToContext(m)),
                    (!n.antialias || s.scaleX > 1 || s.scaleY > 1) && (m.imageSmoothingEnabled = !1);
                    for (var T = 0; T < u; T++) {
                        var E = h[T]
                          , P = x[E.index];
                        if (P) {
                            var M = P.image.getSourceImage()
                              , L = P.getTileTextureCoordinates(E.index);
                            if (L !== null) {
                                var R = P.tileWidth
                                  , O = P.tileHeight
                                  , F = R * .5
                                  , B = O * .5;
                                m.save(),
                                m.translate(E.pixelX + F, E.pixelY + B),
                                E.rotation !== 0 && m.rotate(E.rotation),
                                (E.flipX || E.flipY) && m.scale(E.flipX ? -1 : 1, E.flipY ? -1 : 1),
                                m.globalAlpha = d * E.alpha,
                                m.drawImage(M, L.x, L.y, R, O, -F, -B, R, O),
                                m.restore()
                            }
                        }
                    }
                    m.restore()
                }
            };
            c.exports = a
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(16)
              , f = t(262);
            e.register("tilemap", function(r) {
                var o = r !== void 0 ? r : {};
                return f(this.scene, o.key, o.tileWidth, o.tileHeight, o.width, o.height, o.data, o.insertNull)
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(5)
              , f = t(262);
            e.register("tilemap", function(r, o, a, n, s, l, i) {
                return r === null && (r = void 0),
                o === null && (o = void 0),
                a === null && (a = void 0),
                n === null && (n = void 0),
                s === null && (s = void 0),
                f(this.scene, r, o, a, n, s, l, i)
            })
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Clock: t(1462),
                TimerEvent: t(582)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(0)
              , f = t(24)
              , r = t(20)
              , o = t(582)
              , a = t(93)
              , n = new e({
                initialize: function(l) {
                    this.scene = l,
                    this.systems = l.sys,
                    this.now = 0,
                    this.timeScale = 1,
                    this.paused = !1,
                    this._active = [],
                    this._pendingInsertion = [],
                    this._pendingRemoval = [],
                    l.sys.events.once(r.BOOT, this.boot, this),
                    l.sys.events.on(r.START, this.start, this)
                },
                boot: function() {
                    this.now = this.systems.game.loop.time,
                    this.systems.events.once(r.DESTROY, this.destroy, this)
                },
                start: function() {
                    var s = this.systems.events;
                    s.on(r.PRE_UPDATE, this.preUpdate, this),
                    s.on(r.UPDATE, this.update, this),
                    s.once(r.SHUTDOWN, this.shutdown, this)
                },
                addEvent: function(s) {
                    var l;
                    return s instanceof o ? (l = s,
                    this.removeEvent(l),
                    l.elapsed = l.startAt,
                    l.hasDispatched = !1,
                    l.repeatCount = l.repeat === -1 || l.loop ? 999999999999 : l.repeat) : l = new o(s),
                    this._pendingInsertion.push(l),
                    l
                },
                delayedCall: function(s, l, i, h) {
                    return this.addEvent({
                        delay: s,
                        callback: l,
                        args: i,
                        callbackScope: h
                    })
                },
                clearPendingEvents: function() {
                    return this._pendingInsertion = [],
                    this
                },
                removeEvent: function(s) {
                    Array.isArray(s) || (s = [s]);
                    for (var l = 0; l < s.length; l++) {
                        var i = s[l];
                        a(this._pendingRemoval, i),
                        a(this._pendingInsertion, i),
                        a(this._active, i)
                    }
                    return this
                },
                removeAllEvents: function() {
                    return this._pendingRemoval = this._pendingRemoval.concat(this._active),
                    this
                },
                preUpdate: function() {
                    var s = this._pendingRemoval.length
                      , l = this._pendingInsertion.length;
                    if (!(s === 0 && l === 0)) {
                        var i, h;
                        for (i = 0; i < s; i++) {
                            h = this._pendingRemoval[i];
                            var u = this._active.indexOf(h);
                            u > -1 && this._active.splice(u, 1),
                            h.destroy()
                        }
                        for (i = 0; i < l; i++)
                            h = this._pendingInsertion[i],
                            this._active.push(h);
                        this._pendingRemoval.length = 0,
                        this._pendingInsertion.length = 0
                    }
                },
                update: function(s, l) {
                    if (this.now = s,
                    !this.paused) {
                        l *= this.timeScale;
                        for (var i = 0; i < this._active.length; i++) {
                            var h = this._active[i];
                            if (!h.paused && (h.elapsed += l * h.timeScale,
                            h.elapsed >= h.delay)) {
                                var u = h.elapsed - h.delay;
                                h.elapsed = h.delay,
                                !h.hasDispatched && h.callback && (h.hasDispatched = !0,
                                h.callback.apply(h.callbackScope, h.args)),
                                h.repeatCount > 0 ? (h.repeatCount--,
                                h.elapsed = u,
                                h.hasDispatched = !1) : this._pendingRemoval.push(h)
                            }
                        }
                    }
                },
                shutdown: function() {
                    var s;
                    for (s = 0; s < this._pendingInsertion.length; s++)
                        this._pendingInsertion[s].destroy();
                    for (s = 0; s < this._active.length; s++)
                        this._active[s].destroy();
                    for (s = 0; s < this._pendingRemoval.length; s++)
                        this._pendingRemoval[s].destroy();
                    this._active.length = 0,
                    this._pendingRemoval.length = 0,
                    this._pendingInsertion.length = 0;
                    var l = this.systems.events;
                    l.off(r.PRE_UPDATE, this.preUpdate, this),
                    l.off(r.UPDATE, this.update, this),
                    l.off(r.SHUTDOWN, this.shutdown, this)
                },
                destroy: function() {
                    this.shutdown(),
                    this.scene.sys.events.off(r.START, this.start, this),
                    this.scene = null,
                    this.systems = null
                }
            });
            f.register("Clock", n, "time"),
            c.exports = n
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(100)
              , f = t(17)
              , r = {
                Builders: t(1464),
                Events: t(267),
                TweenManager: t(1480),
                Tween: t(266),
                TweenData: t(268),
                Timeline: t(588)
            };
            r = f(!1, r, e),
            c.exports = r
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                GetBoolean: t(99),
                GetEaseFunction: t(80),
                GetNewValue: t(162),
                GetProps: t(583),
                GetTargets: t(263),
                GetTweens: t(584),
                GetValueOp: t(264),
                NumberTweenBuilder: t(585),
                StaggerBuilder: t(586),
                TimelineBuilder: t(587),
                TweenBuilder: t(163)
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = ["callbackScope", "completeDelay", "delay", "duration", "ease", "easeParams", "flipX", "flipY", "hold", "loop", "loopDelay", "offset", "onActive", "onActiveParams", "onActiveScope", "onComplete", "onCompleteParams", "onCompleteScope", "onLoop", "onLoopParams", "onLoopScope", "onRepeat", "onRepeatParams", "onRepeatScope", "onStart", "onStartParams", "onStartScope", "onStop", "onStopParams", "onStopScope", "onUpdate", "onUpdateParams", "onUpdateScope", "onYoyo", "onYoyoParams", "onYoyoScope", "paused", "props", "repeat", "repeatDelay", "targets", "useFrames", "yoyo"]
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "complete"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "loop"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pause"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "resume"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "start"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "update"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "active"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "complete"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "loop"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "repeat"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "start"
        }
        , function(c, S) {
            /**
 * @author       samme
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "stop"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "update"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "yoyo"
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(93)
              , f = t(0)
              , r = t(585)
              , o = t(24)
              , a = t(20)
              , n = t(586)
              , s = t(587)
              , l = t(100)
              , i = t(163)
              , h = new f({
                initialize: function(d) {
                    this.scene = d,
                    this.systems = d.sys,
                    this.timeScale = 1,
                    this._add = [],
                    this._pending = [],
                    this._active = [],
                    this._destroy = [],
                    this._toProcess = 0,
                    d.sys.events.once(a.BOOT, this.boot, this),
                    d.sys.events.on(a.START, this.start, this)
                },
                boot: function() {
                    this.systems.events.once(a.DESTROY, this.destroy, this)
                },
                start: function() {
                    var u = this.systems.events;
                    u.on(a.PRE_UPDATE, this.preUpdate, this),
                    u.on(a.UPDATE, this.update, this),
                    u.once(a.SHUTDOWN, this.shutdown, this),
                    this.timeScale = 1
                },
                createTimeline: function(u) {
                    return s(this, u)
                },
                timeline: function(u) {
                    var d = s(this, u);
                    return d.paused || (this._add.push(d),
                    this._toProcess++),
                    d
                },
                create: function(u) {
                    return i(this, u)
                },
                add: function(u) {
                    var d = i(this, u);
                    return this._add.push(d),
                    this._toProcess++,
                    d
                },
                existing: function(u) {
                    return this._add.push(u),
                    this._toProcess++,
                    this
                },
                addCounter: function(u) {
                    var d = r(this, u);
                    return this._add.push(d),
                    this._toProcess++,
                    d
                },
                stagger: function(u, d) {
                    return n(u, d)
                },
                preUpdate: function() {
                    if (this._toProcess !== 0) {
                        var u = this._destroy, d = this._active, v = this._pending, p, g;
                        for (p = 0; p < u.length; p++) {
                            g = u[p];
                            var m = d.indexOf(g);
                            m === -1 ? (m = v.indexOf(g),
                            m > -1 && (g.state = l.REMOVED,
                            v.splice(m, 1))) : (g.state = l.REMOVED,
                            d.splice(m, 1))
                        }
                        for (u.length = 0,
                        u = this._add,
                        p = 0; p < u.length; p++)
                            g = u[p],
                            g.state === l.PENDING_ADD && (g.init() ? (g.play(),
                            this._active.push(g)) : this._pending.push(g));
                        u.length = 0,
                        this._toProcess = 0
                    }
                },
                update: function(u, d) {
                    var v = this._active, p;
                    d *= this.timeScale;
                    for (var g = 0; g < v.length; g++)
                        p = v[g],
                        p.update(u, d) && (this._destroy.push(p),
                        this._toProcess++)
                },
                remove: function(u) {
                    return e(this._add, u),
                    e(this._pending, u),
                    e(this._active, u),
                    e(this._destroy, u),
                    u.state = l.REMOVED,
                    this
                },
                makeActive: function(u) {
                    if (this._add.indexOf(u) !== -1 || this._active.indexOf(u) !== -1)
                        return this;
                    var d = this._pending.indexOf(u);
                    return d !== -1 && this._pending.splice(d, 1),
                    this._add.push(u),
                    u.state = l.PENDING_ADD,
                    this._toProcess++,
                    this
                },
                each: function(u, d) {
                    for (var v = [null], p = 1; p < arguments.length; p++)
                        v.push(arguments[p]);
                    for (var g in this.list)
                        v[0] = this.list[g],
                        u.apply(d, v)
                },
                getAllTweens: function() {
                    for (var u = this._active, d = [], v = 0; v < u.length; v++)
                        d.push(u[v]);
                    return d
                },
                getGlobalTimeScale: function() {
                    return this.timeScale
                },
                getTweensOf: function(u, d) {
                    d === void 0 && (d = !1);
                    var v = this._active, p, g = [], m, x;
                    for (Array.isArray(u) || (u = [u]),
                    m = 0; m < v.length; m++)
                        for (p = v[m],
                        x = 0; x < u.length; x++)
                            p.hasTarget(u[x]) && g.push(p);
                    if (d)
                        for (v = this._pending,
                        m = 0; m < v.length; m++)
                            for (p = v[m],
                            x = 0; x < u.length; x++)
                                p.hasTarget(u[x]) && g.push(p);
                    return g
                },
                isTweening: function(u) {
                    for (var d = this._active, v, p = 0; p < d.length; p++)
                        if (v = d[p],
                        v.hasTarget(u) && v.isPlaying())
                            return !0;
                    return !1
                },
                killAll: function() {
                    for (var u = this.getAllTweens(), d = 0; d < u.length; d++)
                        u[d].stop();
                    return this
                },
                killTweensOf: function(u) {
                    for (var d = this.getTweensOf(u), v = 0; v < d.length; v++)
                        d[v].stop();
                    return this
                },
                pauseAll: function() {
                    for (var u = this._active, d = 0; d < u.length; d++)
                        u[d].pause();
                    return this
                },
                resumeAll: function() {
                    for (var u = this._active, d = 0; d < u.length; d++)
                        u[d].resume();
                    return this
                },
                setGlobalTimeScale: function(u) {
                    return this.timeScale = u,
                    this
                },
                shutdown: function() {
                    this.killAll(),
                    this._add = [],
                    this._pending = [],
                    this._active = [],
                    this._destroy = [],
                    this._toProcess = 0;
                    var u = this.systems.events;
                    u.off(a.PRE_UPDATE, this.preUpdate, this),
                    u.off(a.UPDATE, this.update, this),
                    u.off(a.SHUTDOWN, this.shutdown, this)
                },
                destroy: function() {
                    this.shutdown(),
                    this.scene.sys.events.off(a.START, this.start, this),
                    this.scene = null,
                    this.systems = null
                }
            });
            o.register("TweenManager", h, "tweens"),
            c.exports = h
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Array: t(208),
                Base64: t(1482),
                Objects: t(1484),
                String: t(1488),
                NOOP: t(1)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                ArrayBufferToBase64: t(1483),
                Base64ToArrayBuffer: t(433)
            }
        }
        , function(c, S) {
            /**
 * @author       Niklas von Hertzen (https://github.com/niklasvh/base64-arraybuffer)
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
              , e = function(f, r) {
                for (var o = new Uint8Array(f), a = o.length, n = r ? "data:" + r + ";base64," : "", s = 0; s < a; s += 3)
                    n += t[o[s] >> 2],
                    n += t[(o[s] & 3) << 4 | o[s + 1] >> 4],
                    n += t[(o[s + 1] & 15) << 2 | o[s + 2] >> 6],
                    n += t[o[s + 2] & 63];
                return a % 3 === 2 ? n = n.substring(0, n.length - 1) + "=" : a % 3 === 1 && (n = n.substring(0, n.length - 2) + "=="),
                n
            };
            c.exports = e
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Clone: t(77),
                DeepCopy: t(175),
                Extend: t(17),
                GetAdvancedValue: t(13),
                GetFastValue: t(2),
                GetMinMaxValue: t(1485),
                GetValue: t(6),
                HasAll: t(1486),
                HasAny: t(455),
                HasValue: t(126),
                IsPlainObject: t(7),
                Merge: t(127),
                MergeRight: t(1487),
                Pick: t(571),
                SetValue: t(478)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(6)
              , f = t(18)
              , r = function(o, a, n, s, l) {
                l === void 0 && (l = n);
                var i = e(o, a, l);
                return f(i, n, s)
            };
            c.exports = r
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                for (var r = 0; r < f.length; r++)
                    if (!e.hasOwnProperty(f[r]))
                        return !1;
                return !0
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(77)
              , f = function(r, o) {
                var a = e(r);
                for (var n in o)
                    a.hasOwnProperty(n) && (a[n] = o[n]);
                return a
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Format: t(1489),
                Pad: t(186),
                RemoveAt: t(1490),
                Reverse: t(1491),
                UppercaseFirst: t(205),
                UUID: t(222)
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return e.replace(/%([0-9]+)/g, function(r, o) {
                    return f[Number(o) - 1]
                })
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e, f) {
                return f === 0 ? e.slice(1) : e.slice(0, f - 1) + e.slice(f)
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = function(e) {
                return e.split("").reverse().join("")
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                SoundManagerCreator: t(426),
                Events: t(70),
                BaseSound: t(146),
                BaseSoundManager: t(145),
                WebAudioSound: t(434),
                WebAudioSoundManager: t(432),
                HTML5AudioSound: t(429),
                HTML5AudioSoundManager: t(427),
                NoAudioSound: t(431),
                NoAudioSoundManager: t(430)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                Arcade: t(1366),
                Matter: t(1494)
            }
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = {
                BodyBounds: t(1392),
                Components: t(249),
                Events: t(272),
                Factory: t(1394),
                MatterGameObject: t(1395),
                Image: t(1396),
                Matter: t(594),
                MatterPhysics: t(1524),
                PolyDecomp: t(1393),
                Sprite: t(1397),
                TileBody: t(593),
                PhysicsEditorParser: t(589),
                PhysicsJSONParser: t(590),
                PointerConstraint: t(1398),
                World: t(1402)
            }
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                setBounce: function(e) {
                    return this.body.restitution = e,
                    this
                }
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                setCollisionCategory: function(e) {
                    return this.body.collisionFilter.category = e,
                    this
                },
                setCollisionGroup: function(e) {
                    return this.body.collisionFilter.group = e,
                    this
                },
                setCollidesWith: function(e) {
                    var f = 0;
                    if (!Array.isArray(e))
                        f = e;
                    else
                        for (var r = 0; r < e.length; r++)
                            f |= e[r];
                    return this.body.collisionFilter.mask = f,
                    this
                },
                setOnCollide: function(e) {
                    return this.body.onCollideCallback = e,
                    this
                },
                setOnCollideEnd: function(e) {
                    return this.body.onCollideEndCallback = e,
                    this
                },
                setOnCollideActive: function(e) {
                    return this.body.onCollideActiveCallback = e,
                    this
                },
                setOnCollideWith: function(e, f) {
                    Array.isArray(e) || (e = [e]);
                    for (var r = 0; r < e.length; r++) {
                        var o = e[r].hasOwnProperty("body") ? e[r].body : e[r];
                        this.body.setOnCollideWith(o, f)
                    }
                    return this
                }
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(41)
              , f = {
                applyForce: function(r) {
                    return this._tempVec2.set(this.body.position.x, this.body.position.y),
                    e.applyForce(this.body, this._tempVec2, r),
                    this
                },
                applyForceFrom: function(r, o) {
                    return e.applyForce(this.body, r, o),
                    this
                },
                thrust: function(r) {
                    var o = this.body.angle;
                    return this._tempVec2.set(r * Math.cos(o), r * Math.sin(o)),
                    e.applyForce(this.body, {
                        x: this.body.position.x,
                        y: this.body.position.y
                    }, this._tempVec2),
                    this
                },
                thrustLeft: function(r) {
                    var o = this.body.angle - Math.PI / 2;
                    return this._tempVec2.set(r * Math.cos(o), r * Math.sin(o)),
                    e.applyForce(this.body, {
                        x: this.body.position.x,
                        y: this.body.position.y
                    }, this._tempVec2),
                    this
                },
                thrustRight: function(r) {
                    var o = this.body.angle + Math.PI / 2;
                    return this._tempVec2.set(r * Math.cos(o), r * Math.sin(o)),
                    e.applyForce(this.body, {
                        x: this.body.position.x,
                        y: this.body.position.y
                    }, this._tempVec2),
                    this
                },
                thrustBack: function(r) {
                    var o = this.body.angle - Math.PI;
                    return this._tempVec2.set(r * Math.cos(o), r * Math.sin(o)),
                    e.applyForce(this.body, {
                        x: this.body.position.x,
                        y: this.body.position.y
                    }, this._tempVec2),
                    this
                }
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                setFriction: function(e, f, r) {
                    return this.body.friction = e,
                    f !== void 0 && (this.body.frictionAir = f),
                    r !== void 0 && (this.body.frictionStatic = r),
                    this
                },
                setFrictionAir: function(e) {
                    return this.body.frictionAir = e,
                    this
                },
                setFrictionStatic: function(e) {
                    return this.body.frictionStatic = e,
                    this
                }
            };
            c.exports = t
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                setIgnoreGravity: function(e) {
                    return this.body.ignoreGravity = e,
                    this
                }
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(41)
              , f = t(3)
              , r = {
                setMass: function(o) {
                    return e.setMass(this.body, o),
                    this
                },
                setDensity: function(o) {
                    return e.setDensity(this.body, o),
                    this
                },
                centerOfMass: {
                    get: function() {
                        return new f(this.body.centerOfMass.x,this.body.centerOfMass.y)
                    }
                }
            };
            c.exports = r
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                setSensor: function(e) {
                    return this.body.isSensor = e,
                    this
                },
                isSensor: function() {
                    return this.body.isSensor
                }
            };
            c.exports = t
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(86)
              , f = t(41)
              , r = t(124)
              , o = t(2)
              , a = t(589)
              , n = t(590)
              , s = t(64)
              , l = {
                setRectangle: function(i, h, u) {
                    return this.setBody({
                        type: "rectangle",
                        width: i,
                        height: h
                    }, u)
                },
                setCircle: function(i, h) {
                    return this.setBody({
                        type: "circle",
                        radius: i
                    }, h)
                },
                setPolygon: function(i, h, u) {
                    return this.setBody({
                        type: "polygon",
                        sides: h,
                        radius: i
                    }, u)
                },
                setTrapezoid: function(i, h, u, d) {
                    return this.setBody({
                        type: "trapezoid",
                        width: i,
                        height: h,
                        slope: u
                    }, d)
                },
                setExistingBody: function(i, h) {
                    h === void 0 && (h = !0),
                    this.body && this.world.remove(this.body, !0),
                    this.body = i;
                    for (var u = 0; u < i.parts.length; u++)
                        i.parts[u].gameObject = this;
                    var d = this;
                    if (i.destroy = function() {
                        d.world.remove(d.body, !0),
                        d.body.gameObject = null
                    }
                    ,
                    h && (this.world.has(i) && this.world.remove(i, !0),
                    this.world.add(i)),
                    this._originComponent) {
                        var v = i.render.sprite.xOffset
                          , p = i.render.sprite.yOffset
                          , g = i.centerOfMass.x
                          , m = i.centerOfMass.y;
                        if (r(g, .5) && r(m, .5))
                            this.setOrigin(v + .5, p + .5);
                        else {
                            var x = i.centerOffset.x
                              , T = i.centerOffset.y;
                            this.setOrigin(v + x / this.displayWidth, p + T / this.displayHeight)
                        }
                    }
                    return this
                },
                setBody: function(i, h) {
                    if (!i)
                        return this;
                    var u;
                    typeof i == "string" && (i = {
                        type: i
                    });
                    var d = o(i, "type", "rectangle")
                      , v = o(i, "x", this._tempVec2.x)
                      , p = o(i, "y", this._tempVec2.y)
                      , g = o(i, "width", this.width)
                      , m = o(i, "height", this.height);
                    switch (d) {
                    case "rectangle":
                        u = e.rectangle(v, p, g, m, h);
                        break;
                    case "circle":
                        var x = o(i, "radius", Math.max(g, m) / 2)
                          , T = o(i, "maxSides", 25);
                        u = e.circle(v, p, x, h, T);
                        break;
                    case "trapezoid":
                        var E = o(i, "slope", .5);
                        u = e.trapezoid(v, p, g, m, E, h);
                        break;
                    case "polygon":
                        var P = o(i, "sides", 5)
                          , M = o(i, "radius", Math.max(g, m) / 2);
                        u = e.polygon(v, p, P, M, h);
                        break;
                    case "fromVertices":
                    case "fromVerts":
                        var L = o(i, "verts", null);
                        if (L)
                            if (typeof L == "string" && (L = s.fromPath(L)),
                            this.body && !this.body.hasOwnProperty("temp"))
                                f.setVertices(this.body, L),
                                u = this.body;
                            else {
                                var R = o(i, "flagInternal", !1)
                                  , O = o(i, "removeCollinear", .01)
                                  , F = o(i, "minimumArea", 10);
                                u = e.fromVertices(v, p, L, h, R, O, F)
                            }
                        break;
                    case "fromPhysicsEditor":
                        u = a.parseBody(v, p, i, h);
                        break;
                    case "fromPhysicsTracer":
                        u = n.parseBody(v, p, i, h);
                        break
                    }
                    return u && this.setExistingBody(u, i.addToWorld),
                    this
                }
            };
            c.exports = l
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(272)
              , f = t(165)
              , r = t(166)
              , o = {
                setToSleep: function() {
                    return f.set(this.body, !0),
                    this
                },
                setAwake: function() {
                    return f.set(this.body, !1),
                    this
                },
                setSleepThreshold: function(a) {
                    return a === void 0 && (a = 60),
                    this.body.sleepThreshold = a,
                    this
                },
                setSleepEvents: function(a, n) {
                    return this.setSleepStartEvent(a),
                    this.setSleepEndEvent(n),
                    this
                },
                setSleepStartEvent: function(a) {
                    if (a) {
                        var n = this.world;
                        r.on(this.body, "sleepStart", function(s) {
                            n.emit(e.SLEEP_START, s, this)
                        })
                    } else
                        r.off(this.body, "sleepStart");
                    return this
                },
                setSleepEndEvent: function(a) {
                    if (a) {
                        var n = this.world;
                        r.on(this.body, "sleepEnd", function(s) {
                            n.emit(e.SLEEP_END, s, this)
                        })
                    } else
                        r.off(this.body, "sleepEnd");
                    return this
                }
            };
            c.exports = o
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "afteradd"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "afterremove"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "afterupdate"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "beforeadd"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "beforeremove"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "beforeupdate"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "collisionactive"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "collisionend"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "collisionstart"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "dragend"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "drag"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "dragstart"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "pause"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "resume"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "sleepend"
        }
        , function(c, S) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            c.exports = "sleepstart"
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(41)
              , f = {
                setStatic: function(r) {
                    return e.setStatic(this.body, r),
                    this
                },
                isStatic: function() {
                    return this.body.isStatic
                }
            };
            c.exports = f
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(41)
              , f = t(14)
              , r = t(269)
              , o = t(270)
              , a = 4
              , n = {
                x: {
                    get: function() {
                        return this.body.position.x
                    },
                    set: function(s) {
                        this._tempVec2.set(s, this.y),
                        e.setPosition(this.body, this._tempVec2)
                    }
                },
                y: {
                    get: function() {
                        return this.body.position.y
                    },
                    set: function(s) {
                        this._tempVec2.set(this.x, s),
                        e.setPosition(this.body, this._tempVec2)
                    }
                },
                scaleX: {
                    get: function() {
                        return this._scaleX
                    },
                    set: function(s) {
                        var l = 1 / this._scaleX
                          , i = 1 / this._scaleY;
                        this._scaleX = s,
                        this._scaleX === 0 ? this.renderFlags &= ~a : this.renderFlags |= a,
                        e.scale(this.body, l, i),
                        e.scale(this.body, s, this._scaleY)
                    }
                },
                scaleY: {
                    get: function() {
                        return this._scaleY
                    },
                    set: function(s) {
                        var l = 1 / this._scaleX
                          , i = 1 / this._scaleY;
                        this._scaleY = s,
                        this._scaleY === 0 ? this.renderFlags &= ~a : this.renderFlags |= a,
                        e.scale(this.body, l, i),
                        e.scale(this.body, this._scaleX, s)
                    }
                },
                angle: {
                    get: function() {
                        return o(this.body.angle * f.RAD_TO_DEG)
                    },
                    set: function(s) {
                        this.rotation = o(s) * f.DEG_TO_RAD
                    }
                },
                rotation: {
                    get: function() {
                        return this.body.angle
                    },
                    set: function(s) {
                        this._rotation = r(s),
                        e.setAngle(this.body, this._rotation)
                    }
                },
                setPosition: function(s, l) {
                    return s === void 0 && (s = 0),
                    l === void 0 && (l = s),
                    this._tempVec2.set(s, l),
                    e.setPosition(this.body, this._tempVec2),
                    this
                },
                setRotation: function(s) {
                    return s === void 0 && (s = 0),
                    this._rotation = r(s),
                    e.setAngle(this.body, s),
                    this
                },
                setFixedRotation: function() {
                    return e.setInertia(this.body, 1 / 0),
                    this
                },
                setAngle: function(s) {
                    return s === void 0 && (s = 0),
                    this.angle = s,
                    e.setAngle(this.body, this.rotation),
                    this
                },
                setScale: function(s, l, i) {
                    s === void 0 && (s = 1),
                    l === void 0 && (l = s);
                    var h = 1 / this._scaleX
                      , u = 1 / this._scaleY;
                    return this._scaleX = s,
                    this._scaleY = l,
                    e.scale(this.body, h, u, i),
                    e.scale(this.body, s, l, i),
                    this
                }
            };
            c.exports = n
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(41)
              , f = {
                setAngularVelocity: function(r) {
                    return e.setAngularVelocity(this.body, r),
                    this
                },
                setVelocityX: function(r) {
                    return this._tempVec2.set(r, this.body.velocity.y),
                    e.setVelocity(this.body, this._tempVec2),
                    this
                },
                setVelocityY: function(r) {
                    return this._tempVec2.set(this.body.velocity.x, r),
                    e.setVelocity(this.body, this._tempVec2),
                    this
                },
                setVelocity: function(r, o) {
                    return this._tempVec2.set(r, o),
                    e.setVelocity(this.body, this._tempVec2),
                    this
                }
            };
            c.exports = f
        }
        , function(c, S, t) {
            var e = {};
            c.exports = e;
            var f = t(118)
              , r = t(32);
            (function() {
                e.create = function(o) {
                    var a = {
                        extended: !1,
                        narrowDetections: 0,
                        narrowphaseTests: 0,
                        narrowReuse: 0,
                        narrowReuseCount: 0,
                        midphaseTests: 0,
                        broadphaseTests: 0,
                        narrowEff: 1e-4,
                        midEff: 1e-4,
                        broadEff: 1e-4,
                        collisions: 0,
                        buckets: 0,
                        bodies: 0,
                        pairs: 0
                    };
                    return r.extend(a, !1, o)
                }
                ,
                e.reset = function(o) {
                    o.extended && (o.narrowDetections = 0,
                    o.narrowphaseTests = 0,
                    o.narrowReuse = 0,
                    o.narrowReuseCount = 0,
                    o.midphaseTests = 0,
                    o.broadphaseTests = 0,
                    o.narrowEff = 0,
                    o.midEff = 0,
                    o.broadEff = 0,
                    o.collisions = 0,
                    o.buckets = 0,
                    o.pairs = 0,
                    o.bodies = 0)
                }
                ,
                e.update = function(o, a) {
                    if (o.extended) {
                        var n = a.world
                          , s = f.allBodies(n);
                        o.collisions = o.narrowDetections,
                        o.pairs = a.pairs.list.length,
                        o.bodies = s.length,
                        o.midEff = (o.narrowDetections / (o.midphaseTests || 1)).toFixed(2),
                        o.narrowEff = (o.narrowDetections / (o.narrowphaseTests || 1)).toFixed(2),
                        o.broadEff = (1 - o.broadphaseTests / (s.length || 1)).toFixed(2),
                        o.narrowReuse = (o.narrowReuseCount / (o.narrowphaseTests || 1)).toFixed(2)
                    }
                }
            }
            )()
        }
        , function(c, S, t) {
            /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var e = t(123)
              , f = t(271)
              , r = t(86)
              , o = t(41)
              , a = t(1392)
              , n = t(84)
              , s = t(0)
              , l = t(118)
              , i = t(591)
              , h = t(128)
              , u = t(273)
              , d = t(50)
              , v = t(1394)
              , p = t(2)
              , g = t(6)
              , m = t(597)
              , x = t(1525)
              , T = t(1526)
              , E = t(1399)
              , P = t(1527)
              , M = t(127)
              , L = t(250)
              , R = t(598)
              , O = t(595)
              , F = t(24)
              , B = t(1400)
              , N = t(599)
              , Y = t(274)
              , z = t(20)
              , W = t(592)
              , b = t(83)
              , D = t(64)
              , I = t(1402)
              , G = new s({
                initialize: function(U) {
                    this.scene = U,
                    this.systems = U.sys,
                    this.config = this.getConfig(),
                    this.world,
                    this.add,
                    this.bodyBounds,
                    this.body = o,
                    this.composite = l,
                    this.detector = u,
                    this.grid = m,
                    this.pair = L,
                    this.pairs = R,
                    this.query = B,
                    this.resolver = N,
                    this.sat = Y,
                    this.constraint = h,
                    this.bodies = r,
                    this.composites = i,
                    this.axes = f,
                    this.bounds = n,
                    this.svg = W,
                    this.vector = b,
                    this.vertices = D,
                    this.verts = D,
                    this._tempVec2 = b.create(),
                    g(this.config, "plugins.collisionevents", !0) && this.enableCollisionEventsPlugin(),
                    g(this.config, "plugins.attractors", !1) && this.enableAttractorPlugin(),
                    g(this.config, "plugins.wrap", !1) && this.enableWrapPlugin(),
                    N._restingThresh = g(this.config, "restingThresh", 4),
                    N._restingThreshTangent = g(this.config, "restingThreshTangent", 6),
                    N._positionDampen = g(this.config, "positionDampen", .9),
                    N._positionWarming = g(this.config, "positionWarming", .8),
                    N._frictionNormalMultiplier = g(this.config, "frictionNormalMultiplier", 5),
                    U.sys.events.once(z.BOOT, this.boot, this),
                    U.sys.events.on(z.START, this.start, this)
                },
                boot: function() {
                    this.world = new I(this.scene,this.config),
                    this.add = new v(this.world),
                    this.bodyBounds = new a,
                    this.systems.events.once(z.DESTROY, this.destroy, this)
                },
                start: function() {
                    this.world || (this.world = new I(this.scene,this.config),
                    this.add = new v(this.world));
                    var w = this.systems.events;
                    w.on(z.UPDATE, this.world.update, this.world),
                    w.on(z.POST_UPDATE, this.world.postUpdate, this.world),
                    w.once(z.SHUTDOWN, this.shutdown, this)
                },
                getConfig: function() {
                    var w = this.systems.game.config.physics
                      , U = this.systems.settings.physics
                      , X = M(p(U, "matter", {}), p(w, "matter", {}));
                    return X
                },
                enableAttractorPlugin: function() {
                    return O.register(x),
                    O.use(E, x),
                    this
                },
                enableWrapPlugin: function() {
                    return O.register(P),
                    O.use(E, P),
                    this
                },
                enableCollisionEventsPlugin: function() {
                    return O.register(T),
                    O.use(E, T),
                    this
                },
                pause: function() {
                    return this.world.pause()
                },
                resume: function() {
                    return this.world.resume()
                },
                set60Hz: function() {
                    return this.world.getDelta = this.world.update60Hz,
                    this.world.autoUpdate = !0,
                    this
                },
                set30Hz: function() {
                    return this.world.getDelta = this.world.update30Hz,
                    this.world.autoUpdate = !0,
                    this
                },
                step: function(w, U) {
                    this.world.step(w, U)
                },
                containsPoint: function(w, U, X) {
                    w = this.getMatterBodies(w);
                    var V = b.create(U, X)
                      , H = B.point(w, V);
                    return H.length > 0
                },
                intersectPoint: function(w, U, X) {
                    X = this.getMatterBodies(X);
                    var V = b.create(w, U)
                      , H = []
                      , J = B.point(X, V);
                    return J.forEach(function($) {
                        H.indexOf($) === -1 && H.push($)
                    }),
                    H
                },
                intersectRect: function(w, U, X, V, H, J) {
                    H === void 0 && (H = !1),
                    J = this.getMatterBodies(J);
                    var $ = {
                        min: {
                            x: w,
                            y: U
                        },
                        max: {
                            x: w + X,
                            y: U + V
                        }
                    }
                      , _ = []
                      , nt = B.region(J, $, H);
                    return nt.forEach(function(K) {
                        _.indexOf(K) === -1 && _.push(K)
                    }),
                    _
                },
                intersectRay: function(w, U, X, V, H, J) {
                    H === void 0 && (H = 1),
                    J = this.getMatterBodies(J);
                    for (var $ = [], _ = B.ray(J, b.create(w, U), b.create(X, V), H), nt = 0; nt < _.length; nt++)
                        $.push(_[nt].body);
                    return $
                },
                intersectBody: function(w, U) {
                    U = this.getMatterBodies(U);
                    for (var X = [], V = B.collides(w, U), H = 0; H < V.length; H++) {
                        var J = V[H];
                        J.bodyA === w ? X.push(J.bodyB) : X.push(J.bodyA)
                    }
                    return X
                },
                overlap: function(w, U, X, V, H) {
                    X === void 0 && (X = null),
                    V === void 0 && (V = null),
                    H === void 0 && (H = X),
                    Array.isArray(w) || (w = [w]),
                    w = this.getMatterBodies(w),
                    U = this.getMatterBodies(U);
                    for (var J = !1, $ = 0; $ < w.length; $++)
                        for (var _ = w[$], nt = B.collides(_, U), K = 0; K < nt.length; K++) {
                            var Z = nt[K]
                              , j = Z.bodyA.id === _.id ? Z.bodyB : Z.bodyA;
                            if (!V || V.call(H, _, j, Z)) {
                                if (J = !0,
                                X)
                                    X.call(H, _, j, Z);
                                else if (!V)
                                    return !0
                            }
                        }
                    return J
                },
                setCollisionCategory: function(w, U) {
                    return w = this.getMatterBodies(w),
                    w.forEach(function(X) {
                        X.collisionFilter.category = U
                    }),
                    this
                },
                setCollisionGroup: function(w, U) {
                    return w = this.getMatterBodies(w),
                    w.forEach(function(X) {
                        X.collisionFilter.group = U
                    }),
                    this
                },
                setCollidesWith: function(w, U) {
                    w = this.getMatterBodies(w);
                    var X = 0;
                    if (!Array.isArray(U))
                        X = U;
                    else
                        for (var V = 0; V < U.length; V++)
                            X |= U[V];
                    return w.forEach(function(H) {
                        H.collisionFilter.mask = X
                    }),
                    this
                },
                getMatterBodies: function(w) {
                    if (!w)
                        return this.world.getAllBodies();
                    Array.isArray(w) || (w = [w]);
                    for (var U = [], X = 0; X < w.length; X++) {
                        var V = w[X].hasOwnProperty("body") ? w[X].body : w[X];
                        U.push(V)
                    }
                    return U
                },
                setVelocity: function(w, U, X) {
                    w = this.getMatterBodies(w);
                    var V = this._tempVec2;
                    return V.x = U,
                    V.y = X,
                    w.forEach(function(H) {
                        o.setVelocity(H, V)
                    }),
                    this
                },
                setVelocityX: function(w, U) {
                    w = this.getMatterBodies(w);
                    var X = this._tempVec2;
                    return X.x = U,
                    w.forEach(function(V) {
                        X.y = V.velocity.y,
                        o.setVelocity(V, X)
                    }),
                    this
                },
                setVelocityY: function(w, U) {
                    w = this.getMatterBodies(w);
                    var X = this._tempVec2;
                    return X.y = U,
                    w.forEach(function(V) {
                        X.x = V.velocity.x,
                        o.setVelocity(V, X)
                    }),
                    this
                },
                setAngularVelocity: function(w, U) {
                    return w = this.getMatterBodies(w),
                    w.forEach(function(X) {
                        o.setAngularVelocity(X, U)
                    }),
                    this
                },
                applyForce: function(w, U) {
                    w = this.getMatterBodies(w);
                    var X = this._tempVec2;
                    return w.forEach(function(V) {
                        X.x = V.position.x,
                        X.y = V.position.y,
                        o.applyForce(V, X, U)
                    }),
                    this
                },
                applyForceFromPosition: function(w, U, X, V) {
                    w = this.getMatterBodies(w);
                    var H = this._tempVec2;
                    return w.forEach(function(J) {
                        V === void 0 && (V = J.angle),
                        H.x = X * Math.cos(V),
                        H.y = X * Math.sin(V),
                        o.applyForce(J, U, H)
                    }),
                    this
                },
                applyForceFromAngle: function(w, U, X) {
                    w = this.getMatterBodies(w);
                    var V = this._tempVec2;
                    return w.forEach(function(H) {
                        X === void 0 && (X = H.angle),
                        V.x = U * Math.cos(X),
                        V.y = U * Math.sin(X),
                        o.applyForce(H, {
                            x: H.position.x,
                            y: H.position.y
                        }, V)
                    }),
                    this
                },
                getConstraintLength: function(w) {
                    var U = w.pointA.x
                      , X = w.pointA.y
                      , V = w.pointB.x
                      , H = w.pointB.y;
                    return w.bodyA && (U += w.bodyA.position.x,
                    X += w.bodyA.position.y),
                    w.bodyB && (V += w.bodyB.position.x,
                    H += w.bodyB.position.y),
                    d(U, X, V, H)
                },
                alignBody: function(w, U, X, V) {
                    w = w.hasOwnProperty("body") ? w.body : w;
                    var H;
                    switch (V) {
                    case e.TOP_LEFT:
                    case e.LEFT_TOP:
                        H = this.bodyBounds.getTopLeft(w, U, X);
                        break;
                    case e.TOP_CENTER:
                        H = this.bodyBounds.getTopCenter(w, U, X);
                        break;
                    case e.TOP_RIGHT:
                    case e.RIGHT_TOP:
                        H = this.bodyBounds.getTopRight(w, U, X);
                        break;
                    case e.LEFT_CENTER:
                        H = this.bodyBounds.getLeftCenter(w, U, X);
                        break;
                    case e.CENTER:
                        H = this.bodyBounds.getCenter(w, U, X);
                        break;
                    case e.RIGHT_CENTER:
                        H = this.bodyBounds.getRightCenter(w, U, X);
                        break;
                    case e.LEFT_BOTTOM:
                    case e.BOTTOM_LEFT:
                        H = this.bodyBounds.getBottomLeft(w, U, X);
                        break;
                    case e.BOTTOM_CENTER:
                        H = this.bodyBounds.getBottomCenter(w, U, X);
                        break;
                    case e.BOTTOM_RIGHT:
                    case e.RIGHT_BOTTOM:
                        H = this.bodyBounds.getBottomRight(w, U, X);
                        break
                    }
                    return H && o.setPosition(w, H),
                    this
                },
                shutdown: function() {
                    var w = this.systems.events;
                    this.world && (w.off(z.UPDATE, this.world.update, this.world),
                    w.off(z.POST_UPDATE, this.world.postUpdate, this.world)),
                    w.off(z.SHUTDOWN, this.shutdown, this),
                    this.add && this.add.destroy(),
                    this.world && this.world.destroy(),
                    this.add = null,
                    this.world = null
                },
                destroy: function() {
                    this.shutdown(),
                    this.scene.sys.events.off(z.START, this.start, this),
                    this.scene = null,
                    this.systems = null
                }
            });
            F.register("MatterPhysics", G, "matterPhysics"),
            c.exports = G
        }
        , function(c, S, t) {
            var e = t(594)
              , f = {
                name: "matter-attractors",
                version: "0.1.7",
                for: "matter-js@^0.14.2",
                silent: !0,
                install: function(r) {
                    r.after("Body.create", function() {
                        f.Body.init(this)
                    }),
                    r.before("Engine.update", function(o) {
                        f.Engine.update(o)
                    })
                },
                Body: {
                    init: function(r) {
                        r.plugin.attractors = r.plugin.attractors || []
                    }
                },
                Engine: {
                    update: function(r) {
                        for (var o = e.Composite.allBodies(r.world), a = 0; a < o.length; a++) {
                            var n = o[a]
                              , s = n.plugin.attractors;
                            if (s && s.length > 0)
                                for (var l = 0; l < o.length; l++) {
                                    var i = o[l];
                                    if (a !== l)
                                        for (var h = 0; h < s.length; h++) {
                                            var u = s[h]
                                              , d = u;
                                            e.Common.isFunction(u) && (d = u(n, i)),
                                            d && e.Body.applyForce(i, i.position, d)
                                        }
                                }
                        }
                    }
                },
                Attractors: {
                    gravityConstant: .001,
                    gravity: function(r, o) {
                        var a = e.Vector.sub(o.position, r.position)
                          , n = e.Vector.magnitudeSquared(a) || 1e-4
                          , s = e.Vector.normalise(a)
                          , l = -f.Attractors.gravityConstant * (r.mass * o.mass / n)
                          , i = e.Vector.mult(s, l);
                        e.Body.applyForce(r, r.position, e.Vector.neg(i)),
                        e.Body.applyForce(o, o.position, i)
                    }
                }
            };
            c.exports = f
        }
        , function(c, S) {
            /**
 * @author       @dxu https://github.com/dxu/matter-collision-events
 * @author       Richard Davey <rich@photonstorm.com>
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
            var t = {
                name: "matter-collision-events",
                version: "0.1.6",
                for: "matter-js@^0.14.2",
                silent: !0,
                install: function(e) {
                    e.after("Engine.create", function() {
                        e.Events.on(this, "collisionStart", function(f) {
                            f.pairs.map(function(r) {
                                var o = r.bodyA
                                  , a = r.bodyB;
                                o.gameObject && o.gameObject.emit("collide", o, a, r),
                                a.gameObject && a.gameObject.emit("collide", a, o, r),
                                e.Events.trigger(o, "onCollide", {
                                    pair: r
                                }),
                                e.Events.trigger(a, "onCollide", {
                                    pair: r
                                }),
                                o.onCollideCallback && o.onCollideCallback(r),
                                a.onCollideCallback && a.onCollideCallback(r),
                                o.onCollideWith[a.id] && o.onCollideWith[a.id](a, r),
                                a.onCollideWith[o.id] && a.onCollideWith[o.id](o, r)
                            })
                        }),
                        e.Events.on(this, "collisionActive", function(f) {
                            f.pairs.map(function(r) {
                                var o = r.bodyA
                                  , a = r.bodyB;
                                o.gameObject && o.gameObject.emit("collideActive", o, a, r),
                                a.gameObject && a.gameObject.emit("collideActive", a, o, r),
                                e.Events.trigger(o, "onCollideActive", {
                                    pair: r
                                }),
                                e.Events.trigger(a, "onCollideActive", {
                                    pair: r
                                }),
                                o.onCollideActiveCallback && o.onCollideActiveCallback(r),
                                a.onCollideActiveCallback && a.onCollideActiveCallback(r)
                            })
                        }),
                        e.Events.on(this, "collisionEnd", function(f) {
                            f.pairs.map(function(r) {
                                var o = r.bodyA
                                  , a = r.bodyB;
                                o.gameObject && o.gameObject.emit("collideEnd", o, a, r),
                                a.gameObject && a.gameObject.emit("collideEnd", a, o, r),
                                e.Events.trigger(o, "onCollideEnd", {
                                    pair: r
                                }),
                                e.Events.trigger(a, "onCollideEnd", {
                                    pair: r
                                }),
                                o.onCollideEndCallback && o.onCollideEndCallback(r),
                                a.onCollideEndCallback && a.onCollideEndCallback(r)
                            })
                        })
                    })
                }
            };
            c.exports = t
        }
        , function(c, S, t) {
            var e = t(594)
              , f = {
                name: "matter-wrap",
                version: "0.1.4",
                for: "matter-js@^0.14.2",
                silent: !0,
                install: function(r) {
                    r.after("Engine.update", function() {
                        f.Engine.update(this)
                    })
                },
                Engine: {
                    update: function(r) {
                        for (var o = r.world, a = e.Composite.allBodies(o), n = e.Composite.allComposites(o), s = 0; s < a.length; s += 1) {
                            var l = a[s];
                            l.plugin.wrap && f.Body.wrap(l, l.plugin.wrap)
                        }
                        for (s = 0; s < n.length; s += 1) {
                            var i = n[s];
                            i.plugin.wrap && f.Composite.wrap(i, i.plugin.wrap)
                        }
                    }
                },
                Bounds: {
                    wrap: function(r, o) {
                        var a = null
                          , n = null;
                        if (typeof o.min.x < "u" && typeof o.max.x < "u" && (r.min.x > o.max.x ? a = o.min.x - r.max.x : r.max.x < o.min.x && (a = o.max.x - r.min.x)),
                        typeof o.min.y < "u" && typeof o.max.y < "u" && (r.min.y > o.max.y ? n = o.min.y - r.max.y : r.max.y < o.min.y && (n = o.max.y - r.min.y)),
                        a !== null || n !== null)
                            return {
                                x: a || 0,
                                y: n || 0
                            }
                    }
                },
                Body: {
                    wrap: function(r, o) {
                        var a = f.Bounds.wrap(r.bounds, o);
                        return a && e.Body.translate(r, a),
                        a
                    }
                },
                Composite: {
                    bounds: function(r) {
                        for (var o = e.Composite.allBodies(r), a = [], n = 0; n < o.length; n += 1) {
                            var s = o[n];
                            a.push(s.bounds.min, s.bounds.max)
                        }
                        return e.Bounds.create(a)
                    },
                    wrap: function(r, o) {
                        var a = f.Bounds.wrap(f.Composite.bounds(r), o);
                        return a && e.Composite.translate(r, a),
                        a
                    }
                }
            };
            c.exports = f
        }
        , function(c, S, t) {
            (function(e) {
                /**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2020 Photon Storm Ltd.
* @license      {@link https://opensource.org/licenses/MIT|MIT License}
*/
                var f = t(33)
                  , r = t(17)
                  , o = {
                    Actions: t(275),
                    Animations: t(723),
                    BlendModes: t(35),
                    Cache: t(735),
                    Cameras: t(738),
                    Core: t(806),
                    Class: t(0),
                    Create: t(888),
                    Curves: t(894),
                    Data: t(896),
                    Display: t(898),
                    DOM: t(917),
                    Events: t(918),
                    Game: t(920),
                    GameObjects: t(1011),
                    Geom: t(483),
                    Input: t(1308),
                    Loader: t(1338),
                    Math: t(193),
                    Physics: t(1493),
                    Plugins: t(1403),
                    Renderer: t(1405),
                    Scale: t(1412),
                    ScaleModes: t(168),
                    Scene: t(418),
                    Scenes: t(1413),
                    Structs: t(1415),
                    Textures: t(1416),
                    Tilemaps: t(1418),
                    Time: t(1461),
                    Tweens: t(1463),
                    Utils: t(1481)
                };
                o.Sound = t(1492),
                o = r(!1, o, f),
                c.exports = o,
                e.Phaser = o
            }
            ).call(this, t(600))
        }
        ])
    })
}
)(Ho);
const De = Yr(Nn);
let kt;
typeof window > "u" ? kt = require("crypto").webcrypto : kt = window.crypto;
function bo(C, A) {
    var c = new Uint8Array(C.byteLength + A.byteLength);
    return c.set(new Uint8Array(C), 0),
    c.set(new Uint8Array(A), C.byteLength),
    c.buffer
}
class game_Ko {
    constructor() {
        pt(this, "ecAlgo");
        pt(this, "sharedKey");
        this.ecAlgo = {
            name: "ECDH",
            namedCurve: "P-256"
        }
    }
    exchange(A, c) {
        return kt.subtle.deriveKey({
            name: "ECDH",
            public: A
        }, c, {
            name: "AES-GCM",
            length: 256
        }, !0, ["encrypt", "decrypt"])
    }
    async initServer(A) {
        const c = await kt.subtle.generateKey(this.ecAlgo, !0, ["deriveKey"])
          , S = await kt.subtle.exportKey("raw", c.publicKey);
        return await new Promise(t=>A.once("message", t)),
        A.send("done"),
        new Promise(t=>{
            A.once("message", async e=>{
                const f = await kt.subtle.importKey("raw", e, this.ecAlgo, !0, []);
                this.sharedKey = await this.exchange(f, c.privateKey),
                t(0)
            }
            ),
            A.send(S)
        }
        )
    }
    async initClient(A) {
        const c = await kt.subtle.generateKey(this.ecAlgo, !0, ["deriveKey"])
          , S = await kt.subtle.exportKey("raw", c.publicKey);
        return A.send("done"),
        await new Promise(t=>A.addEventListener("message", t, {
            once: !0
        })),
        new Promise(t=>{
            A.addEventListener("message", async e=>{
                const f = await kt.subtle.importKey("raw", e.data, this.ecAlgo, !0, []);
                this.sharedKey = await this.exchange(f, c.privateKey),
                t(0)
            }
            , {
                once: !0
            }),
            A.send(S)
        }
        )
    }
    async parse(A) {
        const c = new Uint8Array(A,0,12)
          , S = new Uint8Array(A,12)
          , t = await kt.subtle.decrypt({
            name: "AES-GCM",
            iv: c
        }, this.sharedKey, S);
        return JSON.parse(new TextDecoder().decode(t))
    }
    async stringify(A) { 
        const c = new TextEncoder().encode(JSON.stringify(A))
          , S = kt.getRandomValues(new Uint8Array(12))
          , t = await kt.subtle.encrypt({
            name: "AES-GCM",
            iv: S
        }, this.sharedKey, c);
        return bo(S.buffer, t)
    }
}
var wn = {}
  , Zo = {
    get exports() {
        return wn
    },
    set exports(C) {
        wn = C
    }
};
(function(C, A) {
    (function(c, S) {
        C.exports = S()
    }
    )(self, function() {
        return function() {
            var c = {
                880: function(e, f, r) {
                    function o(u) {
                        return o = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
                            return typeof d
                        }
                        : function(d) {
                            return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d
                        }
                        ,
                        o(u)
                    }
                    function a(u, d) {
                        for (var v = 0; v < d.length; v++) {
                            var p = d[v];
                            p.enumerable = p.enumerable || !1,
                            p.configurable = !0,
                            "value"in p && (p.writable = !0),
                            Object.defineProperty(u, (g = p.key,
                            m = void 0,
                            m = function(x, T) {
                                if (o(x) !== "object" || x === null)
                                    return x;
                                var E = x[Symbol.toPrimitive];
                                if (E !== void 0) {
                                    var P = E.call(x, T || "default");
                                    if (o(P) !== "object")
                                        return P;
                                    throw new TypeError("@@toPrimitive must return a primitive value.")
                                }
                                return (T === "string" ? String : Number)(x)
                            }(g, "string"),
                            o(m) === "symbol" ? m : String(m)), p)
                        }
                        var g, m
                    }
                    function n(u, d) {
                        return n = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(v, p) {
                            return v.__proto__ = p,
                            v
                        }
                        ,
                        n(u, d)
                    }
                    function s(u) {
                        var d = function() {
                            if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
                                return !1;
                            if (typeof Proxy == "function")
                                return !0;
                            try {
                                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})),
                                !0
                            } catch {
                                return !1
                            }
                        }();
                        return function() {
                            var v, p = i(u);
                            if (d) {
                                var g = i(this).constructor;
                                v = Reflect.construct(p, arguments, g)
                            } else
                                v = p.apply(this, arguments);
                            return l(this, v)
                        }
                    }
                    function l(u, d) {
                        if (d && (o(d) === "object" || typeof d == "function"))
                            return d;
                        if (d !== void 0)
                            throw new TypeError("Derived constructors may only return object or undefined");
                        return function(v) {
                            if (v === void 0)
                                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                            return v
                        }(u)
                    }
                    function i(u) {
                        return i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(d) {
                            return d.__proto__ || Object.getPrototypeOf(d)
                        }
                        ,
                        i(u)
                    }
                    /**
* @author       Marcin Walczak <contact@marcin-walczak.pl>
* @copyright    2022 Marcin Walczak
* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}
*/
                    var h = function(u) {
                        (function(m, x) {
                            if (typeof x != "function" && x !== null)
                                throw new TypeError("Super expression must either be null or a function");
                            m.prototype = Object.create(x && x.prototype, {
                                constructor: {
                                    value: m,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            Object.defineProperty(m, "prototype", {
                                writable: !1
                            }),
                            x && n(m, x)
                        }
                        )(g, Phaser.Plugins.ScenePlugin);
                        var d, v, p = s(g);
                        function g(m, x) {
                            var T;
                            return function(E, P) {
                                if (!(E instanceof P))
                                    throw new TypeError("Cannot call a class as a function")
                            }(this, g),
                            (T = p.call(this, m, x))._Raycaster = r(741).i,
                            T
                        }
                        return d = g,
                        v = [{
                            key: "createRaycaster",
                            value: function() {
                                var m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                                return m.scene = this.scene,
                                new this._Raycaster(m)
                            }
                        }],
                        v && a(d.prototype, v),
                        Object.defineProperty(d, "prototype", {
                            writable: !1
                        }),
                        g
                    }();
                    e.exports = h
                },
                933: function(e, f, r) {
                    function o() {
                        return this.object.getBounds()
                    }
                    r.r(f),
                    r.d(f, {
                        getBoundingBox: function() {
                            return o
                        }
                    })
                },
                163: function(e, f, r) {
                    r.d(f, {
                        v: function() {
                            return v
                        }
                    });
                    var o = r(812)
                      , a = r(840)
                      , n = r(121)
                      , s = r(530)
                      , l = r(99)
                      , i = r(724)
                      , h = r(739)
                      , u = r(98)
                      , d = r(933);
                    function v(p) {
                        switch (this.object = p.object,
                        p.type === void 0 && (p.type = p.object.type),
                        p.type !== "body" && p.type !== "composite" || (p.type = "MatterBody"),
                        this.type = p.type,
                        p.type) {
                        case "Polygon":
                            this.getPoints = n.getPoints,
                            this.getSegments = n.getSegments,
                            this.getBoundingBox = d.getBoundingBox,
                            this.updateMap = n.updateMap;
                            break;
                        case "Arc":
                            this.segmentCount = p.segmentCount ? p.segmentCount : 0,
                            this.circle = !p.segmentCount,
                            this.getPoints = s.getPoints,
                            this.getSegments = s.getSegments,
                            this.getBoundingBox = d.getBoundingBox,
                            this.updateMap = s.updateMap,
                            this.setSegmentCount = u.setSegmentCount;
                            break;
                        case "Line":
                            this.getPoints = a.getPoints,
                            this.getSegments = a.getSegments,
                            this.getBoundingBox = d.getBoundingBox,
                            this.updateMap = a.updateMap;
                            break;
                        case "Container":
                            this.mapChild = p.mapChild ? p.mapChild : null,
                            this.segmentCount = p.segmentCount ? p.segmentCount : 0,
                            this._circles = [],
                            this.getPoints = l.getPoints,
                            this.getSegments = l.getSegments,
                            this.getBoundingBox = d.getBoundingBox,
                            this.updateMap = l.updateMap,
                            this._updateChildMap = l._updateChildMap,
                            this.setSegmentCount = u.setSegmentCount;
                            break;
                        case "StaticTilemapLayer":
                        case "DynamicTilemapLayer":
                        case "TilemapLayer":
                            this.collisionTiles = p.collisionTiles ? p.collisionTiles : [],
                            this.getPoints = i.getPoints,
                            this.getSegments = i.getSegments,
                            this.getBoundingBox = d.getBoundingBox,
                            this.updateMap = i.updateMap,
                            this.setCollisionTiles = i.setCollisionTiles,
                            this.object.setOrigin(0, 0);
                            break;
                        case "MatterBody":
                            this.forceConvex = !!p.forceConvex,
                            this.forceVerticesMapping = !!p.forceVerticesMapping,
                            this.circle = !1,
                            this.getPoints = h.getPoints,
                            this.getSegments = h.getSegments,
                            this.getBoundingBox = h.getBoundingBox,
                            this.updateMap = h.updateMap;
                            break;
                        default:
                            this.getPoints = o.getPoints,
                            this.getSegments = o.getSegments,
                            this.getBoundingBox = d.getBoundingBox,
                            this.updateMap = o.updateMap
                        }
                        return this.type != "MatterBody" && typeof this.object.getBounds != "function" && (this.notSupported = !0),
                        this.dynamic = p.dynamic == 1,
                        this.active = p.active === void 0 || p.active,
                        this
                    }
                },
                6: function(e, f, r) {
                    function o() {
                        for (var a in this.object.type === "body" || this.object.type === "composite" ? delete object.raycasterMap : this.object.data && this.object.data.remove("raycasterMap"),
                        this)
                            delete this[a]
                    }
                    r.d(f, {
                        o: function() {
                            return o
                        }
                    })
                },
                530: function(e, f, r) {
                    function o(i, h) {
                        var u = typeof Symbol < "u" && i[Symbol.iterator] || i["@@iterator"];
                        if (!u) {
                            if (Array.isArray(i) || (u = function(x, T) {
                                if (x) {
                                    if (typeof x == "string")
                                        return a(x, T);
                                    var E = Object.prototype.toString.call(x).slice(8, -1);
                                    if (E === "Object" && x.constructor && (E = x.constructor.name),
                                    E === "Map" || E === "Set")
                                        return Array.from(x);
                                    if (E === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(E))
                                        return a(x, T)
                                }
                            }(i)) || h && i && typeof i.length == "number") {
                                u && (i = u);
                                var d = 0
                                  , v = function() {};
                                return {
                                    s: v,
                                    n: function() {
                                        return d >= i.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: i[d++]
                                        }
                                    },
                                    e: function(x) {
                                        throw x
                                    },
                                    f: v
                                }
                            }
                            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                        }
                        var p, g = !0, m = !1;
                        return {
                            s: function() {
                                u = u.call(i)
                            },
                            n: function() {
                                var x = u.next();
                                return g = x.done,
                                x
                            },
                            e: function(x) {
                                m = !0,
                                p = x
                            },
                            f: function() {
                                try {
                                    g || u.return == null || u.return()
                                } finally {
                                    if (m)
                                        throw p
                                }
                            }
                        }
                    }
                    function a(i, h) {
                        (h == null || h > i.length) && (h = i.length);
                        for (var u = 0, d = new Array(h); u < h; u++)
                            d[u] = i[u];
                        return d
                    }
                    function n() {
                        var i = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
                        if (!this.active)
                            return [];
                        if (this._points.length > 0)
                            return this._points;
                        var h = []
                          , u = new Phaser.Geom.Point;
                        if (u.x = this.object.x - this.object.displayWidth * (this.object.originX - .5),
                        u.y = this.object.y - this.object.displayHeight * (this.object.originY - .5),
                        i) {
                            var d, v = new Phaser.Geom.Line, p = new Phaser.Geom.Line, g = this.object.rotation;
                            if (g !== 0) {
                                var m = new Phaser.Geom.Line(this.object.x,this.object.y,u.x,u.y);
                                Phaser.Geom.Line.SetToAngle(m, this.object.x, this.object.y, Phaser.Geom.Line.Angle(m) + g, Phaser.Geom.Line.Length(m));
                                var x = m.getPointB();
                                d = new Phaser.Geom.Line(i.origin.x,i.origin.y,x.x,x.y)
                            } else
                                d = new Phaser.Geom.Line(i.origin.x,i.origin.y,u.x,u.y);
                            var T = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(d), 2) - Math.pow(this.object.radius * this.object.scaleX, 2))
                              , E = Phaser.Geom.Line.Angle(d)
                              , P = Math.asin(this.object.radius * this.object.scaleX / Phaser.Geom.Line.Length(d));
                            Phaser.Geom.Line.SetToAngle(v, i.origin.x, i.origin.y, E - P, T),
                            Phaser.Geom.Line.SetToAngle(p, i.origin.x, i.origin.y, E + P, T),
                            h.push(v.getPointB()),
                            h.push(p.getPointB())
                        }
                        return h
                    }
                    function s() {
                        return this.active ? this._segments : []
                    }
                    function l() {
                        if (!this.active)
                            return this;
                        if (!this.segmentCount)
                            return this._points = [],
                            this._segments = [],
                            this;
                        var i = new Phaser.Geom.Point;
                        i.x = this.object.x - this.object.displayWidth * this.object.originX + this.object.radius * this.object.scaleX,
                        i.y = this.object.y - this.object.displayHeight * this.object.originY + this.object.radius * this.object.scaleY;
                        var h = this.object.geom.getPoints(this.segmentCount)
                          , u = []
                          , d = this.object.rotation;
                        if (d !== 0) {
                            var v, p = [], g = o(h);
                            try {
                                for (g.s(); !(v = g.n()).done; ) {
                                    var m = v.value
                                      , x = new Phaser.Geom.Line(this.object.x,this.object.y,this.object.x + (m.x + this.object.radius) * this.object.scaleX,this.object.y + (m.y + this.object.radius) * this.object.scaleY);
                                    Phaser.Geom.Line.SetToAngle(x, this.object.x, this.object.y, Phaser.Geom.Line.Angle(x) + d, Phaser.Geom.Line.Length(x)),
                                    p.push(x.getPointB())
                                }
                            } catch (R) {
                                g.e(R)
                            } finally {
                                g.f()
                            }
                            h = p
                        } else {
                            var T, E = o(h);
                            try {
                                for (E.s(); !(T = E.n()).done; ) {
                                    var P = T.value;
                                    P.x = P.x * this.object.scaleX + i.x,
                                    P.y = P.y * this.object.scaleY + i.y
                                }
                            } catch (R) {
                                E.e(R)
                            } finally {
                                E.f()
                            }
                        }
                        for (var M = 0, L = h.length; M < L; M++)
                            M + 1 < L ? u.push(new Phaser.Geom.Line(h[M].x,h[M].y,h[M + 1].x,h[M + 1].y)) : u.push(new Phaser.Geom.Line(h[M].x,h[M].y,h[0].x,h[0].y));
                        return this._points = h,
                        this._segments = u,
                        this
                    }
                    r.r(f),
                    r.d(f, {
                        getPoints: function() {
                            return n
                        },
                        getSegments: function() {
                            return s
                        },
                        updateMap: function() {
                            return l
                        }
                    })
                },
                99: function(e, f, r) {
                    function o(h, u) {
                        var d = typeof Symbol < "u" && h[Symbol.iterator] || h["@@iterator"];
                        if (!d) {
                            if (Array.isArray(h) || (d = function(T, E) {
                                if (T) {
                                    if (typeof T == "string")
                                        return a(T, E);
                                    var P = Object.prototype.toString.call(T).slice(8, -1);
                                    if (P === "Object" && T.constructor && (P = T.constructor.name),
                                    P === "Map" || P === "Set")
                                        return Array.from(T);
                                    if (P === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(P))
                                        return a(T, E)
                                }
                            }(h)) || u && h && typeof h.length == "number") {
                                d && (h = d);
                                var v = 0
                                  , p = function() {};
                                return {
                                    s: p,
                                    n: function() {
                                        return v >= h.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: h[v++]
                                        }
                                    },
                                    e: function(T) {
                                        throw T
                                    },
                                    f: p
                                }
                            }
                            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                        }
                        var g, m = !0, x = !1;
                        return {
                            s: function() {
                                d = d.call(h)
                            },
                            n: function() {
                                var T = d.next();
                                return m = T.done,
                                T
                            },
                            e: function(T) {
                                x = !0,
                                g = T
                            },
                            f: function() {
                                try {
                                    m || d.return == null || d.return()
                                } finally {
                                    if (x)
                                        throw g
                                }
                            }
                        }
                    }
                    function a(h, u) {
                        (u == null || u > h.length) && (u = h.length);
                        for (var d = 0, v = new Array(u); d < u; d++)
                            v[d] = h[d];
                        return v
                    }
                    function n() {
                        var h = arguments.length > 0 && arguments[0] !== void 0 && arguments[0]
                          , u = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
                        if (!this.active)
                            return [];
                        var d = this._points
                          , v = new Phaser.Geom.Point;
                        if (v.x = this.object.x - this.object.displayWidth * this.object.originX,
                        v.y = this.object.y - this.object.displayHeight * this.object.originY,
                        this.segmentCount == 0 && !u && h) {
                            var p = new Phaser.Geom.Line(0,0,h.origin.x - v.x,h.origin.y - v.y);
                            Phaser.Geom.Line.SetToAngle(p, 0, 0, Phaser.Geom.Line.Angle(p) - this.object.rotation, Phaser.Geom.Line.Length(p)),
                            h._raycaster.createRay({
                                origin: {
                                    x: p.getPointB().x,
                                    y: p.getPointB().y
                                }
                            });
                            var g, m, x = new Phaser.Geom.Line, T = new Phaser.Geom.Line, E = o(this._circles);
                            try {
                                for (E.s(); !(m = E.n()).done; ) {
                                    var P = m.value;
                                    P.points = [],
                                    g = new Phaser.Geom.Line(h.origin.x,h.origin.y,P.x,P.y);
                                    var M = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(g), 2) - Math.pow(P.radius, 2))
                                      , L = Phaser.Geom.Line.Angle(g)
                                      , R = Math.asin(P.radius / Phaser.Geom.Line.Length(g));
                                    Phaser.Geom.Line.SetToAngle(x, h.origin.x, h.origin.y, L - R, M),
                                    Phaser.Geom.Line.SetToAngle(T, h.origin.x, h.origin.y, L + R, M),
                                    P.points.push(x.getPointB()),
                                    P.points.push(T.getPointB()),
                                    d.push(x.getPointB()),
                                    d.push(T.getPointB())
                                }
                            } catch (O) {
                                E.e(O)
                            } finally {
                                E.f()
                            }
                        }
                        return d
                    }
                    function s() {
                        return this.active ? this._segments : []
                    }
                    function l() {
                        if (!this.active)
                            return this;
                        var h = []
                          , u = []
                          , d = this.object;
                        this._circles = [];
                        var v = new Phaser.Geom.Point;
                        v.x = this.object.x - this.object.displayWidth * this.object.originX,
                        v.y = this.object.y - this.object.displayHeight * this.object.originY;
                        var p = d.rotation;
                        if (this.mapChild)
                            this._updateChildMap(this.mapChild, h, u, p, v);
                        else {
                            d.iterate(function(b) {
                                this._updateChildMap(b, h, u, p, v)
                            }
                            .bind(this));
                            for (var g = 0, m = d.list.length; g < m; g++) {
                                var x = d.list[g]
                                  , T = x.data.get("raycasterMap");
                                if (T)
                                    for (var E = g + 1, P = d.list.length; E < P; E++) {
                                        var M = d.list[E]
                                          , L = M.data.get("raycasterMap");
                                        if (L && Phaser.Geom.Intersects.RectangleToRectangle(x.getBounds(), M.getBounds())) {
                                            var R, O = o(T.getSegments());
                                            try {
                                                for (O.s(); !(R = O.n()).done; ) {
                                                    var F, B = R.value, N = o(L.getSegments());
                                                    try {
                                                        for (N.s(); !(F = N.n()).done; ) {
                                                            var Y = F.value
                                                              , z = [];
                                                            if (Phaser.Geom.Intersects.LineToLine(B, Y, z))
                                                                if (p !== 0) {
                                                                    var W = new Phaser.Geom.Line(d.x,d.y,z.x * d.scaleX + v.x,z.y * d.scaleY + v.y);
                                                                    Phaser.Geom.Line.SetToAngle(W, this.object.x, this.object.y, Phaser.Geom.Line.Angle(W) + p, Phaser.Geom.Line.Length(W)),
                                                                    h.push(W.getPointB())
                                                                } else
                                                                    h.push(new Phaser.Geom.Point(z.x * d.scaleX + v.x,z.y * d.scaleX + v.y))
                                                        }
                                                    } catch (b) {
                                                        N.e(b)
                                                    } finally {
                                                        N.f()
                                                    }
                                                }
                                            } catch (b) {
                                                O.e(b)
                                            } finally {
                                                O.f()
                                            }
                                        }
                                    }
                            }
                        }
                        return this._points = h,
                        this._segments = u,
                        this
                    }
                    function i(h, u, d, v, p) {
                        if (h.data || h.setDataEnabled(),
                        !h.data.get("raycasterMapNotSupported")) {
                            var g = h.data.get("raycasterMap");
                            if (g)
                                g.updateMap();
                            else {
                                if ((g = new this.constructor({
                                    object: h,
                                    segmentCount: this.segmentCount
                                })).notSupported)
                                    return g.destroy(),
                                    void h.data.set("raycasterMapNotSupported", !0);
                                h.data.set("raycasterMap", g)
                            }
                            var m, x = [], T = o(g.getPoints(!1, !0));
                            try {
                                for (T.s(); !(m = T.n()).done; ) {
                                    var E = m.value;
                                    if (v !== 0) {
                                        var P = new Phaser.Geom.Line(this.object.x,this.object.y,E.x * this.object.scaleX + p.x,E.y * this.object.scaleY + p.y);
                                        Phaser.Geom.Line.SetToAngle(P, this.object.x, this.object.y, Phaser.Geom.Line.Angle(P) + v, Phaser.Geom.Line.Length(P)),
                                        u.push(P.getPointB())
                                    } else
                                        u.push(new Phaser.Geom.Point(E.x * this.object.scaleX + p.x,E.y * this.object.scaleX + p.y));
                                    x.push(u[u.length - 1])
                                }
                            } catch (w) {
                                T.e(w)
                            } finally {
                                T.f()
                            }
                            var M, L = o(g.getSegments());
                            try {
                                for (L.s(); !(M = L.n()).done; ) {
                                    var R = M.value;
                                    if (v !== 0) {
                                        var O = R.getPointA()
                                          , F = R.getPointB()
                                          , B = new Phaser.Geom.Line(this.object.x,this.object.y,O.x * this.object.scaleX + p.x,O.y * this.object.scaleY + p.y)
                                          , N = new Phaser.Geom.Line(this.object.x,this.object.y,F.x * this.object.scaleX + p.x,F.y * this.object.scaleY + p.y);
                                        Phaser.Geom.Line.SetToAngle(B, this.object.x, this.object.y, Phaser.Geom.Line.Angle(B) + v, Phaser.Geom.Line.Length(B)),
                                        Phaser.Geom.Line.SetToAngle(N, this.object.x, this.object.y, Phaser.Geom.Line.Angle(N) + v, Phaser.Geom.Line.Length(N)),
                                        d.push(new Phaser.Geom.Line(B.getPointB().x,B.getPointB().y,N.getPointB().x,N.getPointB().y))
                                    } else
                                        d.push(new Phaser.Geom.Line(R.getPointA().x * this.object.scaleX + p.x,R.getPointA().y * this.object.scaleY + p.y,R.getPointB().x * this.object.scaleX + p.x,R.getPointB().y * this.object.scaleY + p.y))
                                }
                            } catch (w) {
                                L.e(w)
                            } finally {
                                L.f()
                            }
                            if (g.type == "Arc" && this.segmentCount == 0) {
                                var Y = new Phaser.Geom.Point;
                                if (Y.x = (g.object.x - g.object.displayWidth * (g.object.originX - .5)) * this.object.scaleX + p.x,
                                Y.y = (g.object.y - g.object.displayHeight * (g.object.originY - .5)) * this.object.scaleY + p.y,
                                v !== 0) {
                                    var z = new Phaser.Geom.Line(this.object.x,this.object.y,Y.x,Y.y);
                                    Phaser.Geom.Line.SetToAngle(z, this.object.x, this.object.y, Phaser.Geom.Line.Angle(z) + v, Phaser.Geom.Line.Length(z)),
                                    Y = z.getPointB()
                                }
                                this._circles.push(new Phaser.Geom.Circle(Y.x,Y.y,g.object.radius * g.object.scaleX * this.object.scaleX))
                            } else if (g.type === "Container") {
                                var W, b = o(g._circles);
                                try {
                                    for (b.s(); !(W = b.n()).done; ) {
                                        var D = W.value
                                          , I = new Phaser.Geom.Point;
                                        if (I.x = D.x * this.object.scaleX + p.x,
                                        I.y = D.y * this.object.scaleY + p.y,
                                        v !== 0) {
                                            var G = new Phaser.Geom.Line(this.object.x,this.object.y,I.x,I.y);
                                            Phaser.Geom.Line.SetToAngle(G, this.object.x, this.object.y, Phaser.Geom.Line.Angle(G) + v, Phaser.Geom.Line.Length(G)),
                                            I = G.getPointB()
                                        }
                                        this._circles.push(new Phaser.Geom.Circle(I.x,I.y,D.radius * this.object.scaleX))
                                    }
                                } catch (w) {
                                    b.e(w)
                                } finally {
                                    b.f()
                                }
                            }
                        }
                    }
                    r.r(f),
                    r.d(f, {
                        _updateChildMap: function() {
                            return i
                        },
                        getPoints: function() {
                            return n
                        },
                        getSegments: function() {
                            return s
                        },
                        updateMap: function() {
                            return l
                        }
                    })
                },
                667: function(e, f, r) {
                    function o(a, n) {
                        return this._raycaster = n || !1,
                        this.type,
                        this.active,
                        this._dynamic = !1,
                        this.circle = !1,
                        this.object,
                        this._points = [],
                        this._segments = [],
                        this.getPoints,
                        this.getSegments,
                        this.getBoundingBox,
                        this.updateMap,
                        this.config(a),
                        this.notSupported || this.updateMap(),
                        this
                    }
                    r.d(f, {
                        D: function() {
                            return o
                        }
                    }),
                    o.prototype = {
                        config: r(163).v,
                        destroy: r(6).o,
                        get dynamic() {
                            return this._dynamic
                        },
                        set dynamic(a) {
                            if (this._dynamic == a)
                                return this;
                            if (a)
                                this._dynamic = !0,
                                this._raycaster && (this._raycaster.dynamicMappedObjects.push(this.object),
                                this._raycaster._stats.mappedObjects.dynamic = this._raycaster.dynamicMappedObjects.length,
                                this._raycaster._stats.mappedObjects.static = this._raycaster._stats.mappedObjects.total - this._raycaster._stats.mappedObjects.dynamic);
                            else if (this._dynamic = !1,
                            this._raycaster) {
                                var n = this._raycaster.dynamicMappedObjects.indexOf(this.object);
                                n >= 0 && this._raycaster.dynamicMappedObjects.splice(n, 1),
                                this._raycaster._stats.mappedObjects.dynamic = this._raycaster.dynamicMappedObjects.length,
                                this._raycaster._stats.mappedObjects.static = this._raycaster._stats.mappedObjects.total - this._raycaster._stats.mappedObjects.dynamic
                            }
                            return this
                        }
                    },
                    o.prototype.constructor = o
                },
                840: function(e, f, r) {
                    function o() {
                        return this.active ? this._points : []
                    }
                    function a() {
                        return this.active ? this._segments : []
                    }
                    function n() {
                        if (!this.active)
                            return this;
                        var s = []
                          , l = []
                          , i = new Phaser.Geom.Point;
                        i.x = this.object.x - this.object.displayWidth * this.object.originX,
                        i.y = this.object.y - this.object.displayHeight * this.object.originY;
                        var h = this.object.geom.getPointA()
                          , u = this.object.geom.getPointB()
                          , d = this.object.rotation;
                        if (d !== 0) {
                            var v = new Phaser.Geom.Line(this.object.x,this.object.y,h.x * this.object.scaleX + i.x,h.y * this.object.scaleY + i.y);
                            Phaser.Geom.Line.SetToAngle(v, this.object.x, this.object.y, Phaser.Geom.Line.Angle(v) + d, Phaser.Geom.Line.Length(v)),
                            h = v.getPointB();
                            var p = new Phaser.Geom.Line(this.object.x,this.object.y,u.x * this.object.scaleX + i.x,u.y * this.object.scaleY + i.y);
                            Phaser.Geom.Line.SetToAngle(p, this.object.x, this.object.y, Phaser.Geom.Line.Angle(p) + d, Phaser.Geom.Line.Length(p)),
                            u = p.getPointB(),
                            s.push(new Phaser.Geom.Point(h.x,h.y)),
                            s.push(new Phaser.Geom.Point(u.x,u.y)),
                            l.push(new Phaser.Geom.Line(h.x,h.y,u.x,u.y))
                        } else
                            s.push(new Phaser.Geom.Point(h.x * this.object.scaleX + i.x,h.y * this.object.scaleY + i.y)),
                            s.push(new Phaser.Geom.Point(u.x * this.object.scaleX + i.x,u.y * this.object.scaleY + i.y)),
                            l.push(new Phaser.Geom.Line(h.x * this.object.scaleX + i.x,h.y * this.object.scaleY + i.y,u.x + i.x * this.object.scaleX,u.y * this.object.scaleY + i.y));
                        return this._points = s,
                        this._segments = l,
                        this
                    }
                    r.r(f),
                    r.d(f, {
                        getPoints: function() {
                            return o
                        },
                        getSegments: function() {
                            return a
                        },
                        updateMap: function() {
                            return n
                        }
                    })
                },
                739: function(e, f, r) {
                    function o(h, u) {
                        var d = typeof Symbol < "u" && h[Symbol.iterator] || h["@@iterator"];
                        if (!d) {
                            if (Array.isArray(h) || (d = function(T, E) {
                                if (T) {
                                    if (typeof T == "string")
                                        return a(T, E);
                                    var P = Object.prototype.toString.call(T).slice(8, -1);
                                    if (P === "Object" && T.constructor && (P = T.constructor.name),
                                    P === "Map" || P === "Set")
                                        return Array.from(T);
                                    if (P === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(P))
                                        return a(T, E)
                                }
                            }(h)) || u && h && typeof h.length == "number") {
                                d && (h = d);
                                var v = 0
                                  , p = function() {};
                                return {
                                    s: p,
                                    n: function() {
                                        return v >= h.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: h[v++]
                                        }
                                    },
                                    e: function(T) {
                                        throw T
                                    },
                                    f: p
                                }
                            }
                            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                        }
                        var g, m = !0, x = !1;
                        return {
                            s: function() {
                                d = d.call(h)
                            },
                            n: function() {
                                var T = d.next();
                                return m = T.done,
                                T
                            },
                            e: function(T) {
                                x = !0,
                                g = T
                            },
                            f: function() {
                                try {
                                    m || d.return == null || d.return()
                                } finally {
                                    if (x)
                                        throw g
                                }
                            }
                        }
                    }
                    function a(h, u) {
                        (u == null || u > h.length) && (u = h.length);
                        for (var d = 0, v = new Array(u); d < u; d++)
                            v[d] = h[d];
                        return v
                    }
                    function n() {
                        var h = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
                        if (!this.active)
                            return [];
                        var u = this.object.type === "body" || this.object.type === "composite" ? this.object : this.object.body;
                        if (h && !this.forceVerticesMapping && u.circleRadius > 0) {
                            var d = []
                              , v = new Phaser.Geom.Line
                              , p = new Phaser.Geom.Line
                              , g = new Phaser.Geom.Line(h.origin.x,h.origin.y,u.position.x,u.position.y)
                              , m = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(g), 2) - Math.pow(u.circleRadius * u.scale.x, 2))
                              , x = Phaser.Geom.Line.Angle(g)
                              , T = Math.asin(u.circleRadius * u.scale.x / Phaser.Geom.Line.Length(g));
                            return Phaser.Geom.Line.SetToAngle(v, h.origin.x, h.origin.y, x - T, m),
                            Phaser.Geom.Line.SetToAngle(p, h.origin.x, h.origin.y, x + T, m),
                            d.push(v.getPointB()),
                            d.push(p.getPointB()),
                            d
                        }
                        return this._points
                    }
                    function s() {
                        return this.active ? this._segments : []
                    }
                    function l() {
                        if (!this.active)
                            return this;
                        var h = []
                          , u = []
                          , d = this.object.type === "body" || this.object.type === "composite" ? this.object : this.object.body
                          , v = [d]
                          , p = !1;
                        if (d.circleRadius > 0 && !this.forceVerticesMapping)
                            return this.circle = !0,
                            this._points = h,
                            this._segments = u,
                            this;
                        this.circle = !1,
                        d.type == "composite" && (v = d.bodies),
                        (d.bounds === void 0 && d.type == "composite" || d.type == "composite" && this.dynamic) && (p = !0);
                        var g, m = o(v);
                        try {
                            for (m.s(); !(g = m.n()).done; ) {
                                var x = g.value;
                                if (x.parts.length === 1 || this.forceConvex) {
                                    var T = x.parts[0].vertices;
                                    h.push(new Phaser.Geom.Point(T[0].x,T[0].y));
                                    for (var E = 1, P = T.length; E < P; E++) {
                                        var M = new Phaser.Geom.Point(T[E - 1].x,T[E - 1].y)
                                          , L = new Phaser.Geom.Point(T[E].x,T[E].y);
                                        h.push(L);
                                        var R = new Phaser.Geom.Line(M.x,M.y,L.x,L.y);
                                        u.push(R)
                                    }
                                    var O = new Phaser.Geom.Line(T[T.length - 1].x,T[T.length - 1].y,T[0].x,T[0].y);
                                    u.push(O)
                                } else if (x.parts.length > 1)
                                    for (var F = function() {
                                        var z = x.parts[B].vertices
                                          , W = new Phaser.Geom.Point(z[0].x,z[0].y);
                                        h.find(function(U) {
                                            return U.x == W.x && U.y == W.y
                                        }) === void 0 && h.push(W);
                                        for (var b = function() {
                                            var U = new Phaser.Geom.Point(z[D].x,z[D].y)
                                              , X = u.findIndex(function(H) {
                                                return H.x1 == W.x && H.y1 == W.y && H.x2 == U.x && H.y2 == U.y || H.x1 == U.x && H.y1 == U.y && H.x2 == W.x && H.y2 == W.y
                                            });
                                            if (X !== -1)
                                                return u.splice(X, 1),
                                                W = U,
                                                "continue";
                                            h.find(function(H) {
                                                return H.x == U.x && H.y == U.y
                                            }) === void 0 && h.push(U);
                                            var V = new Phaser.Geom.Line(W.x,W.y,U.x,U.y);
                                            u.push(V),
                                            W = U
                                        }, D = 1, I = z.length; D < I; D++)
                                            b();
                                        var G = new Phaser.Geom.Line(z[z.length - 1].x,z[z.length - 1].y,z[0].x,z[0].y)
                                          , w = u.findIndex(function(U) {
                                            return U.x1 == G.x1 && U.y1 == G.y1 && U.x2 == G.x2 && U.y2 == G.y2 || U.x1 == G.x2 && U.y1 == G.y2 && U.x2 == G.x1 && U.y2 == G.y1
                                        });
                                        w === void 0 && u.push(G)
                                    }, B = 1, N = x.parts.length; B < N; B++)
                                        F()
                            }
                        } catch (z) {
                            m.e(z)
                        } finally {
                            m.f()
                        }
                        if (this._points = h,
                        this._segments = u,
                        p) {
                            var Y = this._raycaster.scene.matter.composite.bounds(d);
                            d.bounds = Y
                        }
                        return this
                    }
                    function i() {
                        var h = this.object.type === "body" || this.object.type === "composite" ? this.object.bounds : this.object.body.bounds;
                        return new Phaser.Geom.Rectangle(h.min.x,h.min.y,h.max.x - h.min.x,h.max.y - h.min.y)
                    }
                    r.r(f),
                    r.d(f, {
                        getBoundingBox: function() {
                            return i
                        },
                        getPoints: function() {
                            return n
                        },
                        getSegments: function() {
                            return s
                        },
                        updateMap: function() {
                            return l
                        }
                    })
                },
                121: function(e, f, r) {
                    function o(i, h) {
                        var u = typeof Symbol < "u" && i[Symbol.iterator] || i["@@iterator"];
                        if (!u) {
                            if (Array.isArray(i) || (u = function(x, T) {
                                if (x) {
                                    if (typeof x == "string")
                                        return a(x, T);
                                    var E = Object.prototype.toString.call(x).slice(8, -1);
                                    if (E === "Object" && x.constructor && (E = x.constructor.name),
                                    E === "Map" || E === "Set")
                                        return Array.from(x);
                                    if (E === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(E))
                                        return a(x, T)
                                }
                            }(i)) || h && i && typeof i.length == "number") {
                                u && (i = u);
                                var d = 0
                                  , v = function() {};
                                return {
                                    s: v,
                                    n: function() {
                                        return d >= i.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: i[d++]
                                        }
                                    },
                                    e: function(x) {
                                        throw x
                                    },
                                    f: v
                                }
                            }
                            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                        }
                        var p, g = !0, m = !1;
                        return {
                            s: function() {
                                u = u.call(i)
                            },
                            n: function() {
                                var x = u.next();
                                return g = x.done,
                                x
                            },
                            e: function(x) {
                                m = !0,
                                p = x
                            },
                            f: function() {
                                try {
                                    g || u.return == null || u.return()
                                } finally {
                                    if (m)
                                        throw p
                                }
                            }
                        }
                    }
                    function a(i, h) {
                        (h == null || h > i.length) && (h = i.length);
                        for (var u = 0, d = new Array(h); u < h; u++)
                            d[u] = i[u];
                        return d
                    }
                    function n() {
                        return this.active ? this._points : []
                    }
                    function s() {
                        return this.active ? this._segments : []
                    }
                    function l() {
                        if (!this.active)
                            return this;
                        var i = []
                          , h = []
                          , u = new Phaser.Geom.Point;
                        u.x = this.object.x - this.object.displayWidth * this.object.originX,
                        u.y = this.object.y - this.object.displayHeight * this.object.originY;
                        var d = this.object.rotation;
                        if (d !== 0) {
                            var v, p = o(this.object.geom.points);
                            try {
                                for (p.s(); !(v = p.n()).done; ) {
                                    var g = v.value
                                      , m = new Phaser.Geom.Line(this.object.x,this.object.y,g.x * this.object.scaleX + u.x,g.y * this.object.scaleY + u.y);
                                    Phaser.Geom.Line.SetToAngle(m, this.object.x, this.object.y, Phaser.Geom.Line.Angle(m) + d, Phaser.Geom.Line.Length(m)),
                                    i.push(m.getPointB())
                                }
                            } catch (R) {
                                p.e(R)
                            } finally {
                                p.f()
                            }
                        } else {
                            var x, T = o(this.object.geom.points);
                            try {
                                for (T.s(); !(x = T.n()).done; ) {
                                    var E = x.value;
                                    i.push(new Phaser.Geom.Point(E.x * this.object.scaleX + u.x,E.y * this.object.scaleY + u.y))
                                }
                            } catch (R) {
                                T.e(R)
                            } finally {
                                T.f()
                            }
                        }
                        for (var P = 0, M = i.length; P < M; P++)
                            P + 1 < M && h.push(new Phaser.Geom.Line(i[P].x,i[P].y,i[P + 1].x,i[P + 1].y));
                        if (this.object.closePath) {
                            var L = i.length - 1;
                            h.push(new Phaser.Geom.Line(i[L].x,i[L].y,i[0].x,i[0].y))
                        }
                        return this._points = i,
                        this._segments = h,
                        this
                    }
                    r.r(f),
                    r.d(f, {
                        getPoints: function() {
                            return n
                        },
                        getSegments: function() {
                            return s
                        },
                        updateMap: function() {
                            return l
                        }
                    })
                },
                812: function(e, f, r) {
                    function o() {
                        return this.active ? this._points : []
                    }
                    function a() {
                        return this.active ? this._segments : []
                    }
                    function n() {
                        if (!this.active)
                            return this;
                        for (var s, l = [], i = 0, h = (s = [this.object.getTopLeft(), this.object.getTopRight(), this.object.getBottomRight(), this.object.getBottomLeft()]).length; i < h; i++)
                            i + 1 < h ? l.push(new Phaser.Geom.Line(s[i].x,s[i].y,s[i + 1].x,s[i + 1].y)) : l.push(new Phaser.Geom.Line(s[i].x,s[i].y,s[0].x,s[0].y));
                        return this._points = s,
                        this._segments = l,
                        this
                    }
                    r.r(f),
                    r.d(f, {
                        getPoints: function() {
                            return o
                        },
                        getSegments: function() {
                            return a
                        },
                        updateMap: function() {
                            return n
                        }
                    })
                },
                724: function(e, f, r) {
                    function o(h, u) {
                        var d = typeof Symbol < "u" && h[Symbol.iterator] || h["@@iterator"];
                        if (!d) {
                            if (Array.isArray(h) || (d = function(T, E) {
                                if (T) {
                                    if (typeof T == "string")
                                        return a(T, E);
                                    var P = Object.prototype.toString.call(T).slice(8, -1);
                                    if (P === "Object" && T.constructor && (P = T.constructor.name),
                                    P === "Map" || P === "Set")
                                        return Array.from(T);
                                    if (P === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(P))
                                        return a(T, E)
                                }
                            }(h)) || u && h && typeof h.length == "number") {
                                d && (h = d);
                                var v = 0
                                  , p = function() {};
                                return {
                                    s: p,
                                    n: function() {
                                        return v >= h.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: h[v++]
                                        }
                                    },
                                    e: function(T) {
                                        throw T
                                    },
                                    f: p
                                }
                            }
                            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                        }
                        var g, m = !0, x = !1;
                        return {
                            s: function() {
                                d = d.call(h)
                            },
                            n: function() {
                                var T = d.next();
                                return m = T.done,
                                T
                            },
                            e: function(T) {
                                x = !0,
                                g = T
                            },
                            f: function() {
                                try {
                                    m || d.return == null || d.return()
                                } finally {
                                    if (x)
                                        throw g
                                }
                            }
                        }
                    }
                    function a(h, u) {
                        (u == null || u > h.length) && (u = h.length);
                        for (var d = 0, v = new Array(u); d < u; d++)
                            v[d] = h[d];
                        return v
                    }
                    function n() {
                        var h = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
                        if (!this.active)
                            return [];
                        if (!h || h && (h.detectionRange == 0 || h.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))
                            return this._points;
                        var u, d = [], v = o(this._points);
                        try {
                            for (v.s(); !(u = v.n()).done; ) {
                                var p = u.value;
                                Phaser.Math.Distance.Between(h.origin.x, h.origin.y, p.x, p.y) <= h.detectionRange && d.push(p)
                            }
                        } catch (E) {
                            v.e(E)
                        } finally {
                            v.f()
                        }
                        var g, m = this.getSegments(h), x = o(m);
                        try {
                            for (x.s(); !(g = x.n()).done; ) {
                                var T = g.value;
                                Phaser.Math.Distance.Between(h.origin.x, h.origin.y, T.x1, T.y1) > h.detectionRange && d.push(new Phaser.Geom.Point(T.x1,T.y1)),
                                Phaser.Math.Distance.Between(h.origin.x, h.origin.y, T.x2, T.y2) > h.detectionRange && d.push(new Phaser.Geom.Point(T.x2,T.y2))
                            }
                        } catch (E) {
                            x.e(E)
                        } finally {
                            x.f()
                        }
                        return d
                    }
                    function s() {
                        var h = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
                        if (!this.active)
                            return [];
                        if (!h || h && (h.detectionRange == 0 || h.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))
                            return this._segments;
                        var u, d = [], v = o(this._segments);
                        try {
                            for (v.s(); !(u = v.n()).done; ) {
                                var p = u.value;
                                Phaser.Geom.Intersects.LineToCircle(p, h.detectionRangeCircle) && d.push(p)
                            }
                        } catch (g) {
                            v.e(g)
                        } finally {
                            v.f()
                        }
                        return d
                    }
                    function l() {
                        var h = this;
                        if (!this.active)
                            return this;
                        var u = []
                          , d = []
                          , v = new Phaser.Geom.Point;
                        v.x = this.object.x,
                        v.y = this.object.y;
                        for (var p = !1, g = [], m = [], x = 0, T = this.object.layer.data.length; x < T; x++) {
                            for (var E = this.object.layer.data[x], P = 0, M = E.length; P < M; P++) {
                                var L = E[P]
                                  , R = !!(x > 0 && this.collisionTiles.includes(this.object.layer.data[x - 1][P].index) != this.collisionTiles.includes(L.index) || x == 0 && this.collisionTiles.includes(L.index))
                                  , O = !!(P > 0 && this.collisionTiles.includes(this.object.layer.data[x][P - 1].index) != this.collisionTiles.includes(L.index) || P == 0 && this.collisionTiles.includes(L.index))
                                  , F = !1;
                                if (m.length <= P ? m[P] = [] : m[P].length > 0 && (F = m[P][m[P].length - 1]),
                                O && (F && F.y + F.height == x ? F.height++ : m[P].push({
                                    x: L.x,
                                    y: L.y,
                                    height: 1
                                })),
                                R)
                                    p ? p.width++ : p = {
                                        x: L.x,
                                        y: L.y,
                                        width: 1
                                    };
                                else if (p) {
                                    var B = p.x * this.object.layer.tileWidth * this.object.scaleX + v.x
                                      , N = p.y * this.object.layer.tileHeight * this.object.scaleY + v.y
                                      , Y = new Phaser.Geom.Line(B,N,B + this.object.layer.tileWidth * this.object.scaleX * p.width,N);
                                    d.push(Y),
                                    g.push(Y),
                                    u.push(new Phaser.Geom.Point(B,N)),
                                    u.push(new Phaser.Geom.Point(B + this.object.layer.tileWidth * this.object.scaleX * p.width,N)),
                                    p = !1
                                }
                            }
                            if (p) {
                                var z = p.x * this.object.layer.tileWidth * this.object.scaleX + v.x
                                  , W = p.y * this.object.layer.tileHeight * this.object.scaleY + v.y
                                  , b = new Phaser.Geom.Line(z,W,z + this.object.layer.tileWidth * this.object.scaleX * p.width,W);
                                d.push(b),
                                g.push(b),
                                u.push(new Phaser.Geom.Point(z,W)),
                                u.push(new Phaser.Geom.Point(z + this.object.layer.tileWidth * this.object.scaleX * p.width,W)),
                                p = !1
                            }
                        }
                        var D, I = o(this.object.layer.data[this.object.layer.data.length - 1]);
                        try {
                            for (I.s(); !(D = I.n()).done; ) {
                                var G = D.value;
                                if (this.collisionTiles.includes(G.index))
                                    p ? p.width++ : p = {
                                        x: G.x,
                                        y: G.y + 1,
                                        width: 1
                                    };
                                else if (p) {
                                    var w = p.x * this.object.layer.tileWidth * this.object.scaleX + v.x
                                      , U = p.y * this.object.layer.tileHeight * this.object.scaleY + v.y
                                      , X = new Phaser.Geom.Line(w,U,w + this.object.layer.tileWidth * this.object.scaleX * p.width,U);
                                    d.push(X),
                                    g.push(X),
                                    u.push(new Phaser.Geom.Point(w,U)),
                                    u.push(new Phaser.Geom.Point(w + this.object.layer.tileWidth * this.object.scaleX * p.width,U)),
                                    p = !1
                                }
                            }
                        } catch (q) {
                            I.e(q)
                        } finally {
                            I.f()
                        }
                        if (p) {
                            var V = p.x * this.object.layer.tileWidth * this.object.scaleX + v.x
                              , H = p.y * this.object.layer.tileHeight * this.object.scaleY + v.y
                              , J = new Phaser.Geom.Line(V,H,V + this.object.layer.tileWidth * this.object.scaleX * p.width,H);
                            d.push(J),
                            g.push(J),
                            u.push(new Phaser.Geom.Point(V,H)),
                            u.push(new Phaser.Geom.Point(V + this.object.layer.tileWidth * this.object.scaleX * p.width,H)),
                            p = !1
                        }
                        var $, _ = !1, nt = [], K = o(this.object.layer.data);
                        try {
                            for (K.s(); !($ = K.n()).done; ) {
                                var Z = $.value
                                  , j = Z[Z.length - 1];
                                this.collisionTiles.includes(j.index) ? _ ? _.height++ : _ = {
                                    x: j.x + 1,
                                    y: j.y,
                                    height: 1
                                } : _ && (nt.push(_),
                                _ = !1)
                            }
                        } catch (q) {
                            K.e(q)
                        } finally {
                            K.f()
                        }
                        m.push(nt);
                        for (var Q = 0, tt = m; Q < tt.length; Q++) {
                            var et = tt[Q];
                            if (et) {
                                var it, k = o(et);
                                try {
                                    var st = function() {
                                        var q = it.value
                                          , rt = q.x * h.object.layer.tileWidth * h.object.scaleX + v.x
                                          , ot = q.y * h.object.layer.tileHeight * h.object.scaleY + v.y
                                          , lt = ot + h.object.layer.tileHeight * h.object.scaleY * q.height
                                          , at = new Phaser.Geom.Line(rt,ot,rt,lt);
                                        d.push(at),
                                        u.filter(function(mt) {
                                            return mt.x == rt && mt.y == ot
                                        }) || u.push(new Phaser.Geom.Point(rt,y)),
                                        u.filter(function(mt) {
                                            return mt.x == rt && mt.y == lt
                                        }) || u.push(new Phaser.Geom.Point(rt,y));
                                        var ht, dt = o(g);
                                        try {
                                            for (dt.s(); !(ht = dt.n()).done; ) {
                                                var ut = ht.value;
                                                if (at.x1 != ut.x1 && at.x1 != ut.x2 && at.x2 != ut.x1 && at.x2 != ut.x2 && at.y1 != ut.y1 && at.y1 != ut.y2 && at.y2 != ut.y1 && at.y2 != ut.y2) {
                                                    var ft = new Phaser.Geom.Point;
                                                    Phaser.Geom.Intersects.LineToLine(at, ut, ft) && u.push(ft)
                                                }
                                            }
                                        } catch (mt) {
                                            dt.e(mt)
                                        } finally {
                                            dt.f()
                                        }
                                    };
                                    for (k.s(); !(it = k.n()).done; )
                                        st()
                                } catch (q) {
                                    k.e(q)
                                } finally {
                                    k.f()
                                }
                            }
                        }
                        return this._points = u,
                        this._segments = d,
                        this
                    }
                    function i() {
                        var h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
                        return this.collisionTiles = h,
                        this
                    }
                    r.r(f),
                    r.d(f, {
                        getPoints: function() {
                            return n
                        },
                        getSegments: function() {
                            return s
                        },
                        setCollisionTiles: function() {
                            return i
                        },
                        updateMap: function() {
                            return l
                        }
                    })
                },
                98: function(e, f, r) {
                    function o(a) {
                        return this.segmentCount = a,
                        this.circle = !a,
                        this.updateMap(),
                        this
                    }
                    r.r(f),
                    r.d(f, {
                        setSegmentCount: function() {
                            return o
                        }
                    })
                },
                519: function(e, f, r) {
                    function o() {
                        var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                        return this.angle = Phaser.Math.Angle.Normalize(n),
                        Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange),
                        this
                    }
                    function a() {
                        var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                        return this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(n)),
                        Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange),
                        this
                    }
                    r.d(f, {
                        e: function() {
                            return o
                        },
                        m: function() {
                            return a
                        }
                    })
                },
                157: function(e, f, r) {
                    function o(s, l) {
                        var i = typeof Symbol < "u" && s[Symbol.iterator] || s["@@iterator"];
                        if (!i) {
                            if (Array.isArray(s) || (i = function(g, m) {
                                if (g) {
                                    if (typeof g == "string")
                                        return a(g, m);
                                    var x = Object.prototype.toString.call(g).slice(8, -1);
                                    if (x === "Object" && g.constructor && (x = g.constructor.name),
                                    x === "Map" || x === "Set")
                                        return Array.from(g);
                                    if (x === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(x))
                                        return a(g, m)
                                }
                            }(s)) || l && s && typeof s.length == "number") {
                                i && (s = i);
                                var h = 0
                                  , u = function() {};
                                return {
                                    s: u,
                                    n: function() {
                                        return h >= s.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: s[h++]
                                        }
                                    },
                                    e: function(g) {
                                        throw g
                                    },
                                    f: u
                                }
                            }
                            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                        }
                        var d, v = !0, p = !1;
                        return {
                            s: function() {
                                i = i.call(s)
                            },
                            n: function() {
                                var g = i.next();
                                return v = g.done,
                                g
                            },
                            e: function(g) {
                                p = !0,
                                d = g
                            },
                            f: function() {
                                try {
                                    v || i.return == null || i.return()
                                } finally {
                                    if (p)
                                        throw d
                                }
                            }
                        }
                    }
                    function a(s, l) {
                        (l == null || l > s.length) && (l = s.length);
                        for (var i = 0, h = new Array(l); i < l; i++)
                            h[i] = s[i];
                        return h
                    }
                    function n() {
                        var s, l, i, h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = this.rayRange, d = !!h.internal && h.internal, v = performance.now(), p = {
                            method: "cast",
                            rays: 1,
                            testedMappedObjects: 0,
                            hitMappedObjects: 0,
                            segments: 0,
                            time: 0
                        };
                        if (this._raycaster && this._raycaster.boundingBox) {
                            var g = [];
                            if (Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, g),
                            g.length === 1)
                                s = g[0];
                            else if (g.length > 1) {
                                var m, x = o(g);
                                try {
                                    for (x.s(); !(m = x.n()).done; ) {
                                        var T = m.value
                                          , E = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, T.x, T.y);
                                        E < u && (u = E,
                                        s = T)
                                    }
                                } catch (ft) {
                                    x.e(ft)
                                } finally {
                                    x.f()
                                }
                            } else if (h.target) {
                                var P = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, h.target.x, h.target.y);
                                this.rayRange > P && (u = P,
                                s = h.target)
                            }
                        }
                        if (!h.objects) {
                            if (!this._raycaster)
                                return intersections;
                            h.objects = this._raycaster.mappedObjects
                        }
                        var M, L, R = o(h.objects);
                        try {
                            for (R.s(); !(M = R.n()).done; ) {
                                var O = M.value
                                  , F = void 0
                                  , B = void 0;
                                if (F = O.type === "body" || O.type === "composite" ? O.raycasterMap : O.data.get("raycasterMap"),
                                p.testedMappedObjects++,
                                d ? B = F._boundingBox : (B = F.getBoundingBox()).setTo(B.x - .1, B.y - .1, B.width + .2, B.height + .2),
                                Phaser.Geom.Intersects.GetLineToRectangle(this._ray, B).length !== 0) {
                                    p.hitMappedObjects++,
                                    p.segments += F.getSegments(this).length;
                                    var N, Y = o(F.getSegments(this));
                                    try {
                                        for (Y.s(); !(N = Y.n()).done; ) {
                                            var z = N.value
                                              , W = [];
                                            if (h.target) {
                                                if (Phaser.Geom.Point.Equals(h.target, z.getPointA()) || Phaser.Geom.Point.Equals(h.target, z.getPointB()))
                                                    W = h.target;
                                                else if (!Phaser.Geom.Intersects.LineToLine(this._ray, z, W))
                                                    continue
                                            } else if (!Phaser.Geom.Intersects.LineToLine(this._ray, z, W))
                                                continue;
                                            var b = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, W.x, W.y);
                                            b < u && (u = b,
                                            s = W,
                                            i = F.object,
                                            l = z)
                                        }
                                    } catch (ft) {
                                        Y.e(ft)
                                    } finally {
                                        Y.f()
                                    }
                                    if (F.circle) {
                                        if (F._points.length > 0)
                                            continue;
                                        if (h.target) {
                                            var D, I = F.getPoints(this), G = !1, w = o(I);
                                            try {
                                                for (w.s(); !(D = w.n()).done; ) {
                                                    var U = D.value;
                                                    if (Phaser.Geom.Point.Equals(h.target, U)) {
                                                        var X = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, U.x, U.y);
                                                        if (X < u) {
                                                            u = X,
                                                            s = U,
                                                            i = F.object,
                                                            G = !0;
                                                            break
                                                        }
                                                    }
                                                }
                                            } catch (ft) {
                                                w.e(ft)
                                            } finally {
                                                w.f()
                                            }
                                            if (G)
                                                continue
                                        }
                                        var V = []
                                          , H = new Phaser.Geom.Point;
                                        H.x = F.object.x - F.object.displayWidth * (F.object.originX - .5),
                                        H.y = F.object.y - F.object.displayHeight * (F.object.originY - .5);
                                        var J = F.object.rotation;
                                        if (J !== 0) {
                                            var $ = new Phaser.Geom.Line(F.object.x,F.object.y,H.x,H.y);
                                            Phaser.Geom.Line.SetToAngle($, F.object.x, F.object.y, Phaser.Geom.Line.Angle($) + J, Phaser.Geom.Line.Length($));
                                            var _ = $.getPointB();
                                            H.x = _.x,
                                            H.y = _.y
                                        }
                                        var nt = new Phaser.Geom.Circle(H.x,H.y,F.object.radius * F.object.scaleX);
                                        if (Phaser.Geom.Intersects.GetLineToCircle(this._ray, nt, V)) {
                                            var K, Z = o(V);
                                            try {
                                                for (Z.s(); !(K = Z.n()).done; ) {
                                                    var j = K.value
                                                      , Q = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, j.x, j.y);
                                                    Q < u && (u = Q,
                                                    s = j,
                                                    i = F.object)
                                                }
                                            } catch (ft) {
                                                Z.e(ft)
                                            } finally {
                                                Z.f()
                                            }
                                        }
                                    }
                                    if (F.type == "Container" && F._circles.length > 0) {
                                        var tt, et = o(F._circles);
                                        try {
                                            for (et.s(); !(tt = et.n()).done; ) {
                                                var it = tt.value;
                                                if (h.target) {
                                                    var k, st = !1, q = o(it.points);
                                                    try {
                                                        for (q.s(); !(k = q.n()).done; ) {
                                                            var rt = k.value;
                                                            if (Phaser.Geom.Point.Equals(h.target, rt)) {
                                                                var ot = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, rt.x, rt.y);
                                                                if (ot < u) {
                                                                    u = ot,
                                                                    s = rt,
                                                                    i = F.object,
                                                                    st = !0;
                                                                    break
                                                                }
                                                            }
                                                        }
                                                    } catch (ft) {
                                                        q.e(ft)
                                                    } finally {
                                                        q.f()
                                                    }
                                                    if (st)
                                                        continue
                                                }
                                                var lt = [];
                                                if (Phaser.Geom.Intersects.GetLineToCircle(this._ray, it, lt)) {
                                                    var at, ht = o(lt);
                                                    try {
                                                        for (ht.s(); !(at = ht.n()).done; ) {
                                                            var dt = at.value
                                                              , ut = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, dt.x, dt.y);
                                                            ut < u && (u = ut,
                                                            s = dt,
                                                            i = F.object)
                                                        }
                                                    } catch (ft) {
                                                        ht.e(ft)
                                                    } finally {
                                                        ht.f()
                                                    }
                                                }
                                            }
                                        } catch (ft) {
                                            et.e(ft)
                                        } finally {
                                            et.f()
                                        }
                                    }
                                }
                            }
                        } catch (ft) {
                            R.e(ft)
                        } finally {
                            R.f()
                        }
                        if (d ? (this._stats.rays++,
                        this._stats.testedMappedObjects += p.testedMappedObjects,
                        this._stats.hitMappedObjects += p.hitMappedObjects,
                        this._stats.segments += p.segments) : (p.time = performance.now() - v,
                        this._stats = p),
                        s)
                            (L = new Phaser.Geom.Point(s.x,s.y)).segment = l,
                            L.object = i;
                        else {
                            if (this.ignoreNotIntersectedRays)
                                return !1;
                            L = this._ray.getPointB()
                        }
                        return this.round && (L.x = Math.round(L.x),
                        L.y = Math.round(L.y)),
                        d || this.drawDebug([L]),
                        L
                    }
                    r.d(f, {
                        p: function() {
                            return n
                        }
                    })
                },
                330: function(e, f, r) {
                    function o(s, l) {
                        var i = typeof Symbol < "u" && s[Symbol.iterator] || s["@@iterator"];
                        if (!i) {
                            if (Array.isArray(s) || (i = function(g, m) {
                                if (g) {
                                    if (typeof g == "string")
                                        return a(g, m);
                                    var x = Object.prototype.toString.call(g).slice(8, -1);
                                    if (x === "Object" && g.constructor && (x = g.constructor.name),
                                    x === "Map" || x === "Set")
                                        return Array.from(g);
                                    if (x === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(x))
                                        return a(g, m)
                                }
                            }(s)) || l && s && typeof s.length == "number") {
                                i && (s = i);
                                var h = 0
                                  , u = function() {};
                                return {
                                    s: u,
                                    n: function() {
                                        return h >= s.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: s[h++]
                                        }
                                    },
                                    e: function(g) {
                                        throw g
                                    },
                                    f: u
                                }
                            }
                            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                        }
                        var d, v = !0, p = !1;
                        return {
                            s: function() {
                                i = i.call(s)
                            },
                            n: function() {
                                var g = i.next();
                                return v = g.done,
                                g
                            },
                            e: function(g) {
                                p = !0,
                                d = g
                            },
                            f: function() {
                                try {
                                    v || i.return == null || i.return()
                                } finally {
                                    if (p)
                                        throw d
                                }
                            }
                        }
                    }
                    function a(s, l) {
                        (l == null || l > s.length) && (l = s.length);
                        for (var i = 0, h = new Array(l); i < l; i++)
                            h[i] = s[i];
                        return h
                    }
                    function n() {
                        var s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
                          , l = this.angle
                          , i = []
                          , h = []
                          , u = []
                          , d = performance.now();
                        if (this._stats = {
                            method: "castCircle",
                            rays: 0,
                            testedMappedObjects: 0,
                            hitMappedObjects: 0,
                            segments: 0,
                            time: 0
                        },
                        !s.objects) {
                            if (!this._raycaster)
                                return i;
                            s.objects = this._raycaster.mappedObjects
                        }
                        if (this._raycaster && this._raycaster.boundingBox) {
                            var v, p = o(this._raycaster.boundingBox.points);
                            try {
                                for (p.s(); !(v = p.n()).done; ) {
                                    var g = v.value;
                                    h.push({
                                        point: g,
                                        angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, g.x, g.y)
                                    })
                                }
                            } catch (K) {
                                p.e(K)
                            } finally {
                                p.f()
                            }
                        }
                        for (var m = 0, x = s.objects.length; m < x; m++) {
                            var T = s.objects[m];
                            if (this.boundsInRange(T)) {
                                u.push(T);
                                var E = void 0
                                  , P = void 0;
                                (P = (E = T.type === "body" || T.type === "composite" ? T.raycasterMap : T.data.get("raycasterMap")).getBoundingBox()).setTo(P.x - .1, P.y - .1, P.width + .2, P.height + .2),
                                E._boundingBox = P;
                                var M, L = o(E.getPoints(this));
                                try {
                                    for (L.s(); !(M = L.n()).done; ) {
                                        var R = M.value;
                                        h.push({
                                            point: R,
                                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, R.x, R.y)
                                        })
                                    }
                                } catch (K) {
                                    L.e(K)
                                } finally {
                                    L.f()
                                }
                                for (var O = m + 1, F = s.objects.length; O < F; O++) {
                                    var B = s.objects[O]
                                      , N = void 0;
                                    if (N = B.type === "body" || B.type === "composite" ? B.raycasterMap : B.data.get("raycasterMap"),
                                    Phaser.Geom.Intersects.RectangleToRectangle(E.getBoundingBox(), N.getBoundingBox())) {
                                        var Y, z = o(E.getSegments(this));
                                        try {
                                            for (z.s(); !(Y = z.n()).done; ) {
                                                var W, b = Y.value, D = o(N.getSegments(this));
                                                try {
                                                    for (D.s(); !(W = D.n()).done; ) {
                                                        var I = W.value
                                                          , G = [];
                                                        Phaser.Geom.Intersects.LineToLine(b, I, G) && h.push({
                                                            point: new Phaser.Geom.Point(G.x,G.y),
                                                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, G.x, G.y)
                                                        })
                                                    }
                                                } catch (K) {
                                                    D.e(K)
                                                } finally {
                                                    D.f()
                                                }
                                            }
                                        } catch (K) {
                                            z.e(K)
                                        } finally {
                                            z.f()
                                        }
                                    }
                                }
                            }
                        }
                        h.sort(function(K, Z) {
                            return K.angle == Z.angle ? Phaser.Math.Distance.Between(this.origin.x, this.origin.y, K.point.x, K.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, Z.point.x, Z.point.y) ? 1 : -1 : K.angle - Z.angle
                        }
                        .bind(this));
                        for (var w = {
                            angle: !1
                        }, U = 0, X = h; U < X.length; U++) {
                            var V = X[U];
                            if (V.angle !== w.angle) {
                                w = V,
                                this.setAngle(V.angle);
                                var H = this.cast({
                                    objects: u,
                                    target: V.point,
                                    internal: !0
                                });
                                if (H) {
                                    var J = !1;
                                    if (this.round) {
                                        var $ = new Phaser.Geom.Point(Math.round(V.point.x),Math.round(V.point.y));
                                        J = Phaser.Geom.Point.Equals($, H)
                                    } else
                                        J = Phaser.Geom.Point.Equals(V.point, H);
                                    if (J) {
                                        this.setAngle(V.angle - 1e-4);
                                        var _ = this.cast({
                                            objects: u,
                                            internal: !0
                                        });
                                        _ && i.push(_),
                                        i.push(H),
                                        this.setAngle(V.angle + 1e-4);
                                        var nt = this.cast({
                                            objects: u,
                                            internal: !0
                                        });
                                        nt && i.push(nt);
                                        continue
                                    }
                                    i.push(H)
                                }
                            }
                        }
                        return this.setAngle(l),
                        this.intersections = i,
                        this.autoSlice && (this.slicedIntersections = this.slice()),
                        this._stats.time = performance.now() - d,
                        this.drawDebug(i),
                        i
                    }
                    r.d(f, {
                        q: function() {
                            return n
                        }
                    })
                },
                352: function(e, f, r) {
                    function o(s, l) {
                        var i = typeof Symbol < "u" && s[Symbol.iterator] || s["@@iterator"];
                        if (!i) {
                            if (Array.isArray(s) || (i = function(g, m) {
                                if (g) {
                                    if (typeof g == "string")
                                        return a(g, m);
                                    var x = Object.prototype.toString.call(g).slice(8, -1);
                                    if (x === "Object" && g.constructor && (x = g.constructor.name),
                                    x === "Map" || x === "Set")
                                        return Array.from(g);
                                    if (x === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(x))
                                        return a(g, m)
                                }
                            }(s)) || l && s && typeof s.length == "number") {
                                i && (s = i);
                                var h = 0
                                  , u = function() {};
                                return {
                                    s: u,
                                    n: function() {
                                        return h >= s.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: s[h++]
                                        }
                                    },
                                    e: function(g) {
                                        throw g
                                    },
                                    f: u
                                }
                            }
                            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                        }
                        var d, v = !0, p = !1;
                        return {
                            s: function() {
                                i = i.call(s)
                            },
                            n: function() {
                                var g = i.next();
                                return v = g.done,
                                g
                            },
                            e: function(g) {
                                p = !0,
                                d = g
                            },
                            f: function() {
                                try {
                                    v || i.return == null || i.return()
                                } finally {
                                    if (p)
                                        throw d
                                }
                            }
                        }
                    }
                    function a(s, l) {
                        (l == null || l > s.length) && (l = s.length);
                        for (var i = 0, h = new Array(l); i < l; i++)
                            h[i] = s[i];
                        return h
                    }
                    function n() {
                        var s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
                          , l = this.angle
                          , i = []
                          , h = []
                          , u = []
                          , d = this.cone
                          , v = 0
                          , p = 0
                          , g = performance.now();
                        if (this._stats = {
                            method: "castCone",
                            rays: 0,
                            testedMappedObjects: 0,
                            hitMappedObjects: 0,
                            segments: 0,
                            time: 0
                        },
                        s.cone !== void 0 && (d = s.cone),
                        s.coneDeg !== void 0 && (d = Phaser.Math.DegToRad(s.coneDeg)),
                        v = this.angle - d / 2,
                        p = this.angle + d / 2,
                        this.setAngle(v),
                        h.push({
                            point: this._ray.getPointB(),
                            angle: v,
                            angleOffsetDeg: Phaser.Math.RadToDeg(-d / 2)
                        }),
                        this.setAngle(p),
                        h.push({
                            point: this._ray.getPointB(),
                            angle: p,
                            angleOffsetDeg: Phaser.Math.RadToDeg(d / 2)
                        }),
                        !s.objects) {
                            if (!this._raycaster)
                                return i;
                            s.objects = this._raycaster.mappedObjects
                        }
                        if (this._raycaster && this._raycaster.boundingBox) {
                            var m, x = o(this._raycaster.boundingBox.points);
                            try {
                                for (x.s(); !(m = x.n()).done; ) {
                                    var T = m.value
                                      , E = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, T.x, T.y)
                                      , P = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(E), Phaser.Math.RadToDeg(l));
                                    Math.abs(P) < Phaser.Math.RadToDeg(d / 2) && h.push({
                                        point: T,
                                        angle: E,
                                        angleOffsetDeg: -P
                                    })
                                }
                            } catch (q) {
                                x.e(q)
                            } finally {
                                x.f()
                            }
                        }
                        for (var M = 0, L = s.objects.length; M < L; M++) {
                            var R = s.objects[M];
                            if (this.boundsInRange(R)) {
                                u.push(R);
                                var O = void 0
                                  , F = void 0;
                                (F = (O = R.type === "body" || R.type === "composite" ? R.raycasterMap : R.data.get("raycasterMap")).getBoundingBox()).setTo(F.x - .1, F.y - .1, F.width + .2, F.height + .2),
                                O._boundingBox = F;
                                var B, N = o(O.getPoints(this));
                                try {
                                    for (N.s(); !(B = N.n()).done; ) {
                                        var Y = B.value
                                          , z = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, Y.x, Y.y)
                                          , W = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(z), Phaser.Math.RadToDeg(l));
                                        Math.abs(W) < Phaser.Math.RadToDeg(d / 2) && h.push({
                                            point: Y,
                                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, Y.x, Y.y),
                                            angleOffsetDeg: -W
                                        })
                                    }
                                } catch (q) {
                                    N.e(q)
                                } finally {
                                    N.f()
                                }
                                for (var b = M + 1, D = s.objects.length; b < D; b++) {
                                    var I = s.objects[b]
                                      , G = void 0;
                                    if (G = I.type === "body" || I.type === "composite" ? I.raycasterMap : I.data.get("raycasterMap"),
                                    Phaser.Geom.Intersects.RectangleToRectangle(O.getBoundingBox(), G.getBoundingBox())) {
                                        var w, U = o(O.getSegments(this));
                                        try {
                                            for (U.s(); !(w = U.n()).done; ) {
                                                var X, V = w.value, H = o(G.getSegments(this));
                                                try {
                                                    for (H.s(); !(X = H.n()).done; ) {
                                                        var J = X.value
                                                          , $ = [];
                                                        if (Phaser.Geom.Intersects.LineToLine(V, J, $)) {
                                                            var _ = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, $.x, $.y)
                                                              , nt = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(_), Phaser.Math.RadToDeg(l));
                                                            Math.abs(nt) < Phaser.Math.RadToDeg(d / 2) && h.push({
                                                                point: new Phaser.Geom.Point($.x,$.y),
                                                                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, $.x, $.y),
                                                                angleOffsetDeg: -nt
                                                            })
                                                        }
                                                    }
                                                } catch (q) {
                                                    H.e(q)
                                                } finally {
                                                    H.f()
                                                }
                                            }
                                        } catch (q) {
                                            U.e(q)
                                        } finally {
                                            U.f()
                                        }
                                    }
                                }
                            }
                        }
                        h.sort(function(q, rt) {
                            return q.angle == rt.angle ? Phaser.Math.Distance.Between(this.origin.x, this.origin.y, q.point.x, q.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, rt.point.x, rt.point.y) ? 1 : -1 : q.angleOffsetDeg - rt.angleOffsetDeg
                        }
                        .bind(this));
                        for (var K = {
                            angle: !1
                        }, Z = 0, j = h; Z < j.length; Z++) {
                            var Q = j[Z];
                            if (Q.angle !== K.angle) {
                                K = Q,
                                this.setAngle(Q.angle);
                                var tt = this.cast({
                                    objects: u,
                                    target: Q.point,
                                    internal: !0
                                });
                                if (tt) {
                                    var et = !1;
                                    if (this.round) {
                                        var it = new Phaser.Geom.Point(Math.round(Q.point.x),Math.round(Q.point.y));
                                        et = Phaser.Geom.Point.Equals(it, tt)
                                    } else
                                        et = Phaser.Geom.Point.Equals(Q.point, tt);
                                    if (et) {
                                        this.setAngle(Q.angle - 1e-4);
                                        var k = this.cast({
                                            objects: u,
                                            internal: !0
                                        });
                                        k && i.push(k),
                                        i.push(tt),
                                        this.setAngle(Q.angle + 1e-4);
                                        var st = this.cast({
                                            objects: u,
                                            internal: !0
                                        });
                                        st && i.push(st);
                                        continue
                                    }
                                    i.push(tt)
                                }
                            }
                        }
                        return this.setAngle(l),
                        this.intersections = i,
                        this.autoSlice && (this.slicedIntersections = this.slice(i, !1)),
                        this._stats.time = performance.now() - g,
                        this.drawDebug(i),
                        i
                    }
                    r.d(f, {
                        G: function() {
                            return n
                        }
                    })
                },
                67: function(e, f, r) {
                    function o() {
                        var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                        return this.cone = n,
                        this
                    }
                    function a() {
                        var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                        return this.cone = Phaser.Math.DegToRad(n),
                        this
                    }
                    r.d(f, {
                        x: function() {
                            return a
                        },
                        z: function() {
                            return o
                        }
                    })
                },
                376: function(e, f, r) {
                    function o(a) {
                        return this.object = a.object,
                        a.origin !== void 0 && this.origin.setTo(a.origin.x, a.origin.y),
                        a.angle !== void 0 && (this.angle = Phaser.Math.Angle.Normalize(a.angle)),
                        a.angleDeg !== void 0 && (this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(a.angleDeg))),
                        a.cone !== void 0 && (this.cone = a.cone),
                        a.coneDeg !== void 0 && (this.cone = Phaser.Math.DegToRad(a.coneDeg)),
                        a.rayRange !== void 0 && (this.rayRange = a.rayRange),
                        a.collisionRange !== void 0 && (this.collisionRange = a.collisionRange),
                        a.detectionRange !== void 0 && (this.detectionRange = a.detectionRange),
                        a.ignoreNotIntersectedRays !== void 0 && (this.ignoreNotIntersectedRays = a.ignoreNotIntersectedRays == 1),
                        a.round !== void 0 && (this.round = a.round == 1),
                        a.autoSlice !== void 0 && (this.autoSlice = a.autoSlice == 1),
                        a.enablePhysics !== void 0 && a.enablePhysics && this.enablePhysics(a.enablePhysics),
                        Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange),
                        this.detectionRangeCircle.setTo(this.origin.x, this.origin.y, this.detectionRange),
                        this._raycaster.debugOptions.enabled && this._raycaster.scene !== void 0 && (this.graphics = this._raycaster.scene.add.graphics({
                            lineStyle: {
                                width: 1,
                                color: 65280
                            },
                            fillStyle: {
                                color: 16711935
                            }
                        }),
                        this.graphics.setDepth(1e3)),
                        this
                    }
                    r.d(f, {
                        v: function() {
                            return o
                        }
                    })
                },
                737: function(e, f, r) {
                    function o(s, l) {
                        var i = typeof Symbol < "u" && s[Symbol.iterator] || s["@@iterator"];
                        if (!i) {
                            if (Array.isArray(s) || (i = function(g, m) {
                                if (g) {
                                    if (typeof g == "string")
                                        return a(g, m);
                                    var x = Object.prototype.toString.call(g).slice(8, -1);
                                    if (x === "Object" && g.constructor && (x = g.constructor.name),
                                    x === "Map" || x === "Set")
                                        return Array.from(g);
                                    if (x === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(x))
                                        return a(g, m)
                                }
                            }(s)) || l && s && typeof s.length == "number") {
                                i && (s = i);
                                var h = 0
                                  , u = function() {};
                                return {
                                    s: u,
                                    n: function() {
                                        return h >= s.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: s[h++]
                                        }
                                    },
                                    e: function(g) {
                                        throw g
                                    },
                                    f: u
                                }
                            }
                            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                        }
                        var d, v = !0, p = !1;
                        return {
                            s: function() {
                                i = i.call(s)
                            },
                            n: function() {
                                var g = i.next();
                                return v = g.done,
                                g
                            },
                            e: function(g) {
                                p = !0,
                                d = g
                            },
                            f: function() {
                                try {
                                    v || i.return == null || i.return()
                                } finally {
                                    if (p)
                                        throw d
                                }
                            }
                        }
                    }
                    function a(s, l) {
                        (l == null || l > s.length) && (l = s.length);
                        for (var i = 0, h = new Array(l); i < l; i++)
                            h[i] = s[i];
                        return h
                    }
                    function n(s) {
                        if (this.graphics === void 0 || !this._raycaster.debugOptions.enabled)
                            return this;
                        if (this.graphics.clear(),
                        !this._raycaster.debugOptions.rays)
                            return this;
                        if (this._raycaster.debugOptions.graphics.ray) {
                            this.graphics.lineStyle(1, this._raycaster.debugOptions.graphics.ray);
                            var l, i = o(s);
                            try {
                                for (i.s(); !(l = i.n()).done; ) {
                                    var h = l.value;
                                    this.graphics.strokeLineShape({
                                        x1: this.origin.x,
                                        y1: this.origin.y,
                                        x2: h.x,
                                        y2: h.y
                                    })
                                }
                            } catch (p) {
                                i.e(p)
                            } finally {
                                i.f()
                            }
                        }
                        if (this._raycaster.debugOptions.graphics.rayPoint) {
                            this.graphics.fillStyle(this._raycaster.debugOptions.graphics.rayPoint),
                            this.graphics.fillPoint(this.origin.x, this.origin.y, 3);
                            var u, d = o(s);
                            try {
                                for (d.s(); !(u = d.n()).done; ) {
                                    var v = u.value;
                                    this.graphics.fillPoint(v.x, v.y, 3)
                                }
                            } catch (p) {
                                d.e(p)
                            } finally {
                                d.f()
                            }
                        }
                        return this
                    }
                    r.d(f, {
                        K: function() {
                            return n
                        }
                    })
                },
                645: function(e, f, r) {
                    function o() {
                        for (var a in this.graphics && this.graphics.destroy(),
                        this)
                            delete this[a]
                    }
                    r.d(f, {
                        o: function() {
                            return o
                        }
                    })
                },
                847: function(e, f, r) {
                    function o() {
                        var a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "arcade";
                        if (this.body !== void 0)
                            return this;
                        if (this.collisionCircle = this._raycaster.scene.add.circle(this.origin.x, this.origin.y, this.collisionRange),
                        this.collisionCircle._ray = this,
                        a === "matter") {
                            if (this.bodyType = "matter",
                            this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {
                                var n = this._raycaster.boundingBox;
                                this._raycaster.scene.matter.add.gameObject(this.collisionCircle, {
                                    shape: {
                                        type: "rectangle",
                                        x: n.rectangle.centerX,
                                        y: n.rectangle.centerY,
                                        width: n.rectangle.width,
                                        height: n.rectangle.height
                                    },
                                    label: "phaser-raycaster-ray-body",
                                    isSensor: !0,
                                    ignoreGravity: !0
                                })
                            } else
                                this._raycaster.scene.matter.add.gameObject(this.collisionCircle, {
                                    shape: {
                                        type: "circle"
                                    },
                                    label: "phaser-raycaster-ray-body",
                                    isSensor: !0,
                                    ignoreGravity: !0
                                });
                            this.body = this.collisionCircle.body,
                            this.body._ray = this,
                            this.setOnCollideActive()
                        } else
                            this.bodyType = "arcade",
                            this._raycaster.scene.physics.add.existing(this.collisionCircle),
                            this.body = this.collisionCircle.body,
                            this.body.setCircle(this.collisionRange).setAllowGravity(!1).setImmovable(!0),
                            this.body._ray = this;
                        return this
                    }
                    r.d(f, {
                        W: function() {
                            return o
                        }
                    })
                },
                729: function(e, f, r) {
                    function o(u) {
                        return this.body.collisionFilter.category = u,
                        this
                    }
                    function a(u) {
                        return this.body.collisionFilter.group = u,
                        this
                    }
                    function n(u) {
                        var d = 0;
                        if (Array.isArray(u))
                            for (var v = 0; v < u.length; v++)
                                d |= u[v];
                        else
                            d = u;
                        return this.body.collisionFilter.mask = d,
                        this
                    }
                    function s(u) {
                        var d = this;
                        return this.body.onCollideCallback = function(v) {
                            v.rayCollided ? u(v) : d.processOverlap(v) && (v.rayCollided = !0,
                            u(v))
                        }
                        ,
                        this
                    }
                    function l(u) {
                        return this.body.onCollideEndCallback = function(d) {
                            d.rayCollided && (d.rayCollided = !1,
                            u(d))
                        }
                        ,
                        this
                    }
                    function i(u) {
                        var d = this;
                        return this.body.onCollideActiveCallback = function(v) {
                            if (d.processOverlap(v)) {
                                var p = v.bodyA.label === "phaser-raycaster-ray-body" ? v.bodyB : v.bodyA;
                                v.rayCollided !== !0 && (v.rayCollided = !0,
                                d.body.onCollideCallback && d.body.onCollideCallback(v),
                                d.body.onCollideWith !== void 0 && d.body.onCollideWith[p.id] && d.body.onCollideWith[p.id](p, v)),
                                u && u(v)
                            } else
                                d.body.onCollideEndCallback && v.rayCollided === !0 && d.body.onCollideEndCallback(v)
                        }
                        ,
                        this
                    }
                    function h(u, d) {
                        var v = this
                          , p = function(x, T) {
                            T.rayCollided ? d(x, T) : v.processOverlap(T) && (T.rayCollided = !0,
                            d(x, T))
                        };
                        Array.isArray(u) || (u = [u]);
                        for (var g = 0; g < u.length; g++) {
                            var m = u[g].hasOwnProperty("body") ? u[g].body : u[g];
                            this.body.setOnCollideWith(m, p)
                        }
                        return this
                    }
                    r.d(f, {
                        B5: function() {
                            return a
                        },
                        Jt: function() {
                            return s
                        },
                        f3: function() {
                            return n
                        },
                        iN: function() {
                            return l
                        },
                        kK: function() {
                            return i
                        },
                        wy: function() {
                            return h
                        },
                        y4: function() {
                            return o
                        }
                    })
                },
                262: function(e, f, r) {
                    function o(a, n) {
                        return this.origin.setTo(a, n),
                        Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange),
                        this.detectionRangeCircle.setTo(this.origin.x, this.origin.y, this.detectionRange),
                        (this.bodyType === "matter" && this.collisionRange !== Phaser.Math.MAX_SAFE_INTEGER || this.bodyType === "arcade") && (this.collisionCircle.x = a,
                        this.collisionCircle.y = n),
                        this
                    }
                    r.d(f, {
                        j: function() {
                            return o
                        }
                    })
                },
                72: function(e, f, r) {
                    function o(h, u) {
                        var d = typeof Symbol < "u" && h[Symbol.iterator] || h["@@iterator"];
                        if (!d) {
                            if (Array.isArray(h) || (d = function(T, E) {
                                if (T) {
                                    if (typeof T == "string")
                                        return a(T, E);
                                    var P = Object.prototype.toString.call(T).slice(8, -1);
                                    if (P === "Object" && T.constructor && (P = T.constructor.name),
                                    P === "Map" || P === "Set")
                                        return Array.from(T);
                                    if (P === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(P))
                                        return a(T, E)
                                }
                            }(h)) || u && h && typeof h.length == "number") {
                                d && (h = d);
                                var v = 0
                                  , p = function() {};
                                return {
                                    s: p,
                                    n: function() {
                                        return v >= h.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: h[v++]
                                        }
                                    },
                                    e: function(T) {
                                        throw T
                                    },
                                    f: p
                                }
                            }
                            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                        }
                        var g, m = !0, x = !1;
                        return {
                            s: function() {
                                d = d.call(h)
                            },
                            n: function() {
                                var T = d.next();
                                return m = T.done,
                                T
                            },
                            e: function(T) {
                                x = !0,
                                g = T
                            },
                            f: function() {
                                try {
                                    m || d.return == null || d.return()
                                } finally {
                                    if (x)
                                        throw g
                                }
                            }
                        }
                    }
                    function a(h, u) {
                        (u == null || u > h.length) && (u = h.length);
                        for (var d = 0, v = new Array(u); d < u; d++)
                            v[d] = h[d];
                        return v
                    }
                    function n(h) {
                        var u = []
                          , d = new Phaser.Geom.Circle(this.origin.x,this.origin.y,this.collisionRange);
                        if (this.bodyType === "matter")
                            if (h === void 0) {
                                var v, p = o(h = this._raycaster.scene.matter.query.collides(this.body, this._raycaster.scene.matter.getMatterBodies()));
                                try {
                                    for (p.s(); !(v = p.n()).done; ) {
                                        var g = v.value
                                          , m = g.bodyA === this.body ? g.bodyB : g.bodyA;
                                        this.testMatterOverlap(m) && u.push(m)
                                    }
                                } catch (z) {
                                    p.e(z)
                                } finally {
                                    p.f()
                                }
                            } else {
                                Array.isArray(h) || (h = [h]);
                                var x, T = o(h);
                                try {
                                    for (T.s(); !(x = T.n()).done; ) {
                                        var E = x.value;
                                        E !== this.body && this.testMatterOverlap(E) && u.push(E)
                                    }
                                } catch (z) {
                                    T.e(z)
                                } finally {
                                    T.f()
                                }
                            }
                        else {
                            var P = !1;
                            if (h === void 0 ? (h = this._raycaster.scene.physics.overlapCirc(this.origin.x, this.origin.y, this.collisionRange, !0, !0),
                            P = !0) : Array.isArray(h) || (h = [h]),
                            P) {
                                var M, L = o(h);
                                try {
                                    for (L.s(); !(M = L.n()).done; ) {
                                        var R = M.value;
                                        if (R !== this.body) {
                                            var O = void 0;
                                            O = R.isCircle ? new Phaser.Geom.Circle(R.position.x + R.halfWidth,R.position.y + R.halfWidth,R.halfWidth) : new Phaser.Geom.Rectangle(R.x,R.y,R.width,R.height),
                                            this.testArcadeOverlap(O) && u.push(R.gameObject)
                                        }
                                    }
                                } catch (z) {
                                    L.e(z)
                                } finally {
                                    L.f()
                                }
                            } else {
                                var F, B = o(h);
                                try {
                                    for (B.s(); !(F = B.n()).done; ) {
                                        var N = F.value;
                                        if (N.body !== void 0) {
                                            var Y = void 0;
                                            if (N.body.isCircle) {
                                                if (Y = new Phaser.Geom.Circle(N.body.position.x + N.body.halfWidth,N.body.position.y + N.body.halfWidth,N.body.halfWidth),
                                                !Phaser.Geom.Intersects.CircleToCircle(d, Y))
                                                    continue
                                            } else if (Y = new Phaser.Geom.Rectangle(N.body.x,N.body.y,N.body.width,N.body.height),
                                            !Phaser.Geom.Intersects.CircleToRectangle(d, Y))
                                                continue;
                                            this.testArcadeOverlap(Y) && u.push(N)
                                        }
                                    }
                                } catch (z) {
                                    B.e(z)
                                } finally {
                                    B.f()
                                }
                            }
                        }
                        return u
                    }
                    function s(h, u) {
                        var d, v, p;
                        if (h.bodyA !== void 0 && h.bodyB !== void 0 ? (d = h.bodyA,
                        v = h.bodyB) : (d = h,
                        v = u),
                        d._ray !== void 0 && d._ray === this)
                            p = v;
                        else {
                            if (v._ray === void 0 || v._ray !== this)
                                return !1;
                            p = d
                        }
                        return this.overlap(p).length > 0
                    }
                    function l(h) {
                        var u, d = o(this.slicedIntersections);
                        try {
                            for (d.s(); !(u = d.n()).done; ) {
                                var v = u.value;
                                if (h.type == 0 ? Phaser.Geom.Intersects.TriangleToCircle(v, h) : Phaser.Geom.Intersects.RectangleToTriangle(h, v))
                                    return !0
                            }
                        } catch (p) {
                            d.e(p)
                        } finally {
                            d.f()
                        }
                        return !1
                    }
                    function i(h) {
                        var u;
                        if (h.type === "body")
                            u = h;
                        else {
                            if (h.body === void 0)
                                return !1;
                            u = h.body
                        }
                        var d, v = o(u.parts.length > 1 ? u.parts.splice(1) : u.parts);
                        try {
                            for (v.s(); !(d = v.n()).done; ) {
                                for (var p = d.value, g = p.vertices[0], m = 1, x = p.vertices.length; m < x; m++) {
                                    var T, E = p.vertices[m], P = new Phaser.Geom.Line(g.x,g.y,E.x,E.y), M = o(this.slicedIntersections);
                                    try {
                                        for (M.s(); !(T = M.n()).done; ) {
                                            var L = T.value
                                              , R = Phaser.Geom.Intersects.TriangleToLine(L, P);
                                            if (R || (R = Phaser.Geom.Triangle.ContainsPoint(L, P.getPointA())),
                                            R || (R = Phaser.Geom.Triangle.ContainsPoint(L, P.getPointB())),
                                            R)
                                                return !0
                                        }
                                    } catch (Y) {
                                        M.e(Y)
                                    } finally {
                                        M.f()
                                    }
                                    g = E
                                }
                                var O, F = new Phaser.Geom.Line(p.vertices[p.vertices.length - 1].x,p.vertices[p.vertices.length - 1].y,p.vertices[0].x,p.vertices[0].y), B = o(this.slicedIntersections);
                                try {
                                    for (B.s(); !(O = B.n()).done; ) {
                                        var N = O.value;
                                        if (Phaser.Geom.Intersects.TriangleToLine(N, F))
                                            return !0
                                    }
                                } catch (Y) {
                                    B.e(Y)
                                } finally {
                                    B.f()
                                }
                            }
                        } catch (Y) {
                            v.e(Y)
                        } finally {
                            v.f()
                        }
                        return !1
                    }
                    r.d(f, {
                        at: function() {
                            return n
                        },
                        h2: function() {
                            return l
                        },
                        jD: function() {
                            return s
                        },
                        z_: function() {
                            return i
                        }
                    })
                },
                533: function(e, f, r) {
                    function o() {
                        var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Phaser.Math.MAX_SAFE_INTEGER;
                        return this.rayRange = l,
                        Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange),
                        this
                    }
                    function a() {
                        var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                        return this.detectionRange = l,
                        this.detectionRangeCircle.setTo(this.origin.x, this.origin.y, this.detectionRange),
                        this
                    }
                    function n() {
                        var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Phaser.Math.MAX_SAFE_INTEGER
                          , i = this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER;
                        if (this.collisionRange = l,
                        this.collisionCircle.setRadius(this.collisionRange),
                        this.bodyType === "matter") {
                            if (this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {
                                var h = this._raycaster.boundingBox;
                                this._raycaster.scene.matter.body.set(this.body, {
                                    shape: {
                                        type: "rectangle",
                                        x: h.rectangle.centerX,
                                        y: h.rectangle.centerY,
                                        width: h.rectangle.width,
                                        height: h.rectangle.height,
                                        circleRadius: 0
                                    }
                                })
                            } else
                                i ? this._raycaster.scene.matter.body.set(this.body, {
                                    shape: {
                                        type: "circle",
                                        x: this.collisionCircle.x,
                                        y: this.collisionCircle.y
                                    },
                                    circleRadius: this.collisionRange,
                                    isStatic: !1
                                }) : this.collisionCircle.setRadius(this.collisionRange);
                            this._raycaster.scene.matter.body.set(this.body, "circleRadius", this.collisionRange)
                        } else
                            this.bodyType === "arcade" && this.body.setCircle(this.collisionRange);
                        return this
                    }
                    function s(l) {
                        var i, h = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
                        return !this.detectionRange || (i = h || (l.type === "body" || l.type === "composite" ? l.raycasterMap.getBoundingBox() : l.data.get("raycasterMap").getBoundingBox()),
                        !!Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, i))
                    }
                    r.d(f, {
                        HL: function() {
                            return o
                        },
                        lG: function() {
                            return n
                        },
                        qw: function() {
                            return a
                        },
                        sp: function() {
                            return s
                        }
                    })
                },
                426: function(e, f, r) {
                    function o(a, n) {
                        this._raycaster = n || !1,
                        this.origin = new Phaser.Geom.Point,
                        this._ray = new Phaser.Geom.Line,
                        this.angle = 0,
                        this.cone = 0,
                        this.rayRange = Phaser.Math.MAX_SAFE_INTEGER,
                        this.detectionRange = 0,
                        this.detectionRangeCircle = new Phaser.Geom.Circle,
                        this.collisionRange = Phaser.Math.MAX_SAFE_INTEGER,
                        this.ignoreNotIntersectedRays = !0,
                        this.round = !1,
                        this.autoSlice = !1,
                        this.intersections = [],
                        this.slicedIntersections = [],
                        this.bodyType = !1,
                        this._stats = {
                            method: "cast",
                            rays: 0,
                            testedMappedObjects: 0,
                            hitMappedObjects: 0,
                            segments: 0,
                            time: 0
                        },
                        this.graphics,
                        this.config(a)
                    }
                    r.d(f, {
                        z: function() {
                            return o
                        }
                    }),
                    o.prototype = {
                        config: r(376).v,
                        getStats: r(414).f,
                        setRay: r(394).R,
                        setOrigin: r(262).j,
                        setRayRange: r(533).HL,
                        setAngle: r(519).e,
                        setAngleDeg: r(519).m,
                        setCone: r(67).z,
                        setConeDeg: r(67).x,
                        setDetectionRange: r(533).qw,
                        boundsInRange: r(533).sp,
                        cast: r(157).p,
                        castCircle: r(330).q,
                        castCone: r(352).G,
                        slice: r(663).t,
                        setCollisionRange: r(533).lG,
                        enablePhysics: r(847).W,
                        overlap: r(72).at,
                        processOverlap: r(72).jD,
                        testArcadeOverlap: r(72).h2,
                        testMatterOverlap: r(72).z_,
                        setCollisionCategory: r(729).y4,
                        setCollisionGroup: r(729).B5,
                        setCollidesWith: r(729).f3,
                        setOnCollide: r(729).Jt,
                        setOnCollideEnd: r(729).iN,
                        setOnCollideActive: r(729).kK,
                        setOnCollideWith: r(729).wy,
                        drawDebug: r(737).K,
                        destroy: r(645).o
                    }
                },
                394: function(e, f, r) {
                    function o(a, n, s) {
                        var l = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Phaser.Math.MAX_SAFE_INTEGER;
                        return this.origin.setTo(a, n),
                        this.angle = Phaser.Math.Angle.Normalize(s),
                        this.rayRange = l,
                        Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange),
                        this.detectionRangeCircle.setTo(this.origin.x, this.origin.y, this.detectionRange),
                        this
                    }
                    r.d(f, {
                        R: function() {
                            return o
                        }
                    })
                },
                663: function(e, f, r) {
                    function o() {
                        var a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.intersections
                          , n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
                        if (!Array.isArray(a)) {
                            if (a.type !== 4)
                                return [];
                            a = a.points
                        }
                        if (a.length === 0)
                            return [];
                        for (var s = [], l = 0, i = a.length - 1; l < i; l++)
                            s.push(new Phaser.Geom.Triangle(this.origin.x,this.origin.y,a[l].x,a[l].y,a[l + 1].x,a[l + 1].y));
                        return n && s.push(new Phaser.Geom.Triangle(this.origin.x,this.origin.y,a[0].x,a[0].y,a[a.length - 1].x,a[a.length - 1].y)),
                        s
                    }
                    r.d(f, {
                        t: function() {
                            return o
                        }
                    })
                },
                414: function(e, f, r) {
                    function o() {
                        return this._stats
                    }
                    r.d(f, {
                        f: function() {
                            return o
                        }
                    })
                },
                741: function(e, f, r) {
                    function o(l, i) {
                        var h = typeof Symbol < "u" && l[Symbol.iterator] || l["@@iterator"];
                        if (!h) {
                            if (Array.isArray(l) || (h = function(m, x) {
                                if (m) {
                                    if (typeof m == "string")
                                        return a(m, x);
                                    var T = Object.prototype.toString.call(m).slice(8, -1);
                                    if (T === "Object" && m.constructor && (T = m.constructor.name),
                                    T === "Map" || T === "Set")
                                        return Array.from(m);
                                    if (T === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(T))
                                        return a(m, x)
                                }
                            }(l)) || i && l && typeof l.length == "number") {
                                h && (l = h);
                                var u = 0
                                  , d = function() {};
                                return {
                                    s: d,
                                    n: function() {
                                        return u >= l.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: l[u++]
                                        }
                                    },
                                    e: function(m) {
                                        throw m
                                    },
                                    f: d
                                }
                            }
                            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                        }
                        var v, p = !0, g = !1;
                        return {
                            s: function() {
                                h = h.call(l)
                            },
                            n: function() {
                                var m = h.next();
                                return p = m.done,
                                m
                            },
                            e: function(m) {
                                g = !0,
                                v = m
                            },
                            f: function() {
                                try {
                                    p || h.return == null || h.return()
                                } finally {
                                    if (g)
                                        throw v
                                }
                            }
                        }
                    }
                    function a(l, i) {
                        (i == null || i > l.length) && (i = l.length);
                        for (var h = 0, u = new Array(i); h < i; h++)
                            u[h] = l[h];
                        return u
                    }
                    function n(l) {
                        return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(i) {
                            return typeof i
                        }
                        : function(i) {
                            return i && typeof Symbol == "function" && i.constructor === Symbol && i !== Symbol.prototype ? "symbol" : typeof i
                        }
                        ,
                        n(l);
                        /**
* @author       Marcin Walczak <contact@marcin-walczak.pl>
* @copyright    2023 Marcin Walczak
* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}
*/
                    }
                    function s(l) {
                        if (this.version = "0.10.6",
                        this.scene,
                        this.graphics,
                        this.debugOptions = {
                            enabled: !1,
                            maps: !0,
                            rays: !0,
                            graphics: {
                                ray: 65280,
                                rayPoint: 16711935,
                                mapPoint: 65535,
                                mapSegment: 255,
                                mapBoundingBox: 16711680
                            }
                        },
                        this._stats = {
                            mappedObjects: {
                                total: 0,
                                static: 0,
                                dynamic: 0,
                                rectangleMaps: 0,
                                polygonMaps: 0,
                                circleMaps: 0,
                                lineMaps: 0,
                                containerMaps: 0,
                                tilemapMaps: 0,
                                matterMaps: 0
                            }
                        },
                        this.boundingBox = !1,
                        this.mappedObjects = [],
                        this.dynamicMappedObjects = [],
                        this.mapSegmentCount = 0,
                        l !== void 0) {
                            if (l.boundingBox === void 0 && l.scene !== void 0) {
                                if (l.scene.physics !== void 0)
                                    l.boundingBox = l.scene.physics.world.bounds;
                                else if (l.scene.matter !== void 0) {
                                    var i = l.scene.matter.world.walls;
                                    i.top !== null && (l.boundingBox = new Phaser.Geom.Rectangle(i.top.vertices[3].x,i.top.vertices[3].y,i.bottom.vertices[1].x - i.top.vertices[3].x,i.bottom.vertices[1].y - i.top.vertices[3].y))
                                }
                            }
                            this.setOptions(l),
                            (l.autoUpdate === void 0 || l.autoUpdate) && this.scene.events.on("update", this.update, this)
                        } else
                            this.scene.events.on("update", this.update, this);
                        return this
                    }
                    r.d(f, {
                        i: function() {
                            return s
                        }
                    }),
                    s.prototype = {
                        setOptions: function(l) {
                            return l.scene !== void 0 && (this.scene = l.scene,
                            this.graphics = this.scene.add.graphics({
                                lineStyle: {
                                    width: 1,
                                    color: 65280
                                },
                                fillStyle: {
                                    color: 16711935
                                }
                            }),
                            this.graphics.setDepth(999)),
                            l.debug !== void 0 && l.debug !== !1 && (this.debugOptions.enabled = !0,
                            n(l.debug) === "object" && Object.assign(this.debugOptions, l.debug)),
                            l.mapSegmentCount !== void 0 && (this.mapSegmentCount = l.mapSegmentCount),
                            l.objects !== void 0 && this.mapGameObjects(l.objects),
                            l.boundingBox !== void 0 && this.setBoundingBox(l.boundingBox.x, l.boundingBox.y, l.boundingBox.width, l.boundingBox.height),
                            this
                        },
                        setBoundingBox: function(l, i, h, u) {
                            this.boundingBox = {
                                rectangle: new Phaser.Geom.Rectangle(l,i,h,u),
                                points: [],
                                segments: []
                            };
                            var d = [new Phaser.Geom.Point(this.boundingBox.rectangle.left,this.boundingBox.rectangle.top), new Phaser.Geom.Point(this.boundingBox.rectangle.right,this.boundingBox.rectangle.top), new Phaser.Geom.Point(this.boundingBox.rectangle.right,this.boundingBox.rectangle.bottom), new Phaser.Geom.Point(this.boundingBox.rectangle.left,this.boundingBox.rectangle.bottom)];
                            this.boundingBox.points = d;
                            for (var v = 0, p = this.boundingBox.points.length; v < p; v++)
                                v + 1 < p ? this.boundingBox.segments.push(new Phaser.Geom.Line(d[v].x,d[v].y,d[v + 1].x,d[v + 1].y)) : this.boundingBox.segments.push(new Phaser.Geom.Line(d[v].x,d[v].y,d[0].x,d[0].y))
                        },
                        mapGameObjects: function(l) {
                            var i = arguments.length > 1 && arguments[1] !== void 0 && arguments[1]
                              , h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                            h.dynamic = i,
                            h.segmentCount = h.segmentCount !== void 0 ? h.segmentCount : this.segmentCount,
                            Array.isArray(l) || (l = [l]);
                            var u, d = o(l);
                            try {
                                for (d.s(); !(u = d.n()).done; ) {
                                    var v = u.value;
                                    if (!this.mappedObjects.includes(v) && (!v.data || !v.data.get("raycasterMapNotSupported"))) {
                                        var p = {};
                                        for (var g in h)
                                            p[g] = h[g];
                                        p.object = v;
                                        var m = new this.Map(p,this);
                                        if (m.notSupported)
                                            m.destroy();
                                        else
                                            switch (v.type === "body" || v.type === "composite" ? v.raycasterMap = m : (v.data || v.setDataEnabled(),
                                            v.data.set("raycasterMap", m)),
                                            this.mappedObjects.push(v),
                                            v.type) {
                                            case "Polygon":
                                                this._stats.mappedObjects.polygonMaps++;
                                                break;
                                            case "Arc":
                                                this._stats.mappedObjects.circleMaps++;
                                                break;
                                            case "Line":
                                                this._stats.mappedObjects.lineMaps++;
                                                break;
                                            case "Container":
                                                this._stats.mappedObjects.containerMaps++;
                                                break;
                                            case "StaticTilemapLayer":
                                            case "DynamicTilemapLayer":
                                            case "TilemapLayer":
                                                this._stats.mappedObjects.tilemapMaps++;
                                                break;
                                            case "MatterBody":
                                                this._stats.mappedObjects.matterMaps++;
                                                break;
                                            default:
                                                this._stats.mappedObjects.rectangleMaps++
                                            }
                                    }
                                }
                            } catch (x) {
                                d.e(x)
                            } finally {
                                d.f()
                            }
                            return this._stats.mappedObjects.total = this.mappedObjects.length,
                            this._stats.mappedObjects.static = this._stats.mappedObjects.total - this.dynamicMappedObjects.length,
                            this
                        },
                        removeMappedObjects: function(l) {
                            Array.isArray(l) || (l = [l]);
                            var i, h = o(l);
                            try {
                                for (h.s(); !(i = h.n()).done; ) {
                                    var u = i.value
                                      , d = this.mappedObjects.indexOf(u);
                                    switch (d >= 0 && this.mappedObjects.splice(d, 1),
                                    (d = this.dynamicMappedObjects.indexOf(u)) >= 0 && this.dynamicMappedObjects.splice(d, 1),
                                    u.type === "body" || u.type === "composite" ? u.raycasterMap.destroy() : u.data.get("raycasterMap").destroy(),
                                    u.type) {
                                    case "Polygon":
                                        this._stats.mappedObjects.polygonMaps--;
                                        break;
                                    case "Arc":
                                        this._stats.mappedObjects.circleMaps--;
                                        break;
                                    case "Line":
                                        this._stats.mappedObjects.lineMaps--;
                                        break;
                                    case "Container":
                                        this._stats.mappedObjects.containerMaps--;
                                        break;
                                    case "StaticTilemapLayer":
                                    case "DynamicTilemapLayer":
                                    case "TilemapLayer":
                                        this._stats.mappedObjects.tilemapMaps--;
                                        break;
                                    case "MatterBody":
                                        this._stats.mappedObjects.matterMaps--;
                                        break;
                                    default:
                                        this._stats.mappedObjects.rectangleMaps--
                                    }
                                }
                            } catch (v) {
                                h.e(v)
                            } finally {
                                h.f()
                            }
                            return this._stats.mappedObjects.total = this.mappedObjects.length,
                            this._stats.mappedObjects.dynamic = this.dynamicMappedObjects.length,
                            this._stats.mappedObjects.static = this._stats.mappedObjects.total - this.dynamicMappedObjects.length,
                            this
                        },
                        enableMaps: function(l) {
                            Array.isArray(l) || (l = [l]);
                            var i, h = o(l);
                            try {
                                for (h.s(); !(i = h.n()).done; ) {
                                    var u = i.value
                                      , d = void 0;
                                    u.type === "body" || u.type === "composite" ? d = u.raycasterMap : u.data && (d = u.data.get("raycasterMap")),
                                    d && (d.active = !0)
                                }
                            } catch (v) {
                                h.e(v)
                            } finally {
                                h.f()
                            }
                            return this
                        },
                        disableMaps: function(l) {
                            Array.isArray(l) || (l = [l]);
                            var i, h = o(l);
                            try {
                                for (h.s(); !(i = h.n()).done; ) {
                                    var u = i.value
                                      , d = void 0;
                                    u.type === "body" || u.type === "composite" ? d = u.raycasterMap : u.data && (d = u.data.get("raycasterMap")),
                                    d && (d.active = !1)
                                }
                            } catch (v) {
                                h.e(v)
                            } finally {
                                h.f()
                            }
                            return this
                        },
                        update: function() {
                            if (this.dynamicMappedObjects.length > 0) {
                                var l, i = o(this.dynamicMappedObjects);
                                try {
                                    for (i.s(); !(l = i.n()).done; ) {
                                        var h = l.value
                                          , u = void 0;
                                        h.type === "body" || h.type === "composite" ? u = h.raycasterMap : h.data && (u = h.data.get("raycasterMap")),
                                        u && u.active && u.updateMap()
                                    }
                                } catch (d) {
                                    i.e(d)
                                } finally {
                                    i.f()
                                }
                            }
                            return this.debugOptions.enabled && this.drawDebug(),
                            this
                        },
                        createRay: function() {
                            var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                            return new this.Ray(l,this)
                        },
                        getStats: function() {
                            return this._stats
                        },
                        drawDebug: function() {
                            if (this.graphics === void 0 || !this.debugOptions.enabled)
                                return this;
                            if (this.graphics.clear(),
                            !this.debugOptions.maps)
                                return this;
                            var l, i = o(this.mappedObjects);
                            try {
                                for (i.s(); !(l = i.n()).done; ) {
                                    var h = l.value
                                      , u = void 0;
                                    if (h.type === "body" || h.type === "composite" ? u = h.raycasterMap : h.data && (u = h.data.get("raycasterMap")),
                                    u) {
                                        if (this.debugOptions.graphics.mapBoundingBox && (this.graphics.lineStyle(1, this.debugOptions.graphics.mapBoundingBox),
                                        this.graphics.strokeRectShape(u.getBoundingBox())),
                                        this.debugOptions.graphics.mapSegment) {
                                            this.graphics.lineStyle(1, this.debugOptions.graphics.mapSegment);
                                            var d, v = o(u.getSegments());
                                            try {
                                                for (v.s(); !(d = v.n()).done; ) {
                                                    var p = d.value;
                                                    this.graphics.strokeLineShape(p)
                                                }
                                            } catch (T) {
                                                v.e(T)
                                            } finally {
                                                v.f()
                                            }
                                        }
                                        if (this.debugOptions.graphics.mapPoint) {
                                            this.graphics.fillStyle(this.debugOptions.graphics.mapPoint);
                                            var g, m = o(u.getPoints());
                                            try {
                                                for (m.s(); !(g = m.n()).done; ) {
                                                    var x = g.value;
                                                    this.graphics.fillPoint(x.x, x.y, 3)
                                                }
                                            } catch (T) {
                                                m.e(T)
                                            } finally {
                                                m.f()
                                            }
                                        }
                                    }
                                }
                            } catch (T) {
                                i.e(T)
                            } finally {
                                i.f()
                            }
                            return this
                        },
                        destroy: function() {
                            for (var l in this.removeMappedObjects(this.mappedObjects),
                            this.graphics && this.graphics.destroy(),
                            this.scene && this.scene.events.removeListener("update", null, this),
                            this)
                                delete this[l]
                        }
                    },
                    s.prototype.Map = r(667).D,
                    s.prototype.Ray = r(426).z
                }
            }
              , S = {};
            function t(e) {
                var f = S[e];
                if (f !== void 0)
                    return f.exports;
                var r = S[e] = {
                    exports: {}
                };
                return c[e](r, r.exports, t),
                r.exports
            }
            return t.d = function(e, f) {
                for (var r in f)
                    t.o(f, r) && !t.o(e, r) && Object.defineProperty(e, r, {
                        enumerable: !0,
                        get: f[r]
                    })
            }
            ,
            t.o = function(e, f) {
                return Object.prototype.hasOwnProperty.call(e, f)
            }
            ,
            t.r = function(e) {
                typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                    value: "Module"
                }),
                Object.defineProperty(e, "__esModule", {
                    value: !0
                })
            }
            ,
            t(880)
        }()
    })
}
)(Zo);
const Jo = Yr(wn);
var Xr = "1.13.6"
  , Vs = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global || Function("return this")() || {}
  , rn = Array.prototype
  , ns = Object.prototype
  , Ws = typeof Symbol < "u" ? Symbol.prototype : null
  , jo = rn.push
  , Pi = rn.slice
  , ui = ns.toString
  , $o = ns.hasOwnProperty
  , zr = typeof ArrayBuffer < "u"
  , Qo = typeof DataView < "u"
  , ko = Array.isArray
  , Hs = Object.keys
  , bs = Object.create
  , Ks = zr && ArrayBuffer.isView
  , qo = isNaN
  , _o = isFinite
  , Vr = !{
    toString: null
}.propertyIsEnumerable("toString")
  , Zs = ["valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"]
  , th = Math.pow(2, 53) - 1;
function Ht(C, A) {
    return A = A == null ? C.length - 1 : +A,
    function() {
        for (var c = Math.max(arguments.length - A, 0), S = Array(c), t = 0; t < c; t++)
            S[t] = arguments[t + A];
        switch (A) {
        case 0:
            return C.call(this, S);
        case 1:
            return C.call(this, arguments[0], S);
        case 2:
            return C.call(this, arguments[0], arguments[1], S)
        }
        var e = Array(A + 1);
        for (t = 0; t < A; t++)
            e[t] = arguments[t];
        return e[A] = S,
        C.apply(this, e)
    }
}
function Ye(C) {
    var A = typeof C;
    return A === "function" || A === "object" && !!C
}
function eh(C) {
    return C === null
}
function Wr(C) {
    return C === void 0
}
function Hr(C) {
    return C === !0 || C === !1 || ui.call(C) === "[object Boolean]"
}
function ih(C) {
    return !!(C && C.nodeType === 1)
}
function Ut(C) {
    var A = "[object " + C + "]";
    return function(c) {
        return ui.call(c) === A
    }
}
const ss = Ut("String")
  , br = Ut("Number")
  , nh = Ut("Date")
  , sh = Ut("RegExp")
  , rh = Ut("Error")
  , Kr = Ut("Symbol")
  , Zr = Ut("ArrayBuffer");
var Jr = Ut("Function")
  , ah = Vs.document && Vs.document.childNodes;
typeof /./ != "function" && typeof Int8Array != "object" && typeof ah != "function" && (Jr = function(C) {
    return typeof C == "function" || !1
}
);
const Vt = Jr
  , jr = Ut("Object");
var $r = Qo && jr(new DataView(new ArrayBuffer(8)))
  , rs = typeof Map < "u" && jr(new Map)
  , oh = Ut("DataView");
function hh(C) {
    return C != null && Vt(C.getInt8) && Zr(C.buffer)
}
const ji = $r ? hh : oh
  , Xe = ko || Ut("Array");
function Ce(C, A) {
    return C != null && $o.call(C, A)
}
var Un = Ut("Arguments");
(function() {
    Un(arguments) || (Un = function(C) {
        return Ce(C, "callee")
    }
    )
}
)();
const as = Un;
function lh(C) {
    return !Kr(C) && _o(C) && !isNaN(parseFloat(C))
}
function Qr(C) {
    return br(C) && qo(C)
}
function kr(C) {
    return function() {
        return C
    }
}
function qr(C) {
    return function(A) {
        var c = C(A);
        return typeof c == "number" && c >= 0 && c <= th
    }
}
function _r(C) {
    return function(A) {
        return A == null ? void 0 : A[C]
    }
}
const $i = _r("byteLength")
  , uh = qr($i);
var fh = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
function dh(C) {
    return Ks ? Ks(C) && !ji(C) : uh(C) && fh.test(ui.call(C))
}
const ta = zr ? dh : kr(!1)
  , bt = _r("length");
function vh(C) {
    for (var A = {}, c = C.length, S = 0; S < c; ++S)
        A[C[S]] = !0;
    return {
        contains: function(t) {
            return A[t] === !0
        },
        push: function(t) {
            return A[t] = !0,
            C.push(t)
        }
    }
}
function ea(C, A) {
    A = vh(A);
    var c = Zs.length
      , S = C.constructor
      , t = Vt(S) && S.prototype || ns
      , e = "constructor";
    for (Ce(C, e) && !A.contains(e) && A.push(e); c--; )
        e = Zs[c],
        e in C && C[e] !== t[e] && !A.contains(e) && A.push(e)
}
function It(C) {
    if (!Ye(C))
        return [];
    if (Hs)
        return Hs(C);
    var A = [];
    for (var c in C)
        Ce(C, c) && A.push(c);
    return Vr && ea(C, A),
    A
}
function ch(C) {
    if (C == null)
        return !0;
    var A = bt(C);
    return typeof A == "number" && (Xe(C) || ss(C) || as(C)) ? A === 0 : bt(It(C)) === 0
}
function ia(C, A) {
    var c = It(A)
      , S = c.length;
    if (C == null)
        return !S;
    for (var t = Object(C), e = 0; e < S; e++) {
        var f = c[e];
        if (A[f] !== t[f] || !(f in t))
            return !1
    }
    return !0
}
function Tt(C) {
    if (C instanceof Tt)
        return C;
    if (!(this instanceof Tt))
        return new Tt(C);
    this._wrapped = C
}
Tt.VERSION = Xr;
Tt.prototype.value = function() {
    return this._wrapped
}
;
Tt.prototype.valueOf = Tt.prototype.toJSON = Tt.prototype.value;
Tt.prototype.toString = function() {
    return String(this._wrapped)
}
;
function Js(C) {
    return new Uint8Array(C.buffer || C,C.byteOffset || 0,$i(C))
}
var js = "[object DataView]";
function Yn(C, A, c, S) {
    if (C === A)
        return C !== 0 || 1 / C === 1 / A;
    if (C == null || A == null)
        return !1;
    if (C !== C)
        return A !== A;
    var t = typeof C;
    return t !== "function" && t !== "object" && typeof A != "object" ? !1 : na(C, A, c, S)
}
function na(C, A, c, S) {
    C instanceof Tt && (C = C._wrapped),
    A instanceof Tt && (A = A._wrapped);
    var t = ui.call(C);
    if (t !== ui.call(A))
        return !1;
    if ($r && t == "[object Object]" && ji(C)) {
        if (!ji(A))
            return !1;
        t = js
    }
    switch (t) {
    case "[object RegExp]":
    case "[object String]":
        return "" + C == "" + A;
    case "[object Number]":
        return +C != +C ? +A != +A : +C == 0 ? 1 / +C === 1 / A : +C == +A;
    case "[object Date]":
    case "[object Boolean]":
        return +C == +A;
    case "[object Symbol]":
        return Ws.valueOf.call(C) === Ws.valueOf.call(A);
    case "[object ArrayBuffer]":
    case js:
        return na(Js(C), Js(A), c, S)
    }
    var e = t === "[object Array]";
    if (!e && ta(C)) {
        var f = $i(C);
        if (f !== $i(A))
            return !1;
        if (C.buffer === A.buffer && C.byteOffset === A.byteOffset)
            return !0;
        e = !0
    }
    if (!e) {
        if (typeof C != "object" || typeof A != "object")
            return !1;
        var r = C.constructor
          , o = A.constructor;
        if (r !== o && !(Vt(r) && r instanceof r && Vt(o) && o instanceof o) && "constructor"in C && "constructor"in A)
            return !1
    }
    c = c || [],
    S = S || [];
    for (var a = c.length; a--; )
        if (c[a] === C)
            return S[a] === A;
    if (c.push(C),
    S.push(A),
    e) {
        if (a = C.length,
        a !== A.length)
            return !1;
        for (; a--; )
            if (!Yn(C[a], A[a], c, S))
                return !1
    } else {
        var n = It(C), s;
        if (a = n.length,
        It(A).length !== a)
            return !1;
        for (; a--; )
            if (s = n[a],
            !(Ce(A, s) && Yn(C[s], A[s], c, S)))
                return !1
    }
    return c.pop(),
    S.pop(),
    !0
}
function ph(C, A) {
    return Yn(C, A)
}
function Ai(C) {
    if (!Ye(C))
        return [];
    var A = [];
    for (var c in C)
        A.push(c);
    return Vr && ea(C, A),
    A
}
function os(C) {
    var A = bt(C);
    return function(c) {
        if (c == null)
            return !1;
        var S = Ai(c);
        if (bt(S))
            return !1;
        for (var t = 0; t < A; t++)
            if (!Vt(c[C[t]]))
                return !1;
        return C !== aa || !Vt(c[hs])
    }
}
var hs = "forEach"
  , sa = "has"
  , ls = ["clear", "delete"]
  , ra = ["get", sa, "set"]
  , gh = ls.concat(hs, ra)
  , aa = ls.concat(ra)
  , mh = ["add"].concat(ls, hs, sa);
const xh = rs ? os(gh) : Ut("Map")
  , yh = rs ? os(aa) : Ut("WeakMap")
  , Th = rs ? os(mh) : Ut("Set")
  , Sh = Ut("WeakSet");
function qe(C) {
    for (var A = It(C), c = A.length, S = Array(c), t = 0; t < c; t++)
        S[t] = C[A[t]];
    return S
}
function Eh(C) {
    for (var A = It(C), c = A.length, S = Array(c), t = 0; t < c; t++)
        S[t] = [A[t], C[A[t]]];
    return S
}
function oa(C) {
    for (var A = {}, c = It(C), S = 0, t = c.length; S < t; S++)
        A[C[c[S]]] = c[S];
    return A
}
function Xn(C) {
    var A = [];
    for (var c in C)
        Vt(C[c]) && A.push(c);
    return A.sort()
}
function us(C, A) {
    return function(c) {
        var S = arguments.length;
        if (A && (c = Object(c)),
        S < 2 || c == null)
            return c;
        for (var t = 1; t < S; t++)
            for (var e = arguments[t], f = C(e), r = f.length, o = 0; o < r; o++) {
                var a = f[o];
                (!A || c[a] === void 0) && (c[a] = e[a])
            }
        return c
    }
}
const ha = us(Ai)
  , Qi = us(It)
  , la = us(Ai, !0);
function Ch() {
    return function() {}
}
function ua(C) {
    if (!Ye(C))
        return {};
    if (bs)
        return bs(C);
    var A = Ch();
    A.prototype = C;
    var c = new A;
    return A.prototype = null,
    c
}
function Ph(C, A) {
    var c = ua(C);
    return A && Qi(c, A),
    c
}
function Ah(C) {
    return Ye(C) ? Xe(C) ? C.slice() : ha({}, C) : C
}
function Mh(C, A) {
    return A(C),
    C
}
function fa(C) {
    return Xe(C) ? C : [C]
}
Tt.toPath = fa;
function Mi(C) {
    return Tt.toPath(C)
}
function fs(C, A) {
    for (var c = A.length, S = 0; S < c; S++) {
        if (C == null)
            return;
        C = C[A[S]]
    }
    return c ? C : void 0
}
function da(C, A, c) {
    var S = fs(C, Mi(A));
    return Wr(S) ? c : S
}
function Rh(C, A) {
    A = Mi(A);
    for (var c = A.length, S = 0; S < c; S++) {
        var t = A[S];
        if (!Ce(C, t))
            return !1;
        C = C[t]
    }
    return !!c
}
function ds(C) {
    return C
}
function fi(C) {
    return C = Qi({}, C),
    function(A) {
        return ia(A, C)
    }
}
function vs(C) {
    return C = Mi(C),
    function(A) {
        return fs(A, C)
    }
}
function Ri(C, A, c) {
    if (A === void 0)
        return C;
    switch (c ?? 3) {
    case 1:
        return function(S) {
            return C.call(A, S)
        }
        ;
    case 3:
        return function(S, t, e) {
            return C.call(A, S, t, e)
        }
        ;
    case 4:
        return function(S, t, e, f) {
            return C.call(A, S, t, e, f)
        }
    }
    return function() {
        return C.apply(A, arguments)
    }
}
function va(C, A, c) {
    return C == null ? ds : Vt(C) ? Ri(C, A, c) : Ye(C) && !Xe(C) ? fi(C) : vs(C)
}
function cs(C, A) {
    return va(C, A, 1 / 0)
}
Tt.iteratee = cs;
function Zt(C, A, c) {
    return Tt.iteratee !== cs ? Tt.iteratee(C, A) : va(C, A, c)
}
function Lh(C, A, c) {
    A = Zt(A, c);
    for (var S = It(C), t = S.length, e = {}, f = 0; f < t; f++) {
        var r = S[f];
        e[r] = A(C[r], r, C)
    }
    return e
}
function ca() {}
function Oh(C) {
    return C == null ? ca : function(A) {
        return da(C, A)
    }
}
function Fh(C, A, c) {
    var S = Array(Math.max(0, C));
    A = Ri(A, c, 1);
    for (var t = 0; t < C; t++)
        S[t] = A(t);
    return S
}
function zn(C, A) {
    return A == null && (A = C,
    C = 0),
    C + Math.floor(Math.random() * (A - C + 1))
}
const di = Date.now || function() {
    return new Date().getTime()
}
;
function pa(C) {
    var A = function(e) {
        return C[e]
    }
      , c = "(?:" + It(C).join("|") + ")"
      , S = RegExp(c)
      , t = RegExp(c, "g");
    return function(e) {
        return e = e == null ? "" : "" + e,
        S.test(e) ? e.replace(t, A) : e
    }
}
const ga = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#x27;",
    "`": "&#x60;"
}
  , Ih = pa(ga)
  , Bh = oa(ga)
  , Dh = pa(Bh)
  , Gh = Tt.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
};
var En = /(.)^/
  , Nh = {
    "'": "'",
    "\\": "\\",
    "\r": "r",
    "\n": "n",
    "\u2028": "u2028",
    "\u2029": "u2029"
}
  , wh = /\\|'|\r|\n|\u2028|\u2029/g;
function Uh(C) {
    return "\\" + Nh[C]
}
var Yh = /^\s*(\w|\$)+\s*$/;
function Xh(C, A, c) {
    !A && c && (A = c),
    A = la({}, A, Tt.templateSettings);
    var S = RegExp([(A.escape || En).source, (A.interpolate || En).source, (A.evaluate || En).source].join("|") + "|$", "g")
      , t = 0
      , e = "__p+='";
    C.replace(S, function(a, n, s, l, i) {
        return e += C.slice(t, i).replace(wh, Uh),
        t = i + a.length,
        n ? e += `'+
((__t=(` + n + `))==null?'':_.escape(__t))+
'` : s ? e += `'+
((__t=(` + s + `))==null?'':__t)+
'` : l && (e += `';
` + l + `
__p+='`),
        a
    }),
    e += `';
`;
    var f = A.variable;
    if (f) {
        if (!Yh.test(f))
            throw new Error("variable is not a bare identifier: " + f)
    } else
        e = `with(obj||{}){
` + e + `}
`,
        f = "obj";
    e = `var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
` + e + `return __p;
`;
    var r;
    try {
        r = new Function(f,"_",e)
    } catch (a) {
        throw a.source = e,
        a
    }
    var o = function(a) {
        return r.call(this, a, Tt)
    };
    return o.source = "function(" + f + `){
` + e + "}",
    o
}
function zh(C, A, c) {
    A = Mi(A);
    var S = A.length;
    if (!S)
        return Vt(c) ? c.call(C) : c;
    for (var t = 0; t < S; t++) {
        var e = C == null ? void 0 : C[A[t]];
        e === void 0 && (e = c,
        t = S),
        C = Vt(e) ? e.call(C) : e
    }
    return C
}
var Vh = 0;
function Wh(C) {
    var A = ++Vh + "";
    return C ? C + A : A
}
function Hh(C) {
    var A = Tt(C);
    return A._chain = !0,
    A
}
function ma(C, A, c, S, t) {
    if (!(S instanceof A))
        return C.apply(c, t);
    var e = ua(C.prototype)
      , f = C.apply(e, t);
    return Ye(f) ? f : e
}
var _e = Ht(function(C, A) {
    var c = _e.placeholder
      , S = function() {
        for (var t = 0, e = A.length, f = Array(e), r = 0; r < e; r++)
            f[r] = A[r] === c ? arguments[t++] : A[r];
        for (; t < arguments.length; )
            f.push(arguments[t++]);
        return ma(C, S, this, this, f)
    };
    return S
});
_e.placeholder = Tt;
const xa = Ht(function(C, A, c) {
    if (!Vt(C))
        throw new TypeError("Bind must be called on a function");
    var S = Ht(function(t) {
        return ma(C, S, A, this, c.concat(t))
    });
    return S
})
  , Jt = qr(bt);
function ze(C, A, c, S) {
    if (S = S || [],
    !A && A !== 0)
        A = 1 / 0;
    else if (A <= 0)
        return S.concat(C);
    for (var t = S.length, e = 0, f = bt(C); e < f; e++) {
        var r = C[e];
        if (Jt(r) && (Xe(r) || as(r)))
            if (A > 1)
                ze(r, A - 1, c, S),
                t = S.length;
            else
                for (var o = 0, a = r.length; o < a; )
                    S[t++] = r[o++];
        else
            c || (S[t++] = r)
    }
    return S
}
const bh = Ht(function(C, A) {
    A = ze(A, !1, !1);
    var c = A.length;
    if (c < 1)
        throw new Error("bindAll must be passed function names");
    for (; c--; ) {
        var S = A[c];
        C[S] = xa(C[S], C)
    }
    return C
});
function Kh(C, A) {
    var c = function(S) {
        var t = c.cache
          , e = "" + (A ? A.apply(this, arguments) : S);
        return Ce(t, e) || (t[e] = C.apply(this, arguments)),
        t[e]
    };
    return c.cache = {},
    c
}
const ya = Ht(function(C, A, c) {
    return setTimeout(function() {
        return C.apply(null, c)
    }, A)
})
  , Zh = _e(ya, Tt, 1);
function si(C, A, c) {
    var S, t, e, f, r = 0;
    c || (c = {});
    var o = function() {
        r = c.leading === !1 ? 0 : di(),
        S = null,
        f = C.apply(t, e),
        S || (t = e = null)
    }
      , a = function() {
        var n = di();
        !r && c.leading === !1 && (r = n);
        var s = A - (n - r);
        return t = this,
        e = arguments,
        s <= 0 || s > A ? (S && (clearTimeout(S),
        S = null),
        r = n,
        f = C.apply(t, e),
        S || (t = e = null)) : !S && c.trailing !== !1 && (S = setTimeout(o, s)),
        f
    };
    return a.cancel = function() {
        clearTimeout(S),
        r = 0,
        S = t = e = null
    }
    ,
    a
}
function Jh(C, A, c) {
    var S, t, e, f, r, o = function() {
        var n = di() - t;
        A > n ? S = setTimeout(o, A - n) : (S = null,
        c || (f = C.apply(r, e)),
        S || (e = r = null))
    }, a = Ht(function(n) {
        return r = this,
        e = n,
        t = di(),
        S || (S = setTimeout(o, A),
        c && (f = C.apply(r, e))),
        f
    });
    return a.cancel = function() {
        clearTimeout(S),
        S = e = r = null
    }
    ,
    a
}
function jh(C, A) {
    return _e(A, C)
}
function ps(C) {
    return function() {
        return !C.apply(this, arguments)
    }
}
function $h() {
    var C = arguments
      , A = C.length - 1;
    return function() {
        for (var c = A, S = C[A].apply(this, arguments); c--; )
            S = C[c].call(this, S);
        return S
    }
}
function Qh(C, A) {
    return function() {
        if (--C < 1)
            return A.apply(this, arguments)
    }
}
function Ta(C, A) {
    var c;
    return function() {
        return --C > 0 && (c = A.apply(this, arguments)),
        C <= 1 && (A = null),
        c
    }
}
const kh = _e(Ta, 2);
function Sa(C, A, c) {
    A = Zt(A, c);
    for (var S = It(C), t, e = 0, f = S.length; e < f; e++)
        if (t = S[e],
        A(C[t], t, C))
            return t
}
function Ea(C) {
    return function(A, c, S) {
        c = Zt(c, S);
        for (var t = bt(A), e = C > 0 ? 0 : t - 1; e >= 0 && e < t; e += C)
            if (c(A[e], e, A))
                return e;
        return -1
    }
}
const gs = Ea(1)
  , Ca = Ea(-1);
function Pa(C, A, c, S) {
    c = Zt(c, S, 1);
    for (var t = c(A), e = 0, f = bt(C); e < f; ) {
        var r = Math.floor((e + f) / 2);
        c(C[r]) < t ? e = r + 1 : f = r
    }
    return e
}
function Aa(C, A, c) {
    return function(S, t, e) {
        var f = 0
          , r = bt(S);
        if (typeof e == "number")
            C > 0 ? f = e >= 0 ? e : Math.max(e + r, f) : r = e >= 0 ? Math.min(e + 1, r) : e + r + 1;
        else if (c && e && r)
            return e = c(S, t),
            S[e] === t ? e : -1;
        if (t !== t)
            return e = A(Pi.call(S, f, r), Qr),
            e >= 0 ? e + f : -1;
        for (e = C > 0 ? f : r - 1; e >= 0 && e < r; e += C)
            if (S[e] === t)
                return e;
        return -1
    }
}
const Ma = Aa(1, gs, Pa)
  , qh = Aa(-1, Ca);
function Vn(C, A, c) {
    var S = Jt(C) ? gs : Sa
      , t = S(C, A, c);
    if (t !== void 0 && t !== -1)
        return C[t]
}
function _h(C, A) {
    return Vn(C, fi(A))
}
function de(C, A, c) {
    A = Ri(A, c);
    var S, t;
    if (Jt(C))
        for (S = 0,
        t = C.length; S < t; S++)
            A(C[S], S, C);
    else {
        var e = It(C);
        for (S = 0,
        t = e.length; S < t; S++)
            A(C[e[S]], e[S], C)
    }
    return C
}
function Ue(C, A, c) {
    A = Zt(A, c);
    for (var S = !Jt(C) && It(C), t = (S || C).length, e = Array(t), f = 0; f < t; f++) {
        var r = S ? S[f] : f;
        e[f] = A(C[r], r, C)
    }
    return e
}
function Ra(C) {
    var A = function(c, S, t, e) {
        var f = !Jt(c) && It(c)
          , r = (f || c).length
          , o = C > 0 ? 0 : r - 1;
        for (e || (t = c[f ? f[o] : o],
        o += C); o >= 0 && o < r; o += C) {
            var a = f ? f[o] : o;
            t = S(t, c[a], a, c)
        }
        return t
    };
    return function(c, S, t, e) {
        var f = arguments.length >= 3;
        return A(c, Ri(S, e, 4), t, f)
    }
}
const Cn = Ra(1)
  , $s = Ra(-1);
function Je(C, A, c) {
    var S = [];
    return A = Zt(A, c),
    de(C, function(t, e, f) {
        A(t, e, f) && S.push(t)
    }),
    S
}
function tl(C, A, c) {
    return Je(C, ps(Zt(A)), c)
}
function Qs(C, A, c) {
    A = Zt(A, c);
    for (var S = !Jt(C) && It(C), t = (S || C).length, e = 0; e < t; e++) {
        var f = S ? S[e] : e;
        if (!A(C[f], f, C))
            return !1
    }
    return !0
}
function ks(C, A, c) {
    A = Zt(A, c);
    for (var S = !Jt(C) && It(C), t = (S || C).length, e = 0; e < t; e++) {
        var f = S ? S[e] : e;
        if (A(C[f], f, C))
            return !0
    }
    return !1
}
function fe(C, A, c, S) {
    return Jt(C) || (C = qe(C)),
    (typeof c != "number" || S) && (c = 0),
    Ma(C, A, c) >= 0
}
const el = Ht(function(C, A, c) {
    var S, t;
    return Vt(A) ? t = A : (A = Mi(A),
    S = A.slice(0, -1),
    A = A[A.length - 1]),
    Ue(C, function(e) {
        var f = t;
        if (!f) {
            if (S && S.length && (e = fs(e, S)),
            e == null)
                return;
            f = e[A]
        }
        return f == null ? f : f.apply(e, c)
    })
});
function ms(C, A) {
    return Ue(C, vs(A))
}
function il(C, A) {
    return Je(C, fi(A))
}
function La(C, A, c) {
    var S = -1 / 0, t = -1 / 0, e, f;
    if (A == null || typeof A == "number" && typeof C[0] != "object" && C != null) {
        C = Jt(C) ? C : qe(C);
        for (var r = 0, o = C.length; r < o; r++)
            e = C[r],
            e != null && e > S && (S = e)
    } else
        A = Zt(A, c),
        de(C, function(a, n, s) {
            f = A(a, n, s),
            (f > t || f === -1 / 0 && S === -1 / 0) && (S = a,
            t = f)
        });
    return S
}
function nl(C, A, c) {
    var S = 1 / 0, t = 1 / 0, e, f;
    if (A == null || typeof A == "number" && typeof C[0] != "object" && C != null) {
        C = Jt(C) ? C : qe(C);
        for (var r = 0, o = C.length; r < o; r++)
            e = C[r],
            e != null && e < S && (S = e)
    } else
        A = Zt(A, c),
        de(C, function(a, n, s) {
            f = A(a, n, s),
            (f < t || f === 1 / 0 && S === 1 / 0) && (S = a,
            t = f)
        });
    return S
}
var sl = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
function Oa(C) {
    return C ? Xe(C) ? Pi.call(C) : ss(C) ? C.match(sl) : Jt(C) ? Ue(C, ds) : qe(C) : []
}
function Fa(C, A, c) {
    if (A == null || c)
        return Jt(C) || (C = qe(C)),
        C[zn(C.length - 1)];
    var S = Oa(C)
      , t = bt(S);
    A = Math.max(Math.min(A, t), 0);
    for (var e = t - 1, f = 0; f < A; f++) {
        var r = zn(f, e)
          , o = S[f];
        S[f] = S[r],
        S[r] = o
    }
    return S.slice(0, A)
}
function rl(C) {
    return Fa(C, 1 / 0)
}
function al(C, A, c) {
    var S = 0;
    return A = Zt(A, c),
    ms(Ue(C, function(t, e, f) {
        return {
            value: t,
            index: S++,
            criteria: A(t, e, f)
        }
    }).sort(function(t, e) {
        var f = t.criteria
          , r = e.criteria;
        if (f !== r) {
            if (f > r || f === void 0)
                return 1;
            if (f < r || r === void 0)
                return -1
        }
        return t.index - e.index
    }), "value")
}
function an(C, A) {
    return function(c, S, t) {
        var e = A ? [[], []] : {};
        return S = Zt(S, t),
        de(c, function(f, r) {
            var o = S(f, r, c);
            C(e, f, o)
        }),
        e
    }
}
const ol = an(function(C, A, c) {
    Ce(C, c) ? C[c].push(A) : C[c] = [A]
})
  , hl = an(function(C, A, c) {
    C[c] = A
})
  , ll = an(function(C, A, c) {
    Ce(C, c) ? C[c]++ : C[c] = 1
})
  , ul = an(function(C, A, c) {
    C[c ? 0 : 1].push(A)
}, !0);
function fl(C) {
    return C == null ? 0 : Jt(C) ? C.length : It(C).length
}
function dl(C, A, c) {
    return A in c
}
const Ia = Ht(function(C, A) {
    var c = {}
      , S = A[0];
    if (C == null)
        return c;
    Vt(S) ? (A.length > 1 && (S = Ri(S, A[1])),
    A = Ai(C)) : (S = dl,
    A = ze(A, !1, !1),
    C = Object(C));
    for (var t = 0, e = A.length; t < e; t++) {
        var f = A[t]
          , r = C[f];
        S(r, f, C) && (c[f] = r)
    }
    return c
})
  , vl = Ht(function(C, A) {
    var c = A[0], S;
    return Vt(c) ? (c = ps(c),
    A.length > 1 && (S = A[1])) : (A = Ue(ze(A, !1, !1), String),
    c = function(t, e) {
        return !fe(A, e)
    }
    ),
    Ia(C, c, S)
});
function Ba(C, A, c) {
    return Pi.call(C, 0, Math.max(0, C.length - (A == null || c ? 1 : A)))
}
function Pn(C, A, c) {
    return C == null || C.length < 1 ? A == null || c ? void 0 : [] : A == null || c ? C[0] : Ba(C, C.length - A)
}
function Vi(C, A, c) {
    return Pi.call(C, A == null || c ? 1 : A)
}
function cl(C, A, c) {
    return C == null || C.length < 1 ? A == null || c ? void 0 : [] : A == null || c ? C[C.length - 1] : Vi(C, Math.max(0, C.length - A))
}
function pl(C) {
    return Je(C, Boolean)
}
function gl(C, A) {
    return ze(C, A, !1)
}
const Da = Ht(function(C, A) {
    return A = ze(A, !0, !0),
    Je(C, function(c) {
        return !fe(A, c)
    })
})
  , ml = Ht(function(C, A) {
    return Da(C, A)
});
function Wn(C, A, c, S) {
    Hr(A) || (S = c,
    c = A,
    A = !1),
    c != null && (c = Zt(c, S));
    for (var t = [], e = [], f = 0, r = bt(C); f < r; f++) {
        var o = C[f]
          , a = c ? c(o, f, C) : o;
        A && !c ? ((!f || e !== a) && t.push(o),
        e = a) : c ? fe(e, a) || (e.push(a),
        t.push(o)) : fe(t, o) || t.push(o)
    }
    return t
}
const xl = Ht(function(C) {
    return Wn(ze(C, !0, !0))
});
function yl(C) {
    for (var A = [], c = arguments.length, S = 0, t = bt(C); S < t; S++) {
        var e = C[S];
        if (!fe(A, e)) {
            var f;
            for (f = 1; f < c && fe(arguments[f], e); f++)
                ;
            f === c && A.push(e)
        }
    }
    return A
}
function Hn(C) {
    for (var A = C && La(C, bt).length || 0, c = Array(A), S = 0; S < A; S++)
        c[S] = ms(C, S);
    return c
}
const Tl = Ht(Hn);
function Sl(C, A) {
    for (var c = {}, S = 0, t = bt(C); S < t; S++)
        A ? c[C[S]] = A[S] : c[C[S][0]] = C[S][1];
    return c
}
function El(C, A, c) {
    A == null && (A = C || 0,
    C = 0),
    c || (c = A < C ? -1 : 1);
    for (var S = Math.max(Math.ceil((A - C) / c), 0), t = Array(S), e = 0; e < S; e++,
    C += c)
        t[e] = C;
    return t
}
function Cl(C, A) {
    if (A == null || A < 1)
        return [];
    for (var c = [], S = 0, t = C.length; S < t; )
        c.push(Pi.call(C, S, S += A));
    return c
}
function xs(C, A) {
    return C._chain ? Tt(A).chain() : A
}
function Ga(C) {
    return de(Xn(C), function(A) {
        var c = Tt[A] = C[A];
        Tt.prototype[A] = function() {
            var S = [this._wrapped];
            return jo.apply(S, arguments),
            xs(this, c.apply(Tt, S))
        }
    }),
    Tt
}
de(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(C) {
    var A = rn[C];
    Tt.prototype[C] = function() {
        var c = this._wrapped;
        return c != null && (A.apply(c, arguments),
        (C === "shift" || C === "splice") && c.length === 0 && delete c[0]),
        xs(this, c)
    }
});
de(["concat", "join", "slice"], function(C) {
    var A = rn[C];
    Tt.prototype[C] = function() {
        var c = this._wrapped;
        return c != null && (c = A.apply(c, arguments)),
        xs(this, c)
    }
});
const Pl = Object.freeze(Object.defineProperty({
    __proto__: null,
    VERSION: Xr,
    after: Qh,
    all: Qs,
    allKeys: Ai,
    any: ks,
    assign: Qi,
    before: Ta,
    bind: xa,
    bindAll: bh,
    chain: Hh,
    chunk: Cl,
    clone: Ah,
    collect: Ue,
    compact: pl,
    compose: $h,
    constant: kr,
    contains: fe,
    countBy: ll,
    create: Ph,
    debounce: Jh,
    default: Tt,
    defaults: la,
    defer: Zh,
    delay: ya,
    detect: Vn,
    difference: Da,
    drop: Vi,
    each: de,
    escape: Ih,
    every: Qs,
    extend: ha,
    extendOwn: Qi,
    filter: Je,
    find: Vn,
    findIndex: gs,
    findKey: Sa,
    findLastIndex: Ca,
    findWhere: _h,
    first: Pn,
    flatten: gl,
    foldl: Cn,
    foldr: $s,
    forEach: de,
    functions: Xn,
    get: da,
    groupBy: ol,
    has: Rh,
    head: Pn,
    identity: ds,
    include: fe,
    includes: fe,
    indexBy: hl,
    indexOf: Ma,
    initial: Ba,
    inject: Cn,
    intersection: yl,
    invert: oa,
    invoke: el,
    isArguments: as,
    isArray: Xe,
    isArrayBuffer: Zr,
    isBoolean: Hr,
    isDataView: ji,
    isDate: nh,
    isElement: ih,
    isEmpty: ch,
    isEqual: ph,
    isError: rh,
    isFinite: lh,
    isFunction: Vt,
    isMap: xh,
    isMatch: ia,
    isNaN: Qr,
    isNull: eh,
    isNumber: br,
    isObject: Ye,
    isRegExp: sh,
    isSet: Th,
    isString: ss,
    isSymbol: Kr,
    isTypedArray: ta,
    isUndefined: Wr,
    isWeakMap: yh,
    isWeakSet: Sh,
    iteratee: cs,
    keys: It,
    last: cl,
    lastIndexOf: qh,
    map: Ue,
    mapObject: Lh,
    matcher: fi,
    matches: fi,
    max: La,
    memoize: Kh,
    methods: Xn,
    min: nl,
    mixin: Ga,
    negate: ps,
    noop: ca,
    now: di,
    object: Sl,
    omit: vl,
    once: kh,
    pairs: Eh,
    partial: _e,
    partition: ul,
    pick: Ia,
    pluck: ms,
    property: vs,
    propertyOf: Oh,
    random: zn,
    range: El,
    reduce: Cn,
    reduceRight: $s,
    reject: tl,
    rest: Vi,
    restArguments: Ht,
    result: zh,
    sample: Fa,
    select: Je,
    shuffle: rl,
    size: fl,
    some: ks,
    sortBy: al,
    sortedIndex: Pa,
    tail: Vi,
    take: Pn,
    tap: Mh,
    template: Xh,
    templateSettings: Gh,
    throttle: si,
    times: Fh,
    toArray: Oa,
    toPath: fa,
    transpose: Hn,
    unescape: Dh,
    union: xl,
    uniq: Wn,
    unique: Wn,
    uniqueId: Wh,
    unzip: Hn,
    values: qe,
    where: il,
    without: ml,
    wrap: jh,
    zip: Tl
}, Symbol.toStringTag, {
    value: "Module"
}));
var qs = Ga(Pl);
qs._ = qs;
class Al {
    constructor(A, c) {
        pt(this, "weaponType");
        pt(this, "damageRange");
        this.weaponType = A,
        this.damageRange = c
    }
}
class _s extends Phaser.GameObjects.Container {
    constructor(c, S, t) {
        const e = c.add.text(0, 0, S, {
            color: "white"
        });
        e.setOrigin(.5);
        super(c, ...t.pos.map(r=>r * 32 + 16), e);
        pt(this, "playerText");
        pt(this, "facingLine");
        pt(this, "hpBar");
        pt(this, "facing", [0, 1]);
        pt(this, "identifier");
        pt(this, "name");
        pt(this, "pos");
        pt(this, "weapon");
        pt(this, "inventory");
        pt(this, "hp", 10);
        pt(this, "max_hp", 10);
        this.scene.add.existing(this),
        this.hpBar = c.add.graphics(),
        this.setSize(20, 20),
        c.physics.world.enable(this),
        this.updatePlayer(t);
        const f = c.add.graphics();
        f.clear(),
        f.lineStyle(2, 39168, 1),
        f.beginPath(),
        f.moveTo(0, 0),
        f.lineTo(0, (this.height + 30) / 2),
        f.strokePath(),
        f.closePath(),
        f.setPosition(t.pos[0] * 32 + 16, t.pos[1] * 32 + 16),
        this.facingLine = f,
        this.updateHpBar()
    }
    updatePlayer(c) {
        this.identifier = c.identifier,
        this.name = c.name,
        this.weapon = new Al(c.current_weapon.weapon_type,c.current_weapon.range),
        this.inventory = c.inventory,
        this.face(c.facing),
        this.setPositionTo(c.pos)
    }
    face(c) {
        this.facing = c
    }
    setPositionTo(c) {
        var e, f, r;
        this.pos = c,
        this.setPosition(...c.map(o=>o * 32 + 16)),
        (e = this.facingLine) == null || e.setPosition(...c.map(o=>o * 32 + 16));
        const [S,t] = this.facing;
        (f = this.facingLine) == null || f.setAngle(Math.atan2(-S, t) * (180 / Math.PI)),
        (r = this.hpBar) == null || r.setPosition(...c.map(o=>o * 32))
    }
    updateHpBar() {
        this.hpBar.clear(),
        this.hpBar.fillStyle(0),
        this.hpBar.fillRect(6, -3, 20 + 1 * 2, 6 + 1 * 2),
        this.hpBar.fillStyle(16777215),
        this.hpBar.fillRect(6 + 1, -3 + 1, 20, 6),
        this.max_hp - this.hp >= this.max_hp * .7 ? this.hpBar.fillStyle(16711680) : this.hpBar.fillStyle(65280);
        var r = Math.floor(20 * (this.hp / this.max_hp));
        this.hpBar.fillRect(6 + 1, -3 + 1, r, 6)
    }
    getDamage(c, S, t) {
        const e = c.add.text(this.x + 12, this.y - 12, S.toString(), {
            fontSize: "18px",
            color: "#ff0000"
        }).setDepth(100).setOrigin(.5, .5)
          , f = c.add.text(this.x + 12, this.y - 12, S.toString(), {
            fontSize: "22px",
            color: "#000000"
        }).setDepth(99).setOrigin(.5, .5);
        c.tweens.add({
            targets: [e, f],
            y: this.y - 32,
            duration: 300,
            ease: "Linear"
        }),
        setTimeout(()=>[e, f].forEach(r=>r.destroy()), 300),
        this.hp = t.hp,
        this.max_hp = t.max_hp,
        this.updateHpBar()
    }
    destroy(c) {
        this.facingLine.destroy(),
        super.destroy(c)
    }
    setVisible(c) {
        return this.facingLine.setVisible(c),
        super.setVisible(c),
        this
    }
}
const tr = "AFR_2bffa7efd0493b4b0857a3953fe78456"
  , An = (C,A)=>[C[0] + A[0], C[1] + A[1]]
  , Ml = (C,A)=>C[0] * A[0] + C[1] * A[1]
  , er = C=>Math.sqrt(Ml(C, C))
  , Rl = C=>[C[0] / er(C), C[1] / er(C)]
  , Ll = (C,A)=>{
    const [c,S] = Rl(A)
      , t = C[1] * c - C[0] * S
      , e = C[0] * c + C[1] * S;
    return [t, e]
}
;
class Ol extends De.Scene {
    constructor() {
        super("GameScene");
        pt(this, "layer");
        pt(this, "topLayer");
        pt(this, "map");
        pt(this, "players", new Map);
        pt(this, "me", {});
        pt(this, "cursors");
        pt(this, "tickCallbacks", new Set);
        pt(this, "raycaster");
        pt(this, "ray");
        pt(this, "intersections");
        pt(this, "maskGraphics");
        pt(this, "fow");
        pt(this, "fovRange");
        pt(this, "viewableRange");
        pt(this, "updateVec", si(c=>{
            if (typeof this.me.face != "function")
                return location.reload();
            this.me.face(c),
            An(this.me.pos, c),
            this.send({
                type: "move",
                data: {
                    vec: c,
                    facing: this.me.facing
                }
            })
        }
        , 150, {
            trailing: !1
        }));
        pt(this, "faceAry", []);
        pt(this, "updateFace", si(()=>{
            const c = this.faceAry.reduce((S,t)=>[S[0] || t[0], S[1] || t[1]], [0, 0]);
            this.faceAry = [],
            !(c[0] === 0 && c[1] === 0) && this.updateVec(c)
        }
        , 10));
        pt(this, "attack", si(()=>{
            this.send({
                type: "attack",
                data: {
                    facing: this.me.facing
                }
            })
        }
        , 500, {
            trailing: !1
        }));
        pt(this, "interact", si(()=>{
            let c = An(this.me.pos, this.me.facing);
            this.send({
                type: "interact_map",
                data: {
                    pos: c
                }
            })
        }
        , 500, {
            trailing: !1
        }));
        pt(this, "send", ()=>{}
        );
        pt(this, "events_pool", []);
        const c = window.gameDom;
        delete window.gameDom,
        this.send = S=>{
            c == null || c.dispatchEvent(new CustomEvent("send",{
                detail: S
            }))
        }
        ,
        this.events_pool = window.gameEvents,
        delete window.gameEvents
    }
    createFOV() {
        this.maskGraphics = this.add.graphics({
            fillStyle: {
                color: 16777215,
                alpha: 0
            }
        });
        let c = new De.Display.Masks.GeometryMask(this,this.maskGraphics);
        c.invertAlpha = !0,
        this.fow = this.add.graphics({
            fillStyle: {
                color: 0,
                alpha: 1
            }
        }),
        this.fow.setMask(c),
        this.fow.fillRect(0, 0, this.map.heightInPixels, this.map.widthInPixels),
        this.viewableRange = this.add.circle(0, 0, 350, 0, 0);
        let S = new De.Display.Masks.GeometryMask(this,this.viewableRange);
        S.invertAlpha = !0,
        this.fovRange = this.add.graphics({
            fillStyle: {
                color: 0,
                alpha: .85
            }
        }),
        this.fovRange.setMask(S),
        this.fovRange.fillRect(0, 0, this.map.heightInPixels, this.map.widthInPixels),
        this.fovRange.setDepth(40)
    }
    draw() {
        this.intersections.push(this.ray.origin),
        this.maskGraphics.clear(),
        this.maskGraphics.fillPoints(this.intersections)
    }
    updateFOV() {
        const c = ()=>{
            var S, t;
            this.ray.setOrigin(this.me.x - ((S = this.me.facing) == null ? void 0 : S[0]) * 15, this.me.y - ((t = this.me.facing) == null ? void 0 : t[1]) * 15),
            this.ray.setConeDeg(90),
            this.me.facing && this.ray.setAngle(Math.atan2(this.me.facing[1], this.me.facing[0])),
            this.intersections = this.ray.castCone(),
            this.draw()
        }
        ;
        this.tweens.add({
            targets: this.viewableRange,
            x: this.me.x || 0,
            y: this.me.y || 0,
            duration: 150,
            ease: "Linear",
            onStart: c,
            onComplete: c
        })
    }
    handleEvent(c) {
        var S, t;
        switch (c.type) {
        case "init":
            const e = c.data.player;
            c.data.players.forEach(l=>{
                const i = l.identifier === e.identifier ? "我" : "敵"
                  , h = new _s(this,i,l);
                this.players.set(l.identifier, h)
            }
            ),
            this.me = this.players.get(e.identifier),
            this.updateFOV(),
            this.cameras.main.startFollow(this.me, !0, .05, .05);
            break;
        case "join":
            {
                const l = c.data.player
                  , i = this.players.get(l.identifier) || new _s(this,"敵",l);
                i.face(l.facing),
                i.setPositionTo(l.pos),
                this.players.set(l.identifier, i)
            }
            break;
        case "respawn":
            {
                const {player: l} = c.data
                  , i = this.players.get(l.identifier);
                if (!i)
                    break;
                i.face(l.facing),
                i.setPositionTo(l.pos),
                i.setVisible(!0),
                i.hp = l.hp,
                i.max_hp = l.max_hp,
                i.updateHpBar(),
                l.identifier === this.me.identifier && (this.updateFOV(),
                this.cameras.main.startFollow(this.me, !0, .05, .05))
            }
            break;
        case "leave":
            {
                const {identifier: l} = c.data
                  , i = this.players.get(l);
                if (!i)
                    break;
                i.destroy(),
                this.players.delete(l)
            }
            break;
        case "move":
            const {identifier: f, pos: r, facing: o} = c.data
              , a = this.players.get(f);
            if (!a)
                break;
            a.face(o),
            a.setPositionTo(r),
            f === this.me.identifier && this.updateFOV();
            break;
        case "attack":
            {
                const {attacker: l, targets: i} = c.data
                  , h = this.players.get(l);
                if (!h)
                    break;
                const {x: u, y: d, weapon: v, facing: p} = h
                  , [g,m] = p
                  , x = Math.atan2(m, g) * 180 / Math.PI;
                for (const [T,E] of v.damageRange) {
                    let P = Ll([T, E], p).map(R=>R * 32)
                      , M = this.add.rectangle(...An(c.data.attacker_pos.map(R=>R * 32 + 16), P), 32, 32, 10027008);
                    M.angle = x,
                    M.setDepth(3);
                    let L = 1;
                    setInterval(()=>{
                        M.setAlpha(L -= .1)
                    }
                    , 10),
                    setTimeout(()=>{
                        M.destroy()
                    }
                    , 100)
                }
                for (const T of i) {
                    const E = this.players.get(T.identifier);
                    if (!E)
                        continue;
                    let P = !1
                      , M = setInterval(()=>{
                        E.setAlpha(P ? 1 : .5),
                        P = !P
                    }
                    , 50);
                    setTimeout(()=>{
                        clearInterval(M),
                        E.setAlpha(1)
                    }
                    , 200)
                }
            }
            break;
        case "damage":
            {
                const {player: l, damage: i} = c.data
                  , h = this.players.get(l.identifier);
                if (!h)
                    break;
                h.getDamage(this, i, l);
                break
            }
        case "death":
            {
                let l, i;
                const {victim_identifier: h, attacker_identifier: u, respawn_time: d} = c.data
                  , v = this.players.get(h);
                if (!v)
                    break;
                if (h === this.me.identifier) {
                    this.cameras.main.shake(1e3, .01),
                    this.cameras.main.stopFollow(),
                    l = this.add.rectangle(0, 0, this.map.heightInPixels, this.map.widthInPixels, 0, .5).setDepth(100).setOrigin(0, 0);
                    const g = ((S = this.players.get(u)) == null ? void 0 : S.name) ?? "unknown";
                    i = [this.add.text(this.me.x, this.me.y - 32, "You died", {
                        fontSize: "128px",
                        color: "#ff0000"
                    }).setDepth(101).setOrigin(.5, .5), this.add.text(this.me.x, this.me.y + 128 - 32, `Killed by ${g}`, {
                        fontSize: "64px",
                        color: "#ffffff"
                    }).setDepth(101).setOrigin(.5, .5), this.add.text(this.me.x, this.me.y + 128 + 64 + 20 - 32, `Respawn in ${d} seconds`, {
                        fontSize: "64px",
                        color: "#ffffff"
                    }).setDepth(101).setOrigin(.5, .5)];
                    let m = d;
                    const x = ()=>i[2].setText(`Respawn in ${--m} seconds`);
                    this.tickCallbacks.add(x),
                    setTimeout(()=>this.tickCallbacks.delete(x), (d - .5) * 1e3)
                }
                const p = setInterval(()=>{
                    v.setAlpha(v.alpha === 1 ? .25 : 1)
                }
                , 200);
                setTimeout(()=>{
                    v.setAlpha(1),
                    v.setVisible(!1),
                    clearInterval(p);
                    const g = this.add.text(v.x, v.y, "死", {
                        fontSize: "16px",
                        color: "#ff0000"
                    }).setOrigin(.5, .5).setDepth(100);
                    this.tweens.add({
                        targets: g,
                        scale: 5,
                        duration: 500,
                        ease: "Power2",
                        yoyo: !0,
                        onComplete: ()=>g.setDepth(0).setText("屍")
                    })
                }
                , 1400),
                setTimeout(()=>{
                    l && (l.destroy(),
                    i.forEach(g=>g.destroy()))
                }
                , (d - .5) * 1e3)
            }
            break;
        case "interact_chest":
            const {new_items: n} = c.data
              , s = this.add.text(this.me.x, this.me.y - 32, n.length > 0 ? `你獲得了 ${n.map(l=>l.identifier.split("::").at(-1)).join(", ")}` : "這裡還沒有物資...", {
                fontSize: "16px",
                color: "#ffffff"
            }).setDepth(100).setOrigin(.5, .5);
            setTimeout(()=>s.destroy(), 2e3);
            break;
        case "interact_map":
        case "use":
            (t = this.players.get(c.data.player.identifier)) == null || t.updatePlayer(c.data.player);
            break;
        case "tick":
            this.tickCallbacks.forEach(l=>l(c.data));
            break
        }
    }
    preload() {
        this.load.image("lab_tiles", "assets/images/lab.png"),
        this.load.tilemapTiledJSON("map", JSON.parse(window.sessionStorage.getItem("map") ?? "{}"))
    }
    create() {
        this.map = this.make.tilemap({
            key: "map"
        });
        var c = this.map.addTilesetImage("Lab", "lab_tiles", 32, 32, 0, 0);
        this.layer = this.map.createLayer("Ground", c, 0, 0),
        this.topLayer = this.map.createLayer("Top", c, 0, 0),
        this.physics.world.setBounds(0, 0, this.map.heightInPixels, this.map.widthInPixels),
        this.cameras.main.setBackgroundColor("#222222"),
        this.cursors = this.input.keyboard.createCursorKeys(),
        this.cursors.x = this.input.keyboard.addKey("X"),
        this.players.clear(),
        this.raycaster = this.raycasterPlugin.createRaycaster(),
        this.ray = this.raycaster.createRay({
            autoSlice: !1
        }),
        this.raycaster.mapGameObjects(this.layer, !1, {
            collisionTiles: [...Array(400).keys(), 416, 418, 446, 448, 450, 476, 478, 480]
        }),
        this.createFOV(),
        this.topLayer.setDepth(4),
        this.fow.setDepth(2),
        this.updateFOV()
    }
    update(c, S) {
        let t;
        for (; t = this.events_pool.shift(); )
            this.handleEvent(t);
        this.input.keyboard.checkDown(this.cursors.space, 100) && this.attack(),
        this.input.keyboard.checkDown(this.cursors.x, 100) && this.interact();
        const e = [this.cursors.right.isDown - this.cursors.left.isDown, this.cursors.down.isDown - this.cursors.up.isDown];
        e.some(Boolean) && (this.faceAry.push(e),
        this.updateFace())
    }
}
const Fl = {
    type: De.AUTO,
    parent: "game",
    backgroundColor: "#000000",
    scene: [Ol],
    scale: {
        width: window.innerWidth,
        height: window.innerHeight,
        mode: De.Scale.FIT,
        autoCenter: De.Scale.CENTER_BOTH
    },
    physics: {
        default: "arcade",
        arcade: {
            gravity: {
                y: 0
            }
        }
    },
    plugins: {
        scene: [{
            key: "PhaserRaycaster",
            plugin: Jo,
            mapping: "raycasterPlugin"
        }]
    }
};
class Il {
    constructor(A) {
        pt(this, "tiles");
        pt(this, "tilesData");
        pt(this, "topTilesData");
        pt(this, "chests");
        pt(this, "height");
        pt(this, "width");
        this.tiles = A.tiles,
        this.height = A.height,
        this.width = A.width,
        this.tiles = this.tiles[0].map((c,S)=>this.tiles.map(t=>t[S])),
        this.generateTilesData()
    }
    generateTilesData() {
        this.tilesData = [],
        this.topTilesData = [];
        for (let A = 0; A < this.height; A++)
            for (let c = 0; c < this.width; c++) {
                if (this.tiles[A][c].texture === "chest")
                    this.tilesData.push(456);
                else if (this.tiles[A][c].texture === "ground") {
                    let S = 466;
                    Math.random() < .05 ? S = 455 : Math.random() < .05 && (S = 488),
                    this.tilesData.push(S)
                } else
                    A == 0 ? c == 0 ? this.tilesData.push(226) : c == this.width - 1 ? this.tilesData.push(228) : this.tilesData.push(211 + c % 13) : A == this.height - 1 ? c == 0 ? this.tilesData.push(342) : c == this.width - 1 ? this.tilesData.push(344) : this.tilesData.push(331 + c % 10) : c == 0 ? this.tilesData.push(416 + A % 3 * 30) : c == this.width - 1 ? this.tilesData.push(418 + A % 3 * 30) : this.tiles[A + 1][c].texture === "wall" && this.tiles[A - 1][c].texture === "wall" && this.tiles[A][c + 1].texture === "wall" && this.tiles[A][c - 1].texture === "wall" ? this.tilesData.push(108) : this.tiles[A + 1][c].texture === "wall" && this.tiles[A - 1][c].texture !== "wall" && this.tiles[A][c + 1].texture !== "wall" && this.tiles[A][c - 1].texture !== "wall" ? this.tilesData.push(4) : this.tiles[A + 1][c].texture !== "wall" && this.tiles[A - 1][c].texture === "wall" && this.tiles[A][c + 1].texture !== "wall" && this.tiles[A][c - 1].texture !== "wall" ? this.tilesData.push(102) : this.tiles[A + 1][c].texture !== "wall" && this.tiles[A - 1][c].texture !== "wall" && this.tiles[A][c + 1].texture === "wall" && this.tiles[A][c - 1].texture !== "wall" ? this.tilesData.push(286) : this.tiles[A + 1][c].texture !== "wall" && this.tiles[A - 1][c].texture !== "wall" && this.tiles[A][c + 1].texture !== "wall" && this.tiles[A][c - 1].texture === "wall" ? this.tilesData.push(288) : this.tiles[A + 1][c].texture !== "wall" && this.tiles[A - 1][c].texture === "wall" && this.tiles[A][c + 1].texture === "wall" && this.tiles[A][c - 1].texture === "wall" ? this.tilesData.push(106) : this.tiles[A + 1][c].texture === "wall" && this.tiles[A - 1][c].texture !== "wall" && this.tiles[A][c + 1].texture === "wall" && this.tiles[A][c - 1].texture === "wall" ? this.tilesData.push(174) : this.tiles[A + 1][c].texture === "wall" && this.tiles[A - 1][c].texture === "wall" && this.tiles[A][c + 1].texture !== "wall" && this.tiles[A][c - 1].texture === "wall" ? this.tilesData.push(354) : this.tiles[A + 1][c].texture === "wall" && this.tiles[A - 1][c].texture === "wall" && this.tiles[A][c + 1].texture === "wall" && this.tiles[A][c - 1].texture !== "wall" ? this.tilesData.push(234) : this.tiles[A + 1][c].texture !== "wall" && this.tiles[A - 1][c].texture !== "wall" && this.tiles[A][c + 1].texture === "wall" && this.tiles[A][c - 1].texture === "wall" ? this.tilesData.push(271 + c % 13) : this.tiles[A + 1][c].texture === "wall" && this.tiles[A - 1][c].texture === "wall" && this.tiles[A][c + 1].texture !== "wall" && this.tiles[A][c - 1].texture !== "wall" ? this.tilesData.push(450 + A % 2 * 30) : this.tiles[A + 1][c].texture !== "wall" && this.tiles[A - 1][c].texture === "wall" && this.tiles[A][c + 1].texture === "wall" && this.tiles[A][c - 1].texture !== "wall" && this.tiles[A - 1][c + 1].texture === "wall" ? this.tilesData.push(160) : this.tiles[A + 1][c].texture !== "wall" && this.tiles[A - 1][c].texture === "wall" && this.tiles[A][c + 1].texture === "wall" && this.tiles[A][c - 1].texture !== "wall" && this.tiles[A - 1][c + 1].texture !== "wall" ? this.tilesData.push(158) : this.tiles[A + 1][c].texture !== "wall" && this.tiles[A - 1][c].texture === "wall" && this.tiles[A][c + 1].texture !== "wall" && this.tiles[A][c - 1].texture === "wall" && this.tiles[A - 1][c - 1].texture === "wall" ? this.tilesData.push(162) : this.tiles[A + 1][c].texture !== "wall" && this.tiles[A - 1][c].texture === "wall" && this.tiles[A][c + 1].texture !== "wall" && this.tiles[A][c - 1].texture === "wall" && this.tiles[A - 1][c - 1].texture !== "wall" ? this.tilesData.push(164) : this.tiles[A + 1][c].texture === "wall" && this.tiles[A - 1][c].texture !== "wall" && this.tiles[A][c + 1].texture === "wall" && this.tiles[A][c - 1].texture !== "wall" && this.tiles[A + 1][c + 1].texture === "wall" ? this.tilesData.push(176) : this.tiles[A + 1][c].texture === "wall" && this.tiles[A - 1][c].texture !== "wall" && this.tiles[A][c + 1].texture === "wall" && this.tiles[A][c - 1].texture !== "wall" && this.tiles[A + 1][c + 1].texture !== "wall" ? this.tilesData.push(178) : this.tiles[A + 1][c].texture === "wall" && this.tiles[A - 1][c].texture !== "wall" && this.tiles[A][c + 1].texture !== "wall" && this.tiles[A][c - 1].texture === "wall" && this.tiles[A + 1][c - 1].texture === "wall" ? this.tilesData.push(296) : this.tiles[A + 1][c].texture === "wall" && this.tiles[A - 1][c].texture !== "wall" && this.tiles[A][c + 1].texture !== "wall" && this.tiles[A][c - 1].texture === "wall" && this.tiles[A + 1][c - 1].texture !== "wall" ? this.tilesData.push(298) : this.tilesData.push(100);
                this.topTilesData.push(this.tiles[A][c].texture === "wall" ? this.tilesData[A * this.height + c] : null)
            }
    }
    getJSON() {
        return {
            height: this.height,
            width: this.width,
            layers: [{
                data: this.tilesData,
                height: this.height,
                width: this.width,
                name: "Ground",
                opacity: 1,
                type: "tilelayer",
                visible: !0,
                x: 0,
                y: 0
            }, {
                data: this.topTilesData,
                height: this.height,
                width: this.width,
                name: "Top",
                opacity: 1,
                type: "tilelayer",
                visible: !0,
                x: 0,
                y: 0
            }],
            orientation: "orthogonal",
            properties: {},
            tileheight: 32,
            tilewidth: 32,
            tilesets: [{
                firstgid: 1,
                image: "tiles.png",
                imageheight: 32,
                imagewidth: 64,
                margin: 0,
                name: "Maze",
                properties: {},
                spacing: 0,
                tileheight: 32,
                tilewidth: 32
            }, {
                firstgid: 1,
                image: "lab.png",
                imageheight: 576,
                imagewidth: 960,
                margin: 0,
                name: "Lab",
                properties: {},
                spacing: 1,
                tileheight: 32,
                tilewidth: 32
            }],
            version: 1
        }
    }
}
const Bl = ["login", "round", "init"];
function ai_round(...C) {
    var A;
    window.top && window.top !== window && ((C == null ? void 0 : C[0]) == "ready" || Bl.includes((A = C == null ? void 0 : C[0]) == null ? void 0 : A.type)) && window.top.postMessage.apply(window.top, C)
}
let gmae_oi = null
  , game_ele_je = null;
function ys(C) {
    !gmae_oi || !game_ele_je || game_ele_je.dispatchEvent(new CustomEvent("send",{
        detail: C
    }))
}
function Dl() {
    setTimeout(()=>{
        ai_round("ready", "*")
    }
    , 500);
    const C = document.getElementById("login-input");
    C && (C.removeAttribute("disabled"),
    C.focus(),
    C.addEventListener("keydown", A=>{
        if (A.key === "Enter" || A.key === "NumpadEnter") {
            const c = C.value;
            ys({
                type: "login",
                data: {
                    token: c
                }
            }),
            ai_round({
                type: "login",
                data: {
                    token: c
                }
            }, "*"),
            C.setAttribute("disabled", "true")
        }
    }
    ))
}
function socket_onclose(C) {
    window.top && window.top !== window && location.reload()
}
const Mn = [];
async function processMsg_Nl(C) {
    var c;
    const A = await gmae_oi.parse(C.data);
    switch (A.type) {
    case "login":
        if (A.data.success === !0)
            (c = document.getElementById("login-container")) == null || c.remove(),
            Mn.length = 0;
        else {
            ai_round({
                type: "login",
                data: {
                    token: ""
                }
            }, "*");
            const e = document.getElementById("login-input");
            e == null || e.removeAttribute("disabled");
            const f = document.getElementById("login-error-message");
            f && (f.innerText = A.data.message ?? "Unknown error")
        }
        break;
    case "init":
        ai_round({
            type: "init",
            data: A.data.round
        }, "*");
        const t = new Il(A.data.map).getJSON();
        window.sessionStorage.setItem("map", JSON.stringify(t)),
        window.gameDom = game_ele_je,
        window.gameEvents = Mn,
        new De.Game(Fl),
        window.me = A.data.player.identifier,
        ys({
            type: tr,
            data: {
                path: "../package.json"
            }
        });
        break;
    case "round":
        ai_round({
            type: "round",
            data: A.data
        }, "*");
        break;
    case tr:
        if (A.data.content && A.data.path === "../package.json") {
            const {version: e} = JSON.parse(A.data.content);
            window.version = e,
            document.getElementById("version").innerText = e
        }
        break
    }
    A.type !== "login" && (Mn.push(A),
    game_ele_je.dispatchEvent(new CustomEvent("event",{
        detail: A
    })))
}
async function wl(websocketURL, div_game) {
    window.top && 
	window.top !== window && 
	window.addEventListener("message", S=>{
        S.data.type === "login" && ys({
            type: "login",
            data: {
                token: S.data.data.token
            }
        })
    }),
    game_ele_je = div_game;
    const socket = new WebSocket(websocketURL);
    socket.binaryType = "arraybuffer",
    socket.onclose = socket_onclose,
    await new Promise(socket_open=>socket.addEventListener("open", socket_open)),
    gmae_oi = new game_Ko,
    await gmae_oi.initClient(socket),
    socket.onmessage = processMsg_Nl,
    Dl(),
    game_ele_je.addEventListener("send", async S=>{
        if (S instanceof CustomEvent && S.detail) {
            const t = S.detail;
            socket.send(await gmae_oi.stringify(t))
        }
    })
}
function Ts(C, A) {
    const c = Object.create(null)
      , S = C.split(",");
    for (let t = 0; t < S.length; t++)
        c[S[t]] = !0;
    return A ? t=>!!c[t.toLowerCase()] : t=>!!c[t]
}
function on(C) {
    if (vt(C)) {
        const A = {};
        for (let c = 0; c < C.length; c++) {
            const S = C[c]
              , t = Ft(S) ? zl(S) : on(S);
            if (t)
                for (const e in t)
                    A[e] = t[e]
        }
        return A
    } else {
        if (Ft(C))
            return C;
        if (St(C))
            return C
    }
}
const Ul = /;(?![^(]*\))/g
  , Yl = /:([^]+)/
  , Xl = /\/\*.*?\*\//gs;
function zl(C) {
    const A = {};
    return C.replace(Xl, "").split(Ul).forEach(c=>{
        if (c) {
            const S = c.split(Yl);
            S.length > 1 && (A[S[0].trim()] = S[1].trim())
        }
    }
    ),
    A
}
function Ss(C) {
    let A = "";
    if (Ft(C))
        A = C;
    else if (vt(C))
        for (let c = 0; c < C.length; c++) {
            const S = Ss(C[c]);
            S && (A += S + " ")
        }
    else if (St(C))
        for (const c in C)
            C[c] && (A += c + " ");
    return A.trim()
}
const Vl = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly"
  , Wl = Ts(Vl);
function Na(C) {
    return !!C || C === ""
}
function Hl(C, A) {
    if (C.length !== A.length)
        return !1;
    let c = !0;
    for (let S = 0; c && S < C.length; S++)
        c = hn(C[S], A[S]);
    return c
}
function hn(C, A) {
    if (C === A)
        return !0;
    let c = ir(C)
      , S = ir(A);
    if (c || S)
        return c && S ? C.getTime() === A.getTime() : !1;
    if (c = vi(C),
    S = vi(A),
    c || S)
        return C === A;
    if (c = vt(C),
    S = vt(A),
    c || S)
        return c && S ? Hl(C, A) : !1;
    if (c = St(C),
    S = St(A),
    c || S) {
        if (!c || !S)
            return !1;
        const t = Object.keys(C).length
          , e = Object.keys(A).length;
        if (t !== e)
            return !1;
        for (const f in C) {
            const r = C.hasOwnProperty(f)
              , o = A.hasOwnProperty(f);
            if (r && !o || !r && o || !hn(C[f], A[f]))
                return !1
        }
    }
    return String(C) === String(A)
}
function bl(C, A) {
    return C.findIndex(c=>hn(c, A))
}
const Mt = C=>Ft(C) ? C : C == null ? "" : vt(C) || St(C) && (C.toString === Ya || !gt(C.toString)) ? JSON.stringify(C, wa, 2) : String(C)
  , wa = (C,A)=>A && A.__v_isRef ? wa(C, A.value) : be(A) ? {
    [`Map(${A.size})`]: [...A.entries()].reduce((c,[S,t])=>(c[`${S} =>`] = t,
    c), {})
} : un(A) ? {
    [`Set(${A.size})`]: [...A.values()]
} : St(A) && !vt(A) && !Xa(A) ? String(A) : A
  , Et = {}
  , He = []
  , ne = ()=>{}
  , Kl = ()=>!1
  , Zl = /^on[^a-z]/
  , ln = C=>Zl.test(C)
  , Es = C=>C.startsWith("onUpdate:")
  , Bt = Object.assign
  , Cs = (C,A)=>{
    const c = C.indexOf(A);
    c > -1 && C.splice(c, 1)
}
  , Jl = Object.prototype.hasOwnProperty
  , xt = (C,A)=>Jl.call(C, A)
  , vt = Array.isArray
  , be = C=>Li(C) === "[object Map]"
  , un = C=>Li(C) === "[object Set]"
  , ir = C=>Li(C) === "[object Date]"
  , gt = C=>typeof C == "function"
  , Ft = C=>typeof C == "string"
  , vi = C=>typeof C == "symbol"
  , St = C=>C !== null && typeof C == "object"
  , Ua = C=>St(C) && gt(C.then) && gt(C.catch)
  , Ya = Object.prototype.toString
  , Li = C=>Ya.call(C)
  , jl = C=>Li(C).slice(8, -1)
  , Xa = C=>Li(C) === "[object Object]"
  , Ps = C=>Ft(C) && C !== "NaN" && C[0] !== "-" && "" + parseInt(C, 10) === C
  , Wi = Ts(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted")
  , fn = C=>{
    const A = Object.create(null);
    return c=>A[c] || (A[c] = C(c))
}
  , $l = /-(\w)/g
  , $e = fn(C=>C.replace($l, (A,c)=>c ? c.toUpperCase() : ""))
  , Ql = /\B([A-Z])/g
  , Ve = fn(C=>C.replace(Ql, "-$1").toLowerCase())
  , za = fn(C=>C.charAt(0).toUpperCase() + C.slice(1))
  , Rn = fn(C=>C ? `on${za(C)}` : "")
  , ci = (C,A)=>!Object.is(C, A)
  , Hi = (C,A)=>{
    for (let c = 0; c < C.length; c++)
        C[c](A)
}
  , ki = (C,A,c)=>{
    Object.defineProperty(C, A, {
        configurable: !0,
        enumerable: !1,
        value: c
    })
}
  , qi = C=>{
    const A = parseFloat(C);
    return isNaN(A) ? C : A
}
  , kl = C=>{
    const A = Ft(C) ? Number(C) : NaN;
    return isNaN(A) ? C : A
}
;
let nr;
const ql = ()=>nr || (nr = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
let te;
class _l {
    constructor(A=!1) {
        this.detached = A,
        this._active = !0,
        this.effects = [],
        this.cleanups = [],
        this.parent = te,
        !A && te && (this.index = (te.scopes || (te.scopes = [])).push(this) - 1)
    }
    get active() {
        return this._active
    }
    run(A) {
        if (this._active) {
            const c = te;
            try {
                return te = this,
                A()
            } finally {
                te = c
            }
        }
    }
    on() {
        te = this
    }
    off() {
        te = this.parent
    }
    stop(A) {
        if (this._active) {
            let c, S;
            for (c = 0,
            S = this.effects.length; c < S; c++)
                this.effects[c].stop();
            for (c = 0,
            S = this.cleanups.length; c < S; c++)
                this.cleanups[c]();
            if (this.scopes)
                for (c = 0,
                S = this.scopes.length; c < S; c++)
                    this.scopes[c].stop(!0);
            if (!this.detached && this.parent && !A) {
                const t = this.parent.scopes.pop();
                t && t !== this && (this.parent.scopes[this.index] = t,
                t.index = this.index)
            }
            this.parent = void 0,
            this._active = !1
        }
    }
}
function tu(C, A=te) {
    A && A.active && A.effects.push(C)
}
function eu() {
    return te
}
const As = C=>{
    const A = new Set(C);
    return A.w = 0,
    A.n = 0,
    A
}
  , Va = C=>(C.w & Se) > 0
  , Wa = C=>(C.n & Se) > 0
  , iu = ({deps: C})=>{
    if (C.length)
        for (let A = 0; A < C.length; A++)
            C[A].w |= Se
}
  , nu = C=>{
    const {deps: A} = C;
    if (A.length) {
        let c = 0;
        for (let S = 0; S < A.length; S++) {
            const t = A[S];
            Va(t) && !Wa(t) ? t.delete(C) : A[c++] = t,
            t.w &= ~Se,
            t.n &= ~Se
        }
        A.length = c
    }
}
  , bn = new WeakMap;
let ri = 0
  , Se = 1;
const Kn = 30;
let ee;
const Ge = Symbol("")
  , Zn = Symbol("");
class Ms {
    constructor(A, c=null, S) {
        this.fn = A,
        this.scheduler = c,
        this.active = !0,
        this.deps = [],
        this.parent = void 0,
        tu(this, S)
    }
    run() {
        if (!this.active)
            return this.fn();
        let A = ee
          , c = ye;
        for (; A; ) {
            if (A === this)
                return;
            A = A.parent
        }
        try {
            return this.parent = ee,
            ee = this,
            ye = !0,
            Se = 1 << ++ri,
            ri <= Kn ? iu(this) : sr(this),
            this.fn()
        } finally {
            ri <= Kn && nu(this),
            Se = 1 << --ri,
            ee = this.parent,
            ye = c,
            this.parent = void 0,
            this.deferStop && this.stop()
        }
    }
    stop() {
        ee === this ? this.deferStop = !0 : this.active && (sr(this),
        this.onStop && this.onStop(),
        this.active = !1)
    }
}
function sr(C) {
    const {deps: A} = C;
    if (A.length) {
        for (let c = 0; c < A.length; c++)
            A[c].delete(C);
        A.length = 0
    }
}
let ye = !0;
const Ha = [];
function ti() {
    Ha.push(ye),
    ye = !1
}
function ei() {
    const C = Ha.pop();
    ye = C === void 0 ? !0 : C
}
function Kt(C, A, c) {
    if (ye && ee) {
        let S = bn.get(C);
        S || bn.set(C, S = new Map);
        let t = S.get(c);
        t || S.set(c, t = As()),
        ba(t)
    }
}
function ba(C, A) {
    let c = !1;
    ri <= Kn ? Wa(C) || (C.n |= Se,
    c = !Va(C)) : c = !C.has(ee),
    c && (C.add(ee),
    ee.deps.push(C))
}
function ve(C, A, c, S, t, e) {
    const f = bn.get(C);
    if (!f)
        return;
    let r = [];
    if (A === "clear")
        r = [...f.values()];
    else if (c === "length" && vt(C)) {
        const o = Number(S);
        f.forEach((a,n)=>{
            (n === "length" || n >= o) && r.push(a)
        }
        )
    } else
        switch (c !== void 0 && r.push(f.get(c)),
        A) {
        case "add":
            vt(C) ? Ps(c) && r.push(f.get("length")) : (r.push(f.get(Ge)),
            be(C) && r.push(f.get(Zn)));
            break;
        case "delete":
            vt(C) || (r.push(f.get(Ge)),
            be(C) && r.push(f.get(Zn)));
            break;
        case "set":
            be(C) && r.push(f.get(Ge));
            break
        }
    if (r.length === 1)
        r[0] && Jn(r[0]);
    else {
        const o = [];
        for (const a of r)
            a && o.push(...a);
        Jn(As(o))
    }
}
function Jn(C, A) {
    const c = vt(C) ? C : [...C];
    for (const S of c)
        S.computed && rr(S);
    for (const S of c)
        S.computed || rr(S)
}
function rr(C, A) {
    (C !== ee || C.allowRecurse) && (C.scheduler ? C.scheduler() : C.run())
}
const su = Ts("__proto__,__v_isRef,__isVue")
  , Ka = new Set(Object.getOwnPropertyNames(Symbol).filter(C=>C !== "arguments" && C !== "caller").map(C=>Symbol[C]).filter(vi))
  , ru = Rs()
  , au = Rs(!1, !0)
  , ou = Rs(!0)
  , ar = hu();
function hu() {
    const C = {};
    return ["includes", "indexOf", "lastIndexOf"].forEach(A=>{
        C[A] = function(...c) {
            const S = yt(this);
            for (let e = 0, f = this.length; e < f; e++)
                Kt(S, "get", e + "");
            const t = S[A](...c);
            return t === -1 || t === !1 ? S[A](...c.map(yt)) : t
        }
    }
    ),
    ["push", "pop", "shift", "unshift", "splice"].forEach(A=>{
        C[A] = function(...c) {
            ti();
            const S = yt(this)[A].apply(this, c);
            return ei(),
            S
        }
    }
    ),
    C
}
function lu(C) {
    const A = yt(this);
    return Kt(A, "has", C),
    A.hasOwnProperty(C)
}
function Rs(C=!1, A=!1) {
    return function(S, t, e) {
        if (t === "__v_isReactive")
            return !C;
        if (t === "__v_isReadonly")
            return C;
        if (t === "__v_isShallow")
            return A;
        if (t === "__v_raw" && e === (C ? A ? Au : Qa : A ? $a : ja).get(S))
            return S;
        const f = vt(S);
        if (!C) {
            if (f && xt(ar, t))
                return Reflect.get(ar, t, e);
            if (t === "hasOwnProperty")
                return lu
        }
        const r = Reflect.get(S, t, e);
        return (vi(t) ? Ka.has(t) : su(t)) || (C || Kt(S, "get", t),
        A) ? r : wt(r) ? f && Ps(t) ? r : r.value : St(r) ? C ? ka(r) : Fs(r) : r
    }
}
const uu = Za()
  , fu = Za(!0);
function Za(C=!1) {
    return function(c, S, t, e) {
        let f = c[S];
        if (Qe(f) && wt(f) && !wt(t))
            return !1;
        if (!C && (!_i(t) && !Qe(t) && (f = yt(f),
        t = yt(t)),
        !vt(c) && wt(f) && !wt(t)))
            return f.value = t,
            !0;
        const r = vt(c) && Ps(S) ? Number(S) < c.length : xt(c, S)
          , o = Reflect.set(c, S, t, e);
        return c === yt(e) && (r ? ci(t, f) && ve(c, "set", S, t) : ve(c, "add", S, t)),
        o
    }
}
function du(C, A) {
    const c = xt(C, A);
    C[A];
    const S = Reflect.deleteProperty(C, A);
    return S && c && ve(C, "delete", A, void 0),
    S
}
function vu(C, A) {
    const c = Reflect.has(C, A);
    return (!vi(A) || !Ka.has(A)) && Kt(C, "has", A),
    c
}
function cu(C) {
    return Kt(C, "iterate", vt(C) ? "length" : Ge),
    Reflect.ownKeys(C)
}
const Ja = {
    get: ru,
    set: uu,
    deleteProperty: du,
    has: vu,
    ownKeys: cu
}
  , pu = {
    get: ou,
    set(C, A) {
        return !0
    },
    deleteProperty(C, A) {
        return !0
    }
}
  , gu = Bt({}, Ja, {
    get: au,
    set: fu
})
  , Ls = C=>C
  , dn = C=>Reflect.getPrototypeOf(C);
function Ni(C, A, c=!1, S=!1) {
    C = C.__v_raw;
    const t = yt(C)
      , e = yt(A);
    c || (A !== e && Kt(t, "get", A),
    Kt(t, "get", e));
    const {has: f} = dn(t)
      , r = S ? Ls : c ? Bs : pi;
    if (f.call(t, A))
        return r(C.get(A));
    if (f.call(t, e))
        return r(C.get(e));
    C !== t && C.get(A)
}
function wi(C, A=!1) {
    const c = this.__v_raw
      , S = yt(c)
      , t = yt(C);
    return A || (C !== t && Kt(S, "has", C),
    Kt(S, "has", t)),
    C === t ? c.has(C) : c.has(C) || c.has(t)
}
function Ui(C, A=!1) {
    return C = C.__v_raw,
    !A && Kt(yt(C), "iterate", Ge),
    Reflect.get(C, "size", C)
}
function or(C) {
    C = yt(C);
    const A = yt(this);
    return dn(A).has.call(A, C) || (A.add(C),
    ve(A, "add", C, C)),
    this
}
function hr(C, A) {
    A = yt(A);
    const c = yt(this)
      , {has: S, get: t} = dn(c);
    let e = S.call(c, C);
    e || (C = yt(C),
    e = S.call(c, C));
    const f = t.call(c, C);
    return c.set(C, A),
    e ? ci(A, f) && ve(c, "set", C, A) : ve(c, "add", C, A),
    this
}
function lr(C) {
    const A = yt(this)
      , {has: c, get: S} = dn(A);
    let t = c.call(A, C);
    t || (C = yt(C),
    t = c.call(A, C)),
    S && S.call(A, C);
    const e = A.delete(C);
    return t && ve(A, "delete", C, void 0),
    e
}
function ur() {
    const C = yt(this)
      , A = C.size !== 0
      , c = C.clear();
    return A && ve(C, "clear", void 0, void 0),
    c
}
function Yi(C, A) {
    return function(S, t) {
        const e = this
          , f = e.__v_raw
          , r = yt(f)
          , o = A ? Ls : C ? Bs : pi;
        return !C && Kt(r, "iterate", Ge),
        f.forEach((a,n)=>S.call(t, o(a), o(n), e))
    }
}
function Xi(C, A, c) {
    return function(...S) {
        const t = this.__v_raw
          , e = yt(t)
          , f = be(e)
          , r = C === "entries" || C === Symbol.iterator && f
          , o = C === "keys" && f
          , a = t[C](...S)
          , n = c ? Ls : A ? Bs : pi;
        return !A && Kt(e, "iterate", o ? Zn : Ge),
        {
            next() {
                const {value: s, done: l} = a.next();
                return l ? {
                    value: s,
                    done: l
                } : {
                    value: r ? [n(s[0]), n(s[1])] : n(s),
                    done: l
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}
function pe(C) {
    return function(...A) {
        return C === "delete" ? !1 : this
    }
}
function mu() {
    const C = {
        get(e) {
            return Ni(this, e)
        },
        get size() {
            return Ui(this)
        },
        has: wi,
        add: or,
        set: hr,
        delete: lr,
        clear: ur,
        forEach: Yi(!1, !1)
    }
      , A = {
        get(e) {
            return Ni(this, e, !1, !0)
        },
        get size() {
            return Ui(this)
        },
        has: wi,
        add: or,
        set: hr,
        delete: lr,
        clear: ur,
        forEach: Yi(!1, !0)
    }
      , c = {
        get(e) {
            return Ni(this, e, !0)
        },
        get size() {
            return Ui(this, !0)
        },
        has(e) {
            return wi.call(this, e, !0)
        },
        add: pe("add"),
        set: pe("set"),
        delete: pe("delete"),
        clear: pe("clear"),
        forEach: Yi(!0, !1)
    }
      , S = {
        get(e) {
            return Ni(this, e, !0, !0)
        },
        get size() {
            return Ui(this, !0)
        },
        has(e) {
            return wi.call(this, e, !0)
        },
        add: pe("add"),
        set: pe("set"),
        delete: pe("delete"),
        clear: pe("clear"),
        forEach: Yi(!0, !0)
    };
    return ["keys", "values", "entries", Symbol.iterator].forEach(e=>{
        C[e] = Xi(e, !1, !1),
        c[e] = Xi(e, !0, !1),
        A[e] = Xi(e, !1, !0),
        S[e] = Xi(e, !0, !0)
    }
    ),
    [C, c, A, S]
}
const [xu,yu,Tu,Su] = mu();
function Os(C, A) {
    const c = A ? C ? Su : Tu : C ? yu : xu;
    return (S,t,e)=>t === "__v_isReactive" ? !C : t === "__v_isReadonly" ? C : t === "__v_raw" ? S : Reflect.get(xt(c, t) && t in S ? c : S, t, e)
}
const Eu = {
    get: Os(!1, !1)
}
  , Cu = {
    get: Os(!1, !0)
}
  , Pu = {
    get: Os(!0, !1)
}
  , ja = new WeakMap
  , $a = new WeakMap
  , Qa = new WeakMap
  , Au = new WeakMap;
function Mu(C) {
    switch (C) {
    case "Object":
    case "Array":
        return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
        return 2;
    default:
        return 0
    }
}
function Ru(C) {
    return C.__v_skip || !Object.isExtensible(C) ? 0 : Mu(jl(C))
}
function Fs(C) {
    return Qe(C) ? C : Is(C, !1, Ja, Eu, ja)
}
function Lu(C) {
    return Is(C, !1, gu, Cu, $a)
}
function ka(C) {
    return Is(C, !0, pu, Pu, Qa)
}
function Is(C, A, c, S, t) {
    if (!St(C) || C.__v_raw && !(A && C.__v_isReactive))
        return C;
    const e = t.get(C);
    if (e)
        return e;
    const f = Ru(C);
    if (f === 0)
        return C;
    const r = new Proxy(C,f === 2 ? S : c);
    return t.set(C, r),
    r
}
function Ke(C) {
    return Qe(C) ? Ke(C.__v_raw) : !!(C && C.__v_isReactive)
}
function Qe(C) {
    return !!(C && C.__v_isReadonly)
}
function _i(C) {
    return !!(C && C.__v_isShallow)
}
function qa(C) {
    return Ke(C) || Qe(C)
}
function yt(C) {
    const A = C && C.__v_raw;
    return A ? yt(A) : C
}
function _a(C) {
    return ki(C, "__v_skip", !0),
    C
}
const pi = C=>St(C) ? Fs(C) : C
  , Bs = C=>St(C) ? ka(C) : C;
function to(C) {
    ye && ee && (C = yt(C),
    ba(C.dep || (C.dep = As())))
}
function eo(C, A) {
    C = yt(C);
    const c = C.dep;
    c && Jn(c)
}
function wt(C) {
    return !!(C && C.__v_isRef === !0)
}
function zt(C) {
    return Ou(C, !1)
}
function Ou(C, A) {
    return wt(C) ? C : new Fu(C,A)
}
class Fu {
    constructor(A, c) {
        this.__v_isShallow = c,
        this.dep = void 0,
        this.__v_isRef = !0,
        this._rawValue = c ? A : yt(A),
        this._value = c ? A : pi(A)
    }
    get value() {
        return to(this),
        this._value
    }
    set value(A) {
        const c = this.__v_isShallow || _i(A) || Qe(A);
        A = c ? A : yt(A),
        ci(A, this._rawValue) && (this._rawValue = A,
        this._value = c ? A : pi(A),
        eo(this))
    }
}
function he(C) {
    return wt(C) ? C.value : C
}
const Iu = {
    get: (C,A,c)=>he(Reflect.get(C, A, c)),
    set: (C,A,c,S)=>{
        const t = C[A];
        return wt(t) && !wt(c) ? (t.value = c,
        !0) : Reflect.set(C, A, c, S)
    }
};
function io(C) {
    return Ke(C) ? C : new Proxy(C,Iu)
}
var no;
class Bu {
    constructor(A, c, S, t) {
        this._setter = c,
        this.dep = void 0,
        this.__v_isRef = !0,
        this[no] = !1,
        this._dirty = !0,
        this.effect = new Ms(A,()=>{
            this._dirty || (this._dirty = !0,
            eo(this))
        }
        ),
        this.effect.computed = this,
        this.effect.active = this._cacheable = !t,
        this.__v_isReadonly = S
    }
    get value() {
        const A = yt(this);
        return to(A),
        (A._dirty || !A._cacheable) && (A._dirty = !1,
        A._value = A.effect.run()),
        A._value
    }
    set value(A) {
        this._setter(A)
    }
}
no = "__v_isReadonly";
function Du(C, A, c=!1) {
    let S, t;
    const e = gt(C);
    return e ? (S = C,
    t = ne) : (S = C.get,
    t = C.set),
    new Bu(S,t,e || !t,c)
}
function Te(C, A, c, S) {
    let t;
    try {
        t = S ? C(...S) : C()
    } catch (e) {
        vn(e, A, c)
    }
    return t
}
function _t(C, A, c, S) {
    if (gt(C)) {
        const e = Te(C, A, c, S);
        return e && Ua(e) && e.catch(f=>{
            vn(f, A, c)
        }
        ),
        e
    }
    const t = [];
    for (let e = 0; e < C.length; e++)
        t.push(_t(C[e], A, c, S));
    return t
}
function vn(C, A, c, S=!0) {
    const t = A ? A.vnode : null;
    if (A) {
        let e = A.parent;
        const f = A.proxy
          , r = c;
        for (; e; ) {
            const a = e.ec;
            if (a) {
                for (let n = 0; n < a.length; n++)
                    if (a[n](C, f, r) === !1)
                        return
            }
            e = e.parent
        }
        const o = A.appContext.config.errorHandler;
        if (o) {
            Te(o, null, 10, [C, f, r]);
            return
        }
    }
    Gu(C, c, t, S)
}
function Gu(C, A, c, S=!0) {
    console.error(C)
}
let gi = !1
  , jn = !1;
const Nt = [];
let oe = 0;
const Ze = [];
let ue = null
  , Le = 0;
const so = Promise.resolve();
let Ds = null;
function Nu(C) {
    const A = Ds || so;
    return C ? A.then(this ? C.bind(this) : C) : A
}
function wu(C) {
    let A = oe + 1
      , c = Nt.length;
    for (; A < c; ) {
        const S = A + c >>> 1;
        mi(Nt[S]) < C ? A = S + 1 : c = S
    }
    return A
}
function Gs(C) {
    (!Nt.length || !Nt.includes(C, gi && C.allowRecurse ? oe + 1 : oe)) && (C.id == null ? Nt.push(C) : Nt.splice(wu(C.id), 0, C),
    ro())
}
function ro() {
    !gi && !jn && (jn = !0,
    Ds = so.then(oo))
}
function Uu(C) {
    const A = Nt.indexOf(C);
    A > oe && Nt.splice(A, 1)
}
function Yu(C) {
    vt(C) ? Ze.push(...C) : (!ue || !ue.includes(C, C.allowRecurse ? Le + 1 : Le)) && Ze.push(C),
    ro()
}
function fr(C, A=gi ? oe + 1 : 0) {
    for (; A < Nt.length; A++) {
        const c = Nt[A];
        c && c.pre && (Nt.splice(A, 1),
        A--,
        c())
    }
}
function ao(C) {
    if (Ze.length) {
        const A = [...new Set(Ze)];
        if (Ze.length = 0,
        ue) {
            ue.push(...A);
            return
        }
        for (ue = A,
        ue.sort((c,S)=>mi(c) - mi(S)),
        Le = 0; Le < ue.length; Le++)
            ue[Le]();
        ue = null,
        Le = 0
    }
}
const mi = C=>C.id == null ? 1 / 0 : C.id
  , Xu = (C,A)=>{
    const c = mi(C) - mi(A);
    if (c === 0) {
        if (C.pre && !A.pre)
            return -1;
        if (A.pre && !C.pre)
            return 1
    }
    return c
}
;
function oo(C) {
    jn = !1,
    gi = !0,
    Nt.sort(Xu);
    const A = ne;
    try {
        for (oe = 0; oe < Nt.length; oe++) {
            const c = Nt[oe];
            c && c.active !== !1 && Te(c, null, 14)
        }
    } finally {
        oe = 0,
        Nt.length = 0,
        ao(),
        gi = !1,
        Ds = null,
        (Nt.length || Ze.length) && oo()
    }
}
function zu(C, A, ...c) {
    if (C.isUnmounted)
        return;
    const S = C.vnode.props || Et;
    let t = c;
    const e = A.startsWith("update:")
      , f = e && A.slice(7);
    if (f && f in S) {
        const n = `${f === "modelValue" ? "model" : f}Modifiers`
          , {number: s, trim: l} = S[n] || Et;
        l && (t = c.map(i=>Ft(i) ? i.trim() : i)),
        s && (t = c.map(qi))
    }
    let r, o = S[r = Rn(A)] || S[r = Rn($e(A))];
    !o && e && (o = S[r = Rn(Ve(A))]),
    o && _t(o, C, 6, t);
    const a = S[r + "Once"];
    if (a) {
        if (!C.emitted)
            C.emitted = {};
        else if (C.emitted[r])
            return;
        C.emitted[r] = !0,
        _t(a, C, 6, t)
    }
}
function ho(C, A, c=!1) {
    const S = A.emitsCache
      , t = S.get(C);
    if (t !== void 0)
        return t;
    const e = C.emits;
    let f = {}
      , r = !1;
    if (!gt(C)) {
        const o = a=>{
            const n = ho(a, A, !0);
            n && (r = !0,
            Bt(f, n))
        }
        ;
        !c && A.mixins.length && A.mixins.forEach(o),
        C.extends && o(C.extends),
        C.mixins && C.mixins.forEach(o)
    }
    return !e && !r ? (St(C) && S.set(C, null),
    null) : (vt(e) ? e.forEach(o=>f[o] = null) : Bt(f, e),
    St(C) && S.set(C, f),
    f)
}
function cn(C, A) {
    return !C || !ln(A) ? !1 : (A = A.slice(2).replace(/Once$/, ""),
    xt(C, A[0].toLowerCase() + A.slice(1)) || xt(C, Ve(A)) || xt(C, A))
}
let qt = null
  , pn = null;
function tn(C) {
    const A = qt;
    return qt = C,
    pn = C && C.type.__scopeId || null,
    A
}
function Oi(C) {
    pn = C
}
function Fi() {
    pn = null
}
function Ns(C, A=qt, c) {
    if (!A || C._n)
        return C;
    const S = (...t)=>{
        S._d && Sr(-1);
        const e = tn(A);
        let f;
        try {
            f = C(...t)
        } finally {
            tn(e),
            S._d && Sr(1)
        }
        return f
    }
    ;
    return S._n = !0,
    S._c = !0,
    S._d = !0,
    S
}
function Ln(C) {
    const {type: A, vnode: c, proxy: S, withProxy: t, props: e, propsOptions: [f], slots: r, attrs: o, emit: a, render: n, renderCache: s, data: l, setupState: i, ctx: h, inheritAttrs: u} = C;
    let d, v;
    const p = tn(C);
    try {
        if (c.shapeFlag & 4) {
            const m = t || S;
            d = ae(n.call(m, m, s, e, i, l, h)),
            v = o
        } else {
            const m = A;
            d = ae(m.length > 1 ? m(e, {
                attrs: o,
                slots: r,
                emit: a
            }) : m(e, null)),
            v = A.props ? o : Vu(o)
        }
    } catch (m) {
        li.length = 0,
        vn(m, C, 1),
        d = Dt(se)
    }
    let g = d;
    if (v && u !== !1) {
        const m = Object.keys(v)
          , {shapeFlag: x} = g;
        m.length && x & 7 && (f && m.some(Es) && (v = Wu(v, f)),
        g = Ee(g, v))
    }
    return c.dirs && (g = Ee(g),
    g.dirs = g.dirs ? g.dirs.concat(c.dirs) : c.dirs),
    c.transition && (g.transition = c.transition),
    d = g,
    tn(p),
    d
}
const Vu = C=>{
    let A;
    for (const c in C)
        (c === "class" || c === "style" || ln(c)) && ((A || (A = {}))[c] = C[c]);
    return A
}
  , Wu = (C,A)=>{
    const c = {};
    for (const S in C)
        (!Es(S) || !(S.slice(9)in A)) && (c[S] = C[S]);
    return c
}
;
function Hu(C, A, c) {
    const {props: S, children: t, component: e} = C
      , {props: f, children: r, patchFlag: o} = A
      , a = e.emitsOptions;
    if (A.dirs || A.transition)
        return !0;
    if (c && o >= 0) {
        if (o & 1024)
            return !0;
        if (o & 16)
            return S ? dr(S, f, a) : !!f;
        if (o & 8) {
            const n = A.dynamicProps;
            for (let s = 0; s < n.length; s++) {
                const l = n[s];
                if (f[l] !== S[l] && !cn(a, l))
                    return !0
            }
        }
    } else
        return (t || r) && (!r || !r.$stable) ? !0 : S === f ? !1 : S ? f ? dr(S, f, a) : !0 : !!f;
    return !1
}
function dr(C, A, c) {
    const S = Object.keys(A);
    if (S.length !== Object.keys(C).length)
        return !0;
    for (let t = 0; t < S.length; t++) {
        const e = S[t];
        if (A[e] !== C[e] && !cn(c, e))
            return !0
    }
    return !1
}
function bu({vnode: C, parent: A}, c) {
    for (; A && A.subTree === C; )
        (C = A.vnode).el = c,
        A = A.parent
}
const Ku = C=>C.__isSuspense;
function Zu(C, A) {
    A && A.pendingBranch ? vt(C) ? A.effects.push(...C) : A.effects.push(C) : Yu(C)
}
function Ju(C, A) {
    if (Ot) {
        let c = Ot.provides;
        const S = Ot.parent && Ot.parent.provides;
        S === c && (c = Ot.provides = Object.create(S)),
        c[C] = A
    }
}
function bi(C, A, c=!1) {
    const S = Ot || qt;
    if (S) {
        const t = S.parent == null ? S.vnode.appContext && S.vnode.appContext.provides : S.parent.provides;
        if (t && C in t)
            return t[C];
        if (arguments.length > 1)
            return c && gt(A) ? A.call(S.proxy) : A
    }
}
const zi = {};
function Ki(C, A, c) {
    return lo(C, A, c)
}
function lo(C, A, {immediate: c, deep: S, flush: t, onTrack: e, onTrigger: f}=Et) {
    const r = eu() === (Ot == null ? void 0 : Ot.scope) ? Ot : null;
    let o, a = !1, n = !1;
    if (wt(C) ? (o = ()=>C.value,
    a = _i(C)) : Ke(C) ? (o = ()=>C,
    S = !0) : vt(C) ? (n = !0,
    a = C.some(g=>Ke(g) || _i(g)),
    o = ()=>C.map(g=>{
        if (wt(g))
            return g.value;
        if (Ke(g))
            return Be(g);
        if (gt(g))
            return Te(g, r, 2)
    }
    )) : gt(C) ? A ? o = ()=>Te(C, r, 2) : o = ()=>{
        if (!(r && r.isUnmounted))
            return s && s(),
            _t(C, r, 3, [l])
    }
    : o = ne,
    A && S) {
        const g = o;
        o = ()=>Be(g())
    }
    let s, l = g=>{
        s = v.onStop = ()=>{
            Te(g, r, 4)
        }
    }
    , i;
    if (Ei)
        if (l = ne,
        A ? c && _t(A, r, 3, [o(), n ? [] : void 0, l]) : o(),
        t === "sync") {
            const g = zf();
            i = g.__watcherHandles || (g.__watcherHandles = [])
        } else
            return ne;
    let h = n ? new Array(C.length).fill(zi) : zi;
    const u = ()=>{
        if (v.active)
            if (A) {
                const g = v.run();
                (S || a || (n ? g.some((m,x)=>ci(m, h[x])) : ci(g, h))) && (s && s(),
                _t(A, r, 3, [g, h === zi ? void 0 : n && h[0] === zi ? [] : h, l]),
                h = g)
            } else
                v.run()
    }
    ;
    u.allowRecurse = !!A;
    let d;
    t === "sync" ? d = u : t === "post" ? d = ()=>Wt(u, r && r.suspense) : (u.pre = !0,
    r && (u.id = r.uid),
    d = ()=>Gs(u));
    const v = new Ms(o,d);
    A ? c ? u() : h = v.run() : t === "post" ? Wt(v.run.bind(v), r && r.suspense) : v.run();
    const p = ()=>{
        v.stop(),
        r && r.scope && Cs(r.scope.effects, v)
    }
    ;
    return i && i.push(p),
    p
}
function ju(C, A, c) {
    const S = this.proxy
      , t = Ft(C) ? C.includes(".") ? uo(S, C) : ()=>S[C] : C.bind(S, S);
    let e;
    gt(A) ? e = A : (e = A.handler,
    c = A);
    const f = Ot;
    ke(this);
    const r = lo(t, e.bind(S), c);
    return f ? ke(f) : we(),
    r
}
function uo(C, A) {
    const c = A.split(".");
    return ()=>{
        let S = C;
        for (let t = 0; t < c.length && S; t++)
            S = S[c[t]];
        return S
    }
}
function Be(C, A) {
    if (!St(C) || C.__v_skip || (A = A || new Set,
    A.has(C)))
        return C;
    if (A.add(C),
    wt(C))
        Be(C.value, A);
    else if (vt(C))
        for (let c = 0; c < C.length; c++)
            Be(C[c], A);
    else if (un(C) || be(C))
        C.forEach(c=>{
            Be(c, A)
        }
        );
    else if (Xa(C))
        for (const c in C)
            Be(C[c], A);
    return C
}
function fo() {
    const C = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return Ii(()=>{
        C.isMounted = !0
    }
    ),
    xn(()=>{
        C.isUnmounting = !0
    }
    ),
    C
}
const Qt = [Function, Array]
  , $u = {
    name: "BaseTransition",
    props: {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        onBeforeEnter: Qt,
        onEnter: Qt,
        onAfterEnter: Qt,
        onEnterCancelled: Qt,
        onBeforeLeave: Qt,
        onLeave: Qt,
        onAfterLeave: Qt,
        onLeaveCancelled: Qt,
        onBeforeAppear: Qt,
        onAppear: Qt,
        onAfterAppear: Qt,
        onAppearCancelled: Qt
    },
    setup(C, {slots: A}) {
        const c = Mo()
          , S = fo();
        let t;
        return ()=>{
            const e = A.default && ws(A.default(), !0);
            if (!e || !e.length)
                return;
            let f = e[0];
            if (e.length > 1) {
                for (const u of e)
                    if (u.type !== se) {
                        f = u;
                        break
                    }
            }
            const r = yt(C)
              , {mode: o} = r;
            if (S.isLeaving)
                return On(f);
            const a = vr(f);
            if (!a)
                return On(f);
            const n = xi(a, r, S, c);
            yi(a, n);
            const s = c.subTree
              , l = s && vr(s);
            let i = !1;
            const {getTransitionKey: h} = a.type;
            if (h) {
                const u = h();
                t === void 0 ? t = u : u !== t && (t = u,
                i = !0)
            }
            if (l && l.type !== se && (!Oe(a, l) || i)) {
                const u = xi(l, r, S, c);
                if (yi(l, u),
                o === "out-in")
                    return S.isLeaving = !0,
                    u.afterLeave = ()=>{
                        S.isLeaving = !1,
                        c.update.active !== !1 && c.update()
                    }
                    ,
                    On(f);
                o === "in-out" && a.type !== se && (u.delayLeave = (d,v,p)=>{
                    const g = vo(S, l);
                    g[String(l.key)] = l,
                    d._leaveCb = ()=>{
                        v(),
                        d._leaveCb = void 0,
                        delete n.delayedLeave
                    }
                    ,
                    n.delayedLeave = p
                }
                )
            }
            return f
        }
    }
}
  , Qu = $u;
function vo(C, A) {
    const {leavingVNodes: c} = C;
    let S = c.get(A.type);
    return S || (S = Object.create(null),
    c.set(A.type, S)),
    S
}
function xi(C, A, c, S) {
    const {appear: t, mode: e, persisted: f=!1, onBeforeEnter: r, onEnter: o, onAfterEnter: a, onEnterCancelled: n, onBeforeLeave: s, onLeave: l, onAfterLeave: i, onLeaveCancelled: h, onBeforeAppear: u, onAppear: d, onAfterAppear: v, onAppearCancelled: p} = A
      , g = String(C.key)
      , m = vo(c, C)
      , x = (P,M)=>{
        P && _t(P, S, 9, M)
    }
      , T = (P,M)=>{
        const L = M[1];
        x(P, M),
        vt(P) ? P.every(R=>R.length <= 1) && L() : P.length <= 1 && L()
    }
      , E = {
        mode: e,
        persisted: f,
        beforeEnter(P) {
            let M = r;
            if (!c.isMounted)
                if (t)
                    M = u || r;
                else
                    return;
            P._leaveCb && P._leaveCb(!0);
            const L = m[g];
            L && Oe(C, L) && L.el._leaveCb && L.el._leaveCb(),
            x(M, [P])
        },
        enter(P) {
            let M = o
              , L = a
              , R = n;
            if (!c.isMounted)
                if (t)
                    M = d || o,
                    L = v || a,
                    R = p || n;
                else
                    return;
            let O = !1;
            const F = P._enterCb = B=>{
                O || (O = !0,
                B ? x(R, [P]) : x(L, [P]),
                E.delayedLeave && E.delayedLeave(),
                P._enterCb = void 0)
            }
            ;
            M ? T(M, [P, F]) : F()
        },
        leave(P, M) {
            const L = String(C.key);
            if (P._enterCb && P._enterCb(!0),
            c.isUnmounting)
                return M();
            x(s, [P]);
            let R = !1;
            const O = P._leaveCb = F=>{
                R || (R = !0,
                M(),
                F ? x(h, [P]) : x(i, [P]),
                P._leaveCb = void 0,
                m[L] === C && delete m[L])
            }
            ;
            m[L] = C,
            l ? T(l, [P, O]) : O()
        },
        clone(P) {
            return xi(P, A, c, S)
        }
    };
    return E
}
function On(C) {
    if (gn(C))
        return C = Ee(C),
        C.children = null,
        C
}
function vr(C) {
    return gn(C) ? C.children ? C.children[0] : void 0 : C
}
function yi(C, A) {
    C.shapeFlag & 6 && C.component ? yi(C.component.subTree, A) : C.shapeFlag & 128 ? (C.ssContent.transition = A.clone(C.ssContent),
    C.ssFallback.transition = A.clone(C.ssFallback)) : C.transition = A
}
function ws(C, A=!1, c) {
    let S = []
      , t = 0;
    for (let e = 0; e < C.length; e++) {
        let f = C[e];
        const r = c == null ? f.key : String(c) + String(f.key != null ? f.key : e);
        f.type === Lt ? (f.patchFlag & 128 && t++,
        S = S.concat(ws(f.children, A, r))) : (A || f.type !== se) && S.push(r != null ? Ee(f, {
            key: r
        }) : f)
    }
    if (t > 1)
        for (let e = 0; e < S.length; e++)
            S[e].patchFlag = -2;
    return S
}
function ii(C) {
    return gt(C) ? {
        setup: C,
        name: C.name
    } : C
}
const Zi = C=>!!C.type.__asyncLoader
  , gn = C=>C.type.__isKeepAlive;
function ku(C, A) {
    co(C, "a", A)
}
function qu(C, A) {
    co(C, "da", A)
}
function co(C, A, c=Ot) {
    const S = C.__wdc || (C.__wdc = ()=>{
        let t = c;
        for (; t; ) {
            if (t.isDeactivated)
                return;
            t = t.parent
        }
        return C()
    }
    );
    if (mn(A, S, c),
    c) {
        let t = c.parent;
        for (; t && t.parent; )
            gn(t.parent.vnode) && _u(S, A, c, t),
            t = t.parent
    }
}
function _u(C, A, c, S) {
    const t = mn(A, C, S, !0);
    po(()=>{
        Cs(S[A], t)
    }
    , c)
}
function mn(C, A, c=Ot, S=!1) {
    if (c) {
        const t = c[C] || (c[C] = [])
          , e = A.__weh || (A.__weh = (...f)=>{
            if (c.isUnmounted)
                return;
            ti(),
            ke(c);
            const r = _t(A, c, C, f);
            return we(),
            ei(),
            r
        }
        );
        return S ? t.unshift(e) : t.push(e),
        e
    }
}
const ce = C=>(A,c=Ot)=>(!Ei || C === "sp") && mn(C, (...S)=>A(...S), c)
  , tf = ce("bm")
  , Ii = ce("m")
  , ef = ce("bu")
  , Us = ce("u")
  , xn = ce("bum")
  , po = ce("um")
  , nf = ce("sp")
  , sf = ce("rtg")
  , rf = ce("rtc");
function af(C, A=Ot) {
    mn("ec", C, A)
}
function cr(C, A) {
    const c = qt;
    if (c === null)
        return C;
    const S = Sn(c) || c.proxy
      , t = C.dirs || (C.dirs = []);
    for (let e = 0; e < A.length; e++) {
        let[f,r,o,a=Et] = A[e];
        f && (gt(f) && (f = {
            mounted: f,
            updated: f
        }),
        f.deep && Be(r),
        t.push({
            dir: f,
            instance: S,
            value: r,
            oldValue: void 0,
            arg: o,
            modifiers: a
        }))
    }
    return C
}
function Pe(C, A, c, S) {
    const t = C.dirs
      , e = A && A.dirs;
    for (let f = 0; f < t.length; f++) {
        const r = t[f];
        e && (r.oldValue = e[f].value);
        let o = r.dir[S];
        o && (ti(),
        _t(o, c, 8, [C.el, r, C, A]),
        ei())
    }
}
const of = Symbol();
function Ti(C, A, c, S) {
    let t;
    const e = c && c[S];
    if (vt(C) || Ft(C)) {
        t = new Array(C.length);
        for (let f = 0, r = C.length; f < r; f++)
            t[f] = A(C[f], f, void 0, e && e[f])
    } else if (typeof C == "number") {
        t = new Array(C);
        for (let f = 0; f < C; f++)
            t[f] = A(f + 1, f, void 0, e && e[f])
    } else if (St(C))
        if (C[Symbol.iterator])
            t = Array.from(C, (f,r)=>A(f, r, void 0, e && e[r]));
        else {
            const f = Object.keys(C);
            t = new Array(f.length);
            for (let r = 0, o = f.length; r < o; r++) {
                const a = f[r];
                t[r] = A(C[a], a, r, e && e[r])
            }
        }
    else
        t = [];
    return c && (c[S] = t),
    t
}
const $n = C=>C ? Ro(C) ? Sn(C) || C.proxy : $n(C.parent) : null
  , hi = Bt(Object.create(null), {
    $: C=>C,
    $el: C=>C.vnode.el,
    $data: C=>C.data,
    $props: C=>C.props,
    $attrs: C=>C.attrs,
    $slots: C=>C.slots,
    $refs: C=>C.refs,
    $parent: C=>$n(C.parent),
    $root: C=>$n(C.root),
    $emit: C=>C.emit,
    $options: C=>Ys(C),
    $forceUpdate: C=>C.f || (C.f = ()=>Gs(C.update)),
    $nextTick: C=>C.n || (C.n = Nu.bind(C.proxy)),
    $watch: C=>ju.bind(C)
})
  , Fn = (C,A)=>C !== Et && !C.__isScriptSetup && xt(C, A)
  , hf = {
    get({_: C}, A) {
        const {ctx: c, setupState: S, data: t, props: e, accessCache: f, type: r, appContext: o} = C;
        let a;
        if (A[0] !== "$") {
            const i = f[A];
            if (i !== void 0)
                switch (i) {
                case 1:
                    return S[A];
                case 2:
                    return t[A];
                case 4:
                    return c[A];
                case 3:
                    return e[A]
                }
            else {
                if (Fn(S, A))
                    return f[A] = 1,
                    S[A];
                if (t !== Et && xt(t, A))
                    return f[A] = 2,
                    t[A];
                if ((a = C.propsOptions[0]) && xt(a, A))
                    return f[A] = 3,
                    e[A];
                if (c !== Et && xt(c, A))
                    return f[A] = 4,
                    c[A];
                Qn && (f[A] = 0)
            }
        }
        const n = hi[A];
        let s, l;
        if (n)
            return A === "$attrs" && Kt(C, "get", A),
            n(C);
        if ((s = r.__cssModules) && (s = s[A]))
            return s;
        if (c !== Et && xt(c, A))
            return f[A] = 4,
            c[A];
        if (l = o.config.globalProperties,
        xt(l, A))
            return l[A]
    },
    set({_: C}, A, c) {
        const {data: S, setupState: t, ctx: e} = C;
        return Fn(t, A) ? (t[A] = c,
        !0) : S !== Et && xt(S, A) ? (S[A] = c,
        !0) : xt(C.props, A) || A[0] === "$" && A.slice(1)in C ? !1 : (e[A] = c,
        !0)
    },
    has({_: {data: C, setupState: A, accessCache: c, ctx: S, appContext: t, propsOptions: e}}, f) {
        let r;
        return !!c[f] || C !== Et && xt(C, f) || Fn(A, f) || (r = e[0]) && xt(r, f) || xt(S, f) || xt(hi, f) || xt(t.config.globalProperties, f)
    },
    defineProperty(C, A, c) {
        return c.get != null ? C._.accessCache[A] = 0 : xt(c, "value") && this.set(C, A, c.value, null),
        Reflect.defineProperty(C, A, c)
    }
};
let Qn = !0;
function lf(C) {
    const A = Ys(C)
      , c = C.proxy
      , S = C.ctx;
    Qn = !1,
    A.beforeCreate && pr(A.beforeCreate, C, "bc");
    const {data: t, computed: e, methods: f, watch: r, provide: o, inject: a, created: n, beforeMount: s, mounted: l, beforeUpdate: i, updated: h, activated: u, deactivated: d, beforeDestroy: v, beforeUnmount: p, destroyed: g, unmounted: m, render: x, renderTracked: T, renderTriggered: E, errorCaptured: P, serverPrefetch: M, expose: L, inheritAttrs: R, components: O, directives: F, filters: B} = A;
    if (a && uf(a, S, null, C.appContext.config.unwrapInjectedRef),
    f)
        for (const z in f) {
            const W = f[z];
            gt(W) && (S[z] = W.bind(c))
        }
    if (t) {
        const z = t.call(c, c);
        St(z) && (C.data = Fs(z))
    }
    if (Qn = !0,
    e)
        for (const z in e) {
            const W = e[z]
              , b = gt(W) ? W.bind(c, c) : gt(W.get) ? W.get.bind(c, c) : ne
              , D = !gt(W) && gt(W.set) ? W.set.bind(c) : ne
              , I = Ci({
                get: b,
                set: D
            });
            Object.defineProperty(S, z, {
                enumerable: !0,
                configurable: !0,
                get: ()=>I.value,
                set: G=>I.value = G
            })
        }
    if (r)
        for (const z in r)
            go(r[z], S, c, z);
    if (o) {
        const z = gt(o) ? o.call(c) : o;
        Reflect.ownKeys(z).forEach(W=>{
            Ju(W, z[W])
        }
        )
    }
    n && pr(n, C, "c");
    function Y(z, W) {
        vt(W) ? W.forEach(b=>z(b.bind(c))) : W && z(W.bind(c))
    }
    if (Y(tf, s),
    Y(Ii, l),
    Y(ef, i),
    Y(Us, h),
    Y(ku, u),
    Y(qu, d),
    Y(af, P),
    Y(rf, T),
    Y(sf, E),
    Y(xn, p),
    Y(po, m),
    Y(nf, M),
    vt(L))
        if (L.length) {
            const z = C.exposed || (C.exposed = {});
            L.forEach(W=>{
                Object.defineProperty(z, W, {
                    get: ()=>c[W],
                    set: b=>c[W] = b
                })
            }
            )
        } else
            C.exposed || (C.exposed = {});
    x && C.render === ne && (C.render = x),
    R != null && (C.inheritAttrs = R),
    O && (C.components = O),
    F && (C.directives = F)
}
function uf(C, A, c=ne, S=!1) {
    vt(C) && (C = kn(C));
    for (const t in C) {
        const e = C[t];
        let f;
        St(e) ? "default"in e ? f = bi(e.from || t, e.default, !0) : f = bi(e.from || t) : f = bi(e),
        wt(f) && S ? Object.defineProperty(A, t, {
            enumerable: !0,
            configurable: !0,
            get: ()=>f.value,
            set: r=>f.value = r
        }) : A[t] = f
    }
}
function pr(C, A, c) {
    _t(vt(C) ? C.map(S=>S.bind(A.proxy)) : C.bind(A.proxy), A, c)
}
function go(C, A, c, S) {
    const t = S.includes(".") ? uo(c, S) : ()=>c[S];
    if (Ft(C)) {
        const e = A[C];
        gt(e) && Ki(t, e)
    } else if (gt(C))
        Ki(t, C.bind(c));
    else if (St(C))
        if (vt(C))
            C.forEach(e=>go(e, A, c, S));
        else {
            const e = gt(C.handler) ? C.handler.bind(c) : A[C.handler];
            gt(e) && Ki(t, e, C)
        }
}
function Ys(C) {
    const A = C.type
      , {mixins: c, extends: S} = A
      , {mixins: t, optionsCache: e, config: {optionMergeStrategies: f}} = C.appContext
      , r = e.get(A);
    let o;
    return r ? o = r : !t.length && !c && !S ? o = A : (o = {},
    t.length && t.forEach(a=>en(o, a, f, !0)),
    en(o, A, f)),
    St(A) && e.set(A, o),
    o
}
function en(C, A, c, S=!1) {
    const {mixins: t, extends: e} = A;
    e && en(C, e, c, !0),
    t && t.forEach(f=>en(C, f, c, !0));
    for (const f in A)
        if (!(S && f === "expose")) {
            const r = ff[f] || c && c[f];
            C[f] = r ? r(C[f], A[f]) : A[f]
        }
    return C
}
const ff = {
    data: gr,
    props: Re,
    emits: Re,
    methods: Re,
    computed: Re,
    beforeCreate: Xt,
    created: Xt,
    beforeMount: Xt,
    mounted: Xt,
    beforeUpdate: Xt,
    updated: Xt,
    beforeDestroy: Xt,
    beforeUnmount: Xt,
    destroyed: Xt,
    unmounted: Xt,
    activated: Xt,
    deactivated: Xt,
    errorCaptured: Xt,
    serverPrefetch: Xt,
    components: Re,
    directives: Re,
    watch: vf,
    provide: gr,
    inject: df
};
function gr(C, A) {
    return A ? C ? function() {
        return Bt(gt(C) ? C.call(this, this) : C, gt(A) ? A.call(this, this) : A)
    }
    : A : C
}
function df(C, A) {
    return Re(kn(C), kn(A))
}
function kn(C) {
    if (vt(C)) {
        const A = {};
        for (let c = 0; c < C.length; c++)
            A[C[c]] = C[c];
        return A
    }
    return C
}
function Xt(C, A) {
    return C ? [...new Set([].concat(C, A))] : A
}
function Re(C, A) {
    return C ? Bt(Bt(Object.create(null), C), A) : A
}
function vf(C, A) {
    if (!C)
        return A;
    if (!A)
        return C;
    const c = Bt(Object.create(null), C);
    for (const S in A)
        c[S] = Xt(C[S], A[S]);
    return c
}
function cf(C, A, c, S=!1) {
    const t = {}
      , e = {};
    ki(e, Tn, 1),
    C.propsDefaults = Object.create(null),
    mo(C, A, t, e);
    for (const f in C.propsOptions[0])
        f in t || (t[f] = void 0);
    c ? C.props = S ? t : Lu(t) : C.type.props ? C.props = t : C.props = e,
    C.attrs = e
}
function pf(C, A, c, S) {
    const {props: t, attrs: e, vnode: {patchFlag: f}} = C
      , r = yt(t)
      , [o] = C.propsOptions;
    let a = !1;
    if ((S || f > 0) && !(f & 16)) {
        if (f & 8) {
            const n = C.vnode.dynamicProps;
            for (let s = 0; s < n.length; s++) {
                let l = n[s];
                if (cn(C.emitsOptions, l))
                    continue;
                const i = A[l];
                if (o)
                    if (xt(e, l))
                        i !== e[l] && (e[l] = i,
                        a = !0);
                    else {
                        const h = $e(l);
                        t[h] = qn(o, r, h, i, C, !1)
                    }
                else
                    i !== e[l] && (e[l] = i,
                    a = !0)
            }
        }
    } else {
        mo(C, A, t, e) && (a = !0);
        let n;
        for (const s in r)
            (!A || !xt(A, s) && ((n = Ve(s)) === s || !xt(A, n))) && (o ? c && (c[s] !== void 0 || c[n] !== void 0) && (t[s] = qn(o, r, s, void 0, C, !0)) : delete t[s]);
        if (e !== r)
            for (const s in e)
                (!A || !xt(A, s)) && (delete e[s],
                a = !0)
    }
    a && ve(C, "set", "$attrs")
}
function mo(C, A, c, S) {
    const [t,e] = C.propsOptions;
    let f = !1, r;
    if (A)
        for (let o in A) {
            if (Wi(o))
                continue;
            const a = A[o];
            let n;
            t && xt(t, n = $e(o)) ? !e || !e.includes(n) ? c[n] = a : (r || (r = {}))[n] = a : cn(C.emitsOptions, o) || (!(o in S) || a !== S[o]) && (S[o] = a,
            f = !0)
        }
    if (e) {
        const o = yt(c)
          , a = r || Et;
        for (let n = 0; n < e.length; n++) {
            const s = e[n];
            c[s] = qn(t, o, s, a[s], C, !xt(a, s))
        }
    }
    return f
}
function qn(C, A, c, S, t, e) {
    const f = C[c];
    if (f != null) {
        const r = xt(f, "default");
        if (r && S === void 0) {
            const o = f.default;
            if (f.type !== Function && gt(o)) {
                const {propsDefaults: a} = t;
                c in a ? S = a[c] : (ke(t),
                S = a[c] = o.call(null, A),
                we())
            } else
                S = o
        }
        f[0] && (e && !r ? S = !1 : f[1] && (S === "" || S === Ve(c)) && (S = !0))
    }
    return S
}
function xo(C, A, c=!1) {
    const S = A.propsCache
      , t = S.get(C);
    if (t)
        return t;
    const e = C.props
      , f = {}
      , r = [];
    let o = !1;
    if (!gt(C)) {
        const n = s=>{
            o = !0;
            const [l,i] = xo(s, A, !0);
            Bt(f, l),
            i && r.push(...i)
        }
        ;
        !c && A.mixins.length && A.mixins.forEach(n),
        C.extends && n(C.extends),
        C.mixins && C.mixins.forEach(n)
    }
    if (!e && !o)
        return St(C) && S.set(C, He),
        He;
    if (vt(e))
        for (let n = 0; n < e.length; n++) {
            const s = $e(e[n]);
            mr(s) && (f[s] = Et)
        }
    else if (e)
        for (const n in e) {
            const s = $e(n);
            if (mr(s)) {
                const l = e[n]
                  , i = f[s] = vt(l) || gt(l) ? {
                    type: l
                } : Object.assign({}, l);
                if (i) {
                    const h = Tr(Boolean, i.type)
                      , u = Tr(String, i.type);
                    i[0] = h > -1,
                    i[1] = u < 0 || h < u,
                    (h > -1 || xt(i, "default")) && r.push(s)
                }
            }
        }
    const a = [f, r];
    return St(C) && S.set(C, a),
    a
}
function mr(C) {
    return C[0] !== "$"
}
function xr(C) {
    const A = C && C.toString().match(/^\s*(function|class) (\w+)/);
    return A ? A[2] : C === null ? "null" : ""
}
function yr(C, A) {
    return xr(C) === xr(A)
}
function Tr(C, A) {
    return vt(A) ? A.findIndex(c=>yr(c, C)) : gt(A) && yr(A, C) ? 0 : -1
}
const yo = C=>C[0] === "_" || C === "$stable"
  , Xs = C=>vt(C) ? C.map(ae) : [ae(C)]
  , gf = (C,A,c)=>{
    if (A._n)
        return A;
    const S = Ns((...t)=>Xs(A(...t)), c);
    return S._c = !1,
    S
}
  , To = (C,A,c)=>{
    const S = C._ctx;
    for (const t in C) {
        if (yo(t))
            continue;
        const e = C[t];
        if (gt(e))
            A[t] = gf(t, e, S);
        else if (e != null) {
            const f = Xs(e);
            A[t] = ()=>f
        }
    }
}
  , So = (C,A)=>{
    const c = Xs(A);
    C.slots.default = ()=>c
}
  , mf = (C,A)=>{
    if (C.vnode.shapeFlag & 32) {
        const c = A._;
        c ? (C.slots = yt(A),
        ki(A, "_", c)) : To(A, C.slots = {})
    } else
        C.slots = {},
        A && So(C, A);
    ki(C.slots, Tn, 1)
}
  , xf = (C,A,c)=>{
    const {vnode: S, slots: t} = C;
    let e = !0
      , f = Et;
    if (S.shapeFlag & 32) {
        const r = A._;
        r ? c && r === 1 ? e = !1 : (Bt(t, A),
        !c && r === 1 && delete t._) : (e = !A.$stable,
        To(A, t)),
        f = A
    } else
        A && (So(C, A),
        f = {
            default: 1
        });
    if (e)
        for (const r in t)
            !yo(r) && !(r in f) && delete t[r]
}
;
function Eo() {
    return {
        app: null,
        config: {
            isNativeTag: Kl,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let yf = 0;
function Tf(C, A) {
    return function(S, t=null) {
        gt(S) || (S = Object.assign({}, S)),
        t != null && !St(t) && (t = null);
        const e = Eo()
          , f = new Set;
        let r = !1;
        const o = e.app = {
            _uid: yf++,
            _component: S,
            _props: t,
            _container: null,
            _context: e,
            _instance: null,
            version: Vf,
            get config() {
                return e.config
            },
            set config(a) {},
            use(a, ...n) {
                return f.has(a) || (a && gt(a.install) ? (f.add(a),
                a.install(o, ...n)) : gt(a) && (f.add(a),
                a(o, ...n))),
                o
            },
            mixin(a) {
                return e.mixins.includes(a) || e.mixins.push(a),
                o
            },
            component(a, n) {
                return n ? (e.components[a] = n,
                o) : e.components[a]
            },
            directive(a, n) {
                return n ? (e.directives[a] = n,
                o) : e.directives[a]
            },
            mount(a, n, s) {
                if (!r) {
                    const l = Dt(S, t);
                    return l.appContext = e,
                    n && A ? A(l, a) : C(l, a, s),
                    r = !0,
                    o._container = a,
                    a.__vue_app__ = o,
                    Sn(l.component) || l.component.proxy
                }
            },
            unmount() {
                r && (C(null, o._container),
                delete o._container.__vue_app__)
            },
            provide(a, n) {
                return e.provides[a] = n,
                o
            }
        };
        return o
    }
}
function _n(C, A, c, S, t=!1) {
    if (vt(C)) {
        C.forEach((l,i)=>_n(l, A && (vt(A) ? A[i] : A), c, S, t));
        return
    }
    if (Zi(S) && !t)
        return;
    const e = S.shapeFlag & 4 ? Sn(S.component) || S.component.proxy : S.el
      , f = t ? null : e
      , {i: r, r: o} = C
      , a = A && A.r
      , n = r.refs === Et ? r.refs = {} : r.refs
      , s = r.setupState;
    if (a != null && a !== o && (Ft(a) ? (n[a] = null,
    xt(s, a) && (s[a] = null)) : wt(a) && (a.value = null)),
    gt(o))
        Te(o, r, 12, [f, n]);
    else {
        const l = Ft(o)
          , i = wt(o);
        if (l || i) {
            const h = ()=>{
                if (C.f) {
                    const u = l ? xt(s, o) ? s[o] : n[o] : o.value;
                    t ? vt(u) && Cs(u, e) : vt(u) ? u.includes(e) || u.push(e) : l ? (n[o] = [e],
                    xt(s, o) && (s[o] = n[o])) : (o.value = [e],
                    C.k && (n[C.k] = o.value))
                } else
                    l ? (n[o] = f,
                    xt(s, o) && (s[o] = f)) : i && (o.value = f,
                    C.k && (n[C.k] = f))
            }
            ;
            f ? (h.id = -1,
            Wt(h, c)) : h()
        }
    }
}
const Wt = Zu;
function Sf(C) {
    return Ef(C)
}
function Ef(C, A) {
    const c = ql();
    c.__VUE__ = !0;
    const {insert: S, remove: t, patchProp: e, createElement: f, createText: r, createComment: o, setText: a, setElementText: n, parentNode: s, nextSibling: l, setScopeId: i=ne, insertStaticContent: h} = C
      , u = (K,Z,j,Q=null,tt=null,et=null,it=!1,k=null,st=!!Z.dynamicChildren)=>{
        if (K === Z)
            return;
        K && !Oe(K, Z) && (Q = H(K),
        G(K, tt, et, !0),
        K = null),
        Z.patchFlag === -2 && (st = !1,
        Z.dynamicChildren = null);
        const {type: q, ref: rt, shapeFlag: ot} = Z;
        switch (q) {
        case yn:
            d(K, Z, j, Q);
            break;
        case se:
            v(K, Z, j, Q);
            break;
        case In:
            K == null && p(Z, j, Q, it);
            break;
        case Lt:
            O(K, Z, j, Q, tt, et, it, k, st);
            break;
        default:
            ot & 1 ? x(K, Z, j, Q, tt, et, it, k, st) : ot & 6 ? F(K, Z, j, Q, tt, et, it, k, st) : (ot & 64 || ot & 128) && q.process(K, Z, j, Q, tt, et, it, k, st, $)
        }
        rt != null && tt && _n(rt, K && K.ref, et, Z || K, !Z)
    }
      , d = (K,Z,j,Q)=>{
        if (K == null)
            S(Z.el = r(Z.children), j, Q);
        else {
            const tt = Z.el = K.el;
            Z.children !== K.children && a(tt, Z.children)
        }
    }
      , v = (K,Z,j,Q)=>{
        K == null ? S(Z.el = o(Z.children || ""), j, Q) : Z.el = K.el
    }
      , p = (K,Z,j,Q)=>{
        [K.el,K.anchor] = h(K.children, Z, j, Q, K.el, K.anchor)
    }
      , g = ({el: K, anchor: Z},j,Q)=>{
        let tt;
        for (; K && K !== Z; )
            tt = l(K),
            S(K, j, Q),
            K = tt;
        S(Z, j, Q)
    }
      , m = ({el: K, anchor: Z})=>{
        let j;
        for (; K && K !== Z; )
            j = l(K),
            t(K),
            K = j;
        t(Z)
    }
      , x = (K,Z,j,Q,tt,et,it,k,st)=>{
        it = it || Z.type === "svg",
        K == null ? T(Z, j, Q, tt, et, it, k, st) : M(K, Z, tt, et, it, k, st)
    }
      , T = (K,Z,j,Q,tt,et,it,k)=>{
        let st, q;
        const {type: rt, props: ot, shapeFlag: lt, transition: at, dirs: ht} = K;
        if (st = K.el = f(K.type, et, ot && ot.is, ot),
        lt & 8 ? n(st, K.children) : lt & 16 && P(K.children, st, null, Q, tt, et && rt !== "foreignObject", it, k),
        ht && Pe(K, null, Q, "created"),
        E(st, K, K.scopeId, it, Q),
        ot) {
            for (const ut in ot)
                ut !== "value" && !Wi(ut) && e(st, ut, null, ot[ut], et, K.children, Q, tt, V);
            "value"in ot && e(st, "value", null, ot.value),
            (q = ot.onVnodeBeforeMount) && re(q, Q, K)
        }
        ht && Pe(K, null, Q, "beforeMount");
        const dt = (!tt || tt && !tt.pendingBranch) && at && !at.persisted;
        dt && at.beforeEnter(st),
        S(st, Z, j),
        ((q = ot && ot.onVnodeMounted) || dt || ht) && Wt(()=>{
            q && re(q, Q, K),
            dt && at.enter(st),
            ht && Pe(K, null, Q, "mounted")
        }
        , tt)
    }
      , E = (K,Z,j,Q,tt)=>{
        if (j && i(K, j),
        Q)
            for (let et = 0; et < Q.length; et++)
                i(K, Q[et]);
        if (tt) {
            let et = tt.subTree;
            if (Z === et) {
                const it = tt.vnode;
                E(K, it, it.scopeId, it.slotScopeIds, tt.parent)
            }
        }
    }
      , P = (K,Z,j,Q,tt,et,it,k,st=0)=>{
        for (let q = st; q < K.length; q++) {
            const rt = K[q] = k ? xe(K[q]) : ae(K[q]);
            u(null, rt, Z, j, Q, tt, et, it, k)
        }
    }
      , M = (K,Z,j,Q,tt,et,it)=>{
        const k = Z.el = K.el;
        let {patchFlag: st, dynamicChildren: q, dirs: rt} = Z;
        st |= K.patchFlag & 16;
        const ot = K.props || Et
          , lt = Z.props || Et;
        let at;
        j && Ae(j, !1),
        (at = lt.onVnodeBeforeUpdate) && re(at, j, Z, K),
        rt && Pe(Z, K, j, "beforeUpdate"),
        j && Ae(j, !0);
        const ht = tt && Z.type !== "foreignObject";
        if (q ? L(K.dynamicChildren, q, k, j, Q, ht, et) : it || W(K, Z, k, null, j, Q, ht, et, !1),
        st > 0) {
            if (st & 16)
                R(k, Z, ot, lt, j, Q, tt);
            else if (st & 2 && ot.class !== lt.class && e(k, "class", null, lt.class, tt),
            st & 4 && e(k, "style", ot.style, lt.style, tt),
            st & 8) {
                const dt = Z.dynamicProps;
                for (let ut = 0; ut < dt.length; ut++) {
                    const ft = dt[ut]
                      , mt = ot[ft]
                      , Gt = lt[ft];
                    (Gt !== mt || ft === "value") && e(k, ft, mt, Gt, tt, K.children, j, Q, V)
                }
            }
            st & 1 && K.children !== Z.children && n(k, Z.children)
        } else
            !it && q == null && R(k, Z, ot, lt, j, Q, tt);
        ((at = lt.onVnodeUpdated) || rt) && Wt(()=>{
            at && re(at, j, Z, K),
            rt && Pe(Z, K, j, "updated")
        }
        , Q)
    }
      , L = (K,Z,j,Q,tt,et,it)=>{
        for (let k = 0; k < Z.length; k++) {
            const st = K[k]
              , q = Z[k]
              , rt = st.el && (st.type === Lt || !Oe(st, q) || st.shapeFlag & 70) ? s(st.el) : j;
            u(st, q, rt, null, Q, tt, et, it, !0)
        }
    }
      , R = (K,Z,j,Q,tt,et,it)=>{
        if (j !== Q) {
            if (j !== Et)
                for (const k in j)
                    !Wi(k) && !(k in Q) && e(K, k, j[k], null, it, Z.children, tt, et, V);
            for (const k in Q) {
                if (Wi(k))
                    continue;
                const st = Q[k]
                  , q = j[k];
                st !== q && k !== "value" && e(K, k, q, st, it, Z.children, tt, et, V)
            }
            "value"in Q && e(K, "value", j.value, Q.value)
        }
    }
      , O = (K,Z,j,Q,tt,et,it,k,st)=>{
        const q = Z.el = K ? K.el : r("")
          , rt = Z.anchor = K ? K.anchor : r("");
        let {patchFlag: ot, dynamicChildren: lt, slotScopeIds: at} = Z;
        at && (k = k ? k.concat(at) : at),
        K == null ? (S(q, j, Q),
        S(rt, j, Q),
        P(Z.children, j, rt, tt, et, it, k, st)) : ot > 0 && ot & 64 && lt && K.dynamicChildren ? (L(K.dynamicChildren, lt, j, tt, et, it, k),
        (Z.key != null || tt && Z === tt.subTree) && Co(K, Z, !0)) : W(K, Z, j, rt, tt, et, it, k, st)
    }
      , F = (K,Z,j,Q,tt,et,it,k,st)=>{
        Z.slotScopeIds = k,
        K == null ? Z.shapeFlag & 512 ? tt.ctx.activate(Z, j, Q, it, st) : B(Z, j, Q, tt, et, it, st) : N(K, Z, st)
    }
      , B = (K,Z,j,Q,tt,et,it)=>{
        const k = K.component = Df(K, Q, tt);
        if (gn(K) && (k.ctx.renderer = $),
        Gf(k),
        k.asyncDep) {
            if (tt && tt.registerDep(k, Y),
            !K.el) {
                const st = k.subTree = Dt(se);
                v(null, st, Z, j)
            }
            return
        }
        Y(k, K, Z, j, tt, et, it)
    }
      , N = (K,Z,j)=>{
        const Q = Z.component = K.component;
        if (Hu(K, Z, j))
            if (Q.asyncDep && !Q.asyncResolved) {
                z(Q, Z, j);
                return
            } else
                Q.next = Z,
                Uu(Q.update),
                Q.update();
        else
            Z.el = K.el,
            Q.vnode = Z
    }
      , Y = (K,Z,j,Q,tt,et,it)=>{
        const k = ()=>{
            if (K.isMounted) {
                let {next: rt, bu: ot, u: lt, parent: at, vnode: ht} = K, dt = rt, ut;
                Ae(K, !1),
                rt ? (rt.el = ht.el,
                z(K, rt, it)) : rt = ht,
                ot && Hi(ot),
                (ut = rt.props && rt.props.onVnodeBeforeUpdate) && re(ut, at, rt, ht),
                Ae(K, !0);
                const ft = Ln(K)
                  , mt = K.subTree;
                K.subTree = ft,
                u(mt, ft, s(mt.el), H(mt), K, tt, et),
                rt.el = ft.el,
                dt === null && bu(K, ft.el),
                lt && Wt(lt, tt),
                (ut = rt.props && rt.props.onVnodeUpdated) && Wt(()=>re(ut, at, rt, ht), tt)
            } else {
                let rt;
                const {el: ot, props: lt} = Z
                  , {bm: at, m: ht, parent: dt} = K
                  , ut = Zi(Z);
                if (Ae(K, !1),
                at && Hi(at),
                !ut && (rt = lt && lt.onVnodeBeforeMount) && re(rt, dt, Z),
                Ae(K, !0),
                ot && nt) {
                    const ft = ()=>{
                        K.subTree = Ln(K),
                        nt(ot, K.subTree, K, tt, null)
                    }
                    ;
                    ut ? Z.type.__asyncLoader().then(()=>!K.isUnmounted && ft()) : ft()
                } else {
                    const ft = K.subTree = Ln(K);
                    u(null, ft, j, Q, K, tt, et),
                    Z.el = ft.el
                }
                if (ht && Wt(ht, tt),
                !ut && (rt = lt && lt.onVnodeMounted)) {
                    const ft = Z;
                    Wt(()=>re(rt, dt, ft), tt)
                }
                (Z.shapeFlag & 256 || dt && Zi(dt.vnode) && dt.vnode.shapeFlag & 256) && K.a && Wt(K.a, tt),
                K.isMounted = !0,
                Z = j = Q = null
            }
        }
          , st = K.effect = new Ms(k,()=>Gs(q),K.scope)
          , q = K.update = ()=>st.run();
        q.id = K.uid,
        Ae(K, !0),
        q()
    }
      , z = (K,Z,j)=>{
        Z.component = K;
        const Q = K.vnode.props;
        K.vnode = Z,
        K.next = null,
        pf(K, Z.props, Q, j),
        xf(K, Z.children, j),
        ti(),
        fr(),
        ei()
    }
      , W = (K,Z,j,Q,tt,et,it,k,st=!1)=>{
        const q = K && K.children
          , rt = K ? K.shapeFlag : 0
          , ot = Z.children
          , {patchFlag: lt, shapeFlag: at} = Z;
        if (lt > 0) {
            if (lt & 128) {
                D(q, ot, j, Q, tt, et, it, k, st);
                return
            } else if (lt & 256) {
                b(q, ot, j, Q, tt, et, it, k, st);
                return
            }
        }
        at & 8 ? (rt & 16 && V(q, tt, et),
        ot !== q && n(j, ot)) : rt & 16 ? at & 16 ? D(q, ot, j, Q, tt, et, it, k, st) : V(q, tt, et, !0) : (rt & 8 && n(j, ""),
        at & 16 && P(ot, j, Q, tt, et, it, k, st))
    }
      , b = (K,Z,j,Q,tt,et,it,k,st)=>{
        K = K || He,
        Z = Z || He;
        const q = K.length
          , rt = Z.length
          , ot = Math.min(q, rt);
        let lt;
        for (lt = 0; lt < ot; lt++) {
            const at = Z[lt] = st ? xe(Z[lt]) : ae(Z[lt]);
            u(K[lt], at, j, null, tt, et, it, k, st)
        }
        q > rt ? V(K, tt, et, !0, !1, ot) : P(Z, j, Q, tt, et, it, k, st, ot)
    }
      , D = (K,Z,j,Q,tt,et,it,k,st)=>{
        let q = 0;
        const rt = Z.length;
        let ot = K.length - 1
          , lt = rt - 1;
        for (; q <= ot && q <= lt; ) {
            const at = K[q]
              , ht = Z[q] = st ? xe(Z[q]) : ae(Z[q]);
            if (Oe(at, ht))
                u(at, ht, j, null, tt, et, it, k, st);
            else
                break;
            q++
        }
        for (; q <= ot && q <= lt; ) {
            const at = K[ot]
              , ht = Z[lt] = st ? xe(Z[lt]) : ae(Z[lt]);
            if (Oe(at, ht))
                u(at, ht, j, null, tt, et, it, k, st);
            else
                break;
            ot--,
            lt--
        }
        if (q > ot) {
            if (q <= lt) {
                const at = lt + 1
                  , ht = at < rt ? Z[at].el : Q;
                for (; q <= lt; )
                    u(null, Z[q] = st ? xe(Z[q]) : ae(Z[q]), j, ht, tt, et, it, k, st),
                    q++
            }
        } else if (q > lt)
            for (; q <= ot; )
                G(K[q], tt, et, !0),
                q++;
        else {
            const at = q
              , ht = q
              , dt = new Map;
            for (q = ht; q <= lt; q++) {
                const Ct = Z[q] = st ? xe(Z[q]) : ae(Z[q]);
                Ct.key != null && dt.set(Ct.key, q)
            }
            let ut, ft = 0;
            const mt = lt - ht + 1;
            let Gt = !1
              , jt = 0;
            const Yt = new Array(mt);
            for (q = 0; q < mt; q++)
                Yt[q] = 0;
            for (q = at; q <= ot; q++) {
                const Ct = K[q];
                if (ft >= mt) {
                    G(Ct, tt, et, !0);
                    continue
                }
                let Rt;
                if (Ct.key != null)
                    Rt = dt.get(Ct.key);
                else
                    for (ut = ht; ut <= lt; ut++)
                        if (Yt[ut - ht] === 0 && Oe(Ct, Z[ut])) {
                            Rt = ut;
                            break
                        }
                Rt === void 0 ? G(Ct, tt, et, !0) : (Yt[Rt - ht] = q + 1,
                Rt >= jt ? jt = Rt : Gt = !0,
                u(Ct, Z[Rt], j, null, tt, et, it, k, st),
                ft++)
            }
            const $t = Gt ? Cf(Yt) : He;
            for (ut = $t.length - 1,
            q = mt - 1; q >= 0; q--) {
                const Ct = ht + q
                  , Rt = Z[Ct]
                  , Gi = Ct + 1 < rt ? Z[Ct + 1].el : Q;
                Yt[q] === 0 ? u(null, Rt, j, Gi, tt, et, it, k, st) : Gt && (ut < 0 || q !== $t[ut] ? I(Rt, j, Gi, 2) : ut--)
            }
        }
    }
      , I = (K,Z,j,Q,tt=null)=>{
        const {el: et, type: it, transition: k, children: st, shapeFlag: q} = K;
        if (q & 6) {
            I(K.component.subTree, Z, j, Q);
            return
        }
        if (q & 128) {
            K.suspense.move(Z, j, Q);
            return
        }
        if (q & 64) {
            it.move(K, Z, j, $);
            return
        }
        if (it === Lt) {
            S(et, Z, j);
            for (let ot = 0; ot < st.length; ot++)
                I(st[ot], Z, j, Q);
            S(K.anchor, Z, j);
            return
        }
        if (it === In) {
            g(K, Z, j);
            return
        }
        if (Q !== 2 && q & 1 && k)
            if (Q === 0)
                k.beforeEnter(et),
                S(et, Z, j),
                Wt(()=>k.enter(et), tt);
            else {
                const {leave: ot, delayLeave: lt, afterLeave: at} = k
                  , ht = ()=>S(et, Z, j)
                  , dt = ()=>{
                    ot(et, ()=>{
                        ht(),
                        at && at()
                    }
                    )
                }
                ;
                lt ? lt(et, ht, dt) : dt()
            }
        else
            S(et, Z, j)
    }
      , G = (K,Z,j,Q=!1,tt=!1)=>{
        const {type: et, props: it, ref: k, children: st, dynamicChildren: q, shapeFlag: rt, patchFlag: ot, dirs: lt} = K;
        if (k != null && _n(k, null, j, K, !0),
        rt & 256) {
            Z.ctx.deactivate(K);
            return
        }
        const at = rt & 1 && lt
          , ht = !Zi(K);
        let dt;
        if (ht && (dt = it && it.onVnodeBeforeUnmount) && re(dt, Z, K),
        rt & 6)
            X(K.component, j, Q);
        else {
            if (rt & 128) {
                K.suspense.unmount(j, Q);
                return
            }
            at && Pe(K, null, Z, "beforeUnmount"),
            rt & 64 ? K.type.remove(K, Z, j, tt, $, Q) : q && (et !== Lt || ot > 0 && ot & 64) ? V(q, Z, j, !1, !0) : (et === Lt && ot & 384 || !tt && rt & 16) && V(st, Z, j),
            Q && w(K)
        }
        (ht && (dt = it && it.onVnodeUnmounted) || at) && Wt(()=>{
            dt && re(dt, Z, K),
            at && Pe(K, null, Z, "unmounted")
        }
        , j)
    }
      , w = K=>{
        const {type: Z, el: j, anchor: Q, transition: tt} = K;
        if (Z === Lt) {
            U(j, Q);
            return
        }
        if (Z === In) {
            m(K);
            return
        }
        const et = ()=>{
            t(j),
            tt && !tt.persisted && tt.afterLeave && tt.afterLeave()
        }
        ;
        if (K.shapeFlag & 1 && tt && !tt.persisted) {
            const {leave: it, delayLeave: k} = tt
              , st = ()=>it(j, et);
            k ? k(K.el, et, st) : st()
        } else
            et()
    }
      , U = (K,Z)=>{
        let j;
        for (; K !== Z; )
            j = l(K),
            t(K),
            K = j;
        t(Z)
    }
      , X = (K,Z,j)=>{
        const {bum: Q, scope: tt, update: et, subTree: it, um: k} = K;
        Q && Hi(Q),
        tt.stop(),
        et && (et.active = !1,
        G(it, K, Z, j)),
        k && Wt(k, Z),
        Wt(()=>{
            K.isUnmounted = !0
        }
        , Z),
        Z && Z.pendingBranch && !Z.isUnmounted && K.asyncDep && !K.asyncResolved && K.suspenseId === Z.pendingId && (Z.deps--,
        Z.deps === 0 && Z.resolve())
    }
      , V = (K,Z,j,Q=!1,tt=!1,et=0)=>{
        for (let it = et; it < K.length; it++)
            G(K[it], Z, j, Q, tt)
    }
      , H = K=>K.shapeFlag & 6 ? H(K.component.subTree) : K.shapeFlag & 128 ? K.suspense.next() : l(K.anchor || K.el)
      , J = (K,Z,j)=>{
        K == null ? Z._vnode && G(Z._vnode, null, null, !0) : u(Z._vnode || null, K, Z, null, null, null, j),
        fr(),
        ao(),
        Z._vnode = K
    }
      , $ = {
        p: u,
        um: G,
        m: I,
        r: w,
        mt: B,
        mc: P,
        pc: W,
        pbc: L,
        n: H,
        o: C
    };
    let _, nt;
    return A && ([_,nt] = A($)),
    {
        render: J,
        hydrate: _,
        createApp: Tf(J, _)
    }
}
function Ae({effect: C, update: A}, c) {
    C.allowRecurse = A.allowRecurse = c
}
function Co(C, A, c=!1) {
    const S = C.children
      , t = A.children;
    if (vt(S) && vt(t))
        for (let e = 0; e < S.length; e++) {
            const f = S[e];
            let r = t[e];
            r.shapeFlag & 1 && !r.dynamicChildren && ((r.patchFlag <= 0 || r.patchFlag === 32) && (r = t[e] = xe(t[e]),
            r.el = f.el),
            c || Co(f, r)),
            r.type === yn && (r.el = f.el)
        }
}
function Cf(C) {
    const A = C.slice()
      , c = [0];
    let S, t, e, f, r;
    const o = C.length;
    for (S = 0; S < o; S++) {
        const a = C[S];
        if (a !== 0) {
            if (t = c[c.length - 1],
            C[t] < a) {
                A[S] = t,
                c.push(S);
                continue
            }
            for (e = 0,
            f = c.length - 1; e < f; )
                r = e + f >> 1,
                C[c[r]] < a ? e = r + 1 : f = r;
            a < C[c[e]] && (e > 0 && (A[S] = c[e - 1]),
            c[e] = S)
        }
    }
    for (e = c.length,
    f = c[e - 1]; e-- > 0; )
        c[e] = f,
        f = A[f];
    return c
}
const Pf = C=>C.__isTeleport
  , Lt = Symbol(void 0)
  , yn = Symbol(void 0)
  , se = Symbol(void 0)
  , In = Symbol(void 0)
  , li = [];
let ie = null;
function Pt(C=!1) {
    li.push(ie = C ? null : [])
}
function Af() {
    li.pop(),
    ie = li[li.length - 1] || null
}
let Si = 1;
function Sr(C) {
    Si += C
}
function Po(C) {
    return C.dynamicChildren = Si > 0 ? ie || He : null,
    Af(),
    Si > 0 && ie && ie.push(C),
    C
}
function At(C, A, c, S, t, e) {
    return Po(ct(C, A, c, S, t, e, !0))
}
function Mf(C, A, c, S, t) {
    return Po(Dt(C, A, c, S, t, !0))
}
function Rf(C) {
    return C ? C.__v_isVNode === !0 : !1
}
function Oe(C, A) {
    return C.type === A.type && C.key === A.key
}
const Tn = "__vInternal"
  , Ao = ({key: C})=>C ?? null
  , Ji = ({ref: C, ref_key: A, ref_for: c})=>C != null ? Ft(C) || wt(C) || gt(C) ? {
    i: qt,
    r: C,
    k: A,
    f: !!c
} : C : null;
function ct(C, A=null, c=null, S=0, t=null, e=C === Lt ? 0 : 1, f=!1, r=!1) {
    const o = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: C,
        props: A,
        key: A && Ao(A),
        ref: A && Ji(A),
        scopeId: pn,
        slotScopeIds: null,
        children: c,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: e,
        patchFlag: S,
        dynamicProps: t,
        dynamicChildren: null,
        appContext: null,
        ctx: qt
    };
    return r ? (zs(o, c),
    e & 128 && C.normalize(o)) : c && (o.shapeFlag |= Ft(c) ? 8 : 16),
    Si > 0 && !f && ie && (o.patchFlag > 0 || e & 6) && o.patchFlag !== 32 && ie.push(o),
    o
}
const Dt = Lf;
function Lf(C, A=null, c=null, S=0, t=null, e=!1) {
    if ((!C || C === of) && (C = se),
    Rf(C)) {
        const r = Ee(C, A, !0);
        return c && zs(r, c),
        Si > 0 && !e && ie && (r.shapeFlag & 6 ? ie[ie.indexOf(C)] = r : ie.push(r)),
        r.patchFlag |= -2,
        r
    }
    if (Yf(C) && (C = C.__vccOpts),
    A) {
        A = Of(A);
        let {class: r, style: o} = A;
        r && !Ft(r) && (A.class = Ss(r)),
        St(o) && (qa(o) && !vt(o) && (o = Bt({}, o)),
        A.style = on(o))
    }
    const f = Ft(C) ? 1 : Ku(C) ? 128 : Pf(C) ? 64 : St(C) ? 4 : gt(C) ? 2 : 0;
    return ct(C, A, c, S, t, f, e, !0)
}
function Of(C) {
    return C ? qa(C) || Tn in C ? Bt({}, C) : C : null
}
function Ee(C, A, c=!1) {
    const {props: S, ref: t, patchFlag: e, children: f} = C
      , r = A ? Ff(S || {}, A) : S;
    return {
        __v_isVNode: !0,
        __v_skip: !0,
        type: C.type,
        props: r,
        key: r && Ao(r),
        ref: A && A.ref ? c && t ? vt(t) ? t.concat(Ji(A)) : [t, Ji(A)] : Ji(A) : t,
        scopeId: C.scopeId,
        slotScopeIds: C.slotScopeIds,
        children: f,
        target: C.target,
        targetAnchor: C.targetAnchor,
        staticCount: C.staticCount,
        shapeFlag: C.shapeFlag,
        patchFlag: A && C.type !== Lt ? e === -1 ? 16 : e | 16 : e,
        dynamicProps: C.dynamicProps,
        dynamicChildren: C.dynamicChildren,
        appContext: C.appContext,
        dirs: C.dirs,
        transition: C.transition,
        component: C.component,
        suspense: C.suspense,
        ssContent: C.ssContent && Ee(C.ssContent),
        ssFallback: C.ssFallback && Ee(C.ssFallback),
        el: C.el,
        anchor: C.anchor,
        ctx: C.ctx,
        ce: C.ce
    }
}
function ts(C=" ", A=0) {
    return Dt(yn, null, C, A)
}
function Ne(C="", A=!1) {
    return A ? (Pt(),
    Mf(se, null, C)) : Dt(se, null, C)
}
function ae(C) {
    return C == null || typeof C == "boolean" ? Dt(se) : vt(C) ? Dt(Lt, null, C.slice()) : typeof C == "object" ? xe(C) : Dt(yn, null, String(C))
}
function xe(C) {
    return C.el === null && C.patchFlag !== -1 || C.memo ? C : Ee(C)
}
function zs(C, A) {
    let c = 0;
    const {shapeFlag: S} = C;
    if (A == null)
        A = null;
    else if (vt(A))
        c = 16;
    else if (typeof A == "object")
        if (S & 65) {
            const t = A.default;
            t && (t._c && (t._d = !1),
            zs(C, t()),
            t._c && (t._d = !0));
            return
        } else {
            c = 32;
            const t = A._;
            !t && !(Tn in A) ? A._ctx = qt : t === 3 && qt && (qt.slots._ === 1 ? A._ = 1 : (A._ = 2,
            C.patchFlag |= 1024))
        }
    else
        gt(A) ? (A = {
            default: A,
            _ctx: qt
        },
        c = 32) : (A = String(A),
        S & 64 ? (c = 16,
        A = [ts(A)]) : c = 8);
    C.children = A,
    C.shapeFlag |= c
}
function Ff(...C) {
    const A = {};
    for (let c = 0; c < C.length; c++) {
        const S = C[c];
        for (const t in S)
            if (t === "class")
                A.class !== S.class && (A.class = Ss([A.class, S.class]));
            else if (t === "style")
                A.style = on([A.style, S.style]);
            else if (ln(t)) {
                const e = A[t]
                  , f = S[t];
                f && e !== f && !(vt(e) && e.includes(f)) && (A[t] = e ? [].concat(e, f) : f)
            } else
                t !== "" && (A[t] = S[t])
    }
    return A
}
function re(C, A, c, S=null) {
    _t(C, A, 7, [c, S])
}
const If = Eo();
let Bf = 0;
function Df(C, A, c) {
    const S = C.type
      , t = (A ? A.appContext : C.appContext) || If
      , e = {
        uid: Bf++,
        vnode: C,
        type: S,
        parent: A,
        appContext: t,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        scope: new _l(!0),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: A ? A.provides : Object.create(t.provides),
        accessCache: null,
        renderCache: [],
        components: null,
        directives: null,
        propsOptions: xo(S, t),
        emitsOptions: ho(S, t),
        emit: null,
        emitted: null,
        propsDefaults: Et,
        inheritAttrs: S.inheritAttrs,
        ctx: Et,
        data: Et,
        props: Et,
        attrs: Et,
        slots: Et,
        refs: Et,
        setupState: Et,
        setupContext: null,
        suspense: c,
        suspenseId: c ? c.pendingId : 0,
        asyncDep: null,
        asyncResolved: !1,
        isMounted: !1,
        isUnmounted: !1,
        isDeactivated: !1,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    return e.ctx = {
        _: e
    },
    e.root = A ? A.root : e,
    e.emit = zu.bind(null, e),
    C.ce && C.ce(e),
    e
}
let Ot = null;
const Mo = ()=>Ot || qt
  , ke = C=>{
    Ot = C,
    C.scope.on()
}
  , we = ()=>{
    Ot && Ot.scope.off(),
    Ot = null
}
;
function Ro(C) {
    return C.vnode.shapeFlag & 4
}
let Ei = !1;
function Gf(C, A=!1) {
    Ei = A;
    const {props: c, children: S} = C.vnode
      , t = Ro(C);
    cf(C, c, t, A),
    mf(C, S);
    const e = t ? Nf(C, A) : void 0;
    return Ei = !1,
    e
}
function Nf(C, A) {
    const c = C.type;
    C.accessCache = Object.create(null),
    C.proxy = _a(new Proxy(C.ctx,hf));
    const {setup: S} = c;
    if (S) {
        const t = C.setupContext = S.length > 1 ? Uf(C) : null;
        ke(C),
        ti();
        const e = Te(S, C, 0, [C.props, t]);
        if (ei(),
        we(),
        Ua(e)) {
            if (e.then(we, we),
            A)
                return e.then(f=>{
                    Er(C, f, A)
                }
                ).catch(f=>{
                    vn(f, C, 0)
                }
                );
            C.asyncDep = e
        } else
            Er(C, e, A)
    } else
        Lo(C, A)
}
function Er(C, A, c) {
    gt(A) ? C.type.__ssrInlineRender ? C.ssrRender = A : C.render = A : St(A) && (C.setupState = io(A)),
    Lo(C, c)
}
let Cr;
function Lo(C, A, c) {
    const S = C.type;
    if (!C.render) {
        if (!A && Cr && !S.render) {
            const t = S.template || Ys(C).template;
            if (t) {
                const {isCustomElement: e, compilerOptions: f} = C.appContext.config
                  , {delimiters: r, compilerOptions: o} = S
                  , a = Bt(Bt({
                    isCustomElement: e,
                    delimiters: r
                }, f), o);
                S.render = Cr(t, a)
            }
        }
        C.render = S.render || ne
    }
    ke(C),
    ti(),
    lf(C),
    ei(),
    we()
}
function wf(C) {
    return new Proxy(C.attrs,{
        get(A, c) {
            return Kt(C, "get", "$attrs"),
            A[c]
        }
    })
}
function Uf(C) {
    const A = S=>{
        C.exposed = S || {}
    }
    ;
    let c;
    return {
        get attrs() {
            return c || (c = wf(C))
        },
        slots: C.slots,
        emit: C.emit,
        expose: A
    }
}
function Sn(C) {
    if (C.exposed)
        return C.exposeProxy || (C.exposeProxy = new Proxy(io(_a(C.exposed)),{
            get(A, c) {
                if (c in A)
                    return A[c];
                if (c in hi)
                    return hi[c](C)
            },
            has(A, c) {
                return c in A || c in hi
            }
        }))
}
function Yf(C) {
    return gt(C) && "__vccOpts"in C
}
const Ci = (C,A)=>Du(C, A, Ei)
  , Xf = Symbol("")
  , zf = ()=>bi(Xf)
  , Vf = "3.2.47"
  , Wf = "http://www.w3.org/2000/svg"
  , Fe = typeof document < "u" ? document : null
  , Pr = Fe && Fe.createElement("template")
  , Hf = {
    insert: (C,A,c)=>{
        A.insertBefore(C, c || null)
    }
    ,
    remove: C=>{
        const A = C.parentNode;
        A && A.removeChild(C)
    }
    ,
    createElement: (C,A,c,S)=>{
        const t = A ? Fe.createElementNS(Wf, C) : Fe.createElement(C, c ? {
            is: c
        } : void 0);
        return C === "select" && S && S.multiple != null && t.setAttribute("multiple", S.multiple),
        t
    }
    ,
    createText: C=>Fe.createTextNode(C),
    createComment: C=>Fe.createComment(C),
    setText: (C,A)=>{
        C.nodeValue = A
    }
    ,
    setElementText: (C,A)=>{
        C.textContent = A
    }
    ,
    parentNode: C=>C.parentNode,
    nextSibling: C=>C.nextSibling,
    querySelector: C=>Fe.querySelector(C),
    setScopeId(C, A) {
        C.setAttribute(A, "")
    },
    insertStaticContent(C, A, c, S, t, e) {
        const f = c ? c.previousSibling : A.lastChild;
        if (t && (t === e || t.nextSibling))
            for (; A.insertBefore(t.cloneNode(!0), c),
            !(t === e || !(t = t.nextSibling)); )
                ;
        else {
            Pr.innerHTML = S ? `<svg>${C}</svg>` : C;
            const r = Pr.content;
            if (S) {
                const o = r.firstChild;
                for (; o.firstChild; )
                    r.appendChild(o.firstChild);
                r.removeChild(o)
            }
            A.insertBefore(r, c)
        }
        return [f ? f.nextSibling : A.firstChild, c ? c.previousSibling : A.lastChild]
    }
};
function bf(C, A, c) {
    const S = C._vtc;
    S && (A = (A ? [A, ...S] : [...S]).join(" ")),
    A == null ? C.removeAttribute("class") : c ? C.setAttribute("class", A) : C.className = A
}
function Kf(C, A, c) {
    const S = C.style
      , t = Ft(c);
    if (c && !t) {
        if (A && !Ft(A))
            for (const e in A)
                c[e] == null && es(S, e, "");
        for (const e in c)
            es(S, e, c[e])
    } else {
        const e = S.display;
        t ? A !== c && (S.cssText = c) : A && C.removeAttribute("style"),
        "_vod"in C && (S.display = e)
    }
}
const Ar = /\s*!important$/;
function es(C, A, c) {
    if (vt(c))
        c.forEach(S=>es(C, A, S));
    else if (c == null && (c = ""),
    A.startsWith("--"))
        C.setProperty(A, c);
    else {
        const S = Zf(C, A);
        Ar.test(c) ? C.setProperty(Ve(S), c.replace(Ar, ""), "important") : C[S] = c
    }
}
const Mr = ["Webkit", "Moz", "ms"]
  , Bn = {};
function Zf(C, A) {
    const c = Bn[A];
    if (c)
        return c;
    let S = $e(A);
    if (S !== "filter" && S in C)
        return Bn[A] = S;
    S = za(S);
    for (let t = 0; t < Mr.length; t++) {
        const e = Mr[t] + S;
        if (e in C)
            return Bn[A] = e
    }
    return A
}
const Rr = "http://www.w3.org/1999/xlink";
function Jf(C, A, c, S, t) {
    if (S && A.startsWith("xlink:"))
        c == null ? C.removeAttributeNS(Rr, A.slice(6, A.length)) : C.setAttributeNS(Rr, A, c);
    else {
        const e = Wl(A);
        c == null || e && !Na(c) ? C.removeAttribute(A) : C.setAttribute(A, e ? "" : c)
    }
}
function jf(C, A, c, S, t, e, f) {
    if (A === "innerHTML" || A === "textContent") {
        S && f(S, t, e),
        C[A] = c ?? "";
        return
    }
    if (A === "value" && C.tagName !== "PROGRESS" && !C.tagName.includes("-")) {
        C._value = c;
        const o = c ?? "";
        (C.value !== o || C.tagName === "OPTION") && (C.value = o),
        c == null && C.removeAttribute(A);
        return
    }
    let r = !1;
    if (c === "" || c == null) {
        const o = typeof C[A];
        o === "boolean" ? c = Na(c) : c == null && o === "string" ? (c = "",
        r = !0) : o === "number" && (c = 0,
        r = !0)
    }
    try {
        C[A] = c
    } catch {}
    r && C.removeAttribute(A)
}
function Ie(C, A, c, S) {
    C.addEventListener(A, c, S)
}
function $f(C, A, c, S) {
    C.removeEventListener(A, c, S)
}
function Qf(C, A, c, S, t=null) {
    const e = C._vei || (C._vei = {})
      , f = e[A];
    if (S && f)
        f.value = S;
    else {
        const [r,o] = kf(A);
        if (S) {
            const a = e[A] = td(S, t);
            Ie(C, r, a, o)
        } else
            f && ($f(C, r, f, o),
            e[A] = void 0)
    }
}
const Lr = /(?:Once|Passive|Capture)$/;
function kf(C) {
    let A;
    if (Lr.test(C)) {
        A = {};
        let S;
        for (; S = C.match(Lr); )
            C = C.slice(0, C.length - S[0].length),
            A[S[0].toLowerCase()] = !0
    }
    return [C[2] === ":" ? C.slice(3) : Ve(C.slice(2)), A]
}
let Dn = 0;
const qf = Promise.resolve()
  , _f = ()=>Dn || (qf.then(()=>Dn = 0),
Dn = Date.now());
function td(C, A) {
    const c = S=>{
        if (!S._vts)
            S._vts = Date.now();
        else if (S._vts <= c.attached)
            return;
        _t(ed(S, c.value), A, 5, [S])
    }
    ;
    return c.value = C,
    c.attached = _f(),
    c
}
function ed(C, A) {
    if (vt(A)) {
        const c = C.stopImmediatePropagation;
        return C.stopImmediatePropagation = ()=>{
            c.call(C),
            C._stopped = !0
        }
        ,
        A.map(S=>t=>!t._stopped && S && S(t))
    } else
        return A
}
const Or = /^on[a-z]/
  , id = (C,A,c,S,t=!1,e,f,r,o)=>{
    A === "class" ? bf(C, S, t) : A === "style" ? Kf(C, c, S) : ln(A) ? Es(A) || Qf(C, A, c, S, f) : (A[0] === "." ? (A = A.slice(1),
    !0) : A[0] === "^" ? (A = A.slice(1),
    !1) : nd(C, A, S, t)) ? jf(C, A, S, e, f, r, o) : (A === "true-value" ? C._trueValue = S : A === "false-value" && (C._falseValue = S),
    Jf(C, A, S, t))
}
;
function nd(C, A, c, S) {
    return S ? !!(A === "innerHTML" || A === "textContent" || A in C && Or.test(A) && gt(c)) : A === "spellcheck" || A === "draggable" || A === "translate" || A === "form" || A === "list" && C.tagName === "INPUT" || A === "type" && C.tagName === "TEXTAREA" || Or.test(A) && Ft(c) ? !1 : A in C
}
const ge = "transition"
  , ni = "animation"
  , Oo = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: !0
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
}
  , sd = Bt({}, Qu.props, Oo)
  , Me = (C,A=[])=>{
    vt(C) ? C.forEach(c=>c(...A)) : C && C(...A)
}
  , Fr = C=>C ? vt(C) ? C.some(A=>A.length > 1) : C.length > 1 : !1;
function rd(C) {
    const A = {};
    for (const O in C)
        O in Oo || (A[O] = C[O]);
    if (C.css === !1)
        return A;
    const {name: c="v", type: S, duration: t, enterFromClass: e=`${c}-enter-from`, enterActiveClass: f=`${c}-enter-active`, enterToClass: r=`${c}-enter-to`, appearFromClass: o=e, appearActiveClass: a=f, appearToClass: n=r, leaveFromClass: s=`${c}-leave-from`, leaveActiveClass: l=`${c}-leave-active`, leaveToClass: i=`${c}-leave-to`} = C
      , h = ad(t)
      , u = h && h[0]
      , d = h && h[1]
      , {onBeforeEnter: v, onEnter: p, onEnterCancelled: g, onLeave: m, onLeaveCancelled: x, onBeforeAppear: T=v, onAppear: E=p, onAppearCancelled: P=g} = A
      , M = (O,F,B)=>{
        me(O, F ? n : r),
        me(O, F ? a : f),
        B && B()
    }
      , L = (O,F)=>{
        O._isLeaving = !1,
        me(O, s),
        me(O, i),
        me(O, l),
        F && F()
    }
      , R = O=>(F,B)=>{
        const N = O ? E : p
          , Y = ()=>M(F, O, B);
        Me(N, [F, Y]),
        Ir(()=>{
            me(F, O ? o : e),
            le(F, O ? n : r),
            Fr(N) || Br(F, S, u, Y)
        }
        )
    }
    ;
    return Bt(A, {
        onBeforeEnter(O) {
            Me(v, [O]),
            le(O, e),
            le(O, f)
        },
        onBeforeAppear(O) {
            Me(T, [O]),
            le(O, o),
            le(O, a)
        },
        onEnter: R(!1),
        onAppear: R(!0),
        onLeave(O, F) {
            O._isLeaving = !0;
            const B = ()=>L(O, F);
            le(O, s),
            Io(),
            le(O, l),
            Ir(()=>{
                O._isLeaving && (me(O, s),
                le(O, i),
                Fr(m) || Br(O, S, d, B))
            }
            ),
            Me(m, [O, B])
        },
        onEnterCancelled(O) {
            M(O, !1),
            Me(g, [O])
        },
        onAppearCancelled(O) {
            M(O, !0),
            Me(P, [O])
        },
        onLeaveCancelled(O) {
            L(O),
            Me(x, [O])
        }
    })
}
function ad(C) {
    if (C == null)
        return null;
    if (St(C))
        return [Gn(C.enter), Gn(C.leave)];
    {
        const A = Gn(C);
        return [A, A]
    }
}
function Gn(C) {
    return kl(C)
}
function le(C, A) {
    A.split(/\s+/).forEach(c=>c && C.classList.add(c)),
    (C._vtc || (C._vtc = new Set)).add(A)
}
function me(C, A) {
    A.split(/\s+/).forEach(S=>S && C.classList.remove(S));
    const {_vtc: c} = C;
    c && (c.delete(A),
    c.size || (C._vtc = void 0))
}
function Ir(C) {
    requestAnimationFrame(()=>{
        requestAnimationFrame(C)
    }
    )
}
let od = 0;
function Br(C, A, c, S) {
    const t = C._endId = ++od
      , e = ()=>{
        t === C._endId && S()
    }
    ;
    if (c)
        return setTimeout(e, c);
    const {type: f, timeout: r, propCount: o} = Fo(C, A);
    if (!f)
        return S();
    const a = f + "end";
    let n = 0;
    const s = ()=>{
        C.removeEventListener(a, l),
        e()
    }
      , l = i=>{
        i.target === C && ++n >= o && s()
    }
    ;
    setTimeout(()=>{
        n < o && s()
    }
    , r + 1),
    C.addEventListener(a, l)
}
function Fo(C, A) {
    const c = window.getComputedStyle(C)
      , S = h=>(c[h] || "").split(", ")
      , t = S(`${ge}Delay`)
      , e = S(`${ge}Duration`)
      , f = Dr(t, e)
      , r = S(`${ni}Delay`)
      , o = S(`${ni}Duration`)
      , a = Dr(r, o);
    let n = null
      , s = 0
      , l = 0;
    A === ge ? f > 0 && (n = ge,
    s = f,
    l = e.length) : A === ni ? a > 0 && (n = ni,
    s = a,
    l = o.length) : (s = Math.max(f, a),
    n = s > 0 ? f > a ? ge : ni : null,
    l = n ? n === ge ? e.length : o.length : 0);
    const i = n === ge && /\b(transform|all)(,|$)/.test(S(`${ge}Property`).toString());
    return {
        type: n,
        timeout: s,
        propCount: l,
        hasTransform: i
    }
}
function Dr(C, A) {
    for (; C.length < A.length; )
        C = C.concat(C);
    return Math.max(...A.map((c,S)=>Gr(c) + Gr(C[S])))
}
function Gr(C) {
    return Number(C.slice(0, -1).replace(",", ".")) * 1e3
}
function Io() {
    return document.body.offsetHeight
}
const Bo = new WeakMap
  , Do = new WeakMap
  , Go = {
    name: "TransitionGroup",
    props: Bt({}, sd, {
        tag: String,
        moveClass: String
    }),
    setup(C, {slots: A}) {
        const c = Mo()
          , S = fo();
        let t, e;
        return Us(()=>{
            if (!t.length)
                return;
            const f = C.moveClass || `${C.name || "v"}-move`;
            if (!dd(t[0].el, c.vnode.el, f))
                return;
            t.forEach(ld),
            t.forEach(ud);
            const r = t.filter(fd);
            Io(),
            r.forEach(o=>{
                const a = o.el
                  , n = a.style;
                le(a, f),
                n.transform = n.webkitTransform = n.transitionDuration = "";
                const s = a._moveCb = l=>{
                    l && l.target !== a || (!l || /transform$/.test(l.propertyName)) && (a.removeEventListener("transitionend", s),
                    a._moveCb = null,
                    me(a, f))
                }
                ;
                a.addEventListener("transitionend", s)
            }
            )
        }
        ),
        ()=>{
            const f = yt(C)
              , r = rd(f);
            let o = f.tag || Lt;
            t = e,
            e = A.default ? ws(A.default()) : [];
            for (let a = 0; a < e.length; a++) {
                const n = e[a];
                n.key != null && yi(n, xi(n, r, S, c))
            }
            if (t)
                for (let a = 0; a < t.length; a++) {
                    const n = t[a];
                    yi(n, xi(n, r, S, c)),
                    Bo.set(n, n.el.getBoundingClientRect())
                }
            return Dt(o, null, e)
        }
    }
}
  , hd = C=>delete C.mode;
Go.props;
const No = Go;
function ld(C) {
    const A = C.el;
    A._moveCb && A._moveCb(),
    A._enterCb && A._enterCb()
}
function ud(C) {
    Do.set(C, C.el.getBoundingClientRect())
}
function fd(C) {
    const A = Bo.get(C)
      , c = Do.get(C)
      , S = A.left - c.left
      , t = A.top - c.top;
    if (S || t) {
        const e = C.el.style;
        return e.transform = e.webkitTransform = `translate(${S}px,${t}px)`,
        e.transitionDuration = "0s",
        C
    }
}
function dd(C, A, c) {
    const S = C.cloneNode();
    C._vtc && C._vtc.forEach(f=>{
        f.split(/\s+/).forEach(r=>r && S.classList.remove(r))
    }
    ),
    c.split(/\s+/).forEach(f=>f && S.classList.add(f)),
    S.style.display = "none";
    const t = A.nodeType === 1 ? A : A.parentNode;
    t.appendChild(S);
    const {hasTransform: e} = Fo(S);
    return t.removeChild(S),
    e
}
const nn = C=>{
    const A = C.props["onUpdate:modelValue"] || !1;
    return vt(A) ? c=>Hi(A, c) : A
}
;
function vd(C) {
    C.target.composing = !0
}
function Nr(C) {
    const A = C.target;
    A.composing && (A.composing = !1,
    A.dispatchEvent(new Event("input")))
}
const cd = {
    created(C, {modifiers: {lazy: A, trim: c, number: S}}, t) {
        C._assign = nn(t);
        const e = S || t.props && t.props.type === "number";
        Ie(C, A ? "change" : "input", f=>{
            if (f.target.composing)
                return;
            let r = C.value;
            c && (r = r.trim()),
            e && (r = qi(r)),
            C._assign(r)
        }
        ),
        c && Ie(C, "change", ()=>{
            C.value = C.value.trim()
        }
        ),
        A || (Ie(C, "compositionstart", vd),
        Ie(C, "compositionend", Nr),
        Ie(C, "change", Nr))
    },
    mounted(C, {value: A}) {
        C.value = A ?? ""
    },
    beforeUpdate(C, {value: A, modifiers: {lazy: c, trim: S, number: t}}, e) {
        if (C._assign = nn(e),
        C.composing || document.activeElement === C && C.type !== "range" && (c || S && C.value.trim() === A || (t || C.type === "number") && qi(C.value) === A))
            return;
        const f = A ?? "";
        C.value !== f && (C.value = f)
    }
}
  , pd = {
    deep: !0,
    created(C, {value: A, modifiers: {number: c}}, S) {
        const t = un(A);
        Ie(C, "change", ()=>{
            const e = Array.prototype.filter.call(C.options, f=>f.selected).map(f=>c ? qi(sn(f)) : sn(f));
            C._assign(C.multiple ? t ? new Set(e) : e : e[0])
        }
        ),
        C._assign = nn(S)
    },
    mounted(C, {value: A}) {
        wr(C, A)
    },
    beforeUpdate(C, A, c) {
        C._assign = nn(c)
    },
    updated(C, {value: A}) {
        wr(C, A)
    }
};
function wr(C, A) {
    const c = C.multiple;
    if (!(c && !vt(A) && !un(A))) {
        for (let S = 0, t = C.options.length; S < t; S++) {
            const e = C.options[S]
              , f = sn(e);
            if (c)
                vt(A) ? e.selected = bl(A, f) > -1 : e.selected = A.has(f);
            else if (hn(sn(e), A)) {
                C.selectedIndex !== S && (C.selectedIndex = S);
                return
            }
        }
        !c && C.selectedIndex !== -1 && (C.selectedIndex = -1)
    }
}
function sn(C) {
    return "_value"in C ? C._value : C.value
}
const gd = ["ctrl", "shift", "alt", "meta"]
  , md = {
    stop: C=>C.stopPropagation(),
    prevent: C=>C.preventDefault(),
    self: C=>C.target !== C.currentTarget,
    ctrl: C=>!C.ctrlKey,
    shift: C=>!C.shiftKey,
    alt: C=>!C.altKey,
    meta: C=>!C.metaKey,
    left: C=>"button"in C && C.button !== 0,
    middle: C=>"button"in C && C.button !== 1,
    right: C=>"button"in C && C.button !== 2,
    exact: (C,A)=>gd.some(c=>C[`${c}Key`] && !A.includes(c))
}
  , xd = (C,A)=>(c,...S)=>{
    for (let t = 0; t < A.length; t++) {
        const e = md[A[t]];
        if (e && e(c, A))
            return
    }
    return C(c, ...S)
}
  , yd = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
}
  , Td = (C,A)=>c=>{
    if (!("key"in c))
        return;
    const S = Ve(c.key);
    if (A.some(t=>t === S || yd[t] === S))
        return C(c)
}
  , Sd = Bt({
    patchProp: id
}, Hf);
let Ur;
function Ed() {
    return Ur || (Ur = Sf(Sd))
}
const Cd = (...C)=>{
    const A = Ed().createApp(...C)
      , {mount: c} = A;
    return A.mount = S=>{
        const t = Pd(S);
        if (!t)
            return;
        const e = A._component;
        !gt(e) && !e.render && !e.template && (e.template = t.innerHTML),
        t.innerHTML = "";
        const f = c(t, !1, t instanceof SVGElement);
        return t instanceof Element && (t.removeAttribute("v-cloak"),
        t.setAttribute("data-v-app", "")),
        f
    }
    ,
    A
}
;
function Pd(C) {
    return Ft(C) ? document.querySelector(C) : C
}
function Ad(C) {
    const A = C.split("::")
      , c = A.at(-2)
      , S = A.at(-1);
    return {
        type: c,
        name: S
    }
}
function Md(C) {
    switch (C) {
    case "Weapon":
        return "🗡️";
    case "Armor":
        return "🛡️";
    case "Item":
        return "📦";
    default:
        return "❓"
    }
}
function is(C) {
    const {type: A, name: c} = Ad(C.identifier);
    let S = "";
    switch (c) {
    case "sunshine_shield":
        S = "🌞";
        break;
    case "magic_cloak":
        S = "🧙‍♂️";
        break;
    case "heroin_pants":
        S = "👖";
        break;
    case "broken_cloth":
        S = "🧵";
        break;
    case "iron_chestplate":
        S = "🦺";
        break;
    case "weed_bo":
        S = "🌿";
        break;
    case "nyancat":
        S = "🐱";
        break;
    case "chi_chi":
        S = "🐥";
        break;
    case "ice_bucket_challenge":
        S = "🧊";
        break;
    case "half_moon_sword":
        S = "🌙";
        break;
    case "dagger":
        S = "🗡️";
        break;
    case "ninja_shuriken":
        S = "🥋";
        break;
    case "loic":
        S = "🔥";
        break;
    case "world_ender":
        S = "🌎";
        break;
    case "strength_potion":
        S = "💪";
        break;
    case "recovery_potion":
        S = "🧪";
        break;
    case "dynamite":
        S = "💣";
        break;
    case "grow_potion":
        S = "🧬";
        break
    }
    return S += c,
    `${Md(A)} ${S}`
}
const Rd = C=>(Oi("data-v-88fee120"),
C = C(),
Fi(),
C)
  , Ld = {
    key: 0,
    class: "inventory"
}
  , Od = Rd(()=>ct("h2", {
    class: "inventory-header"
}, "Inventory", -1))
  , Fd = {
    class: "inventory-item"
}
  , Id = {
    style: {
        flex: "1",
        "text-align": "center",
        "padding-left": "64px"
    }
}
  , Bd = ["onClick"]
  , Dd = {
    key: 0,
    class: "inventory-item-description"
}
  , Gd = ["innerHTML"]
  , Nd = ii({
    __name: "Inventory",
    props: {
        show: {
            type: Boolean
        },
        items: null,
        send: null
    },
    setup(C) {
        const A = C;
        function c(t) {
            A.send({
                type: "use",
                data: {
                    uuid: t.uuid
                }
            })
        }
        const S = zt(null);
        return Us(()=>{
            S.value && (S.value.scrollTop = -S.value.scrollHeight)
        }
        ),
        (t,e)=>A.show ? (Pt(),
        At("div", Ld, [Od, ct("div", {
            class: "inventory-items",
            ref_key: "items",
            ref: S
        }, [(Pt(!0),
        At(Lt, null, Ti(A.items, f=>(Pt(),
        At(Lt, {
            key: f.uuid
        }, [ct("div", Fd, [ct("p", Id, Mt(he(is)(f)), 1), ct("button", {
            onClick: r=>c(f)
        }, "Use", 8, Bd)]), f.description ? (Pt(),
        At("p", Dd, [ts(" [" + Mt(f.identifier.split("::").at(-2)) + "] ", 1), ct("span", {
            innerHTML: f.description
        }, null, 8, Gd)])) : Ne("", !0)], 64))), 128)), A.items.length === 0 ? (Pt(),
        At(Lt, {
            key: 0
        }, [ts(" (Nothing Here...) ")], 64)) : Ne("", !0)], 512)])) : Ne("", !0)
    }
});
const Bi = (C,A)=>{
    const c = C.__vccOpts || C;
    for (const [S,t] of A)
        c[S] = t;
    return c
}
  , wd = Bi(Nd, [["__scopeId", "data-v-88fee120"]])
  , Ud = C=>(Oi("data-v-537685fe"),
C = C(),
Fi(),
C)
  , Yd = {
    class: "scoreboard"
}
  , Xd = Ud(()=>ct("h2", {
    class: "header"
}, "Scoreboard", -1))
  , zd = {
    class: "text"
}
  , Vd = {
    class: "time"
}
  , Wd = {
    class: "list"
}
  , Hd = {
    class: "rank"
}
  , bd = {
    class: "name"
}
  , Kd = {
    class: "score"
}
  , Zd = ii({
    __name: "Scoreboard",
    props: {
        scores: null,
        round: null,
        playerMap: null
    },
    setup(C) {
        const A = C
          , c = Ci(()=>{
            switch (A.round.status) {
            case We.PREINIT:
                return "Waiting for init...";
            case We.INIT:
                return `Round ${A.round.id} initializing...`;
            case We.RUNNING:
                return `Round ${A.round.id} running!`;
            case We.END:
                return `Round ${A.round.id} ended.`;
            default:
                return "Unknown round status"
            }
        }
        )
          , S = zt(0);
        function t() {
            S.value = Math.max(0, Math.floor((new Date(A.round.end).getTime() - Date.now()) / 1e3))
        }
        Ki(A.round, t);
        let e;
        Ii(()=>{
            e = setInterval(t, 1e3)
        }
        ),
        xn(()=>{
            clearInterval(e)
        }
        );
        const f = Ci(()=>{
            switch (A.round.status) {
            case We.END:
                return 0;
            case We.RUNNING:
                return S.value;
            default:
                return "--"
            }
        }
        );
        return (r,o)=>(Pt(),
        At("div", Yd, [Xd, ct("h3", zd, Mt(he(c)), 1), ct("p", Vd, Mt(he(f)) + "s left", 1), ct("div", Wd, [Dt(No, {
            name: "scoreboard"
        }, {
            default: Ns(()=>[(Pt(!0),
            At(Lt, null, Ti(A.scores, (a,n)=>(Pt(),
            At(Lt, {
                key: a.identifier
            }, [ct("span", Hd, Mt(n + 1), 1), ct("span", bd, Mt(A.playerMap.get(a.identifier) ?? "Unknown"), 1), ct("span", Kd, Mt(a.score), 1)], 64))), 128))]),
            _: 1
        })])]))
    }
});
const Jd = Bi(Zd, [["__scopeId", "data-v-537685fe"]])
  , wo = C=>(Oi("data-v-b7527117"),
C = C(),
Fi(),
C)
  , jd = {
    class: "chatroom"
}
  , $d = {
    class: "message__user"
}
  , Qd = ["innerHTML"]
  , kd = {
    key: 1,
    class: "message__text"
}
  , qd = {
    class: "message__timestamp"
}
  , _d = {
    key: 0,
    class: "message"
}
  , tv = wo(()=>ct("div", {
    class: "message__text"
}, "No messages yet", -1))
  , ev = [tv]
  , iv = {
    class: "input-group"
}
  , nv = wo(()=>ct("option", {
    value: "(all)"
}, "All", -1))
  , sv = ["value"]
  , rv = ["onKeyup"]
  , av = ii({
    __name: "Chatroom",
    props: {
        send: null,
        playerMap: null,
        messages: null
    },
    setup(C) {
        const A = C
          , c = Ci(()=>Array.from(A.playerMap.entries(), ([n,s])=>({
            identifier: n,
            name: s
        })))
          , S = zt("")
          , t = zt("(all)")
          , e = ()=>{
            const n = {
                timestamp: Date.now(),
                from: window.me,
                to: t.value,
                message: S.value
            };
            S.value.length > 0 && (A.send({
                type: "chat",
                data: n
            }),
            S.value = "",
            n.to !== "(all)" && n.to !== window.me && A.messages.push(n))
        }
          , f = zt();
        Ii(()=>{
            var n;
            (n = f.value) == null || n.addEventListener("DOMNodeInserted", s=>{
                const {currentTarget: l} = s;
                l instanceof HTMLElement && l.scroll({
                    top: l.scrollHeight,
                    behavior: "smooth"
                })
            }
            )
        }
        );
        const r = n=>{
            n = String(n);
            const s = new Map([["&", "&amp;"], ["<", "&lt;"], [">", "&gt;"]])
              , l = u=>u.replace(/[&<>]/g, d=>s.get(d) || d)
              , i = [{
                regex: /\[b\](.*?)\[\/b\]/g,
                replace: "<b>$1</b>"
            }, {
                regex: /\[i\](.*?)\[\/i\]/g,
                replace: "<i>$1</i>"
            }, {
                regex: /\[u\](.*?)\[\/u\]/g,
                replace: "<u>$1</u>"
            }, {
                regex: /\[s\](.*?)\[\/s\]/g,
                replace: "<s>$1</s>"
            }, {
                regex: /\[color=(.*?)\](.*?)\[\/color\]/g,
                replace: '<span style="color: $1">$2</span>'
            }, {
                regex: /\[br\]/g,
                replace: "<br />"
            }];
            let h = l(n);
            for (const {regex: u, replace: d} of i)
                h = h.replace(u, d);
            return h
        }
        ;
        function o(n) {
            return A.playerMap.get(n)
        }
        function a(n) {
            if (n.from === "(server)" || n.from === "(all)")
                return n.from;
            const s = o(n.from);
            if (n.to === "(all)")
                return `${s} 📢`;
            if (n.to === "(server)")
                return `${s}`;
            const l = o(n.to);
            return `${s} → ${l}`
        }
        return (n,s)=>(Pt(),
        At("div", jd, [ct("div", {
            class: "list",
            ref_key: "list",
            ref: f
        }, [Dt(No, {
            name: "chatroom"
        }, {
            default: Ns(()=>[(Pt(!0),
            At(Lt, null, Ti(C.messages, l=>(Pt(),
            At("div", {
                class: "message",
                key: `${l.timestamp} ${l.from}`
            }, [ct("div", $d, [ct("span", null, Mt(a(l)) + ":", 1)]), l.advanced ? (Pt(),
            At("div", {
                key: 0,
                class: "message__text",
                innerHTML: r(l.message)
            }, null, 8, Qd)) : (Pt(),
            At("div", kd, Mt(l.message), 1)), ct("div", qd, Mt(new Date(l.timestamp || 0).toLocaleTimeString("en-US", {
                hour12: !1
            })), 1)]))), 128)), C.messages.length === 0 ? (Pt(),
            At("div", _d, ev)) : Ne("", !0)]),
            _: 1
        })], 512), ct("div", iv, [cr(ct("select", {
            "onUpdate:modelValue": s[0] || (s[0] = l=>t.value = l)
        }, [nv, (Pt(!0),
        At(Lt, null, Ti(he(c), ({identifier: l, name: i})=>(Pt(),
        At("option", {
            value: l,
            key: l
        }, Mt(i), 9, sv))), 128))], 512), [[pd, t.value]]), cr(ct("input", {
            type: "text",
            "onUpdate:modelValue": s[1] || (s[1] = l=>S.value = l),
            onKeyup: Td(e, ["enter"]),
            onKeydown: s[2] || (s[2] = xd(()=>{}
            , ["stop"]))
        }, null, 40, rv), [[cd, S.value]])])]))
    }
});
const ov = Bi(av, [["__scopeId", "data-v-b7527117"]])
  , Di = C=>(Oi("data-v-6a094148"),
C = C(),
Fi(),
C)
  , hv = {
    key: 0,
    class: "profile"
}
  , lv = {
    class: "name"
}
  , uv = {
    class: "health"
}
  , fv = Di(()=>ct("span", {
    class: "label"
}, "Health", -1))
  , dv = {
    class: "bar"
}
  , vv = {
    class: "value"
}
  , cv = {
    class: "stats"
}
  , pv = {
    class: "stat"
}
  , gv = Di(()=>ct("span", {
    class: "label"
}, "Attack", -1))
  , mv = {
    class: "value"
}
  , xv = {
    class: "stat"
}
  , yv = Di(()=>ct("span", {
    class: "label"
}, "Defense", -1))
  , Tv = {
    class: "value"
}
  , Sv = {
    class: "stat"
}
  , Ev = Di(()=>ct("span", {
    class: "label"
}, "Weapon", -1))
  , Cv = {
    class: "value"
}
  , Pv = {
    class: "stat"
}
  , Av = Di(()=>ct("span", {
    class: "label"
}, "Armor", -1))
  , Mv = {
    class: "value"
}
  , Rv = ii({
    __name: "Profile",
    props: {
        currentPlayer: null
    },
    setup(C) {
        const A = C;
        return (c,S)=>A.currentPlayer ? (Pt(),
        At("div", hv, [ct("div", lv, Mt(A.currentPlayer.name), 1), ct("div", uv, [fv, ct("div", dv, [ct("div", {
            class: "bar-fill",
            style: on({
                width: `${A.currentPlayer.hp / A.currentPlayer.max_hp * 100}%`
            })
        }, null, 4), ct("span", vv, Mt(A.currentPlayer.hp) + " / " + Mt(A.currentPlayer.max_hp), 1)])]), ct("div", cv, [ct("div", pv, [gv, ct("span", mv, Mt(A.currentPlayer.atk), 1)]), ct("div", xv, [yv, ct("span", Tv, Mt(A.currentPlayer.def), 1)]), ct("div", Sv, [Ev, ct("span", Cv, Mt(he(is)(A.currentPlayer.current_weapon)), 1)]), ct("div", Pv, [Av, ct("span", Mv, Mt(he(is)(A.currentPlayer.current_armor)), 1)])])])) : Ne("", !0)
    }
});
const Lv = Bi(Rv, [["__scopeId", "data-v-6a094148"]])
  , Ov = C=>(Oi("data-v-e1dec899"),
C = C(),
Fi(),
C)
  , Fv = {
    class: "deathview"
}
  , Iv = {
    class: "attacker"
}
  , Bv = Ov(()=>ct("div", {
    class: "text"
}, "🔪", -1))
  , Dv = {
    class: "victim"
}
  , Gv = {
    class: "time"
}
  , Nv = ii({
    __name: "Deathview",
    props: {
        playerMap: null,
        deathPlayerMap: null
    },
    setup(C) {
        const A = C;
        function c(t) {
            return A.playerMap.get(t) ?? "??"
        }
        const S = Ci(()=>Array.from(A.deathPlayerMap.values()));
        return (t,e)=>(Pt(),
        At("div", Fv, [(Pt(!0),
        At(Lt, null, Ti(he(S), f=>(Pt(),
        At(Lt, {
            key: f.victim_identifier
        }, [ct("div", Iv, Mt(c(f.attacker_identifier)), 1), Bv, ct("div", Dv, Mt(c(f.victim_identifier)), 1), ct("div", Gv, "(" + Mt(f.respawn_time) + "s)", 1)], 64))), 128))]))
    }
});
const wv = Bi(Nv, [["__scopeId", "data-v-e1dec899"]])
  , Uv = {
    key: 0,
    class: "container"
}
  , Yv = {
    key: 0,
    class: "achievement"
}
  , Xv = ["src"]
  , zv = ii({
    __name: "App",
    props: {
        dom: null
    },
    setup(C) {
        const A = C
          , c = zt(!1)
          , S = zt(Vo)
          , t = zt(!1)
          , e = zt([])
          , f = zt(zo)
          , r = zt([])
          , o = zt(new Map)
          , a = zt(new Map)
          , n = zt({});
        var s = zt(!1);
        function l(h) {
            if (h instanceof CustomEvent && h.detail) {
                const u = h.detail;
                switch (u.type) {
                case "init":
                    c.value = !0,
                    S.value = u.data.player.identifier,
                    f.value = u.data.round,
                    u.data.players.forEach(d=>{
                        o.value.set(d.identifier, d.name)
                    }
                    ),
                    n.value = u.data.player;
                    break;
                case "interact_map":
                case "use":
                    u.data.player.identifier === S.value && (n.value.inventory = u.data.player.inventory,
                    n.value = u.data.player);
                    break;
                case "damage":
                    u.data.player.identifier === S.value && (n.value.hp -= u.data.damage);
                    break;
                case "join":
                    o.value.set(u.data.player.identifier, u.data.player.name);
                    break;
                case "leave":
                    o.value.delete(u.data.identifier);
                    break;
                case "tick":
                    e.value = u.data.scores,
                    a.value.forEach(d=>{
                        d.respawn_time -= 1
                    }
                    );
                    break;
                case "round":
                    f.value = u.data;
                    break;
                case "chat":
                    r.value.push(u.data);
                    break;
                case "respawn":
                    u.data.player.identifier === S.value && (n.value = u.data.player),
                    a.value.delete(u.data.player.identifier);
                    break;
                case "death":
                    a.value.set(u.data.victim_identifier, u.data);
                    break;
                case "achievement":
                    console.log("achievement", u),
                    s = u.data.achievement.type,
                    setTimeout(()=>s = "", 1e4);
                    break
                }
            }
            if (h instanceof KeyboardEvent && !h.repeat && c.value)
                switch (h.key.toLowerCase()) {
                case "i":
                    t.value = !t.value;
                    break;
                case "escape":
                    t.value = !1;
                    break
                }
        }
        function i(h) {
            A.dom.dispatchEvent(new CustomEvent("send",{
                detail: h
            }))
        }
        return Ii(()=>{
            A.dom.addEventListener("event", l),
            document.addEventListener("keydown", l)
        }
        ),
        xn(()=>{
            A.dom.removeEventListener("event", l),
            document.removeEventListener("keydown", l)
        }
        ),
        (h,u)=>c.value ? (Pt(),
        At("div", Uv, [he(s) ? (Pt(),
        At("div", Yv, [ct("img", {
            src: `assets/images/${he(s)}.png`
        }, null, 8, Xv)])) : Ne("", !0), Dt(Lv, {
            currentPlayer: n.value
        }, null, 8, ["currentPlayer"]), Dt(Jd, {
            scores: e.value,
            round: f.value,
            playerMap: o.value
        }, null, 8, ["scores", "round", "playerMap"]), Dt(wv, {
            playerMap: o.value,
            deathPlayerMap: a.value
        }, null, 8, ["playerMap", "deathPlayerMap"]), Dt(ov, {
            playerMap: o.value,
            messages: r.value,
            send: i
        }, null, 8, ["playerMap", "messages"]), Dt(wd, {
            show: t.value,
            items: n.value.inventory,
            send: i
        }, null, 8, ["show", "items"])])) : Ne("", !0)
    }
});
function Vv(C) {
    Cd(zv, {
        dom: C
    }).mount("#app")
}
const Uo = document.getElementById("game");
wl(location.origin.replace("http", "ws") + "/ws", Uo);
Vv(Uo);
