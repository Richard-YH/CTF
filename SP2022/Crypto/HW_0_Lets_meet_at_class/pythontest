from Crypto.Util.number import bytes_to_long, getPrime, long_to_bytes
import random
import math
import os
from sympy import mod_inverse, isprime, factorint 

p = 92017932396773207330365205210913184771249549355771692523246399384571269833668487945963934319507538171501041280674304304879328757539798699280378034748542218248740777575679398093116579809607067129824965250071416089841516538588253944223235904445546895574651603636188746948921937704060334290364304972412697492577
enc = 87051682992840829567429886737255563980229964191963649650455667117285375334750716083826527488071966389632402954644144719710970265754062176648776448421065665281172133368294041777397049228273163978348132440822019295870429065335674151133125629968366491582233750452365390672536361224322642295053741696809519283644
hint = 112112804524582393858675176460595338484428048338611753655869733059768929120327158352572131172253127933611583356499525126040647290513660017529498493355846656594143774393256151536590212031416153303085867445488047592792290033548349001067687775149867134619114482370143917491889371548968347491490942978508386339813

keys = [pow(random.randint(1000 * i + 2, 1000 * (i+1) ), 65537, p) for i in range(5)]
keys[0] = pow( 591 , 65537, p)
keys[1] = pow( 1516 , 65537, p)
keys[2] = pow( 2849 , 65537, p)
keys[3] = pow( 3451 , 65537, p)
keys[4] = pow( 4668 , 65537, p)

print("enc is ",long_to_bytes(enc))
if (hint == keys[0] ^ keys[1] ^ keys[2] ^ keys[3] ^ keys[4]):
    print("Key is right")
else:
    print("Different")



dec = enc
dec = pow((keys[4]),-1,p)*dec%p
#print("dec is ",long_to_bytes(dec))
dec = pow((keys[3]),-1,p)*dec%p
#print("dec is ",long_to_bytes(dec))
dec = pow((keys[2]),-1,p)*dec%p
#print("dec is ",long_to_bytes(dec))
dec = pow((keys[1]),-1,p)*dec%p
#print("dec is ",long_to_bytes(dec))
dec = pow((keys[0]),-1,p)*dec%p

print("dec is ",long_to_bytes(dec))


